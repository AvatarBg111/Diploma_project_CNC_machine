
GRBL Driver STM32F401.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0001d370  08008000  08008000  00018000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000082e8  08025370  08025370  00035370  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0802d658  0802d658  00040630  2**0
                  CONTENTS
  4 .ARM          00000008  0802d658  0802d658  0003d658  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0802d660  0802d660  00040630  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0802d660  0802d660  0003d660  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0802d664  0802d664  0003d664  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000630  20000000  0802d668  00040000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00004380  20000630  0802dc98  00040630  2**2
                  ALLOC
 10 ._user_heap_stack 00004000  200049b0  0802dc98  000449b0  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00040630  2**0
                  CONTENTS, READONLY
 12 .comment      00000043  00000000  00000000  00040660  2**0
                  CONTENTS, READONLY
 13 .debug_info   000cf651  00000000  00000000  000406a3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 0000c01a  00000000  00000000  0010fcf4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_loclists 00015c50  00000000  00000000  0011bd0e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 00002490  00000000  00000000  00131960  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_rnglists 0000205c  00000000  00000000  00133df0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   00030077  00000000  00000000  00135e4c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    000111bd  00000000  00000000  00165ec3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_frame  00007750  00000000  00000000  00177080  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 00000063  00000000  00000000  0017e7d0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08008000 <__do_global_dtors_aux>:
 8008000:	b510      	push	{r4, lr}
 8008002:	4c05      	ldr	r4, [pc, #20]	; (8008018 <__do_global_dtors_aux+0x18>)
 8008004:	7823      	ldrb	r3, [r4, #0]
 8008006:	b933      	cbnz	r3, 8008016 <__do_global_dtors_aux+0x16>
 8008008:	4b04      	ldr	r3, [pc, #16]	; (800801c <__do_global_dtors_aux+0x1c>)
 800800a:	b113      	cbz	r3, 8008012 <__do_global_dtors_aux+0x12>
 800800c:	4804      	ldr	r0, [pc, #16]	; (8008020 <__do_global_dtors_aux+0x20>)
 800800e:	f3af 8000 	nop.w
 8008012:	2301      	movs	r3, #1
 8008014:	7023      	strb	r3, [r4, #0]
 8008016:	bd10      	pop	{r4, pc}
 8008018:	20000630 	.word	0x20000630
 800801c:	00000000 	.word	0x00000000
 8008020:	08025358 	.word	0x08025358

08008024 <frame_dummy>:
 8008024:	b508      	push	{r3, lr}
 8008026:	4b03      	ldr	r3, [pc, #12]	; (8008034 <frame_dummy+0x10>)
 8008028:	b11b      	cbz	r3, 8008032 <frame_dummy+0xe>
 800802a:	4903      	ldr	r1, [pc, #12]	; (8008038 <frame_dummy+0x14>)
 800802c:	4803      	ldr	r0, [pc, #12]	; (800803c <frame_dummy+0x18>)
 800802e:	f3af 8000 	nop.w
 8008032:	bd08      	pop	{r3, pc}
 8008034:	00000000 	.word	0x00000000
 8008038:	20000634 	.word	0x20000634
 800803c:	08025358 	.word	0x08025358

08008040 <strcmp>:
 8008040:	f810 2b01 	ldrb.w	r2, [r0], #1
 8008044:	f811 3b01 	ldrb.w	r3, [r1], #1
 8008048:	2a01      	cmp	r2, #1
 800804a:	bf28      	it	cs
 800804c:	429a      	cmpcs	r2, r3
 800804e:	d0f7      	beq.n	8008040 <strcmp>
 8008050:	1ad0      	subs	r0, r2, r3
 8008052:	4770      	bx	lr

08008054 <strlen>:
 8008054:	4603      	mov	r3, r0
 8008056:	f813 2b01 	ldrb.w	r2, [r3], #1
 800805a:	2a00      	cmp	r2, #0
 800805c:	d1fb      	bne.n	8008056 <strlen+0x2>
 800805e:	1a18      	subs	r0, r3, r0
 8008060:	3801      	subs	r0, #1
 8008062:	4770      	bx	lr
	...

08008070 <memchr>:
 8008070:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8008074:	2a10      	cmp	r2, #16
 8008076:	db2b      	blt.n	80080d0 <memchr+0x60>
 8008078:	f010 0f07 	tst.w	r0, #7
 800807c:	d008      	beq.n	8008090 <memchr+0x20>
 800807e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8008082:	3a01      	subs	r2, #1
 8008084:	428b      	cmp	r3, r1
 8008086:	d02d      	beq.n	80080e4 <memchr+0x74>
 8008088:	f010 0f07 	tst.w	r0, #7
 800808c:	b342      	cbz	r2, 80080e0 <memchr+0x70>
 800808e:	d1f6      	bne.n	800807e <memchr+0xe>
 8008090:	b4f0      	push	{r4, r5, r6, r7}
 8008092:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8008096:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800809a:	f022 0407 	bic.w	r4, r2, #7
 800809e:	f07f 0700 	mvns.w	r7, #0
 80080a2:	2300      	movs	r3, #0
 80080a4:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 80080a8:	3c08      	subs	r4, #8
 80080aa:	ea85 0501 	eor.w	r5, r5, r1
 80080ae:	ea86 0601 	eor.w	r6, r6, r1
 80080b2:	fa85 f547 	uadd8	r5, r5, r7
 80080b6:	faa3 f587 	sel	r5, r3, r7
 80080ba:	fa86 f647 	uadd8	r6, r6, r7
 80080be:	faa5 f687 	sel	r6, r5, r7
 80080c2:	b98e      	cbnz	r6, 80080e8 <memchr+0x78>
 80080c4:	d1ee      	bne.n	80080a4 <memchr+0x34>
 80080c6:	bcf0      	pop	{r4, r5, r6, r7}
 80080c8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80080cc:	f002 0207 	and.w	r2, r2, #7
 80080d0:	b132      	cbz	r2, 80080e0 <memchr+0x70>
 80080d2:	f810 3b01 	ldrb.w	r3, [r0], #1
 80080d6:	3a01      	subs	r2, #1
 80080d8:	ea83 0301 	eor.w	r3, r3, r1
 80080dc:	b113      	cbz	r3, 80080e4 <memchr+0x74>
 80080de:	d1f8      	bne.n	80080d2 <memchr+0x62>
 80080e0:	2000      	movs	r0, #0
 80080e2:	4770      	bx	lr
 80080e4:	3801      	subs	r0, #1
 80080e6:	4770      	bx	lr
 80080e8:	2d00      	cmp	r5, #0
 80080ea:	bf06      	itte	eq
 80080ec:	4635      	moveq	r5, r6
 80080ee:	3803      	subeq	r0, #3
 80080f0:	3807      	subne	r0, #7
 80080f2:	f015 0f01 	tst.w	r5, #1
 80080f6:	d107      	bne.n	8008108 <memchr+0x98>
 80080f8:	3001      	adds	r0, #1
 80080fa:	f415 7f80 	tst.w	r5, #256	; 0x100
 80080fe:	bf02      	ittt	eq
 8008100:	3001      	addeq	r0, #1
 8008102:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8008106:	3001      	addeq	r0, #1
 8008108:	bcf0      	pop	{r4, r5, r6, r7}
 800810a:	3801      	subs	r0, #1
 800810c:	4770      	bx	lr
 800810e:	bf00      	nop

08008110 <__aeabi_drsub>:
 8008110:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8008114:	e002      	b.n	800811c <__adddf3>
 8008116:	bf00      	nop

08008118 <__aeabi_dsub>:
 8008118:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0800811c <__adddf3>:
 800811c:	b530      	push	{r4, r5, lr}
 800811e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8008122:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8008126:	ea94 0f05 	teq	r4, r5
 800812a:	bf08      	it	eq
 800812c:	ea90 0f02 	teqeq	r0, r2
 8008130:	bf1f      	itttt	ne
 8008132:	ea54 0c00 	orrsne.w	ip, r4, r0
 8008136:	ea55 0c02 	orrsne.w	ip, r5, r2
 800813a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800813e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8008142:	f000 80e2 	beq.w	800830a <__adddf3+0x1ee>
 8008146:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800814a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800814e:	bfb8      	it	lt
 8008150:	426d      	neglt	r5, r5
 8008152:	dd0c      	ble.n	800816e <__adddf3+0x52>
 8008154:	442c      	add	r4, r5
 8008156:	ea80 0202 	eor.w	r2, r0, r2
 800815a:	ea81 0303 	eor.w	r3, r1, r3
 800815e:	ea82 0000 	eor.w	r0, r2, r0
 8008162:	ea83 0101 	eor.w	r1, r3, r1
 8008166:	ea80 0202 	eor.w	r2, r0, r2
 800816a:	ea81 0303 	eor.w	r3, r1, r3
 800816e:	2d36      	cmp	r5, #54	; 0x36
 8008170:	bf88      	it	hi
 8008172:	bd30      	pophi	{r4, r5, pc}
 8008174:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8008178:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800817c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8008180:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8008184:	d002      	beq.n	800818c <__adddf3+0x70>
 8008186:	4240      	negs	r0, r0
 8008188:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800818c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8008190:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8008194:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8008198:	d002      	beq.n	80081a0 <__adddf3+0x84>
 800819a:	4252      	negs	r2, r2
 800819c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80081a0:	ea94 0f05 	teq	r4, r5
 80081a4:	f000 80a7 	beq.w	80082f6 <__adddf3+0x1da>
 80081a8:	f1a4 0401 	sub.w	r4, r4, #1
 80081ac:	f1d5 0e20 	rsbs	lr, r5, #32
 80081b0:	db0d      	blt.n	80081ce <__adddf3+0xb2>
 80081b2:	fa02 fc0e 	lsl.w	ip, r2, lr
 80081b6:	fa22 f205 	lsr.w	r2, r2, r5
 80081ba:	1880      	adds	r0, r0, r2
 80081bc:	f141 0100 	adc.w	r1, r1, #0
 80081c0:	fa03 f20e 	lsl.w	r2, r3, lr
 80081c4:	1880      	adds	r0, r0, r2
 80081c6:	fa43 f305 	asr.w	r3, r3, r5
 80081ca:	4159      	adcs	r1, r3
 80081cc:	e00e      	b.n	80081ec <__adddf3+0xd0>
 80081ce:	f1a5 0520 	sub.w	r5, r5, #32
 80081d2:	f10e 0e20 	add.w	lr, lr, #32
 80081d6:	2a01      	cmp	r2, #1
 80081d8:	fa03 fc0e 	lsl.w	ip, r3, lr
 80081dc:	bf28      	it	cs
 80081de:	f04c 0c02 	orrcs.w	ip, ip, #2
 80081e2:	fa43 f305 	asr.w	r3, r3, r5
 80081e6:	18c0      	adds	r0, r0, r3
 80081e8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80081ec:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80081f0:	d507      	bpl.n	8008202 <__adddf3+0xe6>
 80081f2:	f04f 0e00 	mov.w	lr, #0
 80081f6:	f1dc 0c00 	rsbs	ip, ip, #0
 80081fa:	eb7e 0000 	sbcs.w	r0, lr, r0
 80081fe:	eb6e 0101 	sbc.w	r1, lr, r1
 8008202:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8008206:	d31b      	bcc.n	8008240 <__adddf3+0x124>
 8008208:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 800820c:	d30c      	bcc.n	8008228 <__adddf3+0x10c>
 800820e:	0849      	lsrs	r1, r1, #1
 8008210:	ea5f 0030 	movs.w	r0, r0, rrx
 8008214:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8008218:	f104 0401 	add.w	r4, r4, #1
 800821c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8008220:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8008224:	f080 809a 	bcs.w	800835c <__adddf3+0x240>
 8008228:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 800822c:	bf08      	it	eq
 800822e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8008232:	f150 0000 	adcs.w	r0, r0, #0
 8008236:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800823a:	ea41 0105 	orr.w	r1, r1, r5
 800823e:	bd30      	pop	{r4, r5, pc}
 8008240:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8008244:	4140      	adcs	r0, r0
 8008246:	eb41 0101 	adc.w	r1, r1, r1
 800824a:	3c01      	subs	r4, #1
 800824c:	bf28      	it	cs
 800824e:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 8008252:	d2e9      	bcs.n	8008228 <__adddf3+0x10c>
 8008254:	f091 0f00 	teq	r1, #0
 8008258:	bf04      	itt	eq
 800825a:	4601      	moveq	r1, r0
 800825c:	2000      	moveq	r0, #0
 800825e:	fab1 f381 	clz	r3, r1
 8008262:	bf08      	it	eq
 8008264:	3320      	addeq	r3, #32
 8008266:	f1a3 030b 	sub.w	r3, r3, #11
 800826a:	f1b3 0220 	subs.w	r2, r3, #32
 800826e:	da0c      	bge.n	800828a <__adddf3+0x16e>
 8008270:	320c      	adds	r2, #12
 8008272:	dd08      	ble.n	8008286 <__adddf3+0x16a>
 8008274:	f102 0c14 	add.w	ip, r2, #20
 8008278:	f1c2 020c 	rsb	r2, r2, #12
 800827c:	fa01 f00c 	lsl.w	r0, r1, ip
 8008280:	fa21 f102 	lsr.w	r1, r1, r2
 8008284:	e00c      	b.n	80082a0 <__adddf3+0x184>
 8008286:	f102 0214 	add.w	r2, r2, #20
 800828a:	bfd8      	it	le
 800828c:	f1c2 0c20 	rsble	ip, r2, #32
 8008290:	fa01 f102 	lsl.w	r1, r1, r2
 8008294:	fa20 fc0c 	lsr.w	ip, r0, ip
 8008298:	bfdc      	itt	le
 800829a:	ea41 010c 	orrle.w	r1, r1, ip
 800829e:	4090      	lslle	r0, r2
 80082a0:	1ae4      	subs	r4, r4, r3
 80082a2:	bfa2      	ittt	ge
 80082a4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80082a8:	4329      	orrge	r1, r5
 80082aa:	bd30      	popge	{r4, r5, pc}
 80082ac:	ea6f 0404 	mvn.w	r4, r4
 80082b0:	3c1f      	subs	r4, #31
 80082b2:	da1c      	bge.n	80082ee <__adddf3+0x1d2>
 80082b4:	340c      	adds	r4, #12
 80082b6:	dc0e      	bgt.n	80082d6 <__adddf3+0x1ba>
 80082b8:	f104 0414 	add.w	r4, r4, #20
 80082bc:	f1c4 0220 	rsb	r2, r4, #32
 80082c0:	fa20 f004 	lsr.w	r0, r0, r4
 80082c4:	fa01 f302 	lsl.w	r3, r1, r2
 80082c8:	ea40 0003 	orr.w	r0, r0, r3
 80082cc:	fa21 f304 	lsr.w	r3, r1, r4
 80082d0:	ea45 0103 	orr.w	r1, r5, r3
 80082d4:	bd30      	pop	{r4, r5, pc}
 80082d6:	f1c4 040c 	rsb	r4, r4, #12
 80082da:	f1c4 0220 	rsb	r2, r4, #32
 80082de:	fa20 f002 	lsr.w	r0, r0, r2
 80082e2:	fa01 f304 	lsl.w	r3, r1, r4
 80082e6:	ea40 0003 	orr.w	r0, r0, r3
 80082ea:	4629      	mov	r1, r5
 80082ec:	bd30      	pop	{r4, r5, pc}
 80082ee:	fa21 f004 	lsr.w	r0, r1, r4
 80082f2:	4629      	mov	r1, r5
 80082f4:	bd30      	pop	{r4, r5, pc}
 80082f6:	f094 0f00 	teq	r4, #0
 80082fa:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80082fe:	bf06      	itte	eq
 8008300:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8008304:	3401      	addeq	r4, #1
 8008306:	3d01      	subne	r5, #1
 8008308:	e74e      	b.n	80081a8 <__adddf3+0x8c>
 800830a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800830e:	bf18      	it	ne
 8008310:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8008314:	d029      	beq.n	800836a <__adddf3+0x24e>
 8008316:	ea94 0f05 	teq	r4, r5
 800831a:	bf08      	it	eq
 800831c:	ea90 0f02 	teqeq	r0, r2
 8008320:	d005      	beq.n	800832e <__adddf3+0x212>
 8008322:	ea54 0c00 	orrs.w	ip, r4, r0
 8008326:	bf04      	itt	eq
 8008328:	4619      	moveq	r1, r3
 800832a:	4610      	moveq	r0, r2
 800832c:	bd30      	pop	{r4, r5, pc}
 800832e:	ea91 0f03 	teq	r1, r3
 8008332:	bf1e      	ittt	ne
 8008334:	2100      	movne	r1, #0
 8008336:	2000      	movne	r0, #0
 8008338:	bd30      	popne	{r4, r5, pc}
 800833a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800833e:	d105      	bne.n	800834c <__adddf3+0x230>
 8008340:	0040      	lsls	r0, r0, #1
 8008342:	4149      	adcs	r1, r1
 8008344:	bf28      	it	cs
 8008346:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800834a:	bd30      	pop	{r4, r5, pc}
 800834c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8008350:	bf3c      	itt	cc
 8008352:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8008356:	bd30      	popcc	{r4, r5, pc}
 8008358:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800835c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8008360:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8008364:	f04f 0000 	mov.w	r0, #0
 8008368:	bd30      	pop	{r4, r5, pc}
 800836a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800836e:	bf1a      	itte	ne
 8008370:	4619      	movne	r1, r3
 8008372:	4610      	movne	r0, r2
 8008374:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8008378:	bf1c      	itt	ne
 800837a:	460b      	movne	r3, r1
 800837c:	4602      	movne	r2, r0
 800837e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8008382:	bf06      	itte	eq
 8008384:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8008388:	ea91 0f03 	teqeq	r1, r3
 800838c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8008390:	bd30      	pop	{r4, r5, pc}
 8008392:	bf00      	nop

08008394 <__aeabi_ui2d>:
 8008394:	f090 0f00 	teq	r0, #0
 8008398:	bf04      	itt	eq
 800839a:	2100      	moveq	r1, #0
 800839c:	4770      	bxeq	lr
 800839e:	b530      	push	{r4, r5, lr}
 80083a0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80083a4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80083a8:	f04f 0500 	mov.w	r5, #0
 80083ac:	f04f 0100 	mov.w	r1, #0
 80083b0:	e750      	b.n	8008254 <__adddf3+0x138>
 80083b2:	bf00      	nop

080083b4 <__aeabi_i2d>:
 80083b4:	f090 0f00 	teq	r0, #0
 80083b8:	bf04      	itt	eq
 80083ba:	2100      	moveq	r1, #0
 80083bc:	4770      	bxeq	lr
 80083be:	b530      	push	{r4, r5, lr}
 80083c0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80083c4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80083c8:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80083cc:	bf48      	it	mi
 80083ce:	4240      	negmi	r0, r0
 80083d0:	f04f 0100 	mov.w	r1, #0
 80083d4:	e73e      	b.n	8008254 <__adddf3+0x138>
 80083d6:	bf00      	nop

080083d8 <__aeabi_f2d>:
 80083d8:	0042      	lsls	r2, r0, #1
 80083da:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80083de:	ea4f 0131 	mov.w	r1, r1, rrx
 80083e2:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80083e6:	bf1f      	itttt	ne
 80083e8:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80083ec:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80083f0:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80083f4:	4770      	bxne	lr
 80083f6:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 80083fa:	bf08      	it	eq
 80083fc:	4770      	bxeq	lr
 80083fe:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 8008402:	bf04      	itt	eq
 8008404:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 8008408:	4770      	bxeq	lr
 800840a:	b530      	push	{r4, r5, lr}
 800840c:	f44f 7460 	mov.w	r4, #896	; 0x380
 8008410:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8008414:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8008418:	e71c      	b.n	8008254 <__adddf3+0x138>
 800841a:	bf00      	nop

0800841c <__aeabi_ul2d>:
 800841c:	ea50 0201 	orrs.w	r2, r0, r1
 8008420:	bf08      	it	eq
 8008422:	4770      	bxeq	lr
 8008424:	b530      	push	{r4, r5, lr}
 8008426:	f04f 0500 	mov.w	r5, #0
 800842a:	e00a      	b.n	8008442 <__aeabi_l2d+0x16>

0800842c <__aeabi_l2d>:
 800842c:	ea50 0201 	orrs.w	r2, r0, r1
 8008430:	bf08      	it	eq
 8008432:	4770      	bxeq	lr
 8008434:	b530      	push	{r4, r5, lr}
 8008436:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 800843a:	d502      	bpl.n	8008442 <__aeabi_l2d+0x16>
 800843c:	4240      	negs	r0, r0
 800843e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8008442:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8008446:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800844a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 800844e:	f43f aed8 	beq.w	8008202 <__adddf3+0xe6>
 8008452:	f04f 0203 	mov.w	r2, #3
 8008456:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800845a:	bf18      	it	ne
 800845c:	3203      	addne	r2, #3
 800845e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8008462:	bf18      	it	ne
 8008464:	3203      	addne	r2, #3
 8008466:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800846a:	f1c2 0320 	rsb	r3, r2, #32
 800846e:	fa00 fc03 	lsl.w	ip, r0, r3
 8008472:	fa20 f002 	lsr.w	r0, r0, r2
 8008476:	fa01 fe03 	lsl.w	lr, r1, r3
 800847a:	ea40 000e 	orr.w	r0, r0, lr
 800847e:	fa21 f102 	lsr.w	r1, r1, r2
 8008482:	4414      	add	r4, r2
 8008484:	e6bd      	b.n	8008202 <__adddf3+0xe6>
 8008486:	bf00      	nop

08008488 <__aeabi_dmul>:
 8008488:	b570      	push	{r4, r5, r6, lr}
 800848a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800848e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8008492:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8008496:	bf1d      	ittte	ne
 8008498:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800849c:	ea94 0f0c 	teqne	r4, ip
 80084a0:	ea95 0f0c 	teqne	r5, ip
 80084a4:	f000 f8de 	bleq	8008664 <__aeabi_dmul+0x1dc>
 80084a8:	442c      	add	r4, r5
 80084aa:	ea81 0603 	eor.w	r6, r1, r3
 80084ae:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 80084b2:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 80084b6:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 80084ba:	bf18      	it	ne
 80084bc:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 80084c0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80084c4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80084c8:	d038      	beq.n	800853c <__aeabi_dmul+0xb4>
 80084ca:	fba0 ce02 	umull	ip, lr, r0, r2
 80084ce:	f04f 0500 	mov.w	r5, #0
 80084d2:	fbe1 e502 	umlal	lr, r5, r1, r2
 80084d6:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 80084da:	fbe0 e503 	umlal	lr, r5, r0, r3
 80084de:	f04f 0600 	mov.w	r6, #0
 80084e2:	fbe1 5603 	umlal	r5, r6, r1, r3
 80084e6:	f09c 0f00 	teq	ip, #0
 80084ea:	bf18      	it	ne
 80084ec:	f04e 0e01 	orrne.w	lr, lr, #1
 80084f0:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80084f4:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80084f8:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80084fc:	d204      	bcs.n	8008508 <__aeabi_dmul+0x80>
 80084fe:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8008502:	416d      	adcs	r5, r5
 8008504:	eb46 0606 	adc.w	r6, r6, r6
 8008508:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 800850c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8008510:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8008514:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8008518:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 800851c:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8008520:	bf88      	it	hi
 8008522:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8008526:	d81e      	bhi.n	8008566 <__aeabi_dmul+0xde>
 8008528:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 800852c:	bf08      	it	eq
 800852e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8008532:	f150 0000 	adcs.w	r0, r0, #0
 8008536:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800853a:	bd70      	pop	{r4, r5, r6, pc}
 800853c:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8008540:	ea46 0101 	orr.w	r1, r6, r1
 8008544:	ea40 0002 	orr.w	r0, r0, r2
 8008548:	ea81 0103 	eor.w	r1, r1, r3
 800854c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8008550:	bfc2      	ittt	gt
 8008552:	ebd4 050c 	rsbsgt	r5, r4, ip
 8008556:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800855a:	bd70      	popgt	{r4, r5, r6, pc}
 800855c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8008560:	f04f 0e00 	mov.w	lr, #0
 8008564:	3c01      	subs	r4, #1
 8008566:	f300 80ab 	bgt.w	80086c0 <__aeabi_dmul+0x238>
 800856a:	f114 0f36 	cmn.w	r4, #54	; 0x36
 800856e:	bfde      	ittt	le
 8008570:	2000      	movle	r0, #0
 8008572:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 8008576:	bd70      	pople	{r4, r5, r6, pc}
 8008578:	f1c4 0400 	rsb	r4, r4, #0
 800857c:	3c20      	subs	r4, #32
 800857e:	da35      	bge.n	80085ec <__aeabi_dmul+0x164>
 8008580:	340c      	adds	r4, #12
 8008582:	dc1b      	bgt.n	80085bc <__aeabi_dmul+0x134>
 8008584:	f104 0414 	add.w	r4, r4, #20
 8008588:	f1c4 0520 	rsb	r5, r4, #32
 800858c:	fa00 f305 	lsl.w	r3, r0, r5
 8008590:	fa20 f004 	lsr.w	r0, r0, r4
 8008594:	fa01 f205 	lsl.w	r2, r1, r5
 8008598:	ea40 0002 	orr.w	r0, r0, r2
 800859c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 80085a0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80085a4:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80085a8:	fa21 f604 	lsr.w	r6, r1, r4
 80085ac:	eb42 0106 	adc.w	r1, r2, r6
 80085b0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80085b4:	bf08      	it	eq
 80085b6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80085ba:	bd70      	pop	{r4, r5, r6, pc}
 80085bc:	f1c4 040c 	rsb	r4, r4, #12
 80085c0:	f1c4 0520 	rsb	r5, r4, #32
 80085c4:	fa00 f304 	lsl.w	r3, r0, r4
 80085c8:	fa20 f005 	lsr.w	r0, r0, r5
 80085cc:	fa01 f204 	lsl.w	r2, r1, r4
 80085d0:	ea40 0002 	orr.w	r0, r0, r2
 80085d4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80085d8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80085dc:	f141 0100 	adc.w	r1, r1, #0
 80085e0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80085e4:	bf08      	it	eq
 80085e6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80085ea:	bd70      	pop	{r4, r5, r6, pc}
 80085ec:	f1c4 0520 	rsb	r5, r4, #32
 80085f0:	fa00 f205 	lsl.w	r2, r0, r5
 80085f4:	ea4e 0e02 	orr.w	lr, lr, r2
 80085f8:	fa20 f304 	lsr.w	r3, r0, r4
 80085fc:	fa01 f205 	lsl.w	r2, r1, r5
 8008600:	ea43 0302 	orr.w	r3, r3, r2
 8008604:	fa21 f004 	lsr.w	r0, r1, r4
 8008608:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800860c:	fa21 f204 	lsr.w	r2, r1, r4
 8008610:	ea20 0002 	bic.w	r0, r0, r2
 8008614:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8008618:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800861c:	bf08      	it	eq
 800861e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8008622:	bd70      	pop	{r4, r5, r6, pc}
 8008624:	f094 0f00 	teq	r4, #0
 8008628:	d10f      	bne.n	800864a <__aeabi_dmul+0x1c2>
 800862a:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 800862e:	0040      	lsls	r0, r0, #1
 8008630:	eb41 0101 	adc.w	r1, r1, r1
 8008634:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8008638:	bf08      	it	eq
 800863a:	3c01      	subeq	r4, #1
 800863c:	d0f7      	beq.n	800862e <__aeabi_dmul+0x1a6>
 800863e:	ea41 0106 	orr.w	r1, r1, r6
 8008642:	f095 0f00 	teq	r5, #0
 8008646:	bf18      	it	ne
 8008648:	4770      	bxne	lr
 800864a:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 800864e:	0052      	lsls	r2, r2, #1
 8008650:	eb43 0303 	adc.w	r3, r3, r3
 8008654:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8008658:	bf08      	it	eq
 800865a:	3d01      	subeq	r5, #1
 800865c:	d0f7      	beq.n	800864e <__aeabi_dmul+0x1c6>
 800865e:	ea43 0306 	orr.w	r3, r3, r6
 8008662:	4770      	bx	lr
 8008664:	ea94 0f0c 	teq	r4, ip
 8008668:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800866c:	bf18      	it	ne
 800866e:	ea95 0f0c 	teqne	r5, ip
 8008672:	d00c      	beq.n	800868e <__aeabi_dmul+0x206>
 8008674:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8008678:	bf18      	it	ne
 800867a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800867e:	d1d1      	bne.n	8008624 <__aeabi_dmul+0x19c>
 8008680:	ea81 0103 	eor.w	r1, r1, r3
 8008684:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8008688:	f04f 0000 	mov.w	r0, #0
 800868c:	bd70      	pop	{r4, r5, r6, pc}
 800868e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8008692:	bf06      	itte	eq
 8008694:	4610      	moveq	r0, r2
 8008696:	4619      	moveq	r1, r3
 8008698:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800869c:	d019      	beq.n	80086d2 <__aeabi_dmul+0x24a>
 800869e:	ea94 0f0c 	teq	r4, ip
 80086a2:	d102      	bne.n	80086aa <__aeabi_dmul+0x222>
 80086a4:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 80086a8:	d113      	bne.n	80086d2 <__aeabi_dmul+0x24a>
 80086aa:	ea95 0f0c 	teq	r5, ip
 80086ae:	d105      	bne.n	80086bc <__aeabi_dmul+0x234>
 80086b0:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 80086b4:	bf1c      	itt	ne
 80086b6:	4610      	movne	r0, r2
 80086b8:	4619      	movne	r1, r3
 80086ba:	d10a      	bne.n	80086d2 <__aeabi_dmul+0x24a>
 80086bc:	ea81 0103 	eor.w	r1, r1, r3
 80086c0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80086c4:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80086c8:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80086cc:	f04f 0000 	mov.w	r0, #0
 80086d0:	bd70      	pop	{r4, r5, r6, pc}
 80086d2:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80086d6:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 80086da:	bd70      	pop	{r4, r5, r6, pc}

080086dc <__aeabi_ddiv>:
 80086dc:	b570      	push	{r4, r5, r6, lr}
 80086de:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80086e2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80086e6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80086ea:	bf1d      	ittte	ne
 80086ec:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80086f0:	ea94 0f0c 	teqne	r4, ip
 80086f4:	ea95 0f0c 	teqne	r5, ip
 80086f8:	f000 f8a7 	bleq	800884a <__aeabi_ddiv+0x16e>
 80086fc:	eba4 0405 	sub.w	r4, r4, r5
 8008700:	ea81 0e03 	eor.w	lr, r1, r3
 8008704:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8008708:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800870c:	f000 8088 	beq.w	8008820 <__aeabi_ddiv+0x144>
 8008710:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8008714:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8008718:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 800871c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8008720:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8008724:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8008728:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 800872c:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8008730:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 8008734:	429d      	cmp	r5, r3
 8008736:	bf08      	it	eq
 8008738:	4296      	cmpeq	r6, r2
 800873a:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 800873e:	f504 7440 	add.w	r4, r4, #768	; 0x300
 8008742:	d202      	bcs.n	800874a <__aeabi_ddiv+0x6e>
 8008744:	085b      	lsrs	r3, r3, #1
 8008746:	ea4f 0232 	mov.w	r2, r2, rrx
 800874a:	1ab6      	subs	r6, r6, r2
 800874c:	eb65 0503 	sbc.w	r5, r5, r3
 8008750:	085b      	lsrs	r3, r3, #1
 8008752:	ea4f 0232 	mov.w	r2, r2, rrx
 8008756:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800875a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 800875e:	ebb6 0e02 	subs.w	lr, r6, r2
 8008762:	eb75 0e03 	sbcs.w	lr, r5, r3
 8008766:	bf22      	ittt	cs
 8008768:	1ab6      	subcs	r6, r6, r2
 800876a:	4675      	movcs	r5, lr
 800876c:	ea40 000c 	orrcs.w	r0, r0, ip
 8008770:	085b      	lsrs	r3, r3, #1
 8008772:	ea4f 0232 	mov.w	r2, r2, rrx
 8008776:	ebb6 0e02 	subs.w	lr, r6, r2
 800877a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800877e:	bf22      	ittt	cs
 8008780:	1ab6      	subcs	r6, r6, r2
 8008782:	4675      	movcs	r5, lr
 8008784:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8008788:	085b      	lsrs	r3, r3, #1
 800878a:	ea4f 0232 	mov.w	r2, r2, rrx
 800878e:	ebb6 0e02 	subs.w	lr, r6, r2
 8008792:	eb75 0e03 	sbcs.w	lr, r5, r3
 8008796:	bf22      	ittt	cs
 8008798:	1ab6      	subcs	r6, r6, r2
 800879a:	4675      	movcs	r5, lr
 800879c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80087a0:	085b      	lsrs	r3, r3, #1
 80087a2:	ea4f 0232 	mov.w	r2, r2, rrx
 80087a6:	ebb6 0e02 	subs.w	lr, r6, r2
 80087aa:	eb75 0e03 	sbcs.w	lr, r5, r3
 80087ae:	bf22      	ittt	cs
 80087b0:	1ab6      	subcs	r6, r6, r2
 80087b2:	4675      	movcs	r5, lr
 80087b4:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80087b8:	ea55 0e06 	orrs.w	lr, r5, r6
 80087bc:	d018      	beq.n	80087f0 <__aeabi_ddiv+0x114>
 80087be:	ea4f 1505 	mov.w	r5, r5, lsl #4
 80087c2:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 80087c6:	ea4f 1606 	mov.w	r6, r6, lsl #4
 80087ca:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80087ce:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 80087d2:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80087d6:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 80087da:	d1c0      	bne.n	800875e <__aeabi_ddiv+0x82>
 80087dc:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80087e0:	d10b      	bne.n	80087fa <__aeabi_ddiv+0x11e>
 80087e2:	ea41 0100 	orr.w	r1, r1, r0
 80087e6:	f04f 0000 	mov.w	r0, #0
 80087ea:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 80087ee:	e7b6      	b.n	800875e <__aeabi_ddiv+0x82>
 80087f0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80087f4:	bf04      	itt	eq
 80087f6:	4301      	orreq	r1, r0
 80087f8:	2000      	moveq	r0, #0
 80087fa:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80087fe:	bf88      	it	hi
 8008800:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8008804:	f63f aeaf 	bhi.w	8008566 <__aeabi_dmul+0xde>
 8008808:	ebb5 0c03 	subs.w	ip, r5, r3
 800880c:	bf04      	itt	eq
 800880e:	ebb6 0c02 	subseq.w	ip, r6, r2
 8008812:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8008816:	f150 0000 	adcs.w	r0, r0, #0
 800881a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800881e:	bd70      	pop	{r4, r5, r6, pc}
 8008820:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 8008824:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8008828:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 800882c:	bfc2      	ittt	gt
 800882e:	ebd4 050c 	rsbsgt	r5, r4, ip
 8008832:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8008836:	bd70      	popgt	{r4, r5, r6, pc}
 8008838:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800883c:	f04f 0e00 	mov.w	lr, #0
 8008840:	3c01      	subs	r4, #1
 8008842:	e690      	b.n	8008566 <__aeabi_dmul+0xde>
 8008844:	ea45 0e06 	orr.w	lr, r5, r6
 8008848:	e68d      	b.n	8008566 <__aeabi_dmul+0xde>
 800884a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800884e:	ea94 0f0c 	teq	r4, ip
 8008852:	bf08      	it	eq
 8008854:	ea95 0f0c 	teqeq	r5, ip
 8008858:	f43f af3b 	beq.w	80086d2 <__aeabi_dmul+0x24a>
 800885c:	ea94 0f0c 	teq	r4, ip
 8008860:	d10a      	bne.n	8008878 <__aeabi_ddiv+0x19c>
 8008862:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8008866:	f47f af34 	bne.w	80086d2 <__aeabi_dmul+0x24a>
 800886a:	ea95 0f0c 	teq	r5, ip
 800886e:	f47f af25 	bne.w	80086bc <__aeabi_dmul+0x234>
 8008872:	4610      	mov	r0, r2
 8008874:	4619      	mov	r1, r3
 8008876:	e72c      	b.n	80086d2 <__aeabi_dmul+0x24a>
 8008878:	ea95 0f0c 	teq	r5, ip
 800887c:	d106      	bne.n	800888c <__aeabi_ddiv+0x1b0>
 800887e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8008882:	f43f aefd 	beq.w	8008680 <__aeabi_dmul+0x1f8>
 8008886:	4610      	mov	r0, r2
 8008888:	4619      	mov	r1, r3
 800888a:	e722      	b.n	80086d2 <__aeabi_dmul+0x24a>
 800888c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8008890:	bf18      	it	ne
 8008892:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8008896:	f47f aec5 	bne.w	8008624 <__aeabi_dmul+0x19c>
 800889a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 800889e:	f47f af0d 	bne.w	80086bc <__aeabi_dmul+0x234>
 80088a2:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 80088a6:	f47f aeeb 	bne.w	8008680 <__aeabi_dmul+0x1f8>
 80088aa:	e712      	b.n	80086d2 <__aeabi_dmul+0x24a>

080088ac <__gedf2>:
 80088ac:	f04f 3cff 	mov.w	ip, #4294967295
 80088b0:	e006      	b.n	80088c0 <__cmpdf2+0x4>
 80088b2:	bf00      	nop

080088b4 <__ledf2>:
 80088b4:	f04f 0c01 	mov.w	ip, #1
 80088b8:	e002      	b.n	80088c0 <__cmpdf2+0x4>
 80088ba:	bf00      	nop

080088bc <__cmpdf2>:
 80088bc:	f04f 0c01 	mov.w	ip, #1
 80088c0:	f84d cd04 	str.w	ip, [sp, #-4]!
 80088c4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80088c8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80088cc:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80088d0:	bf18      	it	ne
 80088d2:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 80088d6:	d01b      	beq.n	8008910 <__cmpdf2+0x54>
 80088d8:	b001      	add	sp, #4
 80088da:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 80088de:	bf0c      	ite	eq
 80088e0:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 80088e4:	ea91 0f03 	teqne	r1, r3
 80088e8:	bf02      	ittt	eq
 80088ea:	ea90 0f02 	teqeq	r0, r2
 80088ee:	2000      	moveq	r0, #0
 80088f0:	4770      	bxeq	lr
 80088f2:	f110 0f00 	cmn.w	r0, #0
 80088f6:	ea91 0f03 	teq	r1, r3
 80088fa:	bf58      	it	pl
 80088fc:	4299      	cmppl	r1, r3
 80088fe:	bf08      	it	eq
 8008900:	4290      	cmpeq	r0, r2
 8008902:	bf2c      	ite	cs
 8008904:	17d8      	asrcs	r0, r3, #31
 8008906:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 800890a:	f040 0001 	orr.w	r0, r0, #1
 800890e:	4770      	bx	lr
 8008910:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8008914:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8008918:	d102      	bne.n	8008920 <__cmpdf2+0x64>
 800891a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 800891e:	d107      	bne.n	8008930 <__cmpdf2+0x74>
 8008920:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8008924:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8008928:	d1d6      	bne.n	80088d8 <__cmpdf2+0x1c>
 800892a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 800892e:	d0d3      	beq.n	80088d8 <__cmpdf2+0x1c>
 8008930:	f85d 0b04 	ldr.w	r0, [sp], #4
 8008934:	4770      	bx	lr
 8008936:	bf00      	nop

08008938 <__aeabi_cdrcmple>:
 8008938:	4684      	mov	ip, r0
 800893a:	4610      	mov	r0, r2
 800893c:	4662      	mov	r2, ip
 800893e:	468c      	mov	ip, r1
 8008940:	4619      	mov	r1, r3
 8008942:	4663      	mov	r3, ip
 8008944:	e000      	b.n	8008948 <__aeabi_cdcmpeq>
 8008946:	bf00      	nop

08008948 <__aeabi_cdcmpeq>:
 8008948:	b501      	push	{r0, lr}
 800894a:	f7ff ffb7 	bl	80088bc <__cmpdf2>
 800894e:	2800      	cmp	r0, #0
 8008950:	bf48      	it	mi
 8008952:	f110 0f00 	cmnmi.w	r0, #0
 8008956:	bd01      	pop	{r0, pc}

08008958 <__aeabi_dcmpeq>:
 8008958:	f84d ed08 	str.w	lr, [sp, #-8]!
 800895c:	f7ff fff4 	bl	8008948 <__aeabi_cdcmpeq>
 8008960:	bf0c      	ite	eq
 8008962:	2001      	moveq	r0, #1
 8008964:	2000      	movne	r0, #0
 8008966:	f85d fb08 	ldr.w	pc, [sp], #8
 800896a:	bf00      	nop

0800896c <__aeabi_dcmplt>:
 800896c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8008970:	f7ff ffea 	bl	8008948 <__aeabi_cdcmpeq>
 8008974:	bf34      	ite	cc
 8008976:	2001      	movcc	r0, #1
 8008978:	2000      	movcs	r0, #0
 800897a:	f85d fb08 	ldr.w	pc, [sp], #8
 800897e:	bf00      	nop

08008980 <__aeabi_dcmple>:
 8008980:	f84d ed08 	str.w	lr, [sp, #-8]!
 8008984:	f7ff ffe0 	bl	8008948 <__aeabi_cdcmpeq>
 8008988:	bf94      	ite	ls
 800898a:	2001      	movls	r0, #1
 800898c:	2000      	movhi	r0, #0
 800898e:	f85d fb08 	ldr.w	pc, [sp], #8
 8008992:	bf00      	nop

08008994 <__aeabi_dcmpge>:
 8008994:	f84d ed08 	str.w	lr, [sp, #-8]!
 8008998:	f7ff ffce 	bl	8008938 <__aeabi_cdrcmple>
 800899c:	bf94      	ite	ls
 800899e:	2001      	movls	r0, #1
 80089a0:	2000      	movhi	r0, #0
 80089a2:	f85d fb08 	ldr.w	pc, [sp], #8
 80089a6:	bf00      	nop

080089a8 <__aeabi_dcmpgt>:
 80089a8:	f84d ed08 	str.w	lr, [sp, #-8]!
 80089ac:	f7ff ffc4 	bl	8008938 <__aeabi_cdrcmple>
 80089b0:	bf34      	ite	cc
 80089b2:	2001      	movcc	r0, #1
 80089b4:	2000      	movcs	r0, #0
 80089b6:	f85d fb08 	ldr.w	pc, [sp], #8
 80089ba:	bf00      	nop

080089bc <__aeabi_d2f>:
 80089bc:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80089c0:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 80089c4:	bf24      	itt	cs
 80089c6:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 80089ca:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 80089ce:	d90d      	bls.n	80089ec <__aeabi_d2f+0x30>
 80089d0:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80089d4:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 80089d8:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 80089dc:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 80089e0:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 80089e4:	bf08      	it	eq
 80089e6:	f020 0001 	biceq.w	r0, r0, #1
 80089ea:	4770      	bx	lr
 80089ec:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 80089f0:	d121      	bne.n	8008a36 <__aeabi_d2f+0x7a>
 80089f2:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 80089f6:	bfbc      	itt	lt
 80089f8:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 80089fc:	4770      	bxlt	lr
 80089fe:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8008a02:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8008a06:	f1c2 0218 	rsb	r2, r2, #24
 8008a0a:	f1c2 0c20 	rsb	ip, r2, #32
 8008a0e:	fa10 f30c 	lsls.w	r3, r0, ip
 8008a12:	fa20 f002 	lsr.w	r0, r0, r2
 8008a16:	bf18      	it	ne
 8008a18:	f040 0001 	orrne.w	r0, r0, #1
 8008a1c:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8008a20:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8008a24:	fa03 fc0c 	lsl.w	ip, r3, ip
 8008a28:	ea40 000c 	orr.w	r0, r0, ip
 8008a2c:	fa23 f302 	lsr.w	r3, r3, r2
 8008a30:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8008a34:	e7cc      	b.n	80089d0 <__aeabi_d2f+0x14>
 8008a36:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8008a3a:	d107      	bne.n	8008a4c <__aeabi_d2f+0x90>
 8008a3c:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8008a40:	bf1e      	ittt	ne
 8008a42:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8008a46:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8008a4a:	4770      	bxne	lr
 8008a4c:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8008a50:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8008a54:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8008a58:	4770      	bx	lr
 8008a5a:	bf00      	nop

08008a5c <__aeabi_uldivmod>:
 8008a5c:	b953      	cbnz	r3, 8008a74 <__aeabi_uldivmod+0x18>
 8008a5e:	b94a      	cbnz	r2, 8008a74 <__aeabi_uldivmod+0x18>
 8008a60:	2900      	cmp	r1, #0
 8008a62:	bf08      	it	eq
 8008a64:	2800      	cmpeq	r0, #0
 8008a66:	bf1c      	itt	ne
 8008a68:	f04f 31ff 	movne.w	r1, #4294967295
 8008a6c:	f04f 30ff 	movne.w	r0, #4294967295
 8008a70:	f000 b970 	b.w	8008d54 <__aeabi_idiv0>
 8008a74:	f1ad 0c08 	sub.w	ip, sp, #8
 8008a78:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8008a7c:	f000 f806 	bl	8008a8c <__udivmoddi4>
 8008a80:	f8dd e004 	ldr.w	lr, [sp, #4]
 8008a84:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8008a88:	b004      	add	sp, #16
 8008a8a:	4770      	bx	lr

08008a8c <__udivmoddi4>:
 8008a8c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8008a90:	9e08      	ldr	r6, [sp, #32]
 8008a92:	460d      	mov	r5, r1
 8008a94:	4604      	mov	r4, r0
 8008a96:	460f      	mov	r7, r1
 8008a98:	2b00      	cmp	r3, #0
 8008a9a:	d14a      	bne.n	8008b32 <__udivmoddi4+0xa6>
 8008a9c:	428a      	cmp	r2, r1
 8008a9e:	4694      	mov	ip, r2
 8008aa0:	d965      	bls.n	8008b6e <__udivmoddi4+0xe2>
 8008aa2:	fab2 f382 	clz	r3, r2
 8008aa6:	b143      	cbz	r3, 8008aba <__udivmoddi4+0x2e>
 8008aa8:	fa02 fc03 	lsl.w	ip, r2, r3
 8008aac:	f1c3 0220 	rsb	r2, r3, #32
 8008ab0:	409f      	lsls	r7, r3
 8008ab2:	fa20 f202 	lsr.w	r2, r0, r2
 8008ab6:	4317      	orrs	r7, r2
 8008ab8:	409c      	lsls	r4, r3
 8008aba:	ea4f 4e1c 	mov.w	lr, ip, lsr #16
 8008abe:	fa1f f58c 	uxth.w	r5, ip
 8008ac2:	fbb7 f1fe 	udiv	r1, r7, lr
 8008ac6:	0c22      	lsrs	r2, r4, #16
 8008ac8:	fb0e 7711 	mls	r7, lr, r1, r7
 8008acc:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
 8008ad0:	fb01 f005 	mul.w	r0, r1, r5
 8008ad4:	4290      	cmp	r0, r2
 8008ad6:	d90a      	bls.n	8008aee <__udivmoddi4+0x62>
 8008ad8:	eb1c 0202 	adds.w	r2, ip, r2
 8008adc:	f101 37ff 	add.w	r7, r1, #4294967295
 8008ae0:	f080 811c 	bcs.w	8008d1c <__udivmoddi4+0x290>
 8008ae4:	4290      	cmp	r0, r2
 8008ae6:	f240 8119 	bls.w	8008d1c <__udivmoddi4+0x290>
 8008aea:	3902      	subs	r1, #2
 8008aec:	4462      	add	r2, ip
 8008aee:	1a12      	subs	r2, r2, r0
 8008af0:	b2a4      	uxth	r4, r4
 8008af2:	fbb2 f0fe 	udiv	r0, r2, lr
 8008af6:	fb0e 2210 	mls	r2, lr, r0, r2
 8008afa:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 8008afe:	fb00 f505 	mul.w	r5, r0, r5
 8008b02:	42a5      	cmp	r5, r4
 8008b04:	d90a      	bls.n	8008b1c <__udivmoddi4+0x90>
 8008b06:	eb1c 0404 	adds.w	r4, ip, r4
 8008b0a:	f100 32ff 	add.w	r2, r0, #4294967295
 8008b0e:	f080 8107 	bcs.w	8008d20 <__udivmoddi4+0x294>
 8008b12:	42a5      	cmp	r5, r4
 8008b14:	f240 8104 	bls.w	8008d20 <__udivmoddi4+0x294>
 8008b18:	4464      	add	r4, ip
 8008b1a:	3802      	subs	r0, #2
 8008b1c:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 8008b20:	1b64      	subs	r4, r4, r5
 8008b22:	2100      	movs	r1, #0
 8008b24:	b11e      	cbz	r6, 8008b2e <__udivmoddi4+0xa2>
 8008b26:	40dc      	lsrs	r4, r3
 8008b28:	2300      	movs	r3, #0
 8008b2a:	e9c6 4300 	strd	r4, r3, [r6]
 8008b2e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008b32:	428b      	cmp	r3, r1
 8008b34:	d908      	bls.n	8008b48 <__udivmoddi4+0xbc>
 8008b36:	2e00      	cmp	r6, #0
 8008b38:	f000 80ed 	beq.w	8008d16 <__udivmoddi4+0x28a>
 8008b3c:	2100      	movs	r1, #0
 8008b3e:	e9c6 0500 	strd	r0, r5, [r6]
 8008b42:	4608      	mov	r0, r1
 8008b44:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008b48:	fab3 f183 	clz	r1, r3
 8008b4c:	2900      	cmp	r1, #0
 8008b4e:	d149      	bne.n	8008be4 <__udivmoddi4+0x158>
 8008b50:	42ab      	cmp	r3, r5
 8008b52:	d302      	bcc.n	8008b5a <__udivmoddi4+0xce>
 8008b54:	4282      	cmp	r2, r0
 8008b56:	f200 80f8 	bhi.w	8008d4a <__udivmoddi4+0x2be>
 8008b5a:	1a84      	subs	r4, r0, r2
 8008b5c:	eb65 0203 	sbc.w	r2, r5, r3
 8008b60:	2001      	movs	r0, #1
 8008b62:	4617      	mov	r7, r2
 8008b64:	2e00      	cmp	r6, #0
 8008b66:	d0e2      	beq.n	8008b2e <__udivmoddi4+0xa2>
 8008b68:	e9c6 4700 	strd	r4, r7, [r6]
 8008b6c:	e7df      	b.n	8008b2e <__udivmoddi4+0xa2>
 8008b6e:	b902      	cbnz	r2, 8008b72 <__udivmoddi4+0xe6>
 8008b70:	deff      	udf	#255	; 0xff
 8008b72:	fab2 f382 	clz	r3, r2
 8008b76:	2b00      	cmp	r3, #0
 8008b78:	f040 8090 	bne.w	8008c9c <__udivmoddi4+0x210>
 8008b7c:	1a8a      	subs	r2, r1, r2
 8008b7e:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8008b82:	fa1f fe8c 	uxth.w	lr, ip
 8008b86:	2101      	movs	r1, #1
 8008b88:	fbb2 f5f7 	udiv	r5, r2, r7
 8008b8c:	fb07 2015 	mls	r0, r7, r5, r2
 8008b90:	0c22      	lsrs	r2, r4, #16
 8008b92:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8008b96:	fb0e f005 	mul.w	r0, lr, r5
 8008b9a:	4290      	cmp	r0, r2
 8008b9c:	d908      	bls.n	8008bb0 <__udivmoddi4+0x124>
 8008b9e:	eb1c 0202 	adds.w	r2, ip, r2
 8008ba2:	f105 38ff 	add.w	r8, r5, #4294967295
 8008ba6:	d202      	bcs.n	8008bae <__udivmoddi4+0x122>
 8008ba8:	4290      	cmp	r0, r2
 8008baa:	f200 80cb 	bhi.w	8008d44 <__udivmoddi4+0x2b8>
 8008bae:	4645      	mov	r5, r8
 8008bb0:	1a12      	subs	r2, r2, r0
 8008bb2:	b2a4      	uxth	r4, r4
 8008bb4:	fbb2 f0f7 	udiv	r0, r2, r7
 8008bb8:	fb07 2210 	mls	r2, r7, r0, r2
 8008bbc:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 8008bc0:	fb0e fe00 	mul.w	lr, lr, r0
 8008bc4:	45a6      	cmp	lr, r4
 8008bc6:	d908      	bls.n	8008bda <__udivmoddi4+0x14e>
 8008bc8:	eb1c 0404 	adds.w	r4, ip, r4
 8008bcc:	f100 32ff 	add.w	r2, r0, #4294967295
 8008bd0:	d202      	bcs.n	8008bd8 <__udivmoddi4+0x14c>
 8008bd2:	45a6      	cmp	lr, r4
 8008bd4:	f200 80bb 	bhi.w	8008d4e <__udivmoddi4+0x2c2>
 8008bd8:	4610      	mov	r0, r2
 8008bda:	eba4 040e 	sub.w	r4, r4, lr
 8008bde:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
 8008be2:	e79f      	b.n	8008b24 <__udivmoddi4+0x98>
 8008be4:	f1c1 0720 	rsb	r7, r1, #32
 8008be8:	408b      	lsls	r3, r1
 8008bea:	fa22 fc07 	lsr.w	ip, r2, r7
 8008bee:	ea4c 0c03 	orr.w	ip, ip, r3
 8008bf2:	fa05 f401 	lsl.w	r4, r5, r1
 8008bf6:	fa20 f307 	lsr.w	r3, r0, r7
 8008bfa:	40fd      	lsrs	r5, r7
 8008bfc:	ea4f 491c 	mov.w	r9, ip, lsr #16
 8008c00:	4323      	orrs	r3, r4
 8008c02:	fbb5 f8f9 	udiv	r8, r5, r9
 8008c06:	fa1f fe8c 	uxth.w	lr, ip
 8008c0a:	fb09 5518 	mls	r5, r9, r8, r5
 8008c0e:	0c1c      	lsrs	r4, r3, #16
 8008c10:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 8008c14:	fb08 f50e 	mul.w	r5, r8, lr
 8008c18:	42a5      	cmp	r5, r4
 8008c1a:	fa02 f201 	lsl.w	r2, r2, r1
 8008c1e:	fa00 f001 	lsl.w	r0, r0, r1
 8008c22:	d90b      	bls.n	8008c3c <__udivmoddi4+0x1b0>
 8008c24:	eb1c 0404 	adds.w	r4, ip, r4
 8008c28:	f108 3aff 	add.w	sl, r8, #4294967295
 8008c2c:	f080 8088 	bcs.w	8008d40 <__udivmoddi4+0x2b4>
 8008c30:	42a5      	cmp	r5, r4
 8008c32:	f240 8085 	bls.w	8008d40 <__udivmoddi4+0x2b4>
 8008c36:	f1a8 0802 	sub.w	r8, r8, #2
 8008c3a:	4464      	add	r4, ip
 8008c3c:	1b64      	subs	r4, r4, r5
 8008c3e:	b29d      	uxth	r5, r3
 8008c40:	fbb4 f3f9 	udiv	r3, r4, r9
 8008c44:	fb09 4413 	mls	r4, r9, r3, r4
 8008c48:	ea45 4404 	orr.w	r4, r5, r4, lsl #16
 8008c4c:	fb03 fe0e 	mul.w	lr, r3, lr
 8008c50:	45a6      	cmp	lr, r4
 8008c52:	d908      	bls.n	8008c66 <__udivmoddi4+0x1da>
 8008c54:	eb1c 0404 	adds.w	r4, ip, r4
 8008c58:	f103 35ff 	add.w	r5, r3, #4294967295
 8008c5c:	d26c      	bcs.n	8008d38 <__udivmoddi4+0x2ac>
 8008c5e:	45a6      	cmp	lr, r4
 8008c60:	d96a      	bls.n	8008d38 <__udivmoddi4+0x2ac>
 8008c62:	3b02      	subs	r3, #2
 8008c64:	4464      	add	r4, ip
 8008c66:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8008c6a:	fba3 9502 	umull	r9, r5, r3, r2
 8008c6e:	eba4 040e 	sub.w	r4, r4, lr
 8008c72:	42ac      	cmp	r4, r5
 8008c74:	46c8      	mov	r8, r9
 8008c76:	46ae      	mov	lr, r5
 8008c78:	d356      	bcc.n	8008d28 <__udivmoddi4+0x29c>
 8008c7a:	d053      	beq.n	8008d24 <__udivmoddi4+0x298>
 8008c7c:	b156      	cbz	r6, 8008c94 <__udivmoddi4+0x208>
 8008c7e:	ebb0 0208 	subs.w	r2, r0, r8
 8008c82:	eb64 040e 	sbc.w	r4, r4, lr
 8008c86:	fa04 f707 	lsl.w	r7, r4, r7
 8008c8a:	40ca      	lsrs	r2, r1
 8008c8c:	40cc      	lsrs	r4, r1
 8008c8e:	4317      	orrs	r7, r2
 8008c90:	e9c6 7400 	strd	r7, r4, [r6]
 8008c94:	4618      	mov	r0, r3
 8008c96:	2100      	movs	r1, #0
 8008c98:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008c9c:	f1c3 0120 	rsb	r1, r3, #32
 8008ca0:	fa02 fc03 	lsl.w	ip, r2, r3
 8008ca4:	fa20 f201 	lsr.w	r2, r0, r1
 8008ca8:	fa25 f101 	lsr.w	r1, r5, r1
 8008cac:	409d      	lsls	r5, r3
 8008cae:	432a      	orrs	r2, r5
 8008cb0:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8008cb4:	fa1f fe8c 	uxth.w	lr, ip
 8008cb8:	fbb1 f0f7 	udiv	r0, r1, r7
 8008cbc:	fb07 1510 	mls	r5, r7, r0, r1
 8008cc0:	0c11      	lsrs	r1, r2, #16
 8008cc2:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
 8008cc6:	fb00 f50e 	mul.w	r5, r0, lr
 8008cca:	428d      	cmp	r5, r1
 8008ccc:	fa04 f403 	lsl.w	r4, r4, r3
 8008cd0:	d908      	bls.n	8008ce4 <__udivmoddi4+0x258>
 8008cd2:	eb1c 0101 	adds.w	r1, ip, r1
 8008cd6:	f100 38ff 	add.w	r8, r0, #4294967295
 8008cda:	d22f      	bcs.n	8008d3c <__udivmoddi4+0x2b0>
 8008cdc:	428d      	cmp	r5, r1
 8008cde:	d92d      	bls.n	8008d3c <__udivmoddi4+0x2b0>
 8008ce0:	3802      	subs	r0, #2
 8008ce2:	4461      	add	r1, ip
 8008ce4:	1b49      	subs	r1, r1, r5
 8008ce6:	b292      	uxth	r2, r2
 8008ce8:	fbb1 f5f7 	udiv	r5, r1, r7
 8008cec:	fb07 1115 	mls	r1, r7, r5, r1
 8008cf0:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8008cf4:	fb05 f10e 	mul.w	r1, r5, lr
 8008cf8:	4291      	cmp	r1, r2
 8008cfa:	d908      	bls.n	8008d0e <__udivmoddi4+0x282>
 8008cfc:	eb1c 0202 	adds.w	r2, ip, r2
 8008d00:	f105 38ff 	add.w	r8, r5, #4294967295
 8008d04:	d216      	bcs.n	8008d34 <__udivmoddi4+0x2a8>
 8008d06:	4291      	cmp	r1, r2
 8008d08:	d914      	bls.n	8008d34 <__udivmoddi4+0x2a8>
 8008d0a:	3d02      	subs	r5, #2
 8008d0c:	4462      	add	r2, ip
 8008d0e:	1a52      	subs	r2, r2, r1
 8008d10:	ea45 4100 	orr.w	r1, r5, r0, lsl #16
 8008d14:	e738      	b.n	8008b88 <__udivmoddi4+0xfc>
 8008d16:	4631      	mov	r1, r6
 8008d18:	4630      	mov	r0, r6
 8008d1a:	e708      	b.n	8008b2e <__udivmoddi4+0xa2>
 8008d1c:	4639      	mov	r1, r7
 8008d1e:	e6e6      	b.n	8008aee <__udivmoddi4+0x62>
 8008d20:	4610      	mov	r0, r2
 8008d22:	e6fb      	b.n	8008b1c <__udivmoddi4+0x90>
 8008d24:	4548      	cmp	r0, r9
 8008d26:	d2a9      	bcs.n	8008c7c <__udivmoddi4+0x1f0>
 8008d28:	ebb9 0802 	subs.w	r8, r9, r2
 8008d2c:	eb65 0e0c 	sbc.w	lr, r5, ip
 8008d30:	3b01      	subs	r3, #1
 8008d32:	e7a3      	b.n	8008c7c <__udivmoddi4+0x1f0>
 8008d34:	4645      	mov	r5, r8
 8008d36:	e7ea      	b.n	8008d0e <__udivmoddi4+0x282>
 8008d38:	462b      	mov	r3, r5
 8008d3a:	e794      	b.n	8008c66 <__udivmoddi4+0x1da>
 8008d3c:	4640      	mov	r0, r8
 8008d3e:	e7d1      	b.n	8008ce4 <__udivmoddi4+0x258>
 8008d40:	46d0      	mov	r8, sl
 8008d42:	e77b      	b.n	8008c3c <__udivmoddi4+0x1b0>
 8008d44:	3d02      	subs	r5, #2
 8008d46:	4462      	add	r2, ip
 8008d48:	e732      	b.n	8008bb0 <__udivmoddi4+0x124>
 8008d4a:	4608      	mov	r0, r1
 8008d4c:	e70a      	b.n	8008b64 <__udivmoddi4+0xd8>
 8008d4e:	4464      	add	r4, ip
 8008d50:	3802      	subs	r0, #2
 8008d52:	e742      	b.n	8008bda <__udivmoddi4+0x14e>

08008d54 <__aeabi_idiv0>:
 8008d54:	4770      	bx	lr
 8008d56:	bf00      	nop

08008d58 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8008d58:	b510      	push	{r4, lr}
 8008d5a:	4604      	mov	r4, r0
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8008d5c:	4b0e      	ldr	r3, [pc, #56]	; (8008d98 <HAL_InitTick+0x40>)
 8008d5e:	781a      	ldrb	r2, [r3, #0]
 8008d60:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8008d64:	fbb3 f3f2 	udiv	r3, r3, r2
 8008d68:	4a0c      	ldr	r2, [pc, #48]	; (8008d9c <HAL_InitTick+0x44>)
 8008d6a:	6810      	ldr	r0, [r2, #0]
 8008d6c:	fbb0 f0f3 	udiv	r0, r0, r3
 8008d70:	f000 f8c2 	bl	8008ef8 <HAL_SYSTICK_Config>
 8008d74:	b968      	cbnz	r0, 8008d92 <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8008d76:	2c0f      	cmp	r4, #15
 8008d78:	d901      	bls.n	8008d7e <HAL_InitTick+0x26>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
    uwTickPrio = TickPriority;
  }
  else
  {
    return HAL_ERROR;
 8008d7a:	2001      	movs	r0, #1
 8008d7c:	e00a      	b.n	8008d94 <HAL_InitTick+0x3c>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8008d7e:	2200      	movs	r2, #0
 8008d80:	4621      	mov	r1, r4
 8008d82:	f04f 30ff 	mov.w	r0, #4294967295
 8008d86:	f000 f85f 	bl	8008e48 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8008d8a:	4b05      	ldr	r3, [pc, #20]	; (8008da0 <HAL_InitTick+0x48>)
 8008d8c:	601c      	str	r4, [r3, #0]
  }

  /* Return function status */
  return HAL_OK;
 8008d8e:	2000      	movs	r0, #0
 8008d90:	e000      	b.n	8008d94 <HAL_InitTick+0x3c>
    return HAL_ERROR;
 8008d92:	2001      	movs	r0, #1
}
 8008d94:	bd10      	pop	{r4, pc}
 8008d96:	bf00      	nop
 8008d98:	20000000 	.word	0x20000000
 8008d9c:	20000364 	.word	0x20000364
 8008da0:	20000004 	.word	0x20000004

08008da4 <HAL_Init>:
{
 8008da4:	b508      	push	{r3, lr}
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8008da6:	4b0b      	ldr	r3, [pc, #44]	; (8008dd4 <HAL_Init+0x30>)
 8008da8:	681a      	ldr	r2, [r3, #0]
 8008daa:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8008dae:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_DATA_CACHE_ENABLE();
 8008db0:	681a      	ldr	r2, [r3, #0]
 8008db2:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8008db6:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8008db8:	681a      	ldr	r2, [r3, #0]
 8008dba:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8008dbe:	601a      	str	r2, [r3, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8008dc0:	2003      	movs	r0, #3
 8008dc2:	f000 f82f 	bl	8008e24 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 8008dc6:	2000      	movs	r0, #0
 8008dc8:	f7ff ffc6 	bl	8008d58 <HAL_InitTick>
  HAL_MspInit();
 8008dcc:	f005 fa48 	bl	800e260 <HAL_MspInit>
}
 8008dd0:	2000      	movs	r0, #0
 8008dd2:	bd08      	pop	{r3, pc}
 8008dd4:	40023c00 	.word	0x40023c00

08008dd8 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8008dd8:	4a03      	ldr	r2, [pc, #12]	; (8008de8 <HAL_IncTick+0x10>)
 8008dda:	6811      	ldr	r1, [r2, #0]
 8008ddc:	4b03      	ldr	r3, [pc, #12]	; (8008dec <HAL_IncTick+0x14>)
 8008dde:	781b      	ldrb	r3, [r3, #0]
 8008de0:	440b      	add	r3, r1
 8008de2:	6013      	str	r3, [r2, #0]
}
 8008de4:	4770      	bx	lr
 8008de6:	bf00      	nop
 8008de8:	2000064c 	.word	0x2000064c
 8008dec:	20000000 	.word	0x20000000

08008df0 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8008df0:	4b01      	ldr	r3, [pc, #4]	; (8008df8 <HAL_GetTick+0x8>)
 8008df2:	6818      	ldr	r0, [r3, #0]
}
 8008df4:	4770      	bx	lr
 8008df6:	bf00      	nop
 8008df8:	2000064c 	.word	0x2000064c

08008dfc <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8008dfc:	b538      	push	{r3, r4, r5, lr}
 8008dfe:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8008e00:	f7ff fff6 	bl	8008df0 <HAL_GetTick>
 8008e04:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8008e06:	f1b4 3fff 	cmp.w	r4, #4294967295
 8008e0a:	d002      	beq.n	8008e12 <HAL_Delay+0x16>
  {
    wait += (uint32_t)(uwTickFreq);
 8008e0c:	4b04      	ldr	r3, [pc, #16]	; (8008e20 <HAL_Delay+0x24>)
 8008e0e:	781b      	ldrb	r3, [r3, #0]
 8008e10:	441c      	add	r4, r3
  }

  while((HAL_GetTick() - tickstart) < wait)
 8008e12:	f7ff ffed 	bl	8008df0 <HAL_GetTick>
 8008e16:	1b40      	subs	r0, r0, r5
 8008e18:	42a0      	cmp	r0, r4
 8008e1a:	d3fa      	bcc.n	8008e12 <HAL_Delay+0x16>
  {
  }
}
 8008e1c:	bd38      	pop	{r3, r4, r5, pc}
 8008e1e:	bf00      	nop
 8008e20:	20000000 	.word	0x20000000

08008e24 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8008e24:	4a07      	ldr	r2, [pc, #28]	; (8008e44 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8008e26:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8008e28:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8008e2c:	041b      	lsls	r3, r3, #16
 8008e2e:	0c1b      	lsrs	r3, r3, #16
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8008e30:	0200      	lsls	r0, r0, #8
 8008e32:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8008e36:	4303      	orrs	r3, r0
  reg_value  =  (reg_value                                   |
 8008e38:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8008e3c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 8008e40:	60d3      	str	r3, [r2, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 8008e42:	4770      	bx	lr
 8008e44:	e000ed00 	.word	0xe000ed00

08008e48 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8008e48:	b500      	push	{lr}
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8008e4a:	4b19      	ldr	r3, [pc, #100]	; (8008eb0 <HAL_NVIC_SetPriority+0x68>)
 8008e4c:	68db      	ldr	r3, [r3, #12]
 8008e4e:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8008e52:	f1c3 0c07 	rsb	ip, r3, #7
 8008e56:	f1bc 0f04 	cmp.w	ip, #4
 8008e5a:	bf28      	it	cs
 8008e5c:	f04f 0c04 	movcs.w	ip, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8008e60:	f103 0e04 	add.w	lr, r3, #4
 8008e64:	f1be 0f06 	cmp.w	lr, #6
 8008e68:	d918      	bls.n	8008e9c <HAL_NVIC_SetPriority+0x54>
 8008e6a:	3b03      	subs	r3, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8008e6c:	f04f 3eff 	mov.w	lr, #4294967295
 8008e70:	fa0e fc0c 	lsl.w	ip, lr, ip
 8008e74:	ea21 010c 	bic.w	r1, r1, ip
 8008e78:	4099      	lsls	r1, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8008e7a:	fa0e fe03 	lsl.w	lr, lr, r3
 8008e7e:	ea22 020e 	bic.w	r2, r2, lr
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8008e82:	430a      	orrs	r2, r1
  if ((int32_t)(IRQn) >= 0)
 8008e84:	2800      	cmp	r0, #0
 8008e86:	db0b      	blt.n	8008ea0 <HAL_NVIC_SetPriority+0x58>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8008e88:	0112      	lsls	r2, r2, #4
 8008e8a:	b2d2      	uxtb	r2, r2
 8008e8c:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8008e90:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8008e94:	f880 2300 	strb.w	r2, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8008e98:	f85d fb04 	ldr.w	pc, [sp], #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8008e9c:	2300      	movs	r3, #0
 8008e9e:	e7e5      	b.n	8008e6c <HAL_NVIC_SetPriority+0x24>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8008ea0:	f000 000f 	and.w	r0, r0, #15
 8008ea4:	0112      	lsls	r2, r2, #4
 8008ea6:	b2d2      	uxtb	r2, r2
 8008ea8:	4b02      	ldr	r3, [pc, #8]	; (8008eb4 <HAL_NVIC_SetPriority+0x6c>)
 8008eaa:	541a      	strb	r2, [r3, r0]
 8008eac:	e7f4      	b.n	8008e98 <HAL_NVIC_SetPriority+0x50>
 8008eae:	bf00      	nop
 8008eb0:	e000ed00 	.word	0xe000ed00
 8008eb4:	e000ed14 	.word	0xe000ed14

08008eb8 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8008eb8:	2800      	cmp	r0, #0
 8008eba:	db07      	blt.n	8008ecc <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8008ebc:	f000 021f 	and.w	r2, r0, #31
 8008ec0:	0940      	lsrs	r0, r0, #5
 8008ec2:	2301      	movs	r3, #1
 8008ec4:	4093      	lsls	r3, r2
 8008ec6:	4a02      	ldr	r2, [pc, #8]	; (8008ed0 <HAL_NVIC_EnableIRQ+0x18>)
 8008ec8:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8008ecc:	4770      	bx	lr
 8008ece:	bf00      	nop
 8008ed0:	e000e100 	.word	0xe000e100

08008ed4 <HAL_NVIC_DisableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8008ed4:	2800      	cmp	r0, #0
 8008ed6:	db0c      	blt.n	8008ef2 <HAL_NVIC_DisableIRQ+0x1e>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8008ed8:	f000 021f 	and.w	r2, r0, #31
 8008edc:	0940      	lsrs	r0, r0, #5
 8008ede:	2301      	movs	r3, #1
 8008ee0:	4093      	lsls	r3, r2
 8008ee2:	3020      	adds	r0, #32
 8008ee4:	4a03      	ldr	r2, [pc, #12]	; (8008ef4 <HAL_NVIC_DisableIRQ+0x20>)
 8008ee6:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8008eea:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8008eee:	f3bf 8f6f 	isb	sy
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 8008ef2:	4770      	bx	lr
 8008ef4:	e000e100 	.word	0xe000e100

08008ef8 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8008ef8:	3801      	subs	r0, #1
 8008efa:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8008efe:	d20b      	bcs.n	8008f18 <HAL_SYSTICK_Config+0x20>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8008f00:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8008f04:	6158      	str	r0, [r3, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8008f06:	4a05      	ldr	r2, [pc, #20]	; (8008f1c <HAL_SYSTICK_Config+0x24>)
 8008f08:	21f0      	movs	r1, #240	; 0xf0
 8008f0a:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8008f0e:	2000      	movs	r0, #0
 8008f10:	6198      	str	r0, [r3, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8008f12:	2207      	movs	r2, #7
 8008f14:	611a      	str	r2, [r3, #16]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8008f16:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8008f18:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8008f1a:	4770      	bx	lr
 8008f1c:	e000ed00 	.word	0xe000ed00

08008f20 <FLASH_Program_DoubleWord>:
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data)
{
 8008f20:	b410      	push	{r4}
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8008f22:	490a      	ldr	r1, [pc, #40]	; (8008f4c <FLASH_Program_DoubleWord+0x2c>)
 8008f24:	690c      	ldr	r4, [r1, #16]
 8008f26:	f424 7440 	bic.w	r4, r4, #768	; 0x300
 8008f2a:	610c      	str	r4, [r1, #16]
  FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
 8008f2c:	690c      	ldr	r4, [r1, #16]
 8008f2e:	f444 7440 	orr.w	r4, r4, #768	; 0x300
 8008f32:	610c      	str	r4, [r1, #16]
  FLASH->CR |= FLASH_CR_PG;
 8008f34:	690c      	ldr	r4, [r1, #16]
 8008f36:	f044 0401 	orr.w	r4, r4, #1
 8008f3a:	610c      	str	r4, [r1, #16]

  /* Program first word */
  *(__IO uint32_t*)Address = (uint32_t)Data;
 8008f3c:	6002      	str	r2, [r0, #0]
 8008f3e:	f3bf 8f6f 	isb	sy
  /* Barrier to ensure programming is performed in 2 steps, in right order
    (independently of compiler optimization behavior) */
  __ISB();

  /* Program second word */
  *(__IO uint32_t*)(Address+4) = (uint32_t)(Data >> 32);
 8008f42:	6043      	str	r3, [r0, #4]
}
 8008f44:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008f48:	4770      	bx	lr
 8008f4a:	bf00      	nop
 8008f4c:	40023c00 	.word	0x40023c00

08008f50 <FLASH_Program_Word>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8008f50:	4b07      	ldr	r3, [pc, #28]	; (8008f70 <FLASH_Program_Word+0x20>)
 8008f52:	691a      	ldr	r2, [r3, #16]
 8008f54:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8008f58:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_PSIZE_WORD;
 8008f5a:	691a      	ldr	r2, [r3, #16]
 8008f5c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8008f60:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_PG;
 8008f62:	691a      	ldr	r2, [r3, #16]
 8008f64:	f042 0201 	orr.w	r2, r2, #1
 8008f68:	611a      	str	r2, [r3, #16]

  *(__IO uint32_t*)Address = Data;
 8008f6a:	6001      	str	r1, [r0, #0]
}
 8008f6c:	4770      	bx	lr
 8008f6e:	bf00      	nop
 8008f70:	40023c00 	.word	0x40023c00

08008f74 <FLASH_Program_HalfWord>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8008f74:	4b07      	ldr	r3, [pc, #28]	; (8008f94 <FLASH_Program_HalfWord+0x20>)
 8008f76:	691a      	ldr	r2, [r3, #16]
 8008f78:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8008f7c:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_PSIZE_HALF_WORD;
 8008f7e:	691a      	ldr	r2, [r3, #16]
 8008f80:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8008f84:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_PG;
 8008f86:	691a      	ldr	r2, [r3, #16]
 8008f88:	f042 0201 	orr.w	r2, r2, #1
 8008f8c:	611a      	str	r2, [r3, #16]

  *(__IO uint16_t*)Address = Data;
 8008f8e:	8001      	strh	r1, [r0, #0]
}
 8008f90:	4770      	bx	lr
 8008f92:	bf00      	nop
 8008f94:	40023c00 	.word	0x40023c00

08008f98 <FLASH_Program_Byte>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8008f98:	4b06      	ldr	r3, [pc, #24]	; (8008fb4 <FLASH_Program_Byte+0x1c>)
 8008f9a:	691a      	ldr	r2, [r3, #16]
 8008f9c:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8008fa0:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_PSIZE_BYTE;
 8008fa2:	691a      	ldr	r2, [r3, #16]
 8008fa4:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_PG;
 8008fa6:	691a      	ldr	r2, [r3, #16]
 8008fa8:	f042 0201 	orr.w	r2, r2, #1
 8008fac:	611a      	str	r2, [r3, #16]

  *(__IO uint8_t*)Address = Data;
 8008fae:	7001      	strb	r1, [r0, #0]
}
 8008fb0:	4770      	bx	lr
 8008fb2:	bf00      	nop
 8008fb4:	40023c00 	.word	0x40023c00

08008fb8 <FLASH_SetErrorCode>:
  * @brief  Set the specific FLASH error flag.
  * @retval None
  */
static void FLASH_SetErrorCode(void)
{ 
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) != RESET)
 8008fb8:	4b20      	ldr	r3, [pc, #128]	; (800903c <FLASH_SetErrorCode+0x84>)
 8008fba:	68db      	ldr	r3, [r3, #12]
 8008fbc:	f013 0f10 	tst.w	r3, #16
 8008fc0:	d007      	beq.n	8008fd2 <FLASH_SetErrorCode+0x1a>
  {
   pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8008fc2:	4a1f      	ldr	r2, [pc, #124]	; (8009040 <FLASH_SetErrorCode+0x88>)
 8008fc4:	69d3      	ldr	r3, [r2, #28]
 8008fc6:	f043 0310 	orr.w	r3, r3, #16
 8008fca:	61d3      	str	r3, [r2, #28]
   
   /* Clear FLASH write protection error pending bit */
   __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_WRPERR);
 8008fcc:	4b1b      	ldr	r3, [pc, #108]	; (800903c <FLASH_SetErrorCode+0x84>)
 8008fce:	2210      	movs	r2, #16
 8008fd0:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR) != RESET)
 8008fd2:	4b1a      	ldr	r3, [pc, #104]	; (800903c <FLASH_SetErrorCode+0x84>)
 8008fd4:	68db      	ldr	r3, [r3, #12]
 8008fd6:	f013 0f20 	tst.w	r3, #32
 8008fda:	d007      	beq.n	8008fec <FLASH_SetErrorCode+0x34>
  {
   pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
 8008fdc:	4a18      	ldr	r2, [pc, #96]	; (8009040 <FLASH_SetErrorCode+0x88>)
 8008fde:	69d3      	ldr	r3, [r2, #28]
 8008fe0:	f043 0308 	orr.w	r3, r3, #8
 8008fe4:	61d3      	str	r3, [r2, #28]
   
   /* Clear FLASH Programming alignment error pending bit */
   __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGAERR);
 8008fe6:	4b15      	ldr	r3, [pc, #84]	; (800903c <FLASH_SetErrorCode+0x84>)
 8008fe8:	2220      	movs	r2, #32
 8008fea:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGPERR) != RESET)
 8008fec:	4b13      	ldr	r3, [pc, #76]	; (800903c <FLASH_SetErrorCode+0x84>)
 8008fee:	68db      	ldr	r3, [r3, #12]
 8008ff0:	f013 0f40 	tst.w	r3, #64	; 0x40
 8008ff4:	d007      	beq.n	8009006 <FLASH_SetErrorCode+0x4e>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGP;
 8008ff6:	4a12      	ldr	r2, [pc, #72]	; (8009040 <FLASH_SetErrorCode+0x88>)
 8008ff8:	69d3      	ldr	r3, [r2, #28]
 8008ffa:	f043 0304 	orr.w	r3, r3, #4
 8008ffe:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Programming parallelism error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGPERR);
 8009000:	4b0e      	ldr	r3, [pc, #56]	; (800903c <FLASH_SetErrorCode+0x84>)
 8009002:	2240      	movs	r2, #64	; 0x40
 8009004:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGSERR) != RESET)
 8009006:	4b0d      	ldr	r3, [pc, #52]	; (800903c <FLASH_SetErrorCode+0x84>)
 8009008:	68db      	ldr	r3, [r3, #12]
 800900a:	f013 0f80 	tst.w	r3, #128	; 0x80
 800900e:	d007      	beq.n	8009020 <FLASH_SetErrorCode+0x68>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGS;
 8009010:	4a0b      	ldr	r2, [pc, #44]	; (8009040 <FLASH_SetErrorCode+0x88>)
 8009012:	69d3      	ldr	r3, [r2, #28]
 8009014:	f043 0302 	orr.w	r3, r3, #2
 8009018:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Programming sequence error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGSERR);
 800901a:	4b08      	ldr	r3, [pc, #32]	; (800903c <FLASH_SetErrorCode+0x84>)
 800901c:	2280      	movs	r2, #128	; 0x80
 800901e:	60da      	str	r2, [r3, #12]
    
    /* Clear FLASH Proprietary readout protection error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_RDERR);
  }
#endif /* FLASH_SR_RDERR */  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR) != RESET)
 8009020:	4b06      	ldr	r3, [pc, #24]	; (800903c <FLASH_SetErrorCode+0x84>)
 8009022:	68db      	ldr	r3, [r3, #12]
 8009024:	f013 0f02 	tst.w	r3, #2
 8009028:	d007      	beq.n	800903a <FLASH_SetErrorCode+0x82>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPERATION;
 800902a:	4a05      	ldr	r2, [pc, #20]	; (8009040 <FLASH_SetErrorCode+0x88>)
 800902c:	69d3      	ldr	r3, [r2, #28]
 800902e:	f043 0320 	orr.w	r3, r3, #32
 8009032:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Operation error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPERR);
 8009034:	4b01      	ldr	r3, [pc, #4]	; (800903c <FLASH_SetErrorCode+0x84>)
 8009036:	2202      	movs	r2, #2
 8009038:	60da      	str	r2, [r3, #12]
  }
}
 800903a:	4770      	bx	lr
 800903c:	40023c00 	.word	0x40023c00
 8009040:	20000650 	.word	0x20000650

08009044 <HAL_FLASH_Unlock>:
  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8009044:	4b09      	ldr	r3, [pc, #36]	; (800906c <HAL_FLASH_Unlock+0x28>)
 8009046:	691b      	ldr	r3, [r3, #16]
 8009048:	2b00      	cmp	r3, #0
 800904a:	db01      	blt.n	8009050 <HAL_FLASH_Unlock+0xc>
  HAL_StatusTypeDef status = HAL_OK;
 800904c:	2000      	movs	r0, #0
 800904e:	4770      	bx	lr
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8009050:	4b06      	ldr	r3, [pc, #24]	; (800906c <HAL_FLASH_Unlock+0x28>)
 8009052:	4a07      	ldr	r2, [pc, #28]	; (8009070 <HAL_FLASH_Unlock+0x2c>)
 8009054:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8009056:	f102 3288 	add.w	r2, r2, #2290649224	; 0x88888888
 800905a:	605a      	str	r2, [r3, #4]
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 800905c:	691b      	ldr	r3, [r3, #16]
 800905e:	2b00      	cmp	r3, #0
 8009060:	db01      	blt.n	8009066 <HAL_FLASH_Unlock+0x22>
  HAL_StatusTypeDef status = HAL_OK;
 8009062:	2000      	movs	r0, #0
 8009064:	4770      	bx	lr
      status = HAL_ERROR;
 8009066:	2001      	movs	r0, #1
}
 8009068:	4770      	bx	lr
 800906a:	bf00      	nop
 800906c:	40023c00 	.word	0x40023c00
 8009070:	45670123 	.word	0x45670123

08009074 <HAL_FLASH_Lock>:
  FLASH->CR |= FLASH_CR_LOCK;
 8009074:	4a03      	ldr	r2, [pc, #12]	; (8009084 <HAL_FLASH_Lock+0x10>)
 8009076:	6913      	ldr	r3, [r2, #16]
 8009078:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800907c:	6113      	str	r3, [r2, #16]
}
 800907e:	2000      	movs	r0, #0
 8009080:	4770      	bx	lr
 8009082:	bf00      	nop
 8009084:	40023c00 	.word	0x40023c00

08009088 <FLASH_WaitForLastOperation>:
{ 
 8009088:	b538      	push	{r3, r4, r5, lr}
 800908a:	4604      	mov	r4, r0
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800908c:	4b14      	ldr	r3, [pc, #80]	; (80090e0 <FLASH_WaitForLastOperation+0x58>)
 800908e:	2200      	movs	r2, #0
 8009090:	61da      	str	r2, [r3, #28]
  tickstart = HAL_GetTick();
 8009092:	f7ff fead 	bl	8008df0 <HAL_GetTick>
 8009096:	4605      	mov	r5, r0
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 8009098:	4b12      	ldr	r3, [pc, #72]	; (80090e4 <FLASH_WaitForLastOperation+0x5c>)
 800909a:	68db      	ldr	r3, [r3, #12]
 800909c:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 80090a0:	d00a      	beq.n	80090b8 <FLASH_WaitForLastOperation+0x30>
    if(Timeout != HAL_MAX_DELAY)
 80090a2:	f1b4 3fff 	cmp.w	r4, #4294967295
 80090a6:	d0f7      	beq.n	8009098 <FLASH_WaitForLastOperation+0x10>
      if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
 80090a8:	b124      	cbz	r4, 80090b4 <FLASH_WaitForLastOperation+0x2c>
 80090aa:	f7ff fea1 	bl	8008df0 <HAL_GetTick>
 80090ae:	1b40      	subs	r0, r0, r5
 80090b0:	42a0      	cmp	r0, r4
 80090b2:	d9f1      	bls.n	8009098 <FLASH_WaitForLastOperation+0x10>
        return HAL_TIMEOUT;
 80090b4:	2003      	movs	r0, #3
 80090b6:	e00d      	b.n	80090d4 <FLASH_WaitForLastOperation+0x4c>
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
 80090b8:	4b0a      	ldr	r3, [pc, #40]	; (80090e4 <FLASH_WaitForLastOperation+0x5c>)
 80090ba:	68db      	ldr	r3, [r3, #12]
 80090bc:	f013 0f01 	tst.w	r3, #1
 80090c0:	d002      	beq.n	80090c8 <FLASH_WaitForLastOperation+0x40>
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 80090c2:	4b08      	ldr	r3, [pc, #32]	; (80090e4 <FLASH_WaitForLastOperation+0x5c>)
 80090c4:	2201      	movs	r2, #1
 80090c6:	60da      	str	r2, [r3, #12]
  if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
 80090c8:	4b06      	ldr	r3, [pc, #24]	; (80090e4 <FLASH_WaitForLastOperation+0x5c>)
 80090ca:	68db      	ldr	r3, [r3, #12]
 80090cc:	f013 0ff2 	tst.w	r3, #242	; 0xf2
 80090d0:	d101      	bne.n	80090d6 <FLASH_WaitForLastOperation+0x4e>
  return HAL_OK;
 80090d2:	2000      	movs	r0, #0
}  
 80090d4:	bd38      	pop	{r3, r4, r5, pc}
    FLASH_SetErrorCode();
 80090d6:	f7ff ff6f 	bl	8008fb8 <FLASH_SetErrorCode>
    return HAL_ERROR;
 80090da:	2001      	movs	r0, #1
 80090dc:	e7fa      	b.n	80090d4 <FLASH_WaitForLastOperation+0x4c>
 80090de:	bf00      	nop
 80090e0:	20000650 	.word	0x20000650
 80090e4:	40023c00 	.word	0x40023c00

080090e8 <HAL_FLASH_Program>:
{
 80090e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80090ea:	4616      	mov	r6, r2
  __HAL_LOCK(&pFlash);
 80090ec:	4a1b      	ldr	r2, [pc, #108]	; (800915c <HAL_FLASH_Program+0x74>)
 80090ee:	7e12      	ldrb	r2, [r2, #24]
 80090f0:	2a01      	cmp	r2, #1
 80090f2:	d030      	beq.n	8009156 <HAL_FLASH_Program+0x6e>
 80090f4:	4604      	mov	r4, r0
 80090f6:	460d      	mov	r5, r1
 80090f8:	461f      	mov	r7, r3
 80090fa:	4b18      	ldr	r3, [pc, #96]	; (800915c <HAL_FLASH_Program+0x74>)
 80090fc:	2201      	movs	r2, #1
 80090fe:	761a      	strb	r2, [r3, #24]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8009100:	f24c 3050 	movw	r0, #50000	; 0xc350
 8009104:	f7ff ffc0 	bl	8009088 <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
 8009108:	b990      	cbnz	r0, 8009130 <HAL_FLASH_Program+0x48>
    if(TypeProgram == FLASH_TYPEPROGRAM_BYTE)
 800910a:	b1ac      	cbz	r4, 8009138 <HAL_FLASH_Program+0x50>
    else if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
 800910c:	2c01      	cmp	r4, #1
 800910e:	d018      	beq.n	8009142 <HAL_FLASH_Program+0x5a>
    else if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
 8009110:	2c02      	cmp	r4, #2
 8009112:	d01b      	beq.n	800914c <HAL_FLASH_Program+0x64>
      FLASH_Program_DoubleWord(Address, Data);
 8009114:	4632      	mov	r2, r6
 8009116:	463b      	mov	r3, r7
 8009118:	4628      	mov	r0, r5
 800911a:	f7ff ff01 	bl	8008f20 <FLASH_Program_DoubleWord>
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 800911e:	f24c 3050 	movw	r0, #50000	; 0xc350
 8009122:	f7ff ffb1 	bl	8009088 <FLASH_WaitForLastOperation>
    FLASH->CR &= (~FLASH_CR_PG);  
 8009126:	4a0e      	ldr	r2, [pc, #56]	; (8009160 <HAL_FLASH_Program+0x78>)
 8009128:	6913      	ldr	r3, [r2, #16]
 800912a:	f023 0301 	bic.w	r3, r3, #1
 800912e:	6113      	str	r3, [r2, #16]
  __HAL_UNLOCK(&pFlash);
 8009130:	4b0a      	ldr	r3, [pc, #40]	; (800915c <HAL_FLASH_Program+0x74>)
 8009132:	2200      	movs	r2, #0
 8009134:	761a      	strb	r2, [r3, #24]
}
 8009136:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      FLASH_Program_Byte(Address, (uint8_t) Data);
 8009138:	b2f1      	uxtb	r1, r6
 800913a:	4628      	mov	r0, r5
 800913c:	f7ff ff2c 	bl	8008f98 <FLASH_Program_Byte>
 8009140:	e7ed      	b.n	800911e <HAL_FLASH_Program+0x36>
      FLASH_Program_HalfWord(Address, (uint16_t) Data);
 8009142:	b2b1      	uxth	r1, r6
 8009144:	4628      	mov	r0, r5
 8009146:	f7ff ff15 	bl	8008f74 <FLASH_Program_HalfWord>
 800914a:	e7e8      	b.n	800911e <HAL_FLASH_Program+0x36>
      FLASH_Program_Word(Address, (uint32_t) Data);
 800914c:	4631      	mov	r1, r6
 800914e:	4628      	mov	r0, r5
 8009150:	f7ff fefe 	bl	8008f50 <FLASH_Program_Word>
 8009154:	e7e3      	b.n	800911e <HAL_FLASH_Program+0x36>
  __HAL_LOCK(&pFlash);
 8009156:	2002      	movs	r0, #2
 8009158:	e7ed      	b.n	8009136 <HAL_FLASH_Program+0x4e>
 800915a:	bf00      	nop
 800915c:	20000650 	.word	0x20000650
 8009160:	40023c00 	.word	0x40023c00

08009164 <FLASH_MassErase>:
  /* Check the parameters */
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  assert_param(IS_FLASH_BANK(Banks));
  
  /* If the previous operation is completed, proceed to erase all sectors */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8009164:	4b07      	ldr	r3, [pc, #28]	; (8009184 <FLASH_MassErase+0x20>)
 8009166:	691a      	ldr	r2, [r3, #16]
 8009168:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 800916c:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_MER;
 800916e:	691a      	ldr	r2, [r3, #16]
 8009170:	f042 0204 	orr.w	r2, r2, #4
 8009174:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_STRT | ((uint32_t)VoltageRange <<8U);
 8009176:	691a      	ldr	r2, [r3, #16]
 8009178:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 800917c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8009180:	611a      	str	r2, [r3, #16]
}
 8009182:	4770      	bx	lr
 8009184:	40023c00 	.word	0x40023c00

08009188 <FLASH_Erase_Sector>:

  /* Check the parameters */
  assert_param(IS_FLASH_SECTOR(Sector));
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  
  if(VoltageRange == FLASH_VOLTAGE_RANGE_1)
 8009188:	2901      	cmp	r1, #1
 800918a:	d01b      	beq.n	80091c4 <FLASH_Erase_Sector+0x3c>
 800918c:	2902      	cmp	r1, #2
 800918e:	d01c      	beq.n	80091ca <FLASH_Erase_Sector+0x42>
 8009190:	b109      	cbz	r1, 8009196 <FLASH_Erase_Sector+0xe>
{
 8009192:	f44f 7140 	mov.w	r1, #768	; 0x300
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
  }

  /* If the previous operation is completed, proceed to erase the sector */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8009196:	4b0e      	ldr	r3, [pc, #56]	; (80091d0 <FLASH_Erase_Sector+0x48>)
 8009198:	691a      	ldr	r2, [r3, #16]
 800919a:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 800919e:	611a      	str	r2, [r3, #16]
  FLASH->CR |= tmp_psize;
 80091a0:	691a      	ldr	r2, [r3, #16]
 80091a2:	430a      	orrs	r2, r1
 80091a4:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(FLASH->CR, FLASH_CR_SNB);
 80091a6:	691a      	ldr	r2, [r3, #16]
 80091a8:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 80091ac:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos);
 80091ae:	691a      	ldr	r2, [r3, #16]
 80091b0:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
 80091b4:	f040 0002 	orr.w	r0, r0, #2
 80091b8:	6118      	str	r0, [r3, #16]
  FLASH->CR |= FLASH_CR_STRT;
 80091ba:	691a      	ldr	r2, [r3, #16]
 80091bc:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80091c0:	611a      	str	r2, [r3, #16]
}
 80091c2:	4770      	bx	lr
{
 80091c4:	f44f 7180 	mov.w	r1, #256	; 0x100
 80091c8:	e7e5      	b.n	8009196 <FLASH_Erase_Sector+0xe>
 80091ca:	f44f 7100 	mov.w	r1, #512	; 0x200
 80091ce:	e7e2      	b.n	8009196 <FLASH_Erase_Sector+0xe>
 80091d0:	40023c00 	.word	0x40023c00

080091d4 <FLASH_FlushCaches>:
  * @retval None
  */
void FLASH_FlushCaches(void)
{
  /* Flush instruction cache  */
  if(READ_BIT(FLASH->ACR, FLASH_ACR_ICEN)!= RESET)
 80091d4:	4b16      	ldr	r3, [pc, #88]	; (8009230 <FLASH_FlushCaches+0x5c>)
 80091d6:	681b      	ldr	r3, [r3, #0]
 80091d8:	f413 7f00 	tst.w	r3, #512	; 0x200
 80091dc:	d010      	beq.n	8009200 <FLASH_FlushCaches+0x2c>
  {
    /* Disable instruction cache  */
    __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
 80091de:	4b14      	ldr	r3, [pc, #80]	; (8009230 <FLASH_FlushCaches+0x5c>)
 80091e0:	681a      	ldr	r2, [r3, #0]
 80091e2:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 80091e6:	601a      	str	r2, [r3, #0]
    /* Reset instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_RESET();
 80091e8:	681a      	ldr	r2, [r3, #0]
 80091ea:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80091ee:	601a      	str	r2, [r3, #0]
 80091f0:	681a      	ldr	r2, [r3, #0]
 80091f2:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80091f6:	601a      	str	r2, [r3, #0]
    /* Enable instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 80091f8:	681a      	ldr	r2, [r3, #0]
 80091fa:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80091fe:	601a      	str	r2, [r3, #0]
  }
  
  /* Flush data cache */
  if(READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != RESET)
 8009200:	4b0b      	ldr	r3, [pc, #44]	; (8009230 <FLASH_FlushCaches+0x5c>)
 8009202:	681b      	ldr	r3, [r3, #0]
 8009204:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8009208:	d010      	beq.n	800922c <FLASH_FlushCaches+0x58>
  {
    /* Disable data cache  */
    __HAL_FLASH_DATA_CACHE_DISABLE();
 800920a:	4b09      	ldr	r3, [pc, #36]	; (8009230 <FLASH_FlushCaches+0x5c>)
 800920c:	681a      	ldr	r2, [r3, #0]
 800920e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8009212:	601a      	str	r2, [r3, #0]
    /* Reset data cache */
    __HAL_FLASH_DATA_CACHE_RESET();
 8009214:	681a      	ldr	r2, [r3, #0]
 8009216:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800921a:	601a      	str	r2, [r3, #0]
 800921c:	681a      	ldr	r2, [r3, #0]
 800921e:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8009222:	601a      	str	r2, [r3, #0]
    /* Enable data cache */
    __HAL_FLASH_DATA_CACHE_ENABLE();
 8009224:	681a      	ldr	r2, [r3, #0]
 8009226:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800922a:	601a      	str	r2, [r3, #0]
  }
}
 800922c:	4770      	bx	lr
 800922e:	bf00      	nop
 8009230:	40023c00 	.word	0x40023c00

08009234 <HAL_FLASHEx_Erase>:
{
 8009234:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(&pFlash);
 8009236:	4b22      	ldr	r3, [pc, #136]	; (80092c0 <HAL_FLASHEx_Erase+0x8c>)
 8009238:	7e1b      	ldrb	r3, [r3, #24]
 800923a:	2b01      	cmp	r3, #1
 800923c:	d03e      	beq.n	80092bc <HAL_FLASHEx_Erase+0x88>
 800923e:	4604      	mov	r4, r0
 8009240:	460e      	mov	r6, r1
 8009242:	4b1f      	ldr	r3, [pc, #124]	; (80092c0 <HAL_FLASHEx_Erase+0x8c>)
 8009244:	2201      	movs	r2, #1
 8009246:	761a      	strb	r2, [r3, #24]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8009248:	f24c 3050 	movw	r0, #50000	; 0xc350
 800924c:	f7ff ff1c 	bl	8009088 <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
 8009250:	4607      	mov	r7, r0
 8009252:	bb70      	cbnz	r0, 80092b2 <HAL_FLASHEx_Erase+0x7e>
    *SectorError = 0xFFFFFFFFU;
 8009254:	f04f 33ff 	mov.w	r3, #4294967295
 8009258:	6033      	str	r3, [r6, #0]
    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 800925a:	6823      	ldr	r3, [r4, #0]
 800925c:	2b01      	cmp	r3, #1
 800925e:	d016      	beq.n	800928e <HAL_FLASHEx_Erase+0x5a>
      for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
 8009260:	68a5      	ldr	r5, [r4, #8]
 8009262:	68e3      	ldr	r3, [r4, #12]
 8009264:	68a2      	ldr	r2, [r4, #8]
 8009266:	4413      	add	r3, r2
 8009268:	42ab      	cmp	r3, r5
 800926a:	d920      	bls.n	80092ae <HAL_FLASHEx_Erase+0x7a>
        FLASH_Erase_Sector(index, (uint8_t) pEraseInit->VoltageRange);
 800926c:	7c21      	ldrb	r1, [r4, #16]
 800926e:	4628      	mov	r0, r5
 8009270:	f7ff ff8a 	bl	8009188 <FLASH_Erase_Sector>
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8009274:	f24c 3050 	movw	r0, #50000	; 0xc350
 8009278:	f7ff ff06 	bl	8009088 <FLASH_WaitForLastOperation>
        CLEAR_BIT(FLASH->CR, (FLASH_CR_SER | FLASH_CR_SNB));
 800927c:	4a11      	ldr	r2, [pc, #68]	; (80092c4 <HAL_FLASHEx_Erase+0x90>)
 800927e:	6913      	ldr	r3, [r2, #16]
 8009280:	f023 03fa 	bic.w	r3, r3, #250	; 0xfa
 8009284:	6113      	str	r3, [r2, #16]
        if(status != HAL_OK) 
 8009286:	4607      	mov	r7, r0
 8009288:	b980      	cbnz	r0, 80092ac <HAL_FLASHEx_Erase+0x78>
      for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
 800928a:	3501      	adds	r5, #1
 800928c:	e7e9      	b.n	8009262 <HAL_FLASHEx_Erase+0x2e>
      FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);
 800928e:	6861      	ldr	r1, [r4, #4]
 8009290:	7c20      	ldrb	r0, [r4, #16]
 8009292:	f7ff ff67 	bl	8009164 <FLASH_MassErase>
      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8009296:	f24c 3050 	movw	r0, #50000	; 0xc350
 800929a:	f7ff fef5 	bl	8009088 <FLASH_WaitForLastOperation>
 800929e:	4607      	mov	r7, r0
      FLASH->CR &= (~FLASH_MER_BIT);
 80092a0:	4a08      	ldr	r2, [pc, #32]	; (80092c4 <HAL_FLASHEx_Erase+0x90>)
 80092a2:	6913      	ldr	r3, [r2, #16]
 80092a4:	f023 0304 	bic.w	r3, r3, #4
 80092a8:	6113      	str	r3, [r2, #16]
 80092aa:	e000      	b.n	80092ae <HAL_FLASHEx_Erase+0x7a>
          *SectorError = index;
 80092ac:	6035      	str	r5, [r6, #0]
    FLASH_FlushCaches();    
 80092ae:	f7ff ff91 	bl	80091d4 <FLASH_FlushCaches>
  __HAL_UNLOCK(&pFlash);
 80092b2:	4b03      	ldr	r3, [pc, #12]	; (80092c0 <HAL_FLASHEx_Erase+0x8c>)
 80092b4:	2200      	movs	r2, #0
 80092b6:	761a      	strb	r2, [r3, #24]
}
 80092b8:	4638      	mov	r0, r7
 80092ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_LOCK(&pFlash);
 80092bc:	2702      	movs	r7, #2
 80092be:	e7fb      	b.n	80092b8 <HAL_FLASHEx_Erase+0x84>
 80092c0:	20000650 	.word	0x20000650
 80092c4:	40023c00 	.word	0x40023c00

080092c8 <HAL_GPIO_Init>:
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 80092c8:	2300      	movs	r3, #0
 80092ca:	2b0f      	cmp	r3, #15
 80092cc:	f200 80da 	bhi.w	8009484 <HAL_GPIO_Init+0x1bc>
{
 80092d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80092d2:	b083      	sub	sp, #12
 80092d4:	e03a      	b.n	800934c <HAL_GPIO_Init+0x84>
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80092d6:	2207      	movs	r2, #7
 80092d8:	e000      	b.n	80092dc <HAL_GPIO_Init+0x14>
 80092da:	2200      	movs	r2, #0
 80092dc:	40aa      	lsls	r2, r5
 80092de:	4332      	orrs	r2, r6
        SYSCFG->EXTICR[position >> 2U] = temp;
 80092e0:	3402      	adds	r4, #2
 80092e2:	4d69      	ldr	r5, [pc, #420]	; (8009488 <HAL_GPIO_Init+0x1c0>)
 80092e4:	f845 2024 	str.w	r2, [r5, r4, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 80092e8:	4a68      	ldr	r2, [pc, #416]	; (800948c <HAL_GPIO_Init+0x1c4>)
 80092ea:	6814      	ldr	r4, [r2, #0]
        temp &= ~((uint32_t)iocurrent);
 80092ec:	ea6f 020c 	mvn.w	r2, ip
 80092f0:	ea24 050c 	bic.w	r5, r4, ip
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80092f4:	684e      	ldr	r6, [r1, #4]
 80092f6:	f416 3f80 	tst.w	r6, #65536	; 0x10000
 80092fa:	d001      	beq.n	8009300 <HAL_GPIO_Init+0x38>
        {
          temp |= iocurrent;
 80092fc:	ea4c 0504 	orr.w	r5, ip, r4
        }
        EXTI->IMR = temp;
 8009300:	4c62      	ldr	r4, [pc, #392]	; (800948c <HAL_GPIO_Init+0x1c4>)
 8009302:	6025      	str	r5, [r4, #0]

        temp = EXTI->EMR;
 8009304:	6864      	ldr	r4, [r4, #4]
        temp &= ~((uint32_t)iocurrent);
 8009306:	ea02 0504 	and.w	r5, r2, r4
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800930a:	684e      	ldr	r6, [r1, #4]
 800930c:	f416 3f00 	tst.w	r6, #131072	; 0x20000
 8009310:	d001      	beq.n	8009316 <HAL_GPIO_Init+0x4e>
        {
          temp |= iocurrent;
 8009312:	ea4c 0504 	orr.w	r5, ip, r4
        }
        EXTI->EMR = temp;
 8009316:	4c5d      	ldr	r4, [pc, #372]	; (800948c <HAL_GPIO_Init+0x1c4>)
 8009318:	6065      	str	r5, [r4, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800931a:	68a4      	ldr	r4, [r4, #8]
        temp &= ~((uint32_t)iocurrent);
 800931c:	ea02 0504 	and.w	r5, r2, r4
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8009320:	684e      	ldr	r6, [r1, #4]
 8009322:	f416 1f80 	tst.w	r6, #1048576	; 0x100000
 8009326:	d001      	beq.n	800932c <HAL_GPIO_Init+0x64>
        {
          temp |= iocurrent;
 8009328:	ea4c 0504 	orr.w	r5, ip, r4
        }
        EXTI->RTSR = temp;
 800932c:	4c57      	ldr	r4, [pc, #348]	; (800948c <HAL_GPIO_Init+0x1c4>)
 800932e:	60a5      	str	r5, [r4, #8]

        temp = EXTI->FTSR;
 8009330:	68e4      	ldr	r4, [r4, #12]
        temp &= ~((uint32_t)iocurrent);
 8009332:	4022      	ands	r2, r4
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8009334:	684d      	ldr	r5, [r1, #4]
 8009336:	f415 1f00 	tst.w	r5, #2097152	; 0x200000
 800933a:	d001      	beq.n	8009340 <HAL_GPIO_Init+0x78>
        {
          temp |= iocurrent;
 800933c:	ea4c 0204 	orr.w	r2, ip, r4
        }
        EXTI->FTSR = temp;
 8009340:	4c52      	ldr	r4, [pc, #328]	; (800948c <HAL_GPIO_Init+0x1c4>)
 8009342:	60e2      	str	r2, [r4, #12]
  for(position = 0U; position < GPIO_NUMBER; position++)
 8009344:	3301      	adds	r3, #1
 8009346:	2b0f      	cmp	r3, #15
 8009348:	f200 809a 	bhi.w	8009480 <HAL_GPIO_Init+0x1b8>
    ioposition = 0x01U << position;
 800934c:	2201      	movs	r2, #1
 800934e:	409a      	lsls	r2, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8009350:	680c      	ldr	r4, [r1, #0]
 8009352:	ea04 0c02 	and.w	ip, r4, r2
    if(iocurrent == ioposition)
 8009356:	ea32 0404 	bics.w	r4, r2, r4
 800935a:	d1f3      	bne.n	8009344 <HAL_GPIO_Init+0x7c>
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800935c:	684c      	ldr	r4, [r1, #4]
 800935e:	1e65      	subs	r5, r4, #1
 8009360:	2d01      	cmp	r5, #1
 8009362:	d903      	bls.n	800936c <HAL_GPIO_Init+0xa4>
 8009364:	2c11      	cmp	r4, #17
 8009366:	d001      	beq.n	800936c <HAL_GPIO_Init+0xa4>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8009368:	2c12      	cmp	r4, #18
 800936a:	d112      	bne.n	8009392 <HAL_GPIO_Init+0xca>
        temp = GPIOx->OSPEEDR; 
 800936c:	6885      	ldr	r5, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 800936e:	005e      	lsls	r6, r3, #1
 8009370:	2403      	movs	r4, #3
 8009372:	40b4      	lsls	r4, r6
 8009374:	ea25 0504 	bic.w	r5, r5, r4
        temp |= (GPIO_Init->Speed << (position * 2U));
 8009378:	68cc      	ldr	r4, [r1, #12]
 800937a:	40b4      	lsls	r4, r6
 800937c:	432c      	orrs	r4, r5
        GPIOx->OSPEEDR = temp;
 800937e:	6084      	str	r4, [r0, #8]
        temp = GPIOx->OTYPER;
 8009380:	6844      	ldr	r4, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8009382:	ea24 0402 	bic.w	r4, r4, r2
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8009386:	684a      	ldr	r2, [r1, #4]
 8009388:	f3c2 1200 	ubfx	r2, r2, #4, #1
 800938c:	409a      	lsls	r2, r3
 800938e:	4322      	orrs	r2, r4
        GPIOx->OTYPER = temp;
 8009390:	6042      	str	r2, [r0, #4]
      temp = GPIOx->PUPDR;
 8009392:	68c5      	ldr	r5, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8009394:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 8009398:	2203      	movs	r2, #3
 800939a:	fa02 f20e 	lsl.w	r2, r2, lr
 800939e:	43d4      	mvns	r4, r2
 80093a0:	ea25 0502 	bic.w	r5, r5, r2
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 80093a4:	688a      	ldr	r2, [r1, #8]
 80093a6:	fa02 f20e 	lsl.w	r2, r2, lr
 80093aa:	432a      	orrs	r2, r5
      GPIOx->PUPDR = temp;
 80093ac:	60c2      	str	r2, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 80093ae:	684a      	ldr	r2, [r1, #4]
 80093b0:	2a02      	cmp	r2, #2
 80093b2:	d001      	beq.n	80093b8 <HAL_GPIO_Init+0xf0>
 80093b4:	2a12      	cmp	r2, #18
 80093b6:	d10f      	bne.n	80093d8 <HAL_GPIO_Init+0x110>
        temp = GPIOx->AFR[position >> 3U];
 80093b8:	08dd      	lsrs	r5, r3, #3
 80093ba:	3508      	adds	r5, #8
 80093bc:	f850 7025 	ldr.w	r7, [r0, r5, lsl #2]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 80093c0:	f003 0607 	and.w	r6, r3, #7
 80093c4:	00b6      	lsls	r6, r6, #2
 80093c6:	220f      	movs	r2, #15
 80093c8:	40b2      	lsls	r2, r6
 80093ca:	ea27 0702 	bic.w	r7, r7, r2
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 80093ce:	690a      	ldr	r2, [r1, #16]
 80093d0:	40b2      	lsls	r2, r6
 80093d2:	433a      	orrs	r2, r7
        GPIOx->AFR[position >> 3U] = temp;
 80093d4:	f840 2025 	str.w	r2, [r0, r5, lsl #2]
      temp = GPIOx->MODER;
 80093d8:	6802      	ldr	r2, [r0, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 80093da:	4014      	ands	r4, r2
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80093dc:	684a      	ldr	r2, [r1, #4]
 80093de:	f002 0203 	and.w	r2, r2, #3
 80093e2:	fa02 f20e 	lsl.w	r2, r2, lr
 80093e6:	4322      	orrs	r2, r4
      GPIOx->MODER = temp;
 80093e8:	6002      	str	r2, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80093ea:	684a      	ldr	r2, [r1, #4]
 80093ec:	f012 5f80 	tst.w	r2, #268435456	; 0x10000000
 80093f0:	d0a8      	beq.n	8009344 <HAL_GPIO_Init+0x7c>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80093f2:	2200      	movs	r2, #0
 80093f4:	9201      	str	r2, [sp, #4]
 80093f6:	4a26      	ldr	r2, [pc, #152]	; (8009490 <HAL_GPIO_Init+0x1c8>)
 80093f8:	6c54      	ldr	r4, [r2, #68]	; 0x44
 80093fa:	f444 4480 	orr.w	r4, r4, #16384	; 0x4000
 80093fe:	6454      	str	r4, [r2, #68]	; 0x44
 8009400:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8009402:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 8009406:	9201      	str	r2, [sp, #4]
 8009408:	9a01      	ldr	r2, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2U];
 800940a:	089c      	lsrs	r4, r3, #2
 800940c:	1ca5      	adds	r5, r4, #2
 800940e:	4a1e      	ldr	r2, [pc, #120]	; (8009488 <HAL_GPIO_Init+0x1c0>)
 8009410:	f852 6025 	ldr.w	r6, [r2, r5, lsl #2]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8009414:	f003 0503 	and.w	r5, r3, #3
 8009418:	00ad      	lsls	r5, r5, #2
 800941a:	220f      	movs	r2, #15
 800941c:	40aa      	lsls	r2, r5
 800941e:	ea26 0602 	bic.w	r6, r6, r2
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8009422:	4a1c      	ldr	r2, [pc, #112]	; (8009494 <HAL_GPIO_Init+0x1cc>)
 8009424:	4290      	cmp	r0, r2
 8009426:	f43f af58 	beq.w	80092da <HAL_GPIO_Init+0x12>
 800942a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800942e:	4290      	cmp	r0, r2
 8009430:	d01a      	beq.n	8009468 <HAL_GPIO_Init+0x1a0>
 8009432:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8009436:	4290      	cmp	r0, r2
 8009438:	d018      	beq.n	800946c <HAL_GPIO_Init+0x1a4>
 800943a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800943e:	4290      	cmp	r0, r2
 8009440:	d016      	beq.n	8009470 <HAL_GPIO_Init+0x1a8>
 8009442:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8009446:	4290      	cmp	r0, r2
 8009448:	d014      	beq.n	8009474 <HAL_GPIO_Init+0x1ac>
 800944a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800944e:	4290      	cmp	r0, r2
 8009450:	d012      	beq.n	8009478 <HAL_GPIO_Init+0x1b0>
 8009452:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8009456:	4290      	cmp	r0, r2
 8009458:	d010      	beq.n	800947c <HAL_GPIO_Init+0x1b4>
 800945a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800945e:	4290      	cmp	r0, r2
 8009460:	f43f af39 	beq.w	80092d6 <HAL_GPIO_Init+0xe>
 8009464:	2208      	movs	r2, #8
 8009466:	e739      	b.n	80092dc <HAL_GPIO_Init+0x14>
 8009468:	2201      	movs	r2, #1
 800946a:	e737      	b.n	80092dc <HAL_GPIO_Init+0x14>
 800946c:	2202      	movs	r2, #2
 800946e:	e735      	b.n	80092dc <HAL_GPIO_Init+0x14>
 8009470:	2203      	movs	r2, #3
 8009472:	e733      	b.n	80092dc <HAL_GPIO_Init+0x14>
 8009474:	2204      	movs	r2, #4
 8009476:	e731      	b.n	80092dc <HAL_GPIO_Init+0x14>
 8009478:	2205      	movs	r2, #5
 800947a:	e72f      	b.n	80092dc <HAL_GPIO_Init+0x14>
 800947c:	2206      	movs	r2, #6
 800947e:	e72d      	b.n	80092dc <HAL_GPIO_Init+0x14>
      }
    }
  }
}
 8009480:	b003      	add	sp, #12
 8009482:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009484:	4770      	bx	lr
 8009486:	bf00      	nop
 8009488:	40013800 	.word	0x40013800
 800948c:	40013c00 	.word	0x40013c00
 8009490:	40023800 	.word	0x40023800
 8009494:	40020000 	.word	0x40020000

08009498 <PCD_WriteEmptyTxFifo>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 8009498:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800949c:	b083      	sub	sp, #12
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800949e:	f8d0 8000 	ldr.w	r8, [r0]
  uint32_t len32b;
  uint32_t fifoemptymsk;

  ep = &hpcd->IN_ep[epnum];

  if (ep->xfer_count > ep->xfer_len)
 80094a2:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 80094a6:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80094aa:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80094ac:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80094ae:	429a      	cmp	r2, r3
 80094b0:	d854      	bhi.n	800955c <PCD_WriteEmptyTxFifo+0xc4>
 80094b2:	4607      	mov	r7, r0
 80094b4:	460c      	mov	r4, r1
  {
    return HAL_ERROR;
  }

  len = ep->xfer_len - ep->xfer_count;
 80094b6:	1a9b      	subs	r3, r3, r2

  if (len > ep->maxpacket)
 80094b8:	ebc1 02c1 	rsb	r2, r1, r1, lsl #3
 80094bc:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 80094c0:	6c52      	ldr	r2, [r2, #68]	; 0x44
 80094c2:	429a      	cmp	r2, r3
 80094c4:	d300      	bcc.n	80094c8 <PCD_WriteEmptyTxFifo+0x30>
  len = ep->xfer_len - ep->xfer_count;
 80094c6:	461a      	mov	r2, r3
  {
    len = ep->maxpacket;
  }

  len32b = (len + 3U) / 4U;
 80094c8:	f102 0903 	add.w	r9, r2, #3
 80094cc:	ea4f 0999 	mov.w	r9, r9, lsr #2

  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 80094d0:	e015      	b.n	80094fe <PCD_WriteEmptyTxFifo+0x66>

    if (len > ep->maxpacket)
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3U) / 4U;
 80094d2:	f106 0903 	add.w	r9, r6, #3
 80094d6:	ea4f 0999 	mov.w	r9, r9, lsr #2

    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 80094da:	ebc4 05c4 	rsb	r5, r4, r4, lsl #3
 80094de:	eb07 0585 	add.w	r5, r7, r5, lsl #2
 80094e2:	6ca9      	ldr	r1, [r5, #72]	; 0x48
 80094e4:	7c3b      	ldrb	r3, [r7, #16]
 80094e6:	9300      	str	r3, [sp, #0]
 80094e8:	b2b3      	uxth	r3, r6
 80094ea:	b2e2      	uxtb	r2, r4
 80094ec:	4640      	mov	r0, r8
 80094ee:	f001 fc7d 	bl	800adec <USB_WritePacket>
                          (uint8_t)hpcd->Init.dma_enable);

    ep->xfer_buff  += len;
 80094f2:	6cab      	ldr	r3, [r5, #72]	; 0x48
 80094f4:	4433      	add	r3, r6
 80094f6:	64ab      	str	r3, [r5, #72]	; 0x48
    ep->xfer_count += len;
 80094f8:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 80094fa:	4433      	add	r3, r6
 80094fc:	656b      	str	r3, [r5, #84]	; 0x54
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 80094fe:	eb08 1344 	add.w	r3, r8, r4, lsl #5
 8009502:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8009506:	699b      	ldr	r3, [r3, #24]
 8009508:	b29b      	uxth	r3, r3
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 800950a:	454b      	cmp	r3, r9
 800950c:	d312      	bcc.n	8009534 <PCD_WriteEmptyTxFifo+0x9c>
 800950e:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
 8009512:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 8009516:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8009518:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 800951a:	429a      	cmp	r2, r3
 800951c:	d20a      	bcs.n	8009534 <PCD_WriteEmptyTxFifo+0x9c>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 800951e:	b14b      	cbz	r3, 8009534 <PCD_WriteEmptyTxFifo+0x9c>
    len = ep->xfer_len - ep->xfer_count;
 8009520:	1a9b      	subs	r3, r3, r2
    if (len > ep->maxpacket)
 8009522:	ebc4 02c4 	rsb	r2, r4, r4, lsl #3
 8009526:	eb07 0282 	add.w	r2, r7, r2, lsl #2
 800952a:	6c56      	ldr	r6, [r2, #68]	; 0x44
 800952c:	429e      	cmp	r6, r3
 800952e:	d3d0      	bcc.n	80094d2 <PCD_WriteEmptyTxFifo+0x3a>
    len = ep->xfer_len - ep->xfer_count;
 8009530:	461e      	mov	r6, r3
 8009532:	e7ce      	b.n	80094d2 <PCD_WriteEmptyTxFifo+0x3a>
  }

  if (ep->xfer_len <= ep->xfer_count)
 8009534:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
 8009538:	eb07 0783 	add.w	r7, r7, r3, lsl #2
 800953c:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800953e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8009540:	429a      	cmp	r2, r3
 8009542:	d80f      	bhi.n	8009564 <PCD_WriteEmptyTxFifo+0xcc>
  {
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8009544:	f004 040f 	and.w	r4, r4, #15
 8009548:	2201      	movs	r2, #1
 800954a:	40a2      	lsls	r2, r4
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 800954c:	f8d8 3834 	ldr.w	r3, [r8, #2100]	; 0x834
 8009550:	ea23 0302 	bic.w	r3, r3, r2
 8009554:	f8c8 3834 	str.w	r3, [r8, #2100]	; 0x834
  }

  return HAL_OK;
 8009558:	2000      	movs	r0, #0
 800955a:	e000      	b.n	800955e <PCD_WriteEmptyTxFifo+0xc6>
    return HAL_ERROR;
 800955c:	2001      	movs	r0, #1
}
 800955e:	b003      	add	sp, #12
 8009560:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  return HAL_OK;
 8009564:	2000      	movs	r0, #0
 8009566:	e7fa      	b.n	800955e <PCD_WriteEmptyTxFifo+0xc6>

08009568 <HAL_PCD_Init>:
{
 8009568:	b570      	push	{r4, r5, r6, lr}
 800956a:	b08a      	sub	sp, #40	; 0x28
  if (hpcd == NULL)
 800956c:	2800      	cmp	r0, #0
 800956e:	f000 8090 	beq.w	8009692 <HAL_PCD_Init+0x12a>
 8009572:	4605      	mov	r5, r0
  USBx = hpcd->Instance;
 8009574:	6804      	ldr	r4, [r0, #0]
  if (hpcd->State == HAL_PCD_STATE_RESET)
 8009576:	f890 33bd 	ldrb.w	r3, [r0, #957]	; 0x3bd
 800957a:	b33b      	cbz	r3, 80095cc <HAL_PCD_Init+0x64>
  hpcd->State = HAL_PCD_STATE_BUSY;
 800957c:	2303      	movs	r3, #3
 800957e:	f885 33bd 	strb.w	r3, [r5, #957]	; 0x3bd
  if ((USBx->CID & (0x1U << 8)) == 0U)
 8009582:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8009584:	f413 7f80 	tst.w	r3, #256	; 0x100
 8009588:	d101      	bne.n	800958e <HAL_PCD_Init+0x26>
    hpcd->Init.dma_enable = 0U;
 800958a:	2300      	movs	r3, #0
 800958c:	612b      	str	r3, [r5, #16]
  __HAL_PCD_DISABLE(hpcd);
 800958e:	6828      	ldr	r0, [r5, #0]
 8009590:	f001 f9ba 	bl	800a908 <USB_DisableGlobalInt>
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 8009594:	462c      	mov	r4, r5
 8009596:	f854 6b10 	ldr.w	r6, [r4], #16
 800959a:	46ec      	mov	ip, sp
 800959c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800959e:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 80095a2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80095a4:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 80095a8:	e894 0003 	ldmia.w	r4, {r0, r1}
 80095ac:	e88c 0003 	stmia.w	ip, {r0, r1}
 80095b0:	1d2b      	adds	r3, r5, #4
 80095b2:	cb0e      	ldmia	r3, {r1, r2, r3}
 80095b4:	4630      	mov	r0, r6
 80095b6:	f001 f8e9 	bl	800a78c <USB_CoreInit>
 80095ba:	4604      	mov	r4, r0
 80095bc:	b158      	cbz	r0, 80095d6 <HAL_PCD_Init+0x6e>
    hpcd->State = HAL_PCD_STATE_ERROR;
 80095be:	2302      	movs	r3, #2
 80095c0:	f885 33bd 	strb.w	r3, [r5, #957]	; 0x3bd
    return HAL_ERROR;
 80095c4:	2401      	movs	r4, #1
}
 80095c6:	4620      	mov	r0, r4
 80095c8:	b00a      	add	sp, #40	; 0x28
 80095ca:	bd70      	pop	{r4, r5, r6, pc}
    hpcd->Lock = HAL_UNLOCKED;
 80095cc:	f880 33bc 	strb.w	r3, [r0, #956]	; 0x3bc
    HAL_PCD_MspInit(hpcd);
 80095d0:	f005 fab2 	bl	800eb38 <HAL_PCD_MspInit>
 80095d4:	e7d2      	b.n	800957c <HAL_PCD_Init+0x14>
  (void)USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE);
 80095d6:	2100      	movs	r1, #0
 80095d8:	6828      	ldr	r0, [r5, #0]
 80095da:	f001 f99b 	bl	800a914 <USB_SetCurrentMode>
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80095de:	4623      	mov	r3, r4
 80095e0:	e016      	b.n	8009610 <HAL_PCD_Init+0xa8>
    hpcd->IN_ep[i].is_in = 1U;
 80095e2:	ebc3 02c3 	rsb	r2, r3, r3, lsl #3
 80095e6:	eb05 0282 	add.w	r2, r5, r2, lsl #2
 80095ea:	2101      	movs	r1, #1
 80095ec:	f882 103d 	strb.w	r1, [r2, #61]	; 0x3d
    hpcd->IN_ep[i].num = i;
 80095f0:	f882 303c 	strb.w	r3, [r2, #60]	; 0x3c
    hpcd->IN_ep[i].tx_fifo_num = i;
 80095f4:	f8a2 3042 	strh.w	r3, [r2, #66]	; 0x42
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 80095f8:	2100      	movs	r1, #0
 80095fa:	f882 103f 	strb.w	r1, [r2, #63]	; 0x3f
    hpcd->IN_ep[i].maxpacket = 0U;
 80095fe:	6451      	str	r1, [r2, #68]	; 0x44
    hpcd->IN_ep[i].xfer_buff = 0U;
 8009600:	6491      	str	r1, [r2, #72]	; 0x48
    hpcd->IN_ep[i].xfer_len = 0U;
 8009602:	ebc3 02c3 	rsb	r2, r3, r3, lsl #3
 8009606:	eb05 0282 	add.w	r2, r5, r2, lsl #2
 800960a:	6511      	str	r1, [r2, #80]	; 0x50
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800960c:	3301      	adds	r3, #1
 800960e:	b2db      	uxtb	r3, r3
 8009610:	6869      	ldr	r1, [r5, #4]
 8009612:	428b      	cmp	r3, r1
 8009614:	d3e5      	bcc.n	80095e2 <HAL_PCD_Init+0x7a>
 8009616:	e016      	b.n	8009646 <HAL_PCD_Init+0xde>
    hpcd->OUT_ep[i].is_in = 0U;
 8009618:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
 800961c:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8009620:	2200      	movs	r2, #0
 8009622:	f883 21fd 	strb.w	r2, [r3, #509]	; 0x1fd
    hpcd->OUT_ep[i].num = i;
 8009626:	f883 41fc 	strb.w	r4, [r3, #508]	; 0x1fc
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 800962a:	f883 21ff 	strb.w	r2, [r3, #511]	; 0x1ff
    hpcd->OUT_ep[i].maxpacket = 0U;
 800962e:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
    hpcd->OUT_ep[i].xfer_buff = 0U;
 8009632:	f8c3 2208 	str.w	r2, [r3, #520]	; 0x208
    hpcd->OUT_ep[i].xfer_len = 0U;
 8009636:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
 800963a:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 800963e:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8009642:	3401      	adds	r4, #1
 8009644:	b2e4      	uxtb	r4, r4
 8009646:	42a1      	cmp	r1, r4
 8009648:	d8e6      	bhi.n	8009618 <HAL_PCD_Init+0xb0>
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 800964a:	462c      	mov	r4, r5
 800964c:	f854 6b10 	ldr.w	r6, [r4], #16
 8009650:	46ec      	mov	ip, sp
 8009652:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8009654:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 8009658:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800965a:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 800965e:	e894 0003 	ldmia.w	r4, {r0, r1}
 8009662:	e88c 0003 	stmia.w	ip, {r0, r1}
 8009666:	1d2b      	adds	r3, r5, #4
 8009668:	cb0e      	ldmia	r3, {r1, r2, r3}
 800966a:	4630      	mov	r0, r6
 800966c:	f001 f998 	bl	800a9a0 <USB_DevInit>
 8009670:	4604      	mov	r4, r0
 8009672:	b120      	cbz	r0, 800967e <HAL_PCD_Init+0x116>
    hpcd->State = HAL_PCD_STATE_ERROR;
 8009674:	2302      	movs	r3, #2
 8009676:	f885 33bd 	strb.w	r3, [r5, #957]	; 0x3bd
    return HAL_ERROR;
 800967a:	2401      	movs	r4, #1
 800967c:	e7a3      	b.n	80095c6 <HAL_PCD_Init+0x5e>
  hpcd->USB_Address = 0U;
 800967e:	2300      	movs	r3, #0
 8009680:	f885 3038 	strb.w	r3, [r5, #56]	; 0x38
  hpcd->State = HAL_PCD_STATE_READY;
 8009684:	2301      	movs	r3, #1
 8009686:	f885 33bd 	strb.w	r3, [r5, #957]	; 0x3bd
  (void)USB_DevDisconnect(hpcd->Instance);
 800968a:	6828      	ldr	r0, [r5, #0]
 800968c:	f001 fd6a 	bl	800b164 <USB_DevDisconnect>
  return HAL_OK;
 8009690:	e799      	b.n	80095c6 <HAL_PCD_Init+0x5e>
    return HAL_ERROR;
 8009692:	2401      	movs	r4, #1
 8009694:	e797      	b.n	80095c6 <HAL_PCD_Init+0x5e>

08009696 <HAL_PCD_Start>:
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8009696:	6802      	ldr	r2, [r0, #0]
  __HAL_LOCK(hpcd);
 8009698:	f890 33bc 	ldrb.w	r3, [r0, #956]	; 0x3bc
 800969c:	2b01      	cmp	r3, #1
 800969e:	d019      	beq.n	80096d4 <HAL_PCD_Start+0x3e>
{
 80096a0:	b510      	push	{r4, lr}
 80096a2:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd);
 80096a4:	2301      	movs	r3, #1
 80096a6:	f880 33bc 	strb.w	r3, [r0, #956]	; 0x3bc
  if ((hpcd->Init.battery_charging_enable == 1U) &&
 80096aa:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80096ac:	2b01      	cmp	r3, #1
 80096ae:	d009      	beq.n	80096c4 <HAL_PCD_Start+0x2e>
  __HAL_PCD_ENABLE(hpcd);
 80096b0:	6820      	ldr	r0, [r4, #0]
 80096b2:	f001 f923 	bl	800a8fc <USB_EnableGlobalInt>
  (void)USB_DevConnect(hpcd->Instance);
 80096b6:	6820      	ldr	r0, [r4, #0]
 80096b8:	f001 fd46 	bl	800b148 <USB_DevConnect>
  __HAL_UNLOCK(hpcd);
 80096bc:	2000      	movs	r0, #0
 80096be:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
}
 80096c2:	bd10      	pop	{r4, pc}
      (hpcd->Init.phy_itface != USB_OTG_ULPI_PHY))
 80096c4:	6983      	ldr	r3, [r0, #24]
  if ((hpcd->Init.battery_charging_enable == 1U) &&
 80096c6:	2b01      	cmp	r3, #1
 80096c8:	d0f2      	beq.n	80096b0 <HAL_PCD_Start+0x1a>
    USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 80096ca:	6b93      	ldr	r3, [r2, #56]	; 0x38
 80096cc:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80096d0:	6393      	str	r3, [r2, #56]	; 0x38
 80096d2:	e7ed      	b.n	80096b0 <HAL_PCD_Start+0x1a>
  __HAL_LOCK(hpcd);
 80096d4:	2002      	movs	r0, #2
}
 80096d6:	4770      	bx	lr

080096d8 <PCD_EP_OutXfrComplete_int>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutXfrComplete_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 80096d8:	b570      	push	{r4, r5, r6, lr}
 80096da:	4604      	mov	r4, r0
 80096dc:	460d      	mov	r5, r1
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80096de:	6800      	ldr	r0, [r0, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 80096e0:	6c06      	ldr	r6, [r0, #64]	; 0x40
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 80096e2:	eb00 1341 	add.w	r3, r0, r1, lsl #5
 80096e6:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 80096ea:	689a      	ldr	r2, [r3, #8]

  if (hpcd->Init.dma_enable == 1U)
 80096ec:	6921      	ldr	r1, [r4, #16]
 80096ee:	2901      	cmp	r1, #1
 80096f0:	d011      	beq.n	8009716 <PCD_EP_OutXfrComplete_int+0x3e>
      /* ... */
    }
  }
  else
  {
    if (gSNPSiD == USB_OTG_CORE_ID_310A)
 80096f2:	4934      	ldr	r1, [pc, #208]	; (80097c4 <PCD_EP_OutXfrComplete_int+0xec>)
 80096f4:	428e      	cmp	r6, r1
 80096f6:	d04e      	beq.n	8009796 <PCD_EP_OutXfrComplete_int+0xbe>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
    }
    else
    {
      if ((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 80096f8:	b93d      	cbnz	r5, 800970a <PCD_EP_OutXfrComplete_int+0x32>
 80096fa:	ebc5 03c5 	rsb	r3, r5, r5, lsl #3
 80096fe:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8009702:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
 8009706:	2b00      	cmp	r3, #0
 8009708:	d056      	beq.n	80097b8 <PCD_EP_OutXfrComplete_int+0xe0>
      }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
      HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 800970a:	b2e9      	uxtb	r1, r5
 800970c:	4620      	mov	r0, r4
 800970e:	f005 fa5d 	bl	800ebcc <HAL_PCD_DataOutStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
    }
  }

  return HAL_OK;
}
 8009712:	2000      	movs	r0, #0
 8009714:	bd70      	pop	{r4, r5, r6, pc}
    if ((DoepintReg & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP) /* Class C */
 8009716:	f012 0f08 	tst.w	r2, #8
 800971a:	d009      	beq.n	8009730 <PCD_EP_OutXfrComplete_int+0x58>
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 800971c:	492a      	ldr	r1, [pc, #168]	; (80097c8 <PCD_EP_OutXfrComplete_int+0xf0>)
 800971e:	428e      	cmp	r6, r1
 8009720:	d9f7      	bls.n	8009712 <PCD_EP_OutXfrComplete_int+0x3a>
 8009722:	f412 4f00 	tst.w	r2, #32768	; 0x8000
 8009726:	d0f4      	beq.n	8009712 <PCD_EP_OutXfrComplete_int+0x3a>
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8009728:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 800972c:	609a      	str	r2, [r3, #8]
 800972e:	e7f0      	b.n	8009712 <PCD_EP_OutXfrComplete_int+0x3a>
    else if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR) /* Class E */
 8009730:	f012 0f20 	tst.w	r2, #32
 8009734:	d002      	beq.n	800973c <PCD_EP_OutXfrComplete_int+0x64>
      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 8009736:	2220      	movs	r2, #32
 8009738:	609a      	str	r2, [r3, #8]
 800973a:	e7ea      	b.n	8009712 <PCD_EP_OutXfrComplete_int+0x3a>
    else if ((DoepintReg & (USB_OTG_DOEPINT_STUP | USB_OTG_DOEPINT_OTEPSPR)) == 0U)
 800973c:	f012 0f28 	tst.w	r2, #40	; 0x28
 8009740:	d1e7      	bne.n	8009712 <PCD_EP_OutXfrComplete_int+0x3a>
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8009742:	4921      	ldr	r1, [pc, #132]	; (80097c8 <PCD_EP_OutXfrComplete_int+0xf0>)
 8009744:	428e      	cmp	r6, r1
 8009746:	d906      	bls.n	8009756 <PCD_EP_OutXfrComplete_int+0x7e>
 8009748:	f412 4f00 	tst.w	r2, #32768	; 0x8000
 800974c:	d003      	beq.n	8009756 <PCD_EP_OutXfrComplete_int+0x7e>
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 800974e:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8009752:	609a      	str	r2, [r3, #8]
 8009754:	e7dd      	b.n	8009712 <PCD_EP_OutXfrComplete_int+0x3a>
          hpcd->OUT_ep[epnum].maxpacket -
 8009756:	ebc5 02c5 	rsb	r2, r5, r5, lsl #3
 800975a:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 800975e:	f8d2 1204 	ldr.w	r1, [r2, #516]	; 0x204
          (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ);
 8009762:	691b      	ldr	r3, [r3, #16]
 8009764:	f3c3 0312 	ubfx	r3, r3, #0, #19
          hpcd->OUT_ep[epnum].maxpacket -
 8009768:	1acb      	subs	r3, r1, r3
        hpcd->OUT_ep[epnum].xfer_count =
 800976a:	f8c2 3214 	str.w	r3, [r2, #532]	; 0x214
        hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;
 800976e:	f8d2 3208 	ldr.w	r3, [r2, #520]	; 0x208
 8009772:	440b      	add	r3, r1
 8009774:	f8c2 3208 	str.w	r3, [r2, #520]	; 0x208
        if ((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 8009778:	b915      	cbnz	r5, 8009780 <PCD_EP_OutXfrComplete_int+0xa8>
 800977a:	f8d2 3210 	ldr.w	r3, [r2, #528]	; 0x210
 800977e:	b123      	cbz	r3, 800978a <PCD_EP_OutXfrComplete_int+0xb2>
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8009780:	b2e9      	uxtb	r1, r5
 8009782:	4620      	mov	r0, r4
 8009784:	f005 fa22 	bl	800ebcc <HAL_PCD_DataOutStageCallback>
 8009788:	e7c3      	b.n	8009712 <PCD_EP_OutXfrComplete_int+0x3a>
          (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 800978a:	f504 7271 	add.w	r2, r4, #964	; 0x3c4
 800978e:	2101      	movs	r1, #1
 8009790:	f001 fd3a 	bl	800b208 <USB_EP0_OutStart>
 8009794:	e7f4      	b.n	8009780 <PCD_EP_OutXfrComplete_int+0xa8>
      if ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX)
 8009796:	f412 4f00 	tst.w	r2, #32768	; 0x8000
 800979a:	d003      	beq.n	80097a4 <PCD_EP_OutXfrComplete_int+0xcc>
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 800979c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 80097a0:	609a      	str	r2, [r3, #8]
 80097a2:	e7b6      	b.n	8009712 <PCD_EP_OutXfrComplete_int+0x3a>
        if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 80097a4:	f012 0f20 	tst.w	r2, #32
 80097a8:	d001      	beq.n	80097ae <PCD_EP_OutXfrComplete_int+0xd6>
          CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 80097aa:	2220      	movs	r2, #32
 80097ac:	609a      	str	r2, [r3, #8]
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 80097ae:	b2e9      	uxtb	r1, r5
 80097b0:	4620      	mov	r0, r4
 80097b2:	f005 fa0b 	bl	800ebcc <HAL_PCD_DataOutStageCallback>
 80097b6:	e7ac      	b.n	8009712 <PCD_EP_OutXfrComplete_int+0x3a>
        (void)USB_EP0_OutStart(hpcd->Instance, 0U, (uint8_t *)hpcd->Setup);
 80097b8:	f504 7271 	add.w	r2, r4, #964	; 0x3c4
 80097bc:	2100      	movs	r1, #0
 80097be:	f001 fd23 	bl	800b208 <USB_EP0_OutStart>
 80097c2:	e7a2      	b.n	800970a <PCD_EP_OutXfrComplete_int+0x32>
 80097c4:	4f54310a 	.word	0x4f54310a
 80097c8:	4f54300a 	.word	0x4f54300a

080097cc <PCD_EP_OutSetupPacket_int>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutSetupPacket_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 80097cc:	b538      	push	{r3, r4, r5, lr}
 80097ce:	4604      	mov	r4, r0
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80097d0:	6803      	ldr	r3, [r0, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 80097d2:	6c1d      	ldr	r5, [r3, #64]	; 0x40
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 80097d4:	eb03 1341 	add.w	r3, r3, r1, lsl #5
 80097d8:	f8d3 1b08 	ldr.w	r1, [r3, #2824]	; 0xb08

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 80097dc:	4a0e      	ldr	r2, [pc, #56]	; (8009818 <PCD_EP_OutSetupPacket_int+0x4c>)
 80097de:	4295      	cmp	r5, r2
 80097e0:	d907      	bls.n	80097f2 <PCD_EP_OutSetupPacket_int+0x26>
 80097e2:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 80097e6:	f411 4f00 	tst.w	r1, #32768	; 0x8000
 80097ea:	d002      	beq.n	80097f2 <PCD_EP_OutSetupPacket_int+0x26>
      ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
  {
    CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 80097ec:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 80097f0:	609a      	str	r2, [r3, #8]

  /* Inform the upper layer that a setup packet is available */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
  hpcd->SetupStageCallback(hpcd);
#else
  HAL_PCD_SetupStageCallback(hpcd);
 80097f2:	4620      	mov	r0, r4
 80097f4:	f005 f9e2 	bl	800ebbc <HAL_PCD_SetupStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
 80097f8:	4b07      	ldr	r3, [pc, #28]	; (8009818 <PCD_EP_OutSetupPacket_int+0x4c>)
 80097fa:	429d      	cmp	r5, r3
 80097fc:	d902      	bls.n	8009804 <PCD_EP_OutSetupPacket_int+0x38>
 80097fe:	6923      	ldr	r3, [r4, #16]
 8009800:	2b01      	cmp	r3, #1
 8009802:	d001      	beq.n	8009808 <PCD_EP_OutSetupPacket_int+0x3c>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
  }

  return HAL_OK;
}
 8009804:	2000      	movs	r0, #0
 8009806:	bd38      	pop	{r3, r4, r5, pc}
    (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8009808:	f504 7271 	add.w	r2, r4, #964	; 0x3c4
 800980c:	2101      	movs	r1, #1
 800980e:	6820      	ldr	r0, [r4, #0]
 8009810:	f001 fcfa 	bl	800b208 <USB_EP0_OutStart>
 8009814:	e7f6      	b.n	8009804 <PCD_EP_OutSetupPacket_int+0x38>
 8009816:	bf00      	nop
 8009818:	4f54300a 	.word	0x4f54300a

0800981c <HAL_PCD_IRQHandler>:
{
 800981c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009820:	4604      	mov	r4, r0
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8009822:	6805      	ldr	r5, [r0, #0]
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 8009824:	4628      	mov	r0, r5
 8009826:	f001 fcda 	bl	800b1de <USB_GetMode>
 800982a:	b108      	cbz	r0, 8009830 <HAL_PCD_IRQHandler+0x14>
}
 800982c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8009830:	4606      	mov	r6, r0
    if (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))
 8009832:	6820      	ldr	r0, [r4, #0]
 8009834:	f001 fca4 	bl	800b180 <USB_ReadInterrupts>
 8009838:	2800      	cmp	r0, #0
 800983a:	d0f7      	beq.n	800982c <HAL_PCD_IRQHandler+0x10>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 800983c:	6820      	ldr	r0, [r4, #0]
 800983e:	f001 fc9f 	bl	800b180 <USB_ReadInterrupts>
 8009842:	f010 0f02 	tst.w	r0, #2
 8009846:	d004      	beq.n	8009852 <HAL_PCD_IRQHandler+0x36>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 8009848:	6822      	ldr	r2, [r4, #0]
 800984a:	6953      	ldr	r3, [r2, #20]
 800984c:	f003 0302 	and.w	r3, r3, #2
 8009850:	6153      	str	r3, [r2, #20]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 8009852:	6820      	ldr	r0, [r4, #0]
 8009854:	f001 fc94 	bl	800b180 <USB_ReadInterrupts>
 8009858:	f010 0f10 	tst.w	r0, #16
 800985c:	d013      	beq.n	8009886 <HAL_PCD_IRQHandler+0x6a>
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 800985e:	6822      	ldr	r2, [r4, #0]
 8009860:	6993      	ldr	r3, [r2, #24]
 8009862:	f023 0310 	bic.w	r3, r3, #16
 8009866:	6193      	str	r3, [r2, #24]
      temp = USBx->GRXSTSP;
 8009868:	6a2f      	ldr	r7, [r5, #32]
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
 800986a:	f007 080f 	and.w	r8, r7, #15
      if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 800986e:	f3c7 4343 	ubfx	r3, r7, #17, #4
 8009872:	2b02      	cmp	r3, #2
 8009874:	d068      	beq.n	8009948 <HAL_PCD_IRQHandler+0x12c>
      else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_SETUP_UPDT)
 8009876:	2b06      	cmp	r3, #6
 8009878:	f000 8084 	beq.w	8009984 <HAL_PCD_IRQHandler+0x168>
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 800987c:	6822      	ldr	r2, [r4, #0]
 800987e:	6993      	ldr	r3, [r2, #24]
 8009880:	f043 0310 	orr.w	r3, r3, #16
 8009884:	6193      	str	r3, [r2, #24]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 8009886:	6820      	ldr	r0, [r4, #0]
 8009888:	f001 fc7a 	bl	800b180 <USB_ReadInterrupts>
 800988c:	f410 2f00 	tst.w	r0, #524288	; 0x80000
 8009890:	f040 808a 	bne.w	80099a8 <HAL_PCD_IRQHandler+0x18c>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 8009894:	6820      	ldr	r0, [r4, #0]
 8009896:	f001 fc73 	bl	800b180 <USB_ReadInterrupts>
 800989a:	f410 2f80 	tst.w	r0, #262144	; 0x40000
 800989e:	f040 80cc 	bne.w	8009a3a <HAL_PCD_IRQHandler+0x21e>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 80098a2:	6820      	ldr	r0, [r4, #0]
 80098a4:	f001 fc6c 	bl	800b180 <USB_ReadInterrupts>
 80098a8:	2800      	cmp	r0, #0
 80098aa:	f2c0 8136 	blt.w	8009b1a <HAL_PCD_IRQHandler+0x2fe>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 80098ae:	6820      	ldr	r0, [r4, #0]
 80098b0:	f001 fc66 	bl	800b180 <USB_ReadInterrupts>
 80098b4:	f410 6f00 	tst.w	r0, #2048	; 0x800
 80098b8:	d00a      	beq.n	80098d0 <HAL_PCD_IRQHandler+0xb4>
      if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 80098ba:	f8d5 3808 	ldr.w	r3, [r5, #2056]	; 0x808
 80098be:	f013 0f01 	tst.w	r3, #1
 80098c2:	f040 8144 	bne.w	8009b4e <HAL_PCD_IRQHandler+0x332>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 80098c6:	6822      	ldr	r2, [r4, #0]
 80098c8:	6953      	ldr	r3, [r2, #20]
 80098ca:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 80098ce:	6153      	str	r3, [r2, #20]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 80098d0:	6820      	ldr	r0, [r4, #0]
 80098d2:	f001 fc55 	bl	800b180 <USB_ReadInterrupts>
 80098d6:	f410 5f80 	tst.w	r0, #4096	; 0x1000
 80098da:	f040 813c 	bne.w	8009b56 <HAL_PCD_IRQHandler+0x33a>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 80098de:	6820      	ldr	r0, [r4, #0]
 80098e0:	f001 fc4e 	bl	800b180 <USB_ReadInterrupts>
 80098e4:	f410 5f00 	tst.w	r0, #8192	; 0x2000
 80098e8:	f040 8191 	bne.w	8009c0e <HAL_PCD_IRQHandler+0x3f2>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 80098ec:	6820      	ldr	r0, [r4, #0]
 80098ee:	f001 fc47 	bl	800b180 <USB_ReadInterrupts>
 80098f2:	f010 0f08 	tst.w	r0, #8
 80098f6:	f040 81a2 	bne.w	8009c3e <HAL_PCD_IRQHandler+0x422>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 80098fa:	6820      	ldr	r0, [r4, #0]
 80098fc:	f001 fc40 	bl	800b180 <USB_ReadInterrupts>
 8009900:	f410 1f80 	tst.w	r0, #1048576	; 0x100000
 8009904:	f040 81a4 	bne.w	8009c50 <HAL_PCD_IRQHandler+0x434>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8009908:	6820      	ldr	r0, [r4, #0]
 800990a:	f001 fc39 	bl	800b180 <USB_ReadInterrupts>
 800990e:	f410 1f00 	tst.w	r0, #2097152	; 0x200000
 8009912:	f040 81a7 	bne.w	8009c64 <HAL_PCD_IRQHandler+0x448>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 8009916:	6820      	ldr	r0, [r4, #0]
 8009918:	f001 fc32 	bl	800b180 <USB_ReadInterrupts>
 800991c:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
 8009920:	f040 81aa 	bne.w	8009c78 <HAL_PCD_IRQHandler+0x45c>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 8009924:	6820      	ldr	r0, [r4, #0]
 8009926:	f001 fc2b 	bl	800b180 <USB_ReadInterrupts>
 800992a:	f010 0f04 	tst.w	r0, #4
 800992e:	f43f af7d 	beq.w	800982c <HAL_PCD_IRQHandler+0x10>
      temp = hpcd->Instance->GOTGINT;
 8009932:	6823      	ldr	r3, [r4, #0]
 8009934:	685d      	ldr	r5, [r3, #4]
      if ((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 8009936:	f015 0f04 	tst.w	r5, #4
 800993a:	f040 81a6 	bne.w	8009c8a <HAL_PCD_IRQHandler+0x46e>
      hpcd->Instance->GOTGINT |= temp;
 800993e:	6822      	ldr	r2, [r4, #0]
 8009940:	6853      	ldr	r3, [r2, #4]
 8009942:	432b      	orrs	r3, r5
 8009944:	6053      	str	r3, [r2, #4]
 8009946:	e771      	b.n	800982c <HAL_PCD_IRQHandler+0x10>
        if ((temp & USB_OTG_GRXSTSP_BCNT) != 0U)
 8009948:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 800994c:	421f      	tst	r7, r3
 800994e:	d095      	beq.n	800987c <HAL_PCD_IRQHandler+0x60>
                               (uint16_t)((temp & USB_OTG_GRXSTSP_BCNT) >> 4));
 8009950:	ea4f 1b17 	mov.w	fp, r7, lsr #4
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 8009954:	ebc8 09c8 	rsb	r9, r8, r8, lsl #3
 8009958:	eb04 0989 	add.w	r9, r4, r9, lsl #2
 800995c:	f3c7 120a 	ubfx	r2, r7, #4, #11
 8009960:	f8d9 1208 	ldr.w	r1, [r9, #520]	; 0x208
 8009964:	4628      	mov	r0, r5
 8009966:	f001 fb75 	bl	800b054 <USB_ReadPacket>
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 800996a:	f3cb 020a 	ubfx	r2, fp, #0, #11
 800996e:	f8d9 3208 	ldr.w	r3, [r9, #520]	; 0x208
 8009972:	4413      	add	r3, r2
 8009974:	f8c9 3208 	str.w	r3, [r9, #520]	; 0x208
          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 8009978:	f8d9 3214 	ldr.w	r3, [r9, #532]	; 0x214
 800997c:	4413      	add	r3, r2
 800997e:	f8c9 3214 	str.w	r3, [r9, #532]	; 0x214
 8009982:	e77b      	b.n	800987c <HAL_PCD_IRQHandler+0x60>
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 8009984:	2208      	movs	r2, #8
 8009986:	f504 7171 	add.w	r1, r4, #964	; 0x3c4
 800998a:	4628      	mov	r0, r5
 800998c:	f001 fb62 	bl	800b054 <USB_ReadPacket>
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 8009990:	f3c7 170a 	ubfx	r7, r7, #4, #11
 8009994:	ebc8 02c8 	rsb	r2, r8, r8, lsl #3
 8009998:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 800999c:	f8d2 3214 	ldr.w	r3, [r2, #532]	; 0x214
 80099a0:	443b      	add	r3, r7
 80099a2:	f8c2 3214 	str.w	r3, [r2, #532]	; 0x214
 80099a6:	e769      	b.n	800987c <HAL_PCD_IRQHandler+0x60>
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 80099a8:	6820      	ldr	r0, [r4, #0]
 80099aa:	f001 fbed 	bl	800b188 <USB_ReadDevAllOutEpInterrupt>
 80099ae:	4607      	mov	r7, r0
      epnum = 0U;
 80099b0:	46b0      	mov	r8, r6
      while (ep_intr != 0U)
 80099b2:	e016      	b.n	80099e2 <HAL_PCD_IRQHandler+0x1c6>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 80099b4:	eb05 1348 	add.w	r3, r5, r8, lsl #5
 80099b8:	2201      	movs	r2, #1
 80099ba:	f8c3 2b08 	str.w	r2, [r3, #2824]	; 0xb08
            (void)PCD_EP_OutXfrComplete_int(hpcd, epnum);
 80099be:	4641      	mov	r1, r8
 80099c0:	4620      	mov	r0, r4
 80099c2:	f7ff fe89 	bl	80096d8 <PCD_EP_OutXfrComplete_int>
 80099c6:	e01b      	b.n	8009a00 <HAL_PCD_IRQHandler+0x1e4>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 80099c8:	eb05 1348 	add.w	r3, r5, r8, lsl #5
 80099cc:	2208      	movs	r2, #8
 80099ce:	f8c3 2b08 	str.w	r2, [r3, #2824]	; 0xb08
            (void)PCD_EP_OutSetupPacket_int(hpcd, epnum);
 80099d2:	4641      	mov	r1, r8
 80099d4:	4620      	mov	r0, r4
 80099d6:	f7ff fef9 	bl	80097cc <PCD_EP_OutSetupPacket_int>
 80099da:	e014      	b.n	8009a06 <HAL_PCD_IRQHandler+0x1ea>
        epnum++;
 80099dc:	f108 0801 	add.w	r8, r8, #1
        ep_intr >>= 1U;
 80099e0:	087f      	lsrs	r7, r7, #1
      while (ep_intr != 0U)
 80099e2:	2f00      	cmp	r7, #0
 80099e4:	f43f af56 	beq.w	8009894 <HAL_PCD_IRQHandler+0x78>
        if ((ep_intr & 0x1U) != 0U)
 80099e8:	f017 0f01 	tst.w	r7, #1
 80099ec:	d0f6      	beq.n	80099dc <HAL_PCD_IRQHandler+0x1c0>
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 80099ee:	fa5f f188 	uxtb.w	r1, r8
 80099f2:	6820      	ldr	r0, [r4, #0]
 80099f4:	f001 fbd8 	bl	800b1a8 <USB_ReadDevOutEPInterrupt>
 80099f8:	4681      	mov	r9, r0
          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 80099fa:	f010 0f01 	tst.w	r0, #1
 80099fe:	d1d9      	bne.n	80099b4 <HAL_PCD_IRQHandler+0x198>
          if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 8009a00:	f019 0f08 	tst.w	r9, #8
 8009a04:	d1e0      	bne.n	80099c8 <HAL_PCD_IRQHandler+0x1ac>
          if ((epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 8009a06:	f019 0f10 	tst.w	r9, #16
 8009a0a:	d004      	beq.n	8009a16 <HAL_PCD_IRQHandler+0x1fa>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 8009a0c:	eb05 1348 	add.w	r3, r5, r8, lsl #5
 8009a10:	2210      	movs	r2, #16
 8009a12:	f8c3 2b08 	str.w	r2, [r3, #2824]	; 0xb08
          if ((epint & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 8009a16:	f019 0f20 	tst.w	r9, #32
 8009a1a:	d004      	beq.n	8009a26 <HAL_PCD_IRQHandler+0x20a>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 8009a1c:	eb05 1348 	add.w	r3, r5, r8, lsl #5
 8009a20:	2220      	movs	r2, #32
 8009a22:	f8c3 2b08 	str.w	r2, [r3, #2824]	; 0xb08
          if ((epint & USB_OTG_DOEPINT_NAK) == USB_OTG_DOEPINT_NAK)
 8009a26:	f419 5f00 	tst.w	r9, #8192	; 0x2000
 8009a2a:	d0d7      	beq.n	80099dc <HAL_PCD_IRQHandler+0x1c0>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_NAK);
 8009a2c:	eb05 1348 	add.w	r3, r5, r8, lsl #5
 8009a30:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8009a34:	f8c3 2b08 	str.w	r2, [r3, #2824]	; 0xb08
 8009a38:	e7d0      	b.n	80099dc <HAL_PCD_IRQHandler+0x1c0>
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 8009a3a:	6820      	ldr	r0, [r4, #0]
 8009a3c:	f001 fbac 	bl	800b198 <USB_ReadDevAllInEpInterrupt>
 8009a40:	4607      	mov	r7, r0
      epnum = 0U;
 8009a42:	46b0      	mov	r8, r6
      while (ep_intr != 0U)
 8009a44:	e029      	b.n	8009a9a <HAL_PCD_IRQHandler+0x27e>
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
 8009a46:	4651      	mov	r1, sl
 8009a48:	4620      	mov	r0, r4
 8009a4a:	f005 f8cb 	bl	800ebe4 <HAL_PCD_DataInStageCallback>
          if ((epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 8009a4e:	f019 0f08 	tst.w	r9, #8
 8009a52:	d004      	beq.n	8009a5e <HAL_PCD_IRQHandler+0x242>
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 8009a54:	eb05 1348 	add.w	r3, r5, r8, lsl #5
 8009a58:	2208      	movs	r2, #8
 8009a5a:	f8c3 2908 	str.w	r2, [r3, #2312]	; 0x908
          if ((epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 8009a5e:	f019 0f10 	tst.w	r9, #16
 8009a62:	d004      	beq.n	8009a6e <HAL_PCD_IRQHandler+0x252>
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 8009a64:	eb05 1348 	add.w	r3, r5, r8, lsl #5
 8009a68:	2210      	movs	r2, #16
 8009a6a:	f8c3 2908 	str.w	r2, [r3, #2312]	; 0x908
          if ((epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 8009a6e:	f019 0f40 	tst.w	r9, #64	; 0x40
 8009a72:	d004      	beq.n	8009a7e <HAL_PCD_IRQHandler+0x262>
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 8009a74:	eb05 1348 	add.w	r3, r5, r8, lsl #5
 8009a78:	2240      	movs	r2, #64	; 0x40
 8009a7a:	f8c3 2908 	str.w	r2, [r3, #2312]	; 0x908
          if ((epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 8009a7e:	f019 0f02 	tst.w	r9, #2
 8009a82:	d004      	beq.n	8009a8e <HAL_PCD_IRQHandler+0x272>
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 8009a84:	eb05 1348 	add.w	r3, r5, r8, lsl #5
 8009a88:	2202      	movs	r2, #2
 8009a8a:	f8c3 2908 	str.w	r2, [r3, #2312]	; 0x908
          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 8009a8e:	f019 0f80 	tst.w	r9, #128	; 0x80
 8009a92:	d13d      	bne.n	8009b10 <HAL_PCD_IRQHandler+0x2f4>
        epnum++;
 8009a94:	f108 0801 	add.w	r8, r8, #1
        ep_intr >>= 1U;
 8009a98:	087f      	lsrs	r7, r7, #1
      while (ep_intr != 0U)
 8009a9a:	2f00      	cmp	r7, #0
 8009a9c:	f43f af01 	beq.w	80098a2 <HAL_PCD_IRQHandler+0x86>
        if ((ep_intr & 0x1U) != 0U) /* In ITR */
 8009aa0:	f017 0f01 	tst.w	r7, #1
 8009aa4:	d0f6      	beq.n	8009a94 <HAL_PCD_IRQHandler+0x278>
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8009aa6:	fa5f fa88 	uxtb.w	sl, r8
 8009aaa:	4651      	mov	r1, sl
 8009aac:	6820      	ldr	r0, [r4, #0]
 8009aae:	f001 fb84 	bl	800b1ba <USB_ReadDevInEPInterrupt>
 8009ab2:	4681      	mov	r9, r0
          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 8009ab4:	f010 0f01 	tst.w	r0, #1
 8009ab8:	d0c9      	beq.n	8009a4e <HAL_PCD_IRQHandler+0x232>
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8009aba:	f008 020f 	and.w	r2, r8, #15
 8009abe:	2101      	movs	r1, #1
 8009ac0:	fa01 f202 	lsl.w	r2, r1, r2
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8009ac4:	f8d5 3834 	ldr.w	r3, [r5, #2100]	; 0x834
 8009ac8:	ea23 0302 	bic.w	r3, r3, r2
 8009acc:	f8c5 3834 	str.w	r3, [r5, #2100]	; 0x834
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 8009ad0:	eb05 1348 	add.w	r3, r5, r8, lsl #5
 8009ad4:	f8c3 1908 	str.w	r1, [r3, #2312]	; 0x908
            if (hpcd->Init.dma_enable == 1U)
 8009ad8:	6923      	ldr	r3, [r4, #16]
 8009ada:	428b      	cmp	r3, r1
 8009adc:	d1b3      	bne.n	8009a46 <HAL_PCD_IRQHandler+0x22a>
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket;
 8009ade:	ebc8 03c8 	rsb	r3, r8, r8, lsl #3
 8009ae2:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8009ae6:	6c59      	ldr	r1, [r3, #68]	; 0x44
 8009ae8:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8009aea:	440a      	add	r2, r1
 8009aec:	649a      	str	r2, [r3, #72]	; 0x48
              if ((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
 8009aee:	f1b8 0f00 	cmp.w	r8, #0
 8009af2:	d1a8      	bne.n	8009a46 <HAL_PCD_IRQHandler+0x22a>
 8009af4:	ebc8 03c8 	rsb	r3, r8, r8, lsl #3
 8009af8:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8009afc:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8009afe:	2b00      	cmp	r3, #0
 8009b00:	d1a1      	bne.n	8009a46 <HAL_PCD_IRQHandler+0x22a>
                (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8009b02:	f504 7271 	add.w	r2, r4, #964	; 0x3c4
 8009b06:	2101      	movs	r1, #1
 8009b08:	6820      	ldr	r0, [r4, #0]
 8009b0a:	f001 fb7d 	bl	800b208 <USB_EP0_OutStart>
 8009b0e:	e79a      	b.n	8009a46 <HAL_PCD_IRQHandler+0x22a>
            (void)PCD_WriteEmptyTxFifo(hpcd, epnum);
 8009b10:	4641      	mov	r1, r8
 8009b12:	4620      	mov	r0, r4
 8009b14:	f7ff fcc0 	bl	8009498 <PCD_WriteEmptyTxFifo>
 8009b18:	e7bc      	b.n	8009a94 <HAL_PCD_IRQHandler+0x278>
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8009b1a:	f8d5 3804 	ldr.w	r3, [r5, #2052]	; 0x804
 8009b1e:	f023 0301 	bic.w	r3, r3, #1
 8009b22:	f8c5 3804 	str.w	r3, [r5, #2052]	; 0x804
      if (hpcd->LPM_State == LPM_L1)
 8009b26:	f894 33f4 	ldrb.w	r3, [r4, #1012]	; 0x3f4
 8009b2a:	2b01      	cmp	r3, #1
 8009b2c:	d008      	beq.n	8009b40 <HAL_PCD_IRQHandler+0x324>
        HAL_PCD_ResumeCallback(hpcd);
 8009b2e:	4620      	mov	r0, r4
 8009b30:	f005 f894 	bl	800ec5c <HAL_PCD_ResumeCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 8009b34:	6822      	ldr	r2, [r4, #0]
 8009b36:	6953      	ldr	r3, [r2, #20]
 8009b38:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8009b3c:	6153      	str	r3, [r2, #20]
 8009b3e:	e6b6      	b.n	80098ae <HAL_PCD_IRQHandler+0x92>
        hpcd->LPM_State = LPM_L0;
 8009b40:	2100      	movs	r1, #0
 8009b42:	f884 13f4 	strb.w	r1, [r4, #1012]	; 0x3f4
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 8009b46:	4620      	mov	r0, r4
 8009b48:	f000 fa45 	bl	8009fd6 <HAL_PCDEx_LPM_Callback>
 8009b4c:	e7f2      	b.n	8009b34 <HAL_PCD_IRQHandler+0x318>
        HAL_PCD_SuspendCallback(hpcd);
 8009b4e:	4620      	mov	r0, r4
 8009b50:	f005 f86c 	bl	800ec2c <HAL_PCD_SuspendCallback>
 8009b54:	e6b7      	b.n	80098c6 <HAL_PCD_IRQHandler+0xaa>
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8009b56:	f505 6700 	add.w	r7, r5, #2048	; 0x800
 8009b5a:	687b      	ldr	r3, [r7, #4]
 8009b5c:	f023 0301 	bic.w	r3, r3, #1
 8009b60:	607b      	str	r3, [r7, #4]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 8009b62:	2110      	movs	r1, #16
 8009b64:	6820      	ldr	r0, [r4, #0]
 8009b66:	f000 feed 	bl	800a944 <USB_FlushTxFifo>
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8009b6a:	e020      	b.n	8009bae <HAL_PCD_IRQHandler+0x392>
        USBx_INEP(i)->DIEPINT = 0xFB7FU;
 8009b6c:	eb05 1346 	add.w	r3, r5, r6, lsl #5
 8009b70:	f64f 317f 	movw	r1, #64383	; 0xfb7f
 8009b74:	f8c3 1908 	str.w	r1, [r3, #2312]	; 0x908
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8009b78:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 8009b7c:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8009b80:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
        USBx_INEP(i)->DIEPCTL |= USB_OTG_DIEPCTL_SNAK;
 8009b84:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 8009b88:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 8009b8c:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
        USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
 8009b90:	f8c3 1b08 	str.w	r1, [r3, #2824]	; 0xb08
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8009b94:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 8009b98:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8009b9c:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
        USBx_OUTEP(i)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 8009ba0:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 8009ba4:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 8009ba8:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8009bac:	3601      	adds	r6, #1
 8009bae:	6863      	ldr	r3, [r4, #4]
 8009bb0:	42b3      	cmp	r3, r6
 8009bb2:	d8db      	bhi.n	8009b6c <HAL_PCD_IRQHandler+0x350>
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 8009bb4:	69fb      	ldr	r3, [r7, #28]
 8009bb6:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
 8009bba:	61fb      	str	r3, [r7, #28]
      if (hpcd->Init.use_dedicated_ep1 != 0U)
 8009bbc:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8009bbe:	b1db      	cbz	r3, 8009bf8 <HAL_PCD_IRQHandler+0x3dc>
        USBx_DEVICE->DOUTEP1MSK |= USB_OTG_DOEPMSK_STUPM |
 8009bc0:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8009bc4:	f043 030b 	orr.w	r3, r3, #11
 8009bc8:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
        USBx_DEVICE->DINEP1MSK |= USB_OTG_DIEPMSK_TOM |
 8009bcc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8009bce:	f043 030b 	orr.w	r3, r3, #11
 8009bd2:	647b      	str	r3, [r7, #68]	; 0x44
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8009bd4:	f8d5 3800 	ldr.w	r3, [r5, #2048]	; 0x800
 8009bd8:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8009bdc:	f8c5 3800 	str.w	r3, [r5, #2048]	; 0x800
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 8009be0:	f504 7271 	add.w	r2, r4, #964	; 0x3c4
 8009be4:	7c21      	ldrb	r1, [r4, #16]
 8009be6:	6820      	ldr	r0, [r4, #0]
 8009be8:	f001 fb0e 	bl	800b208 <USB_EP0_OutStart>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 8009bec:	6822      	ldr	r2, [r4, #0]
 8009bee:	6953      	ldr	r3, [r2, #20]
 8009bf0:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8009bf4:	6153      	str	r3, [r2, #20]
 8009bf6:	e672      	b.n	80098de <HAL_PCD_IRQHandler+0xc2>
        USBx_DEVICE->DOEPMSK |= USB_OTG_DOEPMSK_STUPM |
 8009bf8:	697b      	ldr	r3, [r7, #20]
 8009bfa:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8009bfe:	f043 032b 	orr.w	r3, r3, #43	; 0x2b
 8009c02:	617b      	str	r3, [r7, #20]
        USBx_DEVICE->DIEPMSK |= USB_OTG_DIEPMSK_TOM |
 8009c04:	693b      	ldr	r3, [r7, #16]
 8009c06:	f043 030b 	orr.w	r3, r3, #11
 8009c0a:	613b      	str	r3, [r7, #16]
 8009c0c:	e7e2      	b.n	8009bd4 <HAL_PCD_IRQHandler+0x3b8>
      (void)USB_ActivateSetup(hpcd->Instance);
 8009c0e:	6820      	ldr	r0, [r4, #0]
 8009c10:	f001 fae9 	bl	800b1e6 <USB_ActivateSetup>
      hpcd->Init.speed = USB_GetDevSpeed(hpcd->Instance);
 8009c14:	6820      	ldr	r0, [r4, #0]
 8009c16:	f000 ff8b 	bl	800ab30 <USB_GetDevSpeed>
 8009c1a:	60e0      	str	r0, [r4, #12]
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 8009c1c:	6825      	ldr	r5, [r4, #0]
 8009c1e:	f000 fcef 	bl	800a600 <HAL_RCC_GetHCLKFreq>
 8009c22:	4601      	mov	r1, r0
 8009c24:	7b22      	ldrb	r2, [r4, #12]
 8009c26:	4628      	mov	r0, r5
 8009c28:	f000 fdf6 	bl	800a818 <USB_SetTurnaroundTime>
      HAL_PCD_ResetCallback(hpcd);
 8009c2c:	4620      	mov	r0, r4
 8009c2e:	f004 ffea 	bl	800ec06 <HAL_PCD_ResetCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 8009c32:	6822      	ldr	r2, [r4, #0]
 8009c34:	6953      	ldr	r3, [r2, #20]
 8009c36:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8009c3a:	6153      	str	r3, [r2, #20]
 8009c3c:	e656      	b.n	80098ec <HAL_PCD_IRQHandler+0xd0>
      HAL_PCD_SOFCallback(hpcd);
 8009c3e:	4620      	mov	r0, r4
 8009c40:	f004 ffdb 	bl	800ebfa <HAL_PCD_SOFCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 8009c44:	6822      	ldr	r2, [r4, #0]
 8009c46:	6953      	ldr	r3, [r2, #20]
 8009c48:	f003 0308 	and.w	r3, r3, #8
 8009c4c:	6153      	str	r3, [r2, #20]
 8009c4e:	e654      	b.n	80098fa <HAL_PCD_IRQHandler+0xde>
      HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
 8009c50:	2100      	movs	r1, #0
 8009c52:	4620      	mov	r0, r4
 8009c54:	f005 f80e 	bl	800ec74 <HAL_PCD_ISOINIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 8009c58:	6822      	ldr	r2, [r4, #0]
 8009c5a:	6953      	ldr	r3, [r2, #20]
 8009c5c:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8009c60:	6153      	str	r3, [r2, #20]
 8009c62:	e651      	b.n	8009908 <HAL_PCD_IRQHandler+0xec>
      HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
 8009c64:	2100      	movs	r1, #0
 8009c66:	4620      	mov	r0, r4
 8009c68:	f004 fffe 	bl	800ec68 <HAL_PCD_ISOOUTIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8009c6c:	6822      	ldr	r2, [r4, #0]
 8009c6e:	6953      	ldr	r3, [r2, #20]
 8009c70:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8009c74:	6153      	str	r3, [r2, #20]
 8009c76:	e64e      	b.n	8009916 <HAL_PCD_IRQHandler+0xfa>
      HAL_PCD_ConnectCallback(hpcd);
 8009c78:	4620      	mov	r0, r4
 8009c7a:	f005 f801 	bl	800ec80 <HAL_PCD_ConnectCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 8009c7e:	6822      	ldr	r2, [r4, #0]
 8009c80:	6953      	ldr	r3, [r2, #20]
 8009c82:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8009c86:	6153      	str	r3, [r2, #20]
 8009c88:	e64c      	b.n	8009924 <HAL_PCD_IRQHandler+0x108>
        HAL_PCD_DisconnectCallback(hpcd);
 8009c8a:	4620      	mov	r0, r4
 8009c8c:	f004 fffe 	bl	800ec8c <HAL_PCD_DisconnectCallback>
 8009c90:	e655      	b.n	800993e <HAL_PCD_IRQHandler+0x122>

08009c92 <HAL_PCD_SetAddress>:
  __HAL_LOCK(hpcd);
 8009c92:	f890 33bc 	ldrb.w	r3, [r0, #956]	; 0x3bc
 8009c96:	2b01      	cmp	r3, #1
 8009c98:	d00d      	beq.n	8009cb6 <HAL_PCD_SetAddress+0x24>
{
 8009c9a:	b510      	push	{r4, lr}
 8009c9c:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd);
 8009c9e:	2301      	movs	r3, #1
 8009ca0:	f880 33bc 	strb.w	r3, [r0, #956]	; 0x3bc
  hpcd->USB_Address = address;
 8009ca4:	f880 1038 	strb.w	r1, [r0, #56]	; 0x38
  (void)USB_SetDevAddress(hpcd->Instance, address);
 8009ca8:	6800      	ldr	r0, [r0, #0]
 8009caa:	f001 fa3d 	bl	800b128 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 8009cae:	2000      	movs	r0, #0
 8009cb0:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
}
 8009cb4:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd);
 8009cb6:	2002      	movs	r0, #2
}
 8009cb8:	4770      	bx	lr

08009cba <HAL_PCD_EP_Open>:
{
 8009cba:	b538      	push	{r3, r4, r5, lr}
 8009cbc:	4605      	mov	r5, r0
 8009cbe:	468c      	mov	ip, r1
  if ((ep_addr & 0x80U) == 0x80U)
 8009cc0:	f011 0f80 	tst.w	r1, #128	; 0x80
 8009cc4:	d129      	bne.n	8009d1a <HAL_PCD_EP_Open+0x60>
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8009cc6:	f001 0e0f 	and.w	lr, r1, #15
 8009cca:	ebce 04ce 	rsb	r4, lr, lr, lsl #3
 8009cce:	00a4      	lsls	r4, r4, #2
 8009cd0:	f504 74fc 	add.w	r4, r4, #504	; 0x1f8
 8009cd4:	4404      	add	r4, r0
 8009cd6:	1d21      	adds	r1, r4, #4
    ep->is_in = 0U;
 8009cd8:	ebce 0ece 	rsb	lr, lr, lr, lsl #3
 8009cdc:	eb00 0e8e 	add.w	lr, r0, lr, lsl #2
 8009ce0:	2000      	movs	r0, #0
 8009ce2:	f88e 01fd 	strb.w	r0, [lr, #509]	; 0x1fd
  ep->num = ep_addr & EP_ADDR_MSK;
 8009ce6:	f00c 0c0f 	and.w	ip, ip, #15
 8009cea:	f881 c000 	strb.w	ip, [r1]
  ep->maxpacket = ep_mps;
 8009cee:	608a      	str	r2, [r1, #8]
  ep->type = ep_type;
 8009cf0:	70cb      	strb	r3, [r1, #3]
  if (ep->is_in != 0U)
 8009cf2:	784a      	ldrb	r2, [r1, #1]
 8009cf4:	b10a      	cbz	r2, 8009cfa <HAL_PCD_EP_Open+0x40>
    ep->tx_fifo_num = ep->num;
 8009cf6:	f8a1 c006 	strh.w	ip, [r1, #6]
  if (ep_type == EP_TYPE_BULK)
 8009cfa:	2b02      	cmp	r3, #2
 8009cfc:	d01d      	beq.n	8009d3a <HAL_PCD_EP_Open+0x80>
  __HAL_LOCK(hpcd);
 8009cfe:	f895 33bc 	ldrb.w	r3, [r5, #956]	; 0x3bc
 8009d02:	2b01      	cmp	r3, #1
 8009d04:	d01c      	beq.n	8009d40 <HAL_PCD_EP_Open+0x86>
 8009d06:	2301      	movs	r3, #1
 8009d08:	f885 33bc 	strb.w	r3, [r5, #956]	; 0x3bc
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 8009d0c:	6828      	ldr	r0, [r5, #0]
 8009d0e:	f000 ff20 	bl	800ab52 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8009d12:	2000      	movs	r0, #0
 8009d14:	f885 03bc 	strb.w	r0, [r5, #956]	; 0x3bc
}
 8009d18:	bd38      	pop	{r3, r4, r5, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8009d1a:	f001 000f 	and.w	r0, r1, #15
 8009d1e:	ebc0 01c0 	rsb	r1, r0, r0, lsl #3
 8009d22:	0089      	lsls	r1, r1, #2
 8009d24:	3138      	adds	r1, #56	; 0x38
 8009d26:	4429      	add	r1, r5
 8009d28:	3104      	adds	r1, #4
    ep->is_in = 1U;
 8009d2a:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 8009d2e:	eb05 0080 	add.w	r0, r5, r0, lsl #2
 8009d32:	2401      	movs	r4, #1
 8009d34:	f880 403d 	strb.w	r4, [r0, #61]	; 0x3d
 8009d38:	e7d5      	b.n	8009ce6 <HAL_PCD_EP_Open+0x2c>
    ep->data_pid_start = 0U;
 8009d3a:	2300      	movs	r3, #0
 8009d3c:	710b      	strb	r3, [r1, #4]
 8009d3e:	e7de      	b.n	8009cfe <HAL_PCD_EP_Open+0x44>
  __HAL_LOCK(hpcd);
 8009d40:	2002      	movs	r0, #2
 8009d42:	e7e9      	b.n	8009d18 <HAL_PCD_EP_Open+0x5e>

08009d44 <HAL_PCD_EP_Close>:
{
 8009d44:	b510      	push	{r4, lr}
 8009d46:	4604      	mov	r4, r0
 8009d48:	460a      	mov	r2, r1
  if ((ep_addr & 0x80U) == 0x80U)
 8009d4a:	f011 0f80 	tst.w	r1, #128	; 0x80
 8009d4e:	d120      	bne.n	8009d92 <HAL_PCD_EP_Close+0x4e>
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8009d50:	f001 000f 	and.w	r0, r1, #15
 8009d54:	ebc0 03c0 	rsb	r3, r0, r0, lsl #3
 8009d58:	009b      	lsls	r3, r3, #2
 8009d5a:	f503 73fc 	add.w	r3, r3, #504	; 0x1f8
 8009d5e:	4423      	add	r3, r4
 8009d60:	1d19      	adds	r1, r3, #4
    ep->is_in = 0U;
 8009d62:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 8009d66:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 8009d6a:	2300      	movs	r3, #0
 8009d6c:	f880 31fd 	strb.w	r3, [r0, #509]	; 0x1fd
  ep->num   = ep_addr & EP_ADDR_MSK;
 8009d70:	f002 020f 	and.w	r2, r2, #15
 8009d74:	700a      	strb	r2, [r1, #0]
  __HAL_LOCK(hpcd);
 8009d76:	f894 33bc 	ldrb.w	r3, [r4, #956]	; 0x3bc
 8009d7a:	2b01      	cmp	r3, #1
 8009d7c:	d019      	beq.n	8009db2 <HAL_PCD_EP_Close+0x6e>
 8009d7e:	2301      	movs	r3, #1
 8009d80:	f884 33bc 	strb.w	r3, [r4, #956]	; 0x3bc
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 8009d84:	6820      	ldr	r0, [r4, #0]
 8009d86:	f000 ff31 	bl	800abec <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8009d8a:	2000      	movs	r0, #0
 8009d8c:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
}
 8009d90:	bd10      	pop	{r4, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8009d92:	f001 000f 	and.w	r0, r1, #15
 8009d96:	ebc0 03c0 	rsb	r3, r0, r0, lsl #3
 8009d9a:	009b      	lsls	r3, r3, #2
 8009d9c:	3338      	adds	r3, #56	; 0x38
 8009d9e:	4423      	add	r3, r4
 8009da0:	1d19      	adds	r1, r3, #4
    ep->is_in = 1U;
 8009da2:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 8009da6:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 8009daa:	2301      	movs	r3, #1
 8009dac:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
 8009db0:	e7de      	b.n	8009d70 <HAL_PCD_EP_Close+0x2c>
  __HAL_LOCK(hpcd);
 8009db2:	2002      	movs	r0, #2
 8009db4:	e7ec      	b.n	8009d90 <HAL_PCD_EP_Close+0x4c>

08009db6 <HAL_PCD_EP_Receive>:
{
 8009db6:	b510      	push	{r4, lr}
  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8009db8:	f001 040f 	and.w	r4, r1, #15
 8009dbc:	ebc4 01c4 	rsb	r1, r4, r4, lsl #3
 8009dc0:	0089      	lsls	r1, r1, #2
 8009dc2:	f501 71fc 	add.w	r1, r1, #504	; 0x1f8
 8009dc6:	4401      	add	r1, r0
 8009dc8:	3104      	adds	r1, #4
  ep->xfer_buff = pBuf;
 8009dca:	ebc4 0cc4 	rsb	ip, r4, r4, lsl #3
 8009dce:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
 8009dd2:	f8cc 2208 	str.w	r2, [ip, #520]	; 0x208
  ep->xfer_len = len;
 8009dd6:	f8cc 3210 	str.w	r3, [ip, #528]	; 0x210
  ep->xfer_count = 0U;
 8009dda:	2300      	movs	r3, #0
 8009ddc:	f8cc 3214 	str.w	r3, [ip, #532]	; 0x214
  ep->is_in = 0U;
 8009de0:	f88c 31fd 	strb.w	r3, [ip, #509]	; 0x1fd
  ep->num = ep_addr & EP_ADDR_MSK;
 8009de4:	f88c 41fc 	strb.w	r4, [ip, #508]	; 0x1fc
  if (hpcd->Init.dma_enable == 1U)
 8009de8:	6903      	ldr	r3, [r0, #16]
 8009dea:	2b01      	cmp	r3, #1
 8009dec:	d006      	beq.n	8009dfc <HAL_PCD_EP_Receive+0x46>
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8009dee:	b964      	cbnz	r4, 8009e0a <HAL_PCD_EP_Receive+0x54>
    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8009df0:	b2da      	uxtb	r2, r3
 8009df2:	6800      	ldr	r0, [r0, #0]
 8009df4:	f000 ff6a 	bl	800accc <USB_EP0StartXfer>
}
 8009df8:	2000      	movs	r0, #0
 8009dfa:	bd10      	pop	{r4, pc}
    ep->dma_addr = (uint32_t)pBuf;
 8009dfc:	ebc4 0cc4 	rsb	ip, r4, r4, lsl #3
 8009e00:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
 8009e04:	f8cc 220c 	str.w	r2, [ip, #524]	; 0x20c
 8009e08:	e7f1      	b.n	8009dee <HAL_PCD_EP_Receive+0x38>
    (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8009e0a:	b2da      	uxtb	r2, r3
 8009e0c:	6800      	ldr	r0, [r0, #0]
 8009e0e:	f001 f805 	bl	800ae1c <USB_EPStartXfer>
 8009e12:	e7f1      	b.n	8009df8 <HAL_PCD_EP_Receive+0x42>

08009e14 <HAL_PCD_EP_GetRxCount>:
  return hpcd->OUT_ep[ep_addr & EP_ADDR_MSK].xfer_count;
 8009e14:	f001 010f 	and.w	r1, r1, #15
 8009e18:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 8009e1c:	eb00 0081 	add.w	r0, r0, r1, lsl #2
}
 8009e20:	f8d0 0214 	ldr.w	r0, [r0, #532]	; 0x214
 8009e24:	4770      	bx	lr

08009e26 <HAL_PCD_EP_Transmit>:
{
 8009e26:	b510      	push	{r4, lr}
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8009e28:	f001 040f 	and.w	r4, r1, #15
 8009e2c:	ebc4 01c4 	rsb	r1, r4, r4, lsl #3
 8009e30:	0089      	lsls	r1, r1, #2
 8009e32:	3138      	adds	r1, #56	; 0x38
 8009e34:	4401      	add	r1, r0
 8009e36:	3104      	adds	r1, #4
  ep->xfer_buff = pBuf;
 8009e38:	ebc4 0cc4 	rsb	ip, r4, r4, lsl #3
 8009e3c:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
 8009e40:	f8cc 2048 	str.w	r2, [ip, #72]	; 0x48
  ep->xfer_len = len;
 8009e44:	f8cc 3050 	str.w	r3, [ip, #80]	; 0x50
  ep->xfer_count = 0U;
 8009e48:	2300      	movs	r3, #0
 8009e4a:	f8cc 3054 	str.w	r3, [ip, #84]	; 0x54
  ep->is_in = 1U;
 8009e4e:	2301      	movs	r3, #1
 8009e50:	f88c 303d 	strb.w	r3, [ip, #61]	; 0x3d
  ep->num = ep_addr & EP_ADDR_MSK;
 8009e54:	f88c 403c 	strb.w	r4, [ip, #60]	; 0x3c
  if (hpcd->Init.dma_enable == 1U)
 8009e58:	6903      	ldr	r3, [r0, #16]
 8009e5a:	2b01      	cmp	r3, #1
 8009e5c:	d006      	beq.n	8009e6c <HAL_PCD_EP_Transmit+0x46>
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8009e5e:	b964      	cbnz	r4, 8009e7a <HAL_PCD_EP_Transmit+0x54>
    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8009e60:	b2da      	uxtb	r2, r3
 8009e62:	6800      	ldr	r0, [r0, #0]
 8009e64:	f000 ff32 	bl	800accc <USB_EP0StartXfer>
}
 8009e68:	2000      	movs	r0, #0
 8009e6a:	bd10      	pop	{r4, pc}
    ep->dma_addr = (uint32_t)pBuf;
 8009e6c:	ebc4 0cc4 	rsb	ip, r4, r4, lsl #3
 8009e70:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
 8009e74:	f8cc 204c 	str.w	r2, [ip, #76]	; 0x4c
 8009e78:	e7f1      	b.n	8009e5e <HAL_PCD_EP_Transmit+0x38>
    (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8009e7a:	b2da      	uxtb	r2, r3
 8009e7c:	6800      	ldr	r0, [r0, #0]
 8009e7e:	f000 ffcd 	bl	800ae1c <USB_EPStartXfer>
 8009e82:	e7f1      	b.n	8009e68 <HAL_PCD_EP_Transmit+0x42>

08009e84 <HAL_PCD_EP_SetStall>:
{
 8009e84:	b538      	push	{r3, r4, r5, lr}
  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 8009e86:	f001 050f 	and.w	r5, r1, #15
 8009e8a:	6842      	ldr	r2, [r0, #4]
 8009e8c:	4295      	cmp	r5, r2
 8009e8e:	d839      	bhi.n	8009f04 <HAL_PCD_EP_SetStall+0x80>
 8009e90:	4604      	mov	r4, r0
 8009e92:	460b      	mov	r3, r1
  if ((0x80U & ep_addr) == 0x80U)
 8009e94:	f011 0f80 	tst.w	r1, #128	; 0x80
 8009e98:	d11f      	bne.n	8009eda <HAL_PCD_EP_SetStall+0x56>
    ep = &hpcd->OUT_ep[ep_addr];
 8009e9a:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 8009e9e:	0089      	lsls	r1, r1, #2
 8009ea0:	f501 71fc 	add.w	r1, r1, #504	; 0x1f8
 8009ea4:	4401      	add	r1, r0
 8009ea6:	3104      	adds	r1, #4
    ep->is_in = 0U;
 8009ea8:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8009eac:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8009eb0:	2200      	movs	r2, #0
 8009eb2:	f883 21fd 	strb.w	r2, [r3, #509]	; 0x1fd
  ep->is_stall = 1U;
 8009eb6:	2301      	movs	r3, #1
 8009eb8:	708b      	strb	r3, [r1, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 8009eba:	700d      	strb	r5, [r1, #0]
  __HAL_LOCK(hpcd);
 8009ebc:	f894 33bc 	ldrb.w	r3, [r4, #956]	; 0x3bc
 8009ec0:	2b01      	cmp	r3, #1
 8009ec2:	d021      	beq.n	8009f08 <HAL_PCD_EP_SetStall+0x84>
 8009ec4:	2301      	movs	r3, #1
 8009ec6:	f884 33bc 	strb.w	r3, [r4, #956]	; 0x3bc
  (void)USB_EPSetStall(hpcd->Instance, ep);
 8009eca:	6820      	ldr	r0, [r4, #0]
 8009ecc:	f001 f8d1 	bl	800b072 <USB_EPSetStall>
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8009ed0:	b18d      	cbz	r5, 8009ef6 <HAL_PCD_EP_SetStall+0x72>
  __HAL_UNLOCK(hpcd);
 8009ed2:	2000      	movs	r0, #0
 8009ed4:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
}
 8009ed8:	bd38      	pop	{r3, r4, r5, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8009eda:	ebc5 01c5 	rsb	r1, r5, r5, lsl #3
 8009ede:	0089      	lsls	r1, r1, #2
 8009ee0:	3138      	adds	r1, #56	; 0x38
 8009ee2:	4401      	add	r1, r0
 8009ee4:	3104      	adds	r1, #4
    ep->is_in = 1U;
 8009ee6:	ebc5 03c5 	rsb	r3, r5, r5, lsl #3
 8009eea:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8009eee:	2201      	movs	r2, #1
 8009ef0:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 8009ef4:	e7df      	b.n	8009eb6 <HAL_PCD_EP_SetStall+0x32>
    (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8009ef6:	f504 7271 	add.w	r2, r4, #964	; 0x3c4
 8009efa:	7c21      	ldrb	r1, [r4, #16]
 8009efc:	6820      	ldr	r0, [r4, #0]
 8009efe:	f001 f983 	bl	800b208 <USB_EP0_OutStart>
 8009f02:	e7e6      	b.n	8009ed2 <HAL_PCD_EP_SetStall+0x4e>
    return HAL_ERROR;
 8009f04:	2001      	movs	r0, #1
 8009f06:	e7e7      	b.n	8009ed8 <HAL_PCD_EP_SetStall+0x54>
  __HAL_LOCK(hpcd);
 8009f08:	2002      	movs	r0, #2
 8009f0a:	e7e5      	b.n	8009ed8 <HAL_PCD_EP_SetStall+0x54>

08009f0c <HAL_PCD_EP_ClrStall>:
  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 8009f0c:	f001 030f 	and.w	r3, r1, #15
 8009f10:	6842      	ldr	r2, [r0, #4]
 8009f12:	4293      	cmp	r3, r2
 8009f14:	d831      	bhi.n	8009f7a <HAL_PCD_EP_ClrStall+0x6e>
{
 8009f16:	b510      	push	{r4, lr}
 8009f18:	4604      	mov	r4, r0
  if ((0x80U & ep_addr) == 0x80U)
 8009f1a:	f011 0f80 	tst.w	r1, #128	; 0x80
 8009f1e:	d11e      	bne.n	8009f5e <HAL_PCD_EP_ClrStall+0x52>
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8009f20:	ebc3 01c3 	rsb	r1, r3, r3, lsl #3
 8009f24:	0089      	lsls	r1, r1, #2
 8009f26:	f501 71fc 	add.w	r1, r1, #504	; 0x1f8
 8009f2a:	4401      	add	r1, r0
 8009f2c:	3104      	adds	r1, #4
    ep->is_in = 0U;
 8009f2e:	ebc3 02c3 	rsb	r2, r3, r3, lsl #3
 8009f32:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8009f36:	2000      	movs	r0, #0
 8009f38:	f882 01fd 	strb.w	r0, [r2, #509]	; 0x1fd
  ep->is_stall = 0U;
 8009f3c:	2200      	movs	r2, #0
 8009f3e:	708a      	strb	r2, [r1, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 8009f40:	700b      	strb	r3, [r1, #0]
  __HAL_LOCK(hpcd);
 8009f42:	f894 33bc 	ldrb.w	r3, [r4, #956]	; 0x3bc
 8009f46:	2b01      	cmp	r3, #1
 8009f48:	d019      	beq.n	8009f7e <HAL_PCD_EP_ClrStall+0x72>
 8009f4a:	2301      	movs	r3, #1
 8009f4c:	f884 33bc 	strb.w	r3, [r4, #956]	; 0x3bc
  (void)USB_EPClearStall(hpcd->Instance, ep);
 8009f50:	6820      	ldr	r0, [r4, #0]
 8009f52:	f001 f8bb 	bl	800b0cc <USB_EPClearStall>
  __HAL_UNLOCK(hpcd);
 8009f56:	2000      	movs	r0, #0
 8009f58:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
}
 8009f5c:	bd10      	pop	{r4, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8009f5e:	ebc3 01c3 	rsb	r1, r3, r3, lsl #3
 8009f62:	0089      	lsls	r1, r1, #2
 8009f64:	3138      	adds	r1, #56	; 0x38
 8009f66:	4401      	add	r1, r0
 8009f68:	3104      	adds	r1, #4
    ep->is_in = 1U;
 8009f6a:	ebc3 02c3 	rsb	r2, r3, r3, lsl #3
 8009f6e:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8009f72:	2001      	movs	r0, #1
 8009f74:	f882 003d 	strb.w	r0, [r2, #61]	; 0x3d
 8009f78:	e7e0      	b.n	8009f3c <HAL_PCD_EP_ClrStall+0x30>
    return HAL_ERROR;
 8009f7a:	2001      	movs	r0, #1
}
 8009f7c:	4770      	bx	lr
  __HAL_LOCK(hpcd);
 8009f7e:	2002      	movs	r0, #2
 8009f80:	e7ec      	b.n	8009f5c <HAL_PCD_EP_ClrStall+0x50>

08009f82 <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo The number of Tx fifo
  * @param  size Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
 8009f82:	b410      	push	{r4}
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */

  Tx_Offset = hpcd->Instance->GRXFSIZ;
 8009f84:	6804      	ldr	r4, [r0, #0]
 8009f86:	6a60      	ldr	r0, [r4, #36]	; 0x24

  if (fifo == 0U)
 8009f88:	b931      	cbnz	r1, 8009f98 <HAL_PCDEx_SetTxFiFo+0x16>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = ((uint32_t)size << 16) | Tx_Offset;
 8009f8a:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
 8009f8e:	62a0      	str	r0, [r4, #40]	; 0x28
    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
  }

  return HAL_OK;
}
 8009f90:	2000      	movs	r0, #0
 8009f92:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009f96:	4770      	bx	lr
 8009f98:	468c      	mov	ip, r1
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 8009f9a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8009f9c:	eb00 4013 	add.w	r0, r0, r3, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 8009fa0:	2300      	movs	r3, #0
 8009fa2:	e008      	b.n	8009fb6 <HAL_PCDEx_SetTxFiFo+0x34>
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8009fa4:	f103 0140 	add.w	r1, r3, #64	; 0x40
 8009fa8:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 8009fac:	6849      	ldr	r1, [r1, #4]
 8009fae:	eb00 4011 	add.w	r0, r0, r1, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 8009fb2:	3301      	adds	r3, #1
 8009fb4:	b2db      	uxtb	r3, r3
 8009fb6:	f10c 31ff 	add.w	r1, ip, #4294967295
 8009fba:	428b      	cmp	r3, r1
 8009fbc:	d3f2      	bcc.n	8009fa4 <HAL_PCDEx_SetTxFiFo+0x22>
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
 8009fbe:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
 8009fc2:	f10c 013f 	add.w	r1, ip, #63	; 0x3f
 8009fc6:	eb04 0481 	add.w	r4, r4, r1, lsl #2
 8009fca:	6060      	str	r0, [r4, #4]
 8009fcc:	e7e0      	b.n	8009f90 <HAL_PCDEx_SetTxFiFo+0xe>

08009fce <HAL_PCDEx_SetRxFiFo>:
  * @param  size Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
  hpcd->Instance->GRXFSIZ = size;
 8009fce:	6803      	ldr	r3, [r0, #0]
 8009fd0:	6259      	str	r1, [r3, #36]	; 0x24

  return HAL_OK;
}
 8009fd2:	2000      	movs	r0, #0
 8009fd4:	4770      	bx	lr

08009fd6 <HAL_PCDEx_LPM_Callback>:
  UNUSED(msg);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PCDEx_LPM_Callback could be implemented in the user file
   */
}
 8009fd6:	4770      	bx	lr

08009fd8 <HAL_RCC_OscConfig>:
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
  uint32_t tickstart, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 8009fd8:	2800      	cmp	r0, #0
 8009fda:	f000 81da 	beq.w	800a392 <HAL_RCC_OscConfig+0x3ba>
{
 8009fde:	b570      	push	{r4, r5, r6, lr}
 8009fe0:	b082      	sub	sp, #8
 8009fe2:	4604      	mov	r4, r0
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8009fe4:	6803      	ldr	r3, [r0, #0]
 8009fe6:	f013 0f01 	tst.w	r3, #1
 8009fea:	d03b      	beq.n	800a064 <HAL_RCC_OscConfig+0x8c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8009fec:	4b9f      	ldr	r3, [pc, #636]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 8009fee:	689b      	ldr	r3, [r3, #8]
 8009ff0:	f003 030c 	and.w	r3, r3, #12
 8009ff4:	2b04      	cmp	r3, #4
 8009ff6:	d02c      	beq.n	800a052 <HAL_RCC_OscConfig+0x7a>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8009ff8:	4b9c      	ldr	r3, [pc, #624]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 8009ffa:	689b      	ldr	r3, [r3, #8]
 8009ffc:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 800a000:	2b08      	cmp	r3, #8
 800a002:	d021      	beq.n	800a048 <HAL_RCC_OscConfig+0x70>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800a004:	6863      	ldr	r3, [r4, #4]
 800a006:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800a00a:	d04f      	beq.n	800a0ac <HAL_RCC_OscConfig+0xd4>
 800a00c:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 800a010:	d052      	beq.n	800a0b8 <HAL_RCC_OscConfig+0xe0>
 800a012:	4b96      	ldr	r3, [pc, #600]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 800a014:	681a      	ldr	r2, [r3, #0]
 800a016:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800a01a:	601a      	str	r2, [r3, #0]
 800a01c:	681a      	ldr	r2, [r3, #0]
 800a01e:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800a022:	601a      	str	r2, [r3, #0]

      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 800a024:	6863      	ldr	r3, [r4, #4]
 800a026:	2b00      	cmp	r3, #0
 800a028:	d050      	beq.n	800a0cc <HAL_RCC_OscConfig+0xf4>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800a02a:	f7fe fee1 	bl	8008df0 <HAL_GetTick>
 800a02e:	4605      	mov	r5, r0

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800a030:	4b8e      	ldr	r3, [pc, #568]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 800a032:	681b      	ldr	r3, [r3, #0]
 800a034:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 800a038:	d114      	bne.n	800a064 <HAL_RCC_OscConfig+0x8c>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800a03a:	f7fe fed9 	bl	8008df0 <HAL_GetTick>
 800a03e:	1b40      	subs	r0, r0, r5
 800a040:	2864      	cmp	r0, #100	; 0x64
 800a042:	d9f5      	bls.n	800a030 <HAL_RCC_OscConfig+0x58>
          {
            return HAL_TIMEOUT;
 800a044:	2003      	movs	r0, #3
 800a046:	e1ab      	b.n	800a3a0 <HAL_RCC_OscConfig+0x3c8>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800a048:	4b88      	ldr	r3, [pc, #544]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 800a04a:	685b      	ldr	r3, [r3, #4]
 800a04c:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 800a050:	d0d8      	beq.n	800a004 <HAL_RCC_OscConfig+0x2c>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800a052:	4b86      	ldr	r3, [pc, #536]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 800a054:	681b      	ldr	r3, [r3, #0]
 800a056:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 800a05a:	d003      	beq.n	800a064 <HAL_RCC_OscConfig+0x8c>
 800a05c:	6863      	ldr	r3, [r4, #4]
 800a05e:	2b00      	cmp	r3, #0
 800a060:	f000 8199 	beq.w	800a396 <HAL_RCC_OscConfig+0x3be>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800a064:	6823      	ldr	r3, [r4, #0]
 800a066:	f013 0f02 	tst.w	r3, #2
 800a06a:	d054      	beq.n	800a116 <HAL_RCC_OscConfig+0x13e>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 800a06c:	4b7f      	ldr	r3, [pc, #508]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 800a06e:	689b      	ldr	r3, [r3, #8]
 800a070:	f013 0f0c 	tst.w	r3, #12
 800a074:	d03e      	beq.n	800a0f4 <HAL_RCC_OscConfig+0x11c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 800a076:	4b7d      	ldr	r3, [pc, #500]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 800a078:	689b      	ldr	r3, [r3, #8]
 800a07a:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 800a07e:	2b08      	cmp	r3, #8
 800a080:	d033      	beq.n	800a0ea <HAL_RCC_OscConfig+0x112>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 800a082:	68e3      	ldr	r3, [r4, #12]
 800a084:	2b00      	cmp	r3, #0
 800a086:	d068      	beq.n	800a15a <HAL_RCC_OscConfig+0x182>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800a088:	4b79      	ldr	r3, [pc, #484]	; (800a270 <HAL_RCC_OscConfig+0x298>)
 800a08a:	2201      	movs	r2, #1
 800a08c:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800a08e:	f7fe feaf 	bl	8008df0 <HAL_GetTick>
 800a092:	4605      	mov	r5, r0

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800a094:	4b75      	ldr	r3, [pc, #468]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 800a096:	681b      	ldr	r3, [r3, #0]
 800a098:	f013 0f02 	tst.w	r3, #2
 800a09c:	d154      	bne.n	800a148 <HAL_RCC_OscConfig+0x170>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800a09e:	f7fe fea7 	bl	8008df0 <HAL_GetTick>
 800a0a2:	1b40      	subs	r0, r0, r5
 800a0a4:	2802      	cmp	r0, #2
 800a0a6:	d9f5      	bls.n	800a094 <HAL_RCC_OscConfig+0xbc>
          {
            return HAL_TIMEOUT;
 800a0a8:	2003      	movs	r0, #3
 800a0aa:	e179      	b.n	800a3a0 <HAL_RCC_OscConfig+0x3c8>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800a0ac:	4a6f      	ldr	r2, [pc, #444]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 800a0ae:	6813      	ldr	r3, [r2, #0]
 800a0b0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800a0b4:	6013      	str	r3, [r2, #0]
 800a0b6:	e7b5      	b.n	800a024 <HAL_RCC_OscConfig+0x4c>
 800a0b8:	4b6c      	ldr	r3, [pc, #432]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 800a0ba:	681a      	ldr	r2, [r3, #0]
 800a0bc:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 800a0c0:	601a      	str	r2, [r3, #0]
 800a0c2:	681a      	ldr	r2, [r3, #0]
 800a0c4:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800a0c8:	601a      	str	r2, [r3, #0]
 800a0ca:	e7ab      	b.n	800a024 <HAL_RCC_OscConfig+0x4c>
        tickstart = HAL_GetTick();
 800a0cc:	f7fe fe90 	bl	8008df0 <HAL_GetTick>
 800a0d0:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800a0d2:	4b66      	ldr	r3, [pc, #408]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 800a0d4:	681b      	ldr	r3, [r3, #0]
 800a0d6:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 800a0da:	d0c3      	beq.n	800a064 <HAL_RCC_OscConfig+0x8c>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800a0dc:	f7fe fe88 	bl	8008df0 <HAL_GetTick>
 800a0e0:	1b40      	subs	r0, r0, r5
 800a0e2:	2864      	cmp	r0, #100	; 0x64
 800a0e4:	d9f5      	bls.n	800a0d2 <HAL_RCC_OscConfig+0xfa>
            return HAL_TIMEOUT;
 800a0e6:	2003      	movs	r0, #3
 800a0e8:	e15a      	b.n	800a3a0 <HAL_RCC_OscConfig+0x3c8>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 800a0ea:	4b60      	ldr	r3, [pc, #384]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 800a0ec:	685b      	ldr	r3, [r3, #4]
 800a0ee:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 800a0f2:	d1c6      	bne.n	800a082 <HAL_RCC_OscConfig+0xaa>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800a0f4:	4b5d      	ldr	r3, [pc, #372]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 800a0f6:	681b      	ldr	r3, [r3, #0]
 800a0f8:	f013 0f02 	tst.w	r3, #2
 800a0fc:	d003      	beq.n	800a106 <HAL_RCC_OscConfig+0x12e>
 800a0fe:	68e3      	ldr	r3, [r4, #12]
 800a100:	2b01      	cmp	r3, #1
 800a102:	f040 814a 	bne.w	800a39a <HAL_RCC_OscConfig+0x3c2>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800a106:	4a59      	ldr	r2, [pc, #356]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 800a108:	6813      	ldr	r3, [r2, #0]
 800a10a:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 800a10e:	6921      	ldr	r1, [r4, #16]
 800a110:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 800a114:	6013      	str	r3, [r2, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800a116:	6823      	ldr	r3, [r4, #0]
 800a118:	f013 0f08 	tst.w	r3, #8
 800a11c:	d042      	beq.n	800a1a4 <HAL_RCC_OscConfig+0x1cc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 800a11e:	6963      	ldr	r3, [r4, #20]
 800a120:	b36b      	cbz	r3, 800a17e <HAL_RCC_OscConfig+0x1a6>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800a122:	4b53      	ldr	r3, [pc, #332]	; (800a270 <HAL_RCC_OscConfig+0x298>)
 800a124:	2201      	movs	r2, #1
 800a126:	f8c3 2e80 	str.w	r2, [r3, #3712]	; 0xe80

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800a12a:	f7fe fe61 	bl	8008df0 <HAL_GetTick>
 800a12e:	4605      	mov	r5, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800a130:	4b4e      	ldr	r3, [pc, #312]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 800a132:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800a134:	f013 0f02 	tst.w	r3, #2
 800a138:	d134      	bne.n	800a1a4 <HAL_RCC_OscConfig+0x1cc>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800a13a:	f7fe fe59 	bl	8008df0 <HAL_GetTick>
 800a13e:	1b40      	subs	r0, r0, r5
 800a140:	2802      	cmp	r0, #2
 800a142:	d9f5      	bls.n	800a130 <HAL_RCC_OscConfig+0x158>
        {
          return HAL_TIMEOUT;
 800a144:	2003      	movs	r0, #3
 800a146:	e12b      	b.n	800a3a0 <HAL_RCC_OscConfig+0x3c8>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800a148:	4a48      	ldr	r2, [pc, #288]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 800a14a:	6813      	ldr	r3, [r2, #0]
 800a14c:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 800a150:	6921      	ldr	r1, [r4, #16]
 800a152:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 800a156:	6013      	str	r3, [r2, #0]
 800a158:	e7dd      	b.n	800a116 <HAL_RCC_OscConfig+0x13e>
        __HAL_RCC_HSI_DISABLE();
 800a15a:	4b45      	ldr	r3, [pc, #276]	; (800a270 <HAL_RCC_OscConfig+0x298>)
 800a15c:	2200      	movs	r2, #0
 800a15e:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800a160:	f7fe fe46 	bl	8008df0 <HAL_GetTick>
 800a164:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800a166:	4b41      	ldr	r3, [pc, #260]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 800a168:	681b      	ldr	r3, [r3, #0]
 800a16a:	f013 0f02 	tst.w	r3, #2
 800a16e:	d0d2      	beq.n	800a116 <HAL_RCC_OscConfig+0x13e>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800a170:	f7fe fe3e 	bl	8008df0 <HAL_GetTick>
 800a174:	1b40      	subs	r0, r0, r5
 800a176:	2802      	cmp	r0, #2
 800a178:	d9f5      	bls.n	800a166 <HAL_RCC_OscConfig+0x18e>
            return HAL_TIMEOUT;
 800a17a:	2003      	movs	r0, #3
 800a17c:	e110      	b.n	800a3a0 <HAL_RCC_OscConfig+0x3c8>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 800a17e:	4b3c      	ldr	r3, [pc, #240]	; (800a270 <HAL_RCC_OscConfig+0x298>)
 800a180:	2200      	movs	r2, #0
 800a182:	f8c3 2e80 	str.w	r2, [r3, #3712]	; 0xe80

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800a186:	f7fe fe33 	bl	8008df0 <HAL_GetTick>
 800a18a:	4605      	mov	r5, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800a18c:	4b37      	ldr	r3, [pc, #220]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 800a18e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800a190:	f013 0f02 	tst.w	r3, #2
 800a194:	d006      	beq.n	800a1a4 <HAL_RCC_OscConfig+0x1cc>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800a196:	f7fe fe2b 	bl	8008df0 <HAL_GetTick>
 800a19a:	1b40      	subs	r0, r0, r5
 800a19c:	2802      	cmp	r0, #2
 800a19e:	d9f5      	bls.n	800a18c <HAL_RCC_OscConfig+0x1b4>
        {
          return HAL_TIMEOUT;
 800a1a0:	2003      	movs	r0, #3
 800a1a2:	e0fd      	b.n	800a3a0 <HAL_RCC_OscConfig+0x3c8>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800a1a4:	6823      	ldr	r3, [r4, #0]
 800a1a6:	f013 0f04 	tst.w	r3, #4
 800a1aa:	d077      	beq.n	800a29c <HAL_RCC_OscConfig+0x2c4>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800a1ac:	4b2f      	ldr	r3, [pc, #188]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 800a1ae:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800a1b0:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 800a1b4:	d133      	bne.n	800a21e <HAL_RCC_OscConfig+0x246>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800a1b6:	2300      	movs	r3, #0
 800a1b8:	9301      	str	r3, [sp, #4]
 800a1ba:	4b2c      	ldr	r3, [pc, #176]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 800a1bc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800a1be:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800a1c2:	641a      	str	r2, [r3, #64]	; 0x40
 800a1c4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800a1c6:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800a1ca:	9301      	str	r3, [sp, #4]
 800a1cc:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 800a1ce:	2501      	movs	r5, #1
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800a1d0:	4b28      	ldr	r3, [pc, #160]	; (800a274 <HAL_RCC_OscConfig+0x29c>)
 800a1d2:	681b      	ldr	r3, [r3, #0]
 800a1d4:	f413 7f80 	tst.w	r3, #256	; 0x100
 800a1d8:	d023      	beq.n	800a222 <HAL_RCC_OscConfig+0x24a>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800a1da:	68a3      	ldr	r3, [r4, #8]
 800a1dc:	2b01      	cmp	r3, #1
 800a1de:	d034      	beq.n	800a24a <HAL_RCC_OscConfig+0x272>
 800a1e0:	2b05      	cmp	r3, #5
 800a1e2:	d038      	beq.n	800a256 <HAL_RCC_OscConfig+0x27e>
 800a1e4:	4b21      	ldr	r3, [pc, #132]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 800a1e6:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800a1e8:	f022 0201 	bic.w	r2, r2, #1
 800a1ec:	671a      	str	r2, [r3, #112]	; 0x70
 800a1ee:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800a1f0:	f022 0204 	bic.w	r2, r2, #4
 800a1f4:	671a      	str	r2, [r3, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 800a1f6:	68a3      	ldr	r3, [r4, #8]
 800a1f8:	2b00      	cmp	r3, #0
 800a1fa:	d03d      	beq.n	800a278 <HAL_RCC_OscConfig+0x2a0>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800a1fc:	f7fe fdf8 	bl	8008df0 <HAL_GetTick>
 800a200:	4606      	mov	r6, r0

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800a202:	4b1a      	ldr	r3, [pc, #104]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 800a204:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800a206:	f013 0f02 	tst.w	r3, #2
 800a20a:	d146      	bne.n	800a29a <HAL_RCC_OscConfig+0x2c2>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800a20c:	f7fe fdf0 	bl	8008df0 <HAL_GetTick>
 800a210:	1b80      	subs	r0, r0, r6
 800a212:	f241 3388 	movw	r3, #5000	; 0x1388
 800a216:	4298      	cmp	r0, r3
 800a218:	d9f3      	bls.n	800a202 <HAL_RCC_OscConfig+0x22a>
        {
          return HAL_TIMEOUT;
 800a21a:	2003      	movs	r0, #3
 800a21c:	e0c0      	b.n	800a3a0 <HAL_RCC_OscConfig+0x3c8>
    FlagStatus       pwrclkchanged = RESET;
 800a21e:	2500      	movs	r5, #0
 800a220:	e7d6      	b.n	800a1d0 <HAL_RCC_OscConfig+0x1f8>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800a222:	4a14      	ldr	r2, [pc, #80]	; (800a274 <HAL_RCC_OscConfig+0x29c>)
 800a224:	6813      	ldr	r3, [r2, #0]
 800a226:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800a22a:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 800a22c:	f7fe fde0 	bl	8008df0 <HAL_GetTick>
 800a230:	4606      	mov	r6, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800a232:	4b10      	ldr	r3, [pc, #64]	; (800a274 <HAL_RCC_OscConfig+0x29c>)
 800a234:	681b      	ldr	r3, [r3, #0]
 800a236:	f413 7f80 	tst.w	r3, #256	; 0x100
 800a23a:	d1ce      	bne.n	800a1da <HAL_RCC_OscConfig+0x202>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800a23c:	f7fe fdd8 	bl	8008df0 <HAL_GetTick>
 800a240:	1b80      	subs	r0, r0, r6
 800a242:	2802      	cmp	r0, #2
 800a244:	d9f5      	bls.n	800a232 <HAL_RCC_OscConfig+0x25a>
          return HAL_TIMEOUT;
 800a246:	2003      	movs	r0, #3
 800a248:	e0aa      	b.n	800a3a0 <HAL_RCC_OscConfig+0x3c8>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800a24a:	4a08      	ldr	r2, [pc, #32]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 800a24c:	6f13      	ldr	r3, [r2, #112]	; 0x70
 800a24e:	f043 0301 	orr.w	r3, r3, #1
 800a252:	6713      	str	r3, [r2, #112]	; 0x70
 800a254:	e7cf      	b.n	800a1f6 <HAL_RCC_OscConfig+0x21e>
 800a256:	4b05      	ldr	r3, [pc, #20]	; (800a26c <HAL_RCC_OscConfig+0x294>)
 800a258:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800a25a:	f042 0204 	orr.w	r2, r2, #4
 800a25e:	671a      	str	r2, [r3, #112]	; 0x70
 800a260:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800a262:	f042 0201 	orr.w	r2, r2, #1
 800a266:	671a      	str	r2, [r3, #112]	; 0x70
 800a268:	e7c5      	b.n	800a1f6 <HAL_RCC_OscConfig+0x21e>
 800a26a:	bf00      	nop
 800a26c:	40023800 	.word	0x40023800
 800a270:	42470000 	.word	0x42470000
 800a274:	40007000 	.word	0x40007000
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800a278:	f7fe fdba 	bl	8008df0 <HAL_GetTick>
 800a27c:	4606      	mov	r6, r0

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800a27e:	4b4f      	ldr	r3, [pc, #316]	; (800a3bc <HAL_RCC_OscConfig+0x3e4>)
 800a280:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800a282:	f013 0f02 	tst.w	r3, #2
 800a286:	d008      	beq.n	800a29a <HAL_RCC_OscConfig+0x2c2>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800a288:	f7fe fdb2 	bl	8008df0 <HAL_GetTick>
 800a28c:	1b80      	subs	r0, r0, r6
 800a28e:	f241 3388 	movw	r3, #5000	; 0x1388
 800a292:	4298      	cmp	r0, r3
 800a294:	d9f3      	bls.n	800a27e <HAL_RCC_OscConfig+0x2a6>
        {
          return HAL_TIMEOUT;
 800a296:	2003      	movs	r0, #3
 800a298:	e082      	b.n	800a3a0 <HAL_RCC_OscConfig+0x3c8>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 800a29a:	b9e5      	cbnz	r5, 800a2d6 <HAL_RCC_OscConfig+0x2fe>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800a29c:	69a3      	ldr	r3, [r4, #24]
 800a29e:	2b00      	cmp	r3, #0
 800a2a0:	d07d      	beq.n	800a39e <HAL_RCC_OscConfig+0x3c6>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 800a2a2:	4a46      	ldr	r2, [pc, #280]	; (800a3bc <HAL_RCC_OscConfig+0x3e4>)
 800a2a4:	6892      	ldr	r2, [r2, #8]
 800a2a6:	f002 020c 	and.w	r2, r2, #12
 800a2aa:	2a08      	cmp	r2, #8
 800a2ac:	d051      	beq.n	800a352 <HAL_RCC_OscConfig+0x37a>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800a2ae:	2b02      	cmp	r3, #2
 800a2b0:	d017      	beq.n	800a2e2 <HAL_RCC_OscConfig+0x30a>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800a2b2:	4b43      	ldr	r3, [pc, #268]	; (800a3c0 <HAL_RCC_OscConfig+0x3e8>)
 800a2b4:	2200      	movs	r2, #0
 800a2b6:	661a      	str	r2, [r3, #96]	; 0x60

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800a2b8:	f7fe fd9a 	bl	8008df0 <HAL_GetTick>
 800a2bc:	4604      	mov	r4, r0

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800a2be:	4b3f      	ldr	r3, [pc, #252]	; (800a3bc <HAL_RCC_OscConfig+0x3e4>)
 800a2c0:	681b      	ldr	r3, [r3, #0]
 800a2c2:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 800a2c6:	d042      	beq.n	800a34e <HAL_RCC_OscConfig+0x376>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800a2c8:	f7fe fd92 	bl	8008df0 <HAL_GetTick>
 800a2cc:	1b00      	subs	r0, r0, r4
 800a2ce:	2802      	cmp	r0, #2
 800a2d0:	d9f5      	bls.n	800a2be <HAL_RCC_OscConfig+0x2e6>
          {
            return HAL_TIMEOUT;
 800a2d2:	2003      	movs	r0, #3
 800a2d4:	e064      	b.n	800a3a0 <HAL_RCC_OscConfig+0x3c8>
      __HAL_RCC_PWR_CLK_DISABLE();
 800a2d6:	4a39      	ldr	r2, [pc, #228]	; (800a3bc <HAL_RCC_OscConfig+0x3e4>)
 800a2d8:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800a2da:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800a2de:	6413      	str	r3, [r2, #64]	; 0x40
 800a2e0:	e7dc      	b.n	800a29c <HAL_RCC_OscConfig+0x2c4>
        __HAL_RCC_PLL_DISABLE();
 800a2e2:	4b37      	ldr	r3, [pc, #220]	; (800a3c0 <HAL_RCC_OscConfig+0x3e8>)
 800a2e4:	2200      	movs	r2, #0
 800a2e6:	661a      	str	r2, [r3, #96]	; 0x60
        tickstart = HAL_GetTick();
 800a2e8:	f7fe fd82 	bl	8008df0 <HAL_GetTick>
 800a2ec:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800a2ee:	4b33      	ldr	r3, [pc, #204]	; (800a3bc <HAL_RCC_OscConfig+0x3e4>)
 800a2f0:	681b      	ldr	r3, [r3, #0]
 800a2f2:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 800a2f6:	d006      	beq.n	800a306 <HAL_RCC_OscConfig+0x32e>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800a2f8:	f7fe fd7a 	bl	8008df0 <HAL_GetTick>
 800a2fc:	1b40      	subs	r0, r0, r5
 800a2fe:	2802      	cmp	r0, #2
 800a300:	d9f5      	bls.n	800a2ee <HAL_RCC_OscConfig+0x316>
            return HAL_TIMEOUT;
 800a302:	2003      	movs	r0, #3
 800a304:	e04c      	b.n	800a3a0 <HAL_RCC_OscConfig+0x3c8>
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 800a306:	69e3      	ldr	r3, [r4, #28]
 800a308:	6a22      	ldr	r2, [r4, #32]
 800a30a:	4313      	orrs	r3, r2
 800a30c:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800a30e:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 800a312:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800a314:	0852      	lsrs	r2, r2, #1
 800a316:	3a01      	subs	r2, #1
 800a318:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 800a31c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800a31e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800a322:	4a26      	ldr	r2, [pc, #152]	; (800a3bc <HAL_RCC_OscConfig+0x3e4>)
 800a324:	6053      	str	r3, [r2, #4]
        __HAL_RCC_PLL_ENABLE();
 800a326:	4b26      	ldr	r3, [pc, #152]	; (800a3c0 <HAL_RCC_OscConfig+0x3e8>)
 800a328:	2201      	movs	r2, #1
 800a32a:	661a      	str	r2, [r3, #96]	; 0x60
        tickstart = HAL_GetTick();
 800a32c:	f7fe fd60 	bl	8008df0 <HAL_GetTick>
 800a330:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800a332:	4b22      	ldr	r3, [pc, #136]	; (800a3bc <HAL_RCC_OscConfig+0x3e4>)
 800a334:	681b      	ldr	r3, [r3, #0]
 800a336:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 800a33a:	d106      	bne.n	800a34a <HAL_RCC_OscConfig+0x372>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800a33c:	f7fe fd58 	bl	8008df0 <HAL_GetTick>
 800a340:	1b00      	subs	r0, r0, r4
 800a342:	2802      	cmp	r0, #2
 800a344:	d9f5      	bls.n	800a332 <HAL_RCC_OscConfig+0x35a>
            return HAL_TIMEOUT;
 800a346:	2003      	movs	r0, #3
 800a348:	e02a      	b.n	800a3a0 <HAL_RCC_OscConfig+0x3c8>
          return HAL_ERROR;
        }
      }
    }
  }
  return HAL_OK;
 800a34a:	2000      	movs	r0, #0
 800a34c:	e028      	b.n	800a3a0 <HAL_RCC_OscConfig+0x3c8>
 800a34e:	2000      	movs	r0, #0
 800a350:	e026      	b.n	800a3a0 <HAL_RCC_OscConfig+0x3c8>
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 800a352:	2b01      	cmp	r3, #1
 800a354:	d026      	beq.n	800a3a4 <HAL_RCC_OscConfig+0x3cc>
        pll_config = RCC->PLLCFGR;
 800a356:	4b19      	ldr	r3, [pc, #100]	; (800a3bc <HAL_RCC_OscConfig+0x3e4>)
 800a358:	685b      	ldr	r3, [r3, #4]
        if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800a35a:	f403 0180 	and.w	r1, r3, #4194304	; 0x400000
 800a35e:	69e2      	ldr	r2, [r4, #28]
 800a360:	4291      	cmp	r1, r2
 800a362:	d121      	bne.n	800a3a8 <HAL_RCC_OscConfig+0x3d0>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 800a364:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 800a368:	6a21      	ldr	r1, [r4, #32]
        if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800a36a:	428a      	cmp	r2, r1
 800a36c:	d11e      	bne.n	800a3ac <HAL_RCC_OscConfig+0x3d4>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != RCC_OscInitStruct->PLL.PLLN) ||
 800a36e:	6a61      	ldr	r1, [r4, #36]	; 0x24
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 800a370:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 800a374:	401a      	ands	r2, r3
 800a376:	428a      	cmp	r2, r1
 800a378:	d11a      	bne.n	800a3b0 <HAL_RCC_OscConfig+0x3d8>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
 800a37a:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
 800a37e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != RCC_OscInitStruct->PLL.PLLN) ||
 800a380:	428a      	cmp	r2, r1
 800a382:	d117      	bne.n	800a3b4 <HAL_RCC_OscConfig+0x3dc>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != RCC_OscInitStruct->PLL.PLLQ))
 800a384:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
 800a388:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
 800a38a:	4293      	cmp	r3, r2
 800a38c:	d114      	bne.n	800a3b8 <HAL_RCC_OscConfig+0x3e0>
  return HAL_OK;
 800a38e:	2000      	movs	r0, #0
 800a390:	e006      	b.n	800a3a0 <HAL_RCC_OscConfig+0x3c8>
    return HAL_ERROR;
 800a392:	2001      	movs	r0, #1
}
 800a394:	4770      	bx	lr
        return HAL_ERROR;
 800a396:	2001      	movs	r0, #1
 800a398:	e002      	b.n	800a3a0 <HAL_RCC_OscConfig+0x3c8>
        return HAL_ERROR;
 800a39a:	2001      	movs	r0, #1
 800a39c:	e000      	b.n	800a3a0 <HAL_RCC_OscConfig+0x3c8>
  return HAL_OK;
 800a39e:	2000      	movs	r0, #0
}
 800a3a0:	b002      	add	sp, #8
 800a3a2:	bd70      	pop	{r4, r5, r6, pc}
        return HAL_ERROR;
 800a3a4:	2001      	movs	r0, #1
 800a3a6:	e7fb      	b.n	800a3a0 <HAL_RCC_OscConfig+0x3c8>
          return HAL_ERROR;
 800a3a8:	2001      	movs	r0, #1
 800a3aa:	e7f9      	b.n	800a3a0 <HAL_RCC_OscConfig+0x3c8>
 800a3ac:	2001      	movs	r0, #1
 800a3ae:	e7f7      	b.n	800a3a0 <HAL_RCC_OscConfig+0x3c8>
 800a3b0:	2001      	movs	r0, #1
 800a3b2:	e7f5      	b.n	800a3a0 <HAL_RCC_OscConfig+0x3c8>
 800a3b4:	2001      	movs	r0, #1
 800a3b6:	e7f3      	b.n	800a3a0 <HAL_RCC_OscConfig+0x3c8>
 800a3b8:	2001      	movs	r0, #1
 800a3ba:	e7f1      	b.n	800a3a0 <HAL_RCC_OscConfig+0x3c8>
 800a3bc:	40023800 	.word	0x40023800
 800a3c0:	42470000 	.word	0x42470000

0800a3c4 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 800a3c4:	b508      	push	{r3, lr}
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800a3c6:	4b33      	ldr	r3, [pc, #204]	; (800a494 <HAL_RCC_GetSysClockFreq+0xd0>)
 800a3c8:	689b      	ldr	r3, [r3, #8]
 800a3ca:	f003 030c 	and.w	r3, r3, #12
 800a3ce:	2b04      	cmp	r3, #4
 800a3d0:	d05b      	beq.n	800a48a <HAL_RCC_GetSysClockFreq+0xc6>
 800a3d2:	2b08      	cmp	r3, #8
 800a3d4:	d15b      	bne.n	800a48e <HAL_RCC_GetSysClockFreq+0xca>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800a3d6:	4b2f      	ldr	r3, [pc, #188]	; (800a494 <HAL_RCC_GetSysClockFreq+0xd0>)
 800a3d8:	685a      	ldr	r2, [r3, #4]
 800a3da:	f002 023f 	and.w	r2, r2, #63	; 0x3f
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 800a3de:	685b      	ldr	r3, [r3, #4]
 800a3e0:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 800a3e4:	d02c      	beq.n	800a440 <HAL_RCC_GetSysClockFreq+0x7c>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800a3e6:	4b2b      	ldr	r3, [pc, #172]	; (800a494 <HAL_RCC_GetSysClockFreq+0xd0>)
 800a3e8:	6858      	ldr	r0, [r3, #4]
 800a3ea:	f3c0 1088 	ubfx	r0, r0, #6, #9
 800a3ee:	ea4f 1c40 	mov.w	ip, r0, lsl #5
 800a3f2:	ebbc 0c00 	subs.w	ip, ip, r0
 800a3f6:	eb6e 0e0e 	sbc.w	lr, lr, lr
 800a3fa:	ea4f 138e 	mov.w	r3, lr, lsl #6
 800a3fe:	ea43 639c 	orr.w	r3, r3, ip, lsr #26
 800a402:	ea4f 118c 	mov.w	r1, ip, lsl #6
 800a406:	ebb1 010c 	subs.w	r1, r1, ip
 800a40a:	eb63 030e 	sbc.w	r3, r3, lr
 800a40e:	00db      	lsls	r3, r3, #3
 800a410:	ea43 7351 	orr.w	r3, r3, r1, lsr #29
 800a414:	00c9      	lsls	r1, r1, #3
 800a416:	eb11 0c00 	adds.w	ip, r1, r0
 800a41a:	f143 0300 	adc.w	r3, r3, #0
 800a41e:	0259      	lsls	r1, r3, #9
 800a420:	2300      	movs	r3, #0
 800a422:	ea4f 204c 	mov.w	r0, ip, lsl #9
 800a426:	ea41 51dc 	orr.w	r1, r1, ip, lsr #23
 800a42a:	f7fe fb17 	bl	8008a5c <__aeabi_uldivmod>
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 800a42e:	4b19      	ldr	r3, [pc, #100]	; (800a494 <HAL_RCC_GetSysClockFreq+0xd0>)
 800a430:	685b      	ldr	r3, [r3, #4]
 800a432:	f3c3 4301 	ubfx	r3, r3, #16, #2
 800a436:	3301      	adds	r3, #1
 800a438:	005b      	lsls	r3, r3, #1

      sysclockfreq = pllvco/pllp;
 800a43a:	fbb0 f0f3 	udiv	r0, r0, r3
      break;
 800a43e:	e027      	b.n	800a490 <HAL_RCC_GetSysClockFreq+0xcc>
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800a440:	4b14      	ldr	r3, [pc, #80]	; (800a494 <HAL_RCC_GetSysClockFreq+0xd0>)
 800a442:	6858      	ldr	r0, [r3, #4]
 800a444:	f3c0 1088 	ubfx	r0, r0, #6, #9
 800a448:	ea4f 1c40 	mov.w	ip, r0, lsl #5
 800a44c:	ebbc 0c00 	subs.w	ip, ip, r0
 800a450:	eb6e 0e0e 	sbc.w	lr, lr, lr
 800a454:	ea4f 138e 	mov.w	r3, lr, lsl #6
 800a458:	ea43 639c 	orr.w	r3, r3, ip, lsr #26
 800a45c:	ea4f 118c 	mov.w	r1, ip, lsl #6
 800a460:	ebb1 010c 	subs.w	r1, r1, ip
 800a464:	eb63 030e 	sbc.w	r3, r3, lr
 800a468:	00db      	lsls	r3, r3, #3
 800a46a:	ea43 7351 	orr.w	r3, r3, r1, lsr #29
 800a46e:	00c9      	lsls	r1, r1, #3
 800a470:	eb11 0c00 	adds.w	ip, r1, r0
 800a474:	f143 0300 	adc.w	r3, r3, #0
 800a478:	0299      	lsls	r1, r3, #10
 800a47a:	2300      	movs	r3, #0
 800a47c:	ea4f 208c 	mov.w	r0, ip, lsl #10
 800a480:	ea41 519c 	orr.w	r1, r1, ip, lsr #22
 800a484:	f7fe faea 	bl	8008a5c <__aeabi_uldivmod>
 800a488:	e7d1      	b.n	800a42e <HAL_RCC_GetSysClockFreq+0x6a>
      sysclockfreq = HSE_VALUE;
 800a48a:	4803      	ldr	r0, [pc, #12]	; (800a498 <HAL_RCC_GetSysClockFreq+0xd4>)
 800a48c:	e000      	b.n	800a490 <HAL_RCC_GetSysClockFreq+0xcc>
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800a48e:	4803      	ldr	r0, [pc, #12]	; (800a49c <HAL_RCC_GetSysClockFreq+0xd8>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 800a490:	bd08      	pop	{r3, pc}
 800a492:	bf00      	nop
 800a494:	40023800 	.word	0x40023800
 800a498:	007a1200 	.word	0x007a1200
 800a49c:	00f42400 	.word	0x00f42400

0800a4a0 <HAL_RCC_ClockConfig>:
  if(RCC_ClkInitStruct == NULL)
 800a4a0:	2800      	cmp	r0, #0
 800a4a2:	f000 809b 	beq.w	800a5dc <HAL_RCC_ClockConfig+0x13c>
{
 800a4a6:	b570      	push	{r4, r5, r6, lr}
 800a4a8:	460d      	mov	r5, r1
 800a4aa:	4604      	mov	r4, r0
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 800a4ac:	4b4f      	ldr	r3, [pc, #316]	; (800a5ec <HAL_RCC_ClockConfig+0x14c>)
 800a4ae:	681b      	ldr	r3, [r3, #0]
 800a4b0:	f003 030f 	and.w	r3, r3, #15
 800a4b4:	428b      	cmp	r3, r1
 800a4b6:	d208      	bcs.n	800a4ca <HAL_RCC_ClockConfig+0x2a>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800a4b8:	b2cb      	uxtb	r3, r1
 800a4ba:	4a4c      	ldr	r2, [pc, #304]	; (800a5ec <HAL_RCC_ClockConfig+0x14c>)
 800a4bc:	7013      	strb	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800a4be:	6813      	ldr	r3, [r2, #0]
 800a4c0:	f003 030f 	and.w	r3, r3, #15
 800a4c4:	428b      	cmp	r3, r1
 800a4c6:	f040 808b 	bne.w	800a5e0 <HAL_RCC_ClockConfig+0x140>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800a4ca:	6823      	ldr	r3, [r4, #0]
 800a4cc:	f013 0f02 	tst.w	r3, #2
 800a4d0:	d017      	beq.n	800a502 <HAL_RCC_ClockConfig+0x62>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800a4d2:	f013 0f04 	tst.w	r3, #4
 800a4d6:	d004      	beq.n	800a4e2 <HAL_RCC_ClockConfig+0x42>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 800a4d8:	4a45      	ldr	r2, [pc, #276]	; (800a5f0 <HAL_RCC_ClockConfig+0x150>)
 800a4da:	6893      	ldr	r3, [r2, #8]
 800a4dc:	f443 53e0 	orr.w	r3, r3, #7168	; 0x1c00
 800a4e0:	6093      	str	r3, [r2, #8]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800a4e2:	6823      	ldr	r3, [r4, #0]
 800a4e4:	f013 0f08 	tst.w	r3, #8
 800a4e8:	d004      	beq.n	800a4f4 <HAL_RCC_ClockConfig+0x54>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 800a4ea:	4a41      	ldr	r2, [pc, #260]	; (800a5f0 <HAL_RCC_ClockConfig+0x150>)
 800a4ec:	6893      	ldr	r3, [r2, #8]
 800a4ee:	f443 4360 	orr.w	r3, r3, #57344	; 0xe000
 800a4f2:	6093      	str	r3, [r2, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800a4f4:	4a3e      	ldr	r2, [pc, #248]	; (800a5f0 <HAL_RCC_ClockConfig+0x150>)
 800a4f6:	6893      	ldr	r3, [r2, #8]
 800a4f8:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800a4fc:	68a1      	ldr	r1, [r4, #8]
 800a4fe:	430b      	orrs	r3, r1
 800a500:	6093      	str	r3, [r2, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800a502:	6823      	ldr	r3, [r4, #0]
 800a504:	f013 0f01 	tst.w	r3, #1
 800a508:	d032      	beq.n	800a570 <HAL_RCC_ClockConfig+0xd0>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800a50a:	6863      	ldr	r3, [r4, #4]
 800a50c:	2b01      	cmp	r3, #1
 800a50e:	d021      	beq.n	800a554 <HAL_RCC_ClockConfig+0xb4>
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 800a510:	1e9a      	subs	r2, r3, #2
 800a512:	2a01      	cmp	r2, #1
 800a514:	d925      	bls.n	800a562 <HAL_RCC_ClockConfig+0xc2>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800a516:	4a36      	ldr	r2, [pc, #216]	; (800a5f0 <HAL_RCC_ClockConfig+0x150>)
 800a518:	6812      	ldr	r2, [r2, #0]
 800a51a:	f012 0f02 	tst.w	r2, #2
 800a51e:	d061      	beq.n	800a5e4 <HAL_RCC_ClockConfig+0x144>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800a520:	4933      	ldr	r1, [pc, #204]	; (800a5f0 <HAL_RCC_ClockConfig+0x150>)
 800a522:	688a      	ldr	r2, [r1, #8]
 800a524:	f022 0203 	bic.w	r2, r2, #3
 800a528:	4313      	orrs	r3, r2
 800a52a:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 800a52c:	f7fe fc60 	bl	8008df0 <HAL_GetTick>
 800a530:	4606      	mov	r6, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800a532:	4b2f      	ldr	r3, [pc, #188]	; (800a5f0 <HAL_RCC_ClockConfig+0x150>)
 800a534:	689b      	ldr	r3, [r3, #8]
 800a536:	f003 030c 	and.w	r3, r3, #12
 800a53a:	6862      	ldr	r2, [r4, #4]
 800a53c:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 800a540:	d016      	beq.n	800a570 <HAL_RCC_ClockConfig+0xd0>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800a542:	f7fe fc55 	bl	8008df0 <HAL_GetTick>
 800a546:	1b80      	subs	r0, r0, r6
 800a548:	f241 3388 	movw	r3, #5000	; 0x1388
 800a54c:	4298      	cmp	r0, r3
 800a54e:	d9f0      	bls.n	800a532 <HAL_RCC_ClockConfig+0x92>
        return HAL_TIMEOUT;
 800a550:	2003      	movs	r0, #3
 800a552:	e042      	b.n	800a5da <HAL_RCC_ClockConfig+0x13a>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800a554:	4a26      	ldr	r2, [pc, #152]	; (800a5f0 <HAL_RCC_ClockConfig+0x150>)
 800a556:	6812      	ldr	r2, [r2, #0]
 800a558:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 800a55c:	d1e0      	bne.n	800a520 <HAL_RCC_ClockConfig+0x80>
        return HAL_ERROR;
 800a55e:	2001      	movs	r0, #1
 800a560:	e03b      	b.n	800a5da <HAL_RCC_ClockConfig+0x13a>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800a562:	4a23      	ldr	r2, [pc, #140]	; (800a5f0 <HAL_RCC_ClockConfig+0x150>)
 800a564:	6812      	ldr	r2, [r2, #0]
 800a566:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 800a56a:	d1d9      	bne.n	800a520 <HAL_RCC_ClockConfig+0x80>
        return HAL_ERROR;
 800a56c:	2001      	movs	r0, #1
 800a56e:	e034      	b.n	800a5da <HAL_RCC_ClockConfig+0x13a>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 800a570:	4b1e      	ldr	r3, [pc, #120]	; (800a5ec <HAL_RCC_ClockConfig+0x14c>)
 800a572:	681b      	ldr	r3, [r3, #0]
 800a574:	f003 030f 	and.w	r3, r3, #15
 800a578:	42ab      	cmp	r3, r5
 800a57a:	d907      	bls.n	800a58c <HAL_RCC_ClockConfig+0xec>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800a57c:	b2ea      	uxtb	r2, r5
 800a57e:	4b1b      	ldr	r3, [pc, #108]	; (800a5ec <HAL_RCC_ClockConfig+0x14c>)
 800a580:	701a      	strb	r2, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800a582:	681b      	ldr	r3, [r3, #0]
 800a584:	f003 030f 	and.w	r3, r3, #15
 800a588:	42ab      	cmp	r3, r5
 800a58a:	d12d      	bne.n	800a5e8 <HAL_RCC_ClockConfig+0x148>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800a58c:	6823      	ldr	r3, [r4, #0]
 800a58e:	f013 0f04 	tst.w	r3, #4
 800a592:	d006      	beq.n	800a5a2 <HAL_RCC_ClockConfig+0x102>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800a594:	4a16      	ldr	r2, [pc, #88]	; (800a5f0 <HAL_RCC_ClockConfig+0x150>)
 800a596:	6893      	ldr	r3, [r2, #8]
 800a598:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 800a59c:	68e1      	ldr	r1, [r4, #12]
 800a59e:	430b      	orrs	r3, r1
 800a5a0:	6093      	str	r3, [r2, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800a5a2:	6823      	ldr	r3, [r4, #0]
 800a5a4:	f013 0f08 	tst.w	r3, #8
 800a5a8:	d007      	beq.n	800a5ba <HAL_RCC_ClockConfig+0x11a>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 800a5aa:	4a11      	ldr	r2, [pc, #68]	; (800a5f0 <HAL_RCC_ClockConfig+0x150>)
 800a5ac:	6893      	ldr	r3, [r2, #8]
 800a5ae:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 800a5b2:	6921      	ldr	r1, [r4, #16]
 800a5b4:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 800a5b8:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 800a5ba:	f7ff ff03 	bl	800a3c4 <HAL_RCC_GetSysClockFreq>
 800a5be:	4b0c      	ldr	r3, [pc, #48]	; (800a5f0 <HAL_RCC_ClockConfig+0x150>)
 800a5c0:	689b      	ldr	r3, [r3, #8]
 800a5c2:	f3c3 1303 	ubfx	r3, r3, #4, #4
 800a5c6:	4a0b      	ldr	r2, [pc, #44]	; (800a5f4 <HAL_RCC_ClockConfig+0x154>)
 800a5c8:	5cd3      	ldrb	r3, [r2, r3]
 800a5ca:	40d8      	lsrs	r0, r3
 800a5cc:	4b0a      	ldr	r3, [pc, #40]	; (800a5f8 <HAL_RCC_ClockConfig+0x158>)
 800a5ce:	6018      	str	r0, [r3, #0]
  HAL_InitTick (uwTickPrio);
 800a5d0:	4b0a      	ldr	r3, [pc, #40]	; (800a5fc <HAL_RCC_ClockConfig+0x15c>)
 800a5d2:	6818      	ldr	r0, [r3, #0]
 800a5d4:	f7fe fbc0 	bl	8008d58 <HAL_InitTick>
  return HAL_OK;
 800a5d8:	2000      	movs	r0, #0
}
 800a5da:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 800a5dc:	2001      	movs	r0, #1
}
 800a5de:	4770      	bx	lr
      return HAL_ERROR;
 800a5e0:	2001      	movs	r0, #1
 800a5e2:	e7fa      	b.n	800a5da <HAL_RCC_ClockConfig+0x13a>
        return HAL_ERROR;
 800a5e4:	2001      	movs	r0, #1
 800a5e6:	e7f8      	b.n	800a5da <HAL_RCC_ClockConfig+0x13a>
      return HAL_ERROR;
 800a5e8:	2001      	movs	r0, #1
 800a5ea:	e7f6      	b.n	800a5da <HAL_RCC_ClockConfig+0x13a>
 800a5ec:	40023c00 	.word	0x40023c00
 800a5f0:	40023800 	.word	0x40023800
 800a5f4:	08025584 	.word	0x08025584
 800a5f8:	20000364 	.word	0x20000364
 800a5fc:	20000004 	.word	0x20000004

0800a600 <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 800a600:	4b01      	ldr	r3, [pc, #4]	; (800a608 <HAL_RCC_GetHCLKFreq+0x8>)
 800a602:	6818      	ldr	r0, [r3, #0]
 800a604:	4770      	bx	lr
 800a606:	bf00      	nop
 800a608:	20000364 	.word	0x20000364

0800a60c <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 800a60c:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 800a60e:	f7ff fff7 	bl	800a600 <HAL_RCC_GetHCLKFreq>
 800a612:	4b04      	ldr	r3, [pc, #16]	; (800a624 <HAL_RCC_GetPCLK1Freq+0x18>)
 800a614:	689b      	ldr	r3, [r3, #8]
 800a616:	f3c3 2382 	ubfx	r3, r3, #10, #3
 800a61a:	4a03      	ldr	r2, [pc, #12]	; (800a628 <HAL_RCC_GetPCLK1Freq+0x1c>)
 800a61c:	5cd3      	ldrb	r3, [r2, r3]
}
 800a61e:	40d8      	lsrs	r0, r3
 800a620:	bd08      	pop	{r3, pc}
 800a622:	bf00      	nop
 800a624:	40023800 	.word	0x40023800
 800a628:	08025594 	.word	0x08025594

0800a62c <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 800a62c:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 800a62e:	f7ff ffe7 	bl	800a600 <HAL_RCC_GetHCLKFreq>
 800a632:	4b04      	ldr	r3, [pc, #16]	; (800a644 <HAL_RCC_GetPCLK2Freq+0x18>)
 800a634:	689b      	ldr	r3, [r3, #8]
 800a636:	f3c3 3342 	ubfx	r3, r3, #13, #3
 800a63a:	4a03      	ldr	r2, [pc, #12]	; (800a648 <HAL_RCC_GetPCLK2Freq+0x1c>)
 800a63c:	5cd3      	ldrb	r3, [r2, r3]
}
 800a63e:	40d8      	lsrs	r0, r3
 800a640:	bd08      	pop	{r3, pc}
 800a642:	bf00      	nop
 800a644:	40023800 	.word	0x40023800
 800a648:	08025594 	.word	0x08025594

0800a64c <HAL_RCC_GetClockConfig>:
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 800a64c:	230f      	movs	r3, #15
 800a64e:	6003      	str	r3, [r0, #0]

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 800a650:	4b0b      	ldr	r3, [pc, #44]	; (800a680 <HAL_RCC_GetClockConfig+0x34>)
 800a652:	689a      	ldr	r2, [r3, #8]
 800a654:	f002 0203 	and.w	r2, r2, #3
 800a658:	6042      	str	r2, [r0, #4]

  /* Get the HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 800a65a:	689a      	ldr	r2, [r3, #8]
 800a65c:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 800a660:	6082      	str	r2, [r0, #8]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
 800a662:	689a      	ldr	r2, [r3, #8]
 800a664:	f402 52e0 	and.w	r2, r2, #7168	; 0x1c00
 800a668:	60c2      	str	r2, [r0, #12]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3U);
 800a66a:	689b      	ldr	r3, [r3, #8]
 800a66c:	08db      	lsrs	r3, r3, #3
 800a66e:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 800a672:	6103      	str	r3, [r0, #16]

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 800a674:	4b03      	ldr	r3, [pc, #12]	; (800a684 <HAL_RCC_GetClockConfig+0x38>)
 800a676:	681b      	ldr	r3, [r3, #0]
 800a678:	f003 030f 	and.w	r3, r3, #15
 800a67c:	600b      	str	r3, [r1, #0]
}
 800a67e:	4770      	bx	lr
 800a680:	40023800 	.word	0x40023800
 800a684:	40023c00 	.word	0x40023c00

0800a688 <TIM_Base_SetConfig>:
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 800a688:	6803      	ldr	r3, [r0, #0]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800a68a:	4a30      	ldr	r2, [pc, #192]	; (800a74c <TIM_Base_SetConfig+0xc4>)
 800a68c:	4290      	cmp	r0, r2
 800a68e:	d012      	beq.n	800a6b6 <TIM_Base_SetConfig+0x2e>
 800a690:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 800a694:	d00f      	beq.n	800a6b6 <TIM_Base_SetConfig+0x2e>
 800a696:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 800a69a:	4290      	cmp	r0, r2
 800a69c:	d00b      	beq.n	800a6b6 <TIM_Base_SetConfig+0x2e>
 800a69e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800a6a2:	4290      	cmp	r0, r2
 800a6a4:	d007      	beq.n	800a6b6 <TIM_Base_SetConfig+0x2e>
 800a6a6:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800a6aa:	4290      	cmp	r0, r2
 800a6ac:	d003      	beq.n	800a6b6 <TIM_Base_SetConfig+0x2e>
 800a6ae:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 800a6b2:	4290      	cmp	r0, r2
 800a6b4:	d103      	bne.n	800a6be <TIM_Base_SetConfig+0x36>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800a6b6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800a6ba:	684a      	ldr	r2, [r1, #4]
 800a6bc:	4313      	orrs	r3, r2
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800a6be:	4a23      	ldr	r2, [pc, #140]	; (800a74c <TIM_Base_SetConfig+0xc4>)
 800a6c0:	4290      	cmp	r0, r2
 800a6c2:	d02a      	beq.n	800a71a <TIM_Base_SetConfig+0x92>
 800a6c4:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 800a6c8:	d027      	beq.n	800a71a <TIM_Base_SetConfig+0x92>
 800a6ca:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 800a6ce:	4290      	cmp	r0, r2
 800a6d0:	d023      	beq.n	800a71a <TIM_Base_SetConfig+0x92>
 800a6d2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800a6d6:	4290      	cmp	r0, r2
 800a6d8:	d01f      	beq.n	800a71a <TIM_Base_SetConfig+0x92>
 800a6da:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800a6de:	4290      	cmp	r0, r2
 800a6e0:	d01b      	beq.n	800a71a <TIM_Base_SetConfig+0x92>
 800a6e2:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 800a6e6:	4290      	cmp	r0, r2
 800a6e8:	d017      	beq.n	800a71a <TIM_Base_SetConfig+0x92>
 800a6ea:	f502 5270 	add.w	r2, r2, #15360	; 0x3c00
 800a6ee:	4290      	cmp	r0, r2
 800a6f0:	d013      	beq.n	800a71a <TIM_Base_SetConfig+0x92>
 800a6f2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800a6f6:	4290      	cmp	r0, r2
 800a6f8:	d00f      	beq.n	800a71a <TIM_Base_SetConfig+0x92>
 800a6fa:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800a6fe:	4290      	cmp	r0, r2
 800a700:	d00b      	beq.n	800a71a <TIM_Base_SetConfig+0x92>
 800a702:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 800a706:	4290      	cmp	r0, r2
 800a708:	d007      	beq.n	800a71a <TIM_Base_SetConfig+0x92>
 800a70a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800a70e:	4290      	cmp	r0, r2
 800a710:	d003      	beq.n	800a71a <TIM_Base_SetConfig+0x92>
 800a712:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800a716:	4290      	cmp	r0, r2
 800a718:	d103      	bne.n	800a722 <TIM_Base_SetConfig+0x9a>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 800a71a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800a71e:	68ca      	ldr	r2, [r1, #12]
 800a720:	4313      	orrs	r3, r2
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800a722:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800a726:	694a      	ldr	r2, [r1, #20]
 800a728:	4313      	orrs	r3, r2

  TIMx->CR1 = tmpcr1;
 800a72a:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 800a72c:	688b      	ldr	r3, [r1, #8]
 800a72e:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 800a730:	680b      	ldr	r3, [r1, #0]
 800a732:	6283      	str	r3, [r0, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800a734:	4b05      	ldr	r3, [pc, #20]	; (800a74c <TIM_Base_SetConfig+0xc4>)
 800a736:	4298      	cmp	r0, r3
 800a738:	d003      	beq.n	800a742 <TIM_Base_SetConfig+0xba>
 800a73a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800a73e:	4298      	cmp	r0, r3
 800a740:	d101      	bne.n	800a746 <TIM_Base_SetConfig+0xbe>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 800a742:	690b      	ldr	r3, [r1, #16]
 800a744:	6303      	str	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 800a746:	2301      	movs	r3, #1
 800a748:	6143      	str	r3, [r0, #20]
}
 800a74a:	4770      	bx	lr
 800a74c:	40010000 	.word	0x40010000

0800a750 <USB_CoreReset>:
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t count = 0U;
 800a750:	2300      	movs	r3, #0

  /* Wait for AHB master IDLE state. */
  do
  {
    if (++count > 200000U)
 800a752:	3301      	adds	r3, #1
 800a754:	4a0c      	ldr	r2, [pc, #48]	; (800a788 <USB_CoreReset+0x38>)
 800a756:	4293      	cmp	r3, r2
 800a758:	d811      	bhi.n	800a77e <USB_CoreReset+0x2e>
    {
      return HAL_TIMEOUT;
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 800a75a:	6902      	ldr	r2, [r0, #16]
 800a75c:	2a00      	cmp	r2, #0
 800a75e:	daf8      	bge.n	800a752 <USB_CoreReset+0x2>

  /* Core Soft Reset */
  count = 0U;
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 800a760:	6903      	ldr	r3, [r0, #16]
 800a762:	f043 0301 	orr.w	r3, r3, #1
 800a766:	6103      	str	r3, [r0, #16]
  count = 0U;
 800a768:	2300      	movs	r3, #0

  do
  {
    if (++count > 200000U)
 800a76a:	3301      	adds	r3, #1
 800a76c:	4a06      	ldr	r2, [pc, #24]	; (800a788 <USB_CoreReset+0x38>)
 800a76e:	4293      	cmp	r3, r2
 800a770:	d807      	bhi.n	800a782 <USB_CoreReset+0x32>
    {
      return HAL_TIMEOUT;
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 800a772:	6902      	ldr	r2, [r0, #16]
 800a774:	f012 0f01 	tst.w	r2, #1
 800a778:	d1f7      	bne.n	800a76a <USB_CoreReset+0x1a>

  return HAL_OK;
 800a77a:	2000      	movs	r0, #0
 800a77c:	4770      	bx	lr
      return HAL_TIMEOUT;
 800a77e:	2003      	movs	r0, #3
 800a780:	4770      	bx	lr
      return HAL_TIMEOUT;
 800a782:	2003      	movs	r0, #3
}
 800a784:	4770      	bx	lr
 800a786:	bf00      	nop
 800a788:	00030d40 	.word	0x00030d40

0800a78c <USB_CoreInit>:
{
 800a78c:	b084      	sub	sp, #16
 800a78e:	b510      	push	{r4, lr}
 800a790:	4604      	mov	r4, r0
 800a792:	a803      	add	r0, sp, #12
 800a794:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 800a798:	9b08      	ldr	r3, [sp, #32]
 800a79a:	2b01      	cmp	r3, #1
 800a79c:	d11f      	bne.n	800a7de <USB_CoreInit+0x52>
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 800a79e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800a7a0:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800a7a4:	63a3      	str	r3, [r4, #56]	; 0x38
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 800a7a6:	68e3      	ldr	r3, [r4, #12]
 800a7a8:	f423 0384 	bic.w	r3, r3, #4325376	; 0x420000
 800a7ac:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800a7b0:	60e3      	str	r3, [r4, #12]
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 800a7b2:	68e3      	ldr	r3, [r4, #12]
 800a7b4:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 800a7b8:	60e3      	str	r3, [r4, #12]
    if (cfg.use_external_vbus == 1U)
 800a7ba:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800a7bc:	2b01      	cmp	r3, #1
 800a7be:	d009      	beq.n	800a7d4 <USB_CoreInit+0x48>
    ret = USB_CoreReset(USBx);
 800a7c0:	4620      	mov	r0, r4
 800a7c2:	f7ff ffc5 	bl	800a750 <USB_CoreReset>
  if (cfg.dma_enable == 1U)
 800a7c6:	9b06      	ldr	r3, [sp, #24]
 800a7c8:	2b01      	cmp	r3, #1
 800a7ca:	d01b      	beq.n	800a804 <USB_CoreInit+0x78>
}
 800a7cc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800a7d0:	b004      	add	sp, #16
 800a7d2:	4770      	bx	lr
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 800a7d4:	68e3      	ldr	r3, [r4, #12]
 800a7d6:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800a7da:	60e3      	str	r3, [r4, #12]
 800a7dc:	e7f0      	b.n	800a7c0 <USB_CoreInit+0x34>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 800a7de:	68e3      	ldr	r3, [r4, #12]
 800a7e0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800a7e4:	60e3      	str	r3, [r4, #12]
    ret = USB_CoreReset(USBx);
 800a7e6:	4620      	mov	r0, r4
 800a7e8:	f7ff ffb2 	bl	800a750 <USB_CoreReset>
    if (cfg.battery_charging_enable == 0U)
 800a7ec:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800a7ee:	b923      	cbnz	r3, 800a7fa <USB_CoreInit+0x6e>
      USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 800a7f0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800a7f2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800a7f6:	63a3      	str	r3, [r4, #56]	; 0x38
 800a7f8:	e7e5      	b.n	800a7c6 <USB_CoreInit+0x3a>
      USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 800a7fa:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800a7fc:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800a800:	63a3      	str	r3, [r4, #56]	; 0x38
 800a802:	e7e0      	b.n	800a7c6 <USB_CoreInit+0x3a>
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 800a804:	68a3      	ldr	r3, [r4, #8]
 800a806:	f043 0306 	orr.w	r3, r3, #6
 800a80a:	60a3      	str	r3, [r4, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 800a80c:	68a3      	ldr	r3, [r4, #8]
 800a80e:	f043 0320 	orr.w	r3, r3, #32
 800a812:	60a3      	str	r3, [r4, #8]
 800a814:	e7da      	b.n	800a7cc <USB_CoreInit+0x40>
	...

0800a818 <USB_SetTurnaroundTime>:
  if (speed == USBD_FS_SPEED)
 800a818:	2a02      	cmp	r2, #2
 800a81a:	d00a      	beq.n	800a832 <USB_SetTurnaroundTime+0x1a>
    UsbTrd = USBD_HS_TRDT_VALUE;
 800a81c:	2209      	movs	r2, #9
  USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 800a81e:	68c3      	ldr	r3, [r0, #12]
 800a820:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 800a824:	60c3      	str	r3, [r0, #12]
  USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
 800a826:	68c3      	ldr	r3, [r0, #12]
 800a828:	ea43 2382 	orr.w	r3, r3, r2, lsl #10
 800a82c:	60c3      	str	r3, [r0, #12]
}
 800a82e:	2000      	movs	r0, #0
 800a830:	4770      	bx	lr
    if ((hclk >= 14200000U) && (hclk < 15000000U))
 800a832:	4b23      	ldr	r3, [pc, #140]	; (800a8c0 <USB_SetTurnaroundTime+0xa8>)
 800a834:	440b      	add	r3, r1
 800a836:	4a23      	ldr	r2, [pc, #140]	; (800a8c4 <USB_SetTurnaroundTime+0xac>)
 800a838:	4293      	cmp	r3, r2
 800a83a:	d92f      	bls.n	800a89c <USB_SetTurnaroundTime+0x84>
    else if ((hclk >= 15000000U) && (hclk < 16000000U))
 800a83c:	4b22      	ldr	r3, [pc, #136]	; (800a8c8 <USB_SetTurnaroundTime+0xb0>)
 800a83e:	440b      	add	r3, r1
 800a840:	4a22      	ldr	r2, [pc, #136]	; (800a8cc <USB_SetTurnaroundTime+0xb4>)
 800a842:	4293      	cmp	r3, r2
 800a844:	d92c      	bls.n	800a8a0 <USB_SetTurnaroundTime+0x88>
    else if ((hclk >= 16000000U) && (hclk < 17200000U))
 800a846:	f5a1 0374 	sub.w	r3, r1, #15990784	; 0xf40000
 800a84a:	f5a3 5310 	sub.w	r3, r3, #9216	; 0x2400
 800a84e:	4a20      	ldr	r2, [pc, #128]	; (800a8d0 <USB_SetTurnaroundTime+0xb8>)
 800a850:	4293      	cmp	r3, r2
 800a852:	d927      	bls.n	800a8a4 <USB_SetTurnaroundTime+0x8c>
    else if ((hclk >= 17200000U) && (hclk < 18500000U))
 800a854:	f1a1 7383 	sub.w	r3, r1, #17170432	; 0x1060000
 800a858:	f5a3 43e7 	sub.w	r3, r3, #29568	; 0x7380
 800a85c:	4a1d      	ldr	r2, [pc, #116]	; (800a8d4 <USB_SetTurnaroundTime+0xbc>)
 800a85e:	4293      	cmp	r3, r2
 800a860:	d322      	bcc.n	800a8a8 <USB_SetTurnaroundTime+0x90>
    else if ((hclk >= 18500000U) && (hclk < 20000000U))
 800a862:	4b1d      	ldr	r3, [pc, #116]	; (800a8d8 <USB_SetTurnaroundTime+0xc0>)
 800a864:	440b      	add	r3, r1
 800a866:	4a1d      	ldr	r2, [pc, #116]	; (800a8dc <USB_SetTurnaroundTime+0xc4>)
 800a868:	4293      	cmp	r3, r2
 800a86a:	d91f      	bls.n	800a8ac <USB_SetTurnaroundTime+0x94>
    else if ((hclk >= 20000000U) && (hclk < 21800000U))
 800a86c:	4b1c      	ldr	r3, [pc, #112]	; (800a8e0 <USB_SetTurnaroundTime+0xc8>)
 800a86e:	440b      	add	r3, r1
 800a870:	4a1c      	ldr	r2, [pc, #112]	; (800a8e4 <USB_SetTurnaroundTime+0xcc>)
 800a872:	4293      	cmp	r3, r2
 800a874:	d31c      	bcc.n	800a8b0 <USB_SetTurnaroundTime+0x98>
    else if ((hclk >= 21800000U) && (hclk < 24000000U))
 800a876:	4b1c      	ldr	r3, [pc, #112]	; (800a8e8 <USB_SetTurnaroundTime+0xd0>)
 800a878:	440b      	add	r3, r1
 800a87a:	4a1c      	ldr	r2, [pc, #112]	; (800a8ec <USB_SetTurnaroundTime+0xd4>)
 800a87c:	4293      	cmp	r3, r2
 800a87e:	d319      	bcc.n	800a8b4 <USB_SetTurnaroundTime+0x9c>
    else if ((hclk >= 24000000U) && (hclk < 27700000U))
 800a880:	f1a1 73b7 	sub.w	r3, r1, #23986176	; 0x16e0000
 800a884:	f5a3 5358 	sub.w	r3, r3, #13824	; 0x3600
 800a888:	4a19      	ldr	r2, [pc, #100]	; (800a8f0 <USB_SetTurnaroundTime+0xd8>)
 800a88a:	4293      	cmp	r3, r2
 800a88c:	d314      	bcc.n	800a8b8 <USB_SetTurnaroundTime+0xa0>
    else if ((hclk >= 27700000U) && (hclk < 32000000U))
 800a88e:	4b19      	ldr	r3, [pc, #100]	; (800a8f4 <USB_SetTurnaroundTime+0xdc>)
 800a890:	440b      	add	r3, r1
 800a892:	4a19      	ldr	r2, [pc, #100]	; (800a8f8 <USB_SetTurnaroundTime+0xe0>)
 800a894:	4293      	cmp	r3, r2
 800a896:	d211      	bcs.n	800a8bc <USB_SetTurnaroundTime+0xa4>
      UsbTrd = 0x7U;
 800a898:	2207      	movs	r2, #7
 800a89a:	e7c0      	b.n	800a81e <USB_SetTurnaroundTime+0x6>
      UsbTrd = 0xFU;
 800a89c:	220f      	movs	r2, #15
 800a89e:	e7be      	b.n	800a81e <USB_SetTurnaroundTime+0x6>
      UsbTrd = 0xEU;
 800a8a0:	220e      	movs	r2, #14
 800a8a2:	e7bc      	b.n	800a81e <USB_SetTurnaroundTime+0x6>
      UsbTrd = 0xDU;
 800a8a4:	220d      	movs	r2, #13
 800a8a6:	e7ba      	b.n	800a81e <USB_SetTurnaroundTime+0x6>
      UsbTrd = 0xCU;
 800a8a8:	220c      	movs	r2, #12
 800a8aa:	e7b8      	b.n	800a81e <USB_SetTurnaroundTime+0x6>
      UsbTrd = 0xBU;
 800a8ac:	220b      	movs	r2, #11
 800a8ae:	e7b6      	b.n	800a81e <USB_SetTurnaroundTime+0x6>
      UsbTrd = 0xAU;
 800a8b0:	220a      	movs	r2, #10
 800a8b2:	e7b4      	b.n	800a81e <USB_SetTurnaroundTime+0x6>
      UsbTrd = 0x9U;
 800a8b4:	2209      	movs	r2, #9
 800a8b6:	e7b2      	b.n	800a81e <USB_SetTurnaroundTime+0x6>
      UsbTrd = 0x8U;
 800a8b8:	2208      	movs	r2, #8
 800a8ba:	e7b0      	b.n	800a81e <USB_SetTurnaroundTime+0x6>
      UsbTrd = 0x6U;
 800a8bc:	2206      	movs	r2, #6
 800a8be:	e7ae      	b.n	800a81e <USB_SetTurnaroundTime+0x6>
 800a8c0:	ff275340 	.word	0xff275340
 800a8c4:	000c34ff 	.word	0x000c34ff
 800a8c8:	ff1b1e40 	.word	0xff1b1e40
 800a8cc:	000f423f 	.word	0x000f423f
 800a8d0:	00124f7f 	.word	0x00124f7f
 800a8d4:	0013d620 	.word	0x0013d620
 800a8d8:	fee5b660 	.word	0xfee5b660
 800a8dc:	0016e35f 	.word	0x0016e35f
 800a8e0:	feced300 	.word	0xfeced300
 800a8e4:	001b7740 	.word	0x001b7740
 800a8e8:	feb35bc0 	.word	0xfeb35bc0
 800a8ec:	002191c0 	.word	0x002191c0
 800a8f0:	00387520 	.word	0x00387520
 800a8f4:	fe5954e0 	.word	0xfe5954e0
 800a8f8:	00419ce0 	.word	0x00419ce0

0800a8fc <USB_EnableGlobalInt>:
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 800a8fc:	6883      	ldr	r3, [r0, #8]
 800a8fe:	f043 0301 	orr.w	r3, r3, #1
 800a902:	6083      	str	r3, [r0, #8]
}
 800a904:	2000      	movs	r0, #0
 800a906:	4770      	bx	lr

0800a908 <USB_DisableGlobalInt>:
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 800a908:	6883      	ldr	r3, [r0, #8]
 800a90a:	f023 0301 	bic.w	r3, r3, #1
 800a90e:	6083      	str	r3, [r0, #8]
}
 800a910:	2000      	movs	r0, #0
 800a912:	4770      	bx	lr

0800a914 <USB_SetCurrentMode>:
{
 800a914:	b508      	push	{r3, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 800a916:	68c3      	ldr	r3, [r0, #12]
 800a918:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 800a91c:	60c3      	str	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 800a91e:	2901      	cmp	r1, #1
 800a920:	d009      	beq.n	800a936 <USB_SetCurrentMode+0x22>
  else if (mode == USB_DEVICE_MODE)
 800a922:	b969      	cbnz	r1, 800a940 <USB_SetCurrentMode+0x2c>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 800a924:	68c3      	ldr	r3, [r0, #12]
 800a926:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800a92a:	60c3      	str	r3, [r0, #12]
  HAL_Delay(50U);
 800a92c:	2032      	movs	r0, #50	; 0x32
 800a92e:	f7fe fa65 	bl	8008dfc <HAL_Delay>
  return HAL_OK;
 800a932:	2000      	movs	r0, #0
}
 800a934:	bd08      	pop	{r3, pc}
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 800a936:	68c3      	ldr	r3, [r0, #12]
 800a938:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800a93c:	60c3      	str	r3, [r0, #12]
 800a93e:	e7f5      	b.n	800a92c <USB_SetCurrentMode+0x18>
    return HAL_ERROR;
 800a940:	2001      	movs	r0, #1
 800a942:	e7f7      	b.n	800a934 <USB_SetCurrentMode+0x20>

0800a944 <USB_FlushTxFifo>:
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 800a944:	0189      	lsls	r1, r1, #6
 800a946:	f041 0120 	orr.w	r1, r1, #32
 800a94a:	6101      	str	r1, [r0, #16]
  uint32_t count = 0U;
 800a94c:	2300      	movs	r3, #0
    if (++count > 200000U)
 800a94e:	3301      	adds	r3, #1
 800a950:	4a05      	ldr	r2, [pc, #20]	; (800a968 <USB_FlushTxFifo+0x24>)
 800a952:	4293      	cmp	r3, r2
 800a954:	d805      	bhi.n	800a962 <USB_FlushTxFifo+0x1e>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 800a956:	6902      	ldr	r2, [r0, #16]
 800a958:	f012 0f20 	tst.w	r2, #32
 800a95c:	d1f7      	bne.n	800a94e <USB_FlushTxFifo+0xa>
  return HAL_OK;
 800a95e:	2000      	movs	r0, #0
 800a960:	4770      	bx	lr
      return HAL_TIMEOUT;
 800a962:	2003      	movs	r0, #3
}
 800a964:	4770      	bx	lr
 800a966:	bf00      	nop
 800a968:	00030d40 	.word	0x00030d40

0800a96c <USB_FlushRxFifo>:
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 800a96c:	2310      	movs	r3, #16
 800a96e:	6103      	str	r3, [r0, #16]
  uint32_t count = 0;
 800a970:	2300      	movs	r3, #0
    if (++count > 200000U)
 800a972:	3301      	adds	r3, #1
 800a974:	4a05      	ldr	r2, [pc, #20]	; (800a98c <USB_FlushRxFifo+0x20>)
 800a976:	4293      	cmp	r3, r2
 800a978:	d805      	bhi.n	800a986 <USB_FlushRxFifo+0x1a>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 800a97a:	6902      	ldr	r2, [r0, #16]
 800a97c:	f012 0f10 	tst.w	r2, #16
 800a980:	d1f7      	bne.n	800a972 <USB_FlushRxFifo+0x6>
  return HAL_OK;
 800a982:	2000      	movs	r0, #0
 800a984:	4770      	bx	lr
      return HAL_TIMEOUT;
 800a986:	2003      	movs	r0, #3
}
 800a988:	4770      	bx	lr
 800a98a:	bf00      	nop
 800a98c:	00030d40 	.word	0x00030d40

0800a990 <USB_SetDevSpeed>:
  USBx_DEVICE->DCFG |= speed;
 800a990:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 800a994:	4319      	orrs	r1, r3
 800a996:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
}
 800a99a:	2000      	movs	r0, #0
 800a99c:	4770      	bx	lr
	...

0800a9a0 <USB_DevInit>:
{
 800a9a0:	b084      	sub	sp, #16
 800a9a2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a9a6:	4604      	mov	r4, r0
 800a9a8:	a807      	add	r0, sp, #28
 800a9aa:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  for (i = 0U; i < 15U; i++)
 800a9ae:	2300      	movs	r3, #0
 800a9b0:	e006      	b.n	800a9c0 <USB_DevInit+0x20>
    USBx->DIEPTXF[i] = 0U;
 800a9b2:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800a9b6:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 800a9ba:	2100      	movs	r1, #0
 800a9bc:	6051      	str	r1, [r2, #4]
  for (i = 0U; i < 15U; i++)
 800a9be:	3301      	adds	r3, #1
 800a9c0:	2b0e      	cmp	r3, #14
 800a9c2:	d9f6      	bls.n	800a9b2 <USB_DevInit+0x12>
  if (cfg.vbus_sensing_enable == 0U)
 800a9c4:	9f11      	ldr	r7, [sp, #68]	; 0x44
 800a9c6:	bb27      	cbnz	r7, 800aa12 <USB_DevInit+0x72>
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 800a9c8:	f8d4 3804 	ldr.w	r3, [r4, #2052]	; 0x804
 800a9cc:	f043 0302 	orr.w	r3, r3, #2
 800a9d0:	f8c4 3804 	str.w	r3, [r4, #2052]	; 0x804
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
 800a9d4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800a9d6:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800a9da:	63a3      	str	r3, [r4, #56]	; 0x38
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSBSEN;
 800a9dc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800a9de:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 800a9e2:	63a3      	str	r3, [r4, #56]	; 0x38
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSASEN;
 800a9e4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800a9e6:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800a9ea:	63a3      	str	r3, [r4, #56]	; 0x38
  USBx_PCGCCTL = 0U;
 800a9ec:	2300      	movs	r3, #0
 800a9ee:	f8c4 3e00 	str.w	r3, [r4, #3584]	; 0xe00
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 800a9f2:	f504 6500 	add.w	r5, r4, #2048	; 0x800
 800a9f6:	f8d4 3800 	ldr.w	r3, [r4, #2048]	; 0x800
 800a9fa:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 800a9fe:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800aa00:	2b01      	cmp	r3, #1
 800aa02:	d114      	bne.n	800aa2e <USB_DevInit+0x8e>
    if (cfg.speed == USBD_HS_SPEED)
 800aa04:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800aa06:	b96b      	cbnz	r3, 800aa24 <USB_DevInit+0x84>
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH);
 800aa08:	2100      	movs	r1, #0
 800aa0a:	4620      	mov	r0, r4
 800aa0c:	f7ff ffc0 	bl	800a990 <USB_SetDevSpeed>
 800aa10:	e011      	b.n	800aa36 <USB_DevInit+0x96>
    USBx->GCCFG &= ~USB_OTG_GCCFG_NOVBUSSENS;
 800aa12:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800aa14:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800aa18:	63a3      	str	r3, [r4, #56]	; 0x38
    USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
 800aa1a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800aa1c:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 800aa20:	63a3      	str	r3, [r4, #56]	; 0x38
 800aa22:	e7e3      	b.n	800a9ec <USB_DevInit+0x4c>
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH_IN_FULL);
 800aa24:	2101      	movs	r1, #1
 800aa26:	4620      	mov	r0, r4
 800aa28:	f7ff ffb2 	bl	800a990 <USB_SetDevSpeed>
 800aa2c:	e003      	b.n	800aa36 <USB_DevInit+0x96>
    (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_FULL);
 800aa2e:	2103      	movs	r1, #3
 800aa30:	4620      	mov	r0, r4
 800aa32:	f7ff ffad 	bl	800a990 <USB_SetDevSpeed>
  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
 800aa36:	2110      	movs	r1, #16
 800aa38:	4620      	mov	r0, r4
 800aa3a:	f7ff ff83 	bl	800a944 <USB_FlushTxFifo>
 800aa3e:	4680      	mov	r8, r0
 800aa40:	b108      	cbz	r0, 800aa46 <USB_DevInit+0xa6>
    ret = HAL_ERROR;
 800aa42:	f04f 0801 	mov.w	r8, #1
  if (USB_FlushRxFifo(USBx) != HAL_OK)
 800aa46:	4620      	mov	r0, r4
 800aa48:	f7ff ff90 	bl	800a96c <USB_FlushRxFifo>
 800aa4c:	b108      	cbz	r0, 800aa52 <USB_DevInit+0xb2>
    ret = HAL_ERROR;
 800aa4e:	f04f 0801 	mov.w	r8, #1
  USBx_DEVICE->DIEPMSK = 0U;
 800aa52:	2300      	movs	r3, #0
 800aa54:	612b      	str	r3, [r5, #16]
  USBx_DEVICE->DOEPMSK = 0U;
 800aa56:	616b      	str	r3, [r5, #20]
  USBx_DEVICE->DAINTMSK = 0U;
 800aa58:	61eb      	str	r3, [r5, #28]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 800aa5a:	e00a      	b.n	800aa72 <USB_DevInit+0xd2>
      if (i == 0U)
 800aa5c:	b9c3      	cbnz	r3, 800aa90 <USB_DevInit+0xf0>
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 800aa5e:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
 800aa62:	f8c2 0900 	str.w	r0, [r2, #2304]	; 0x900
    USBx_INEP(i)->DIEPTSIZ = 0U;
 800aa66:	2200      	movs	r2, #0
 800aa68:	610a      	str	r2, [r1, #16]
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 800aa6a:	f64f 327f 	movw	r2, #64383	; 0xfb7f
 800aa6e:	608a      	str	r2, [r1, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 800aa70:	3301      	adds	r3, #1
 800aa72:	9907      	ldr	r1, [sp, #28]
 800aa74:	4299      	cmp	r1, r3
 800aa76:	d910      	bls.n	800aa9a <USB_DevInit+0xfa>
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 800aa78:	eb04 1243 	add.w	r2, r4, r3, lsl #5
 800aa7c:	f502 6110 	add.w	r1, r2, #2304	; 0x900
 800aa80:	f8d2 0900 	ldr.w	r0, [r2, #2304]	; 0x900
 800aa84:	2800      	cmp	r0, #0
 800aa86:	dbe9      	blt.n	800aa5c <USB_DevInit+0xbc>
      USBx_INEP(i)->DIEPCTL = 0U;
 800aa88:	2000      	movs	r0, #0
 800aa8a:	f8c2 0900 	str.w	r0, [r2, #2304]	; 0x900
 800aa8e:	e7ea      	b.n	800aa66 <USB_DevInit+0xc6>
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 800aa90:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800aa94:	f8c2 0900 	str.w	r0, [r2, #2304]	; 0x900
 800aa98:	e7e5      	b.n	800aa66 <USB_DevInit+0xc6>
  for (i = 0U; i < cfg.dev_endpoints; i++)
 800aa9a:	2300      	movs	r3, #0
 800aa9c:	e00a      	b.n	800aab4 <USB_DevInit+0x114>
      if (i == 0U)
 800aa9e:	b1c3      	cbz	r3, 800aad2 <USB_DevInit+0x132>
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 800aaa0:	f04f 4c90 	mov.w	ip, #1207959552	; 0x48000000
 800aaa4:	f8c2 cb00 	str.w	ip, [r2, #2816]	; 0xb00
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 800aaa8:	2200      	movs	r2, #0
 800aaaa:	6102      	str	r2, [r0, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 800aaac:	f64f 327f 	movw	r2, #64383	; 0xfb7f
 800aab0:	6082      	str	r2, [r0, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 800aab2:	3301      	adds	r3, #1
 800aab4:	4299      	cmp	r1, r3
 800aab6:	d911      	bls.n	800aadc <USB_DevInit+0x13c>
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 800aab8:	eb04 1243 	add.w	r2, r4, r3, lsl #5
 800aabc:	f502 6030 	add.w	r0, r2, #2816	; 0xb00
 800aac0:	f8d2 6b00 	ldr.w	r6, [r2, #2816]	; 0xb00
 800aac4:	2e00      	cmp	r6, #0
 800aac6:	dbea      	blt.n	800aa9e <USB_DevInit+0xfe>
      USBx_OUTEP(i)->DOEPCTL = 0U;
 800aac8:	f04f 0c00 	mov.w	ip, #0
 800aacc:	f8c2 cb00 	str.w	ip, [r2, #2816]	; 0xb00
 800aad0:	e7ea      	b.n	800aaa8 <USB_DevInit+0x108>
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 800aad2:	f04f 6c00 	mov.w	ip, #134217728	; 0x8000000
 800aad6:	f8c2 cb00 	str.w	ip, [r2, #2816]	; 0xb00
 800aada:	e7e5      	b.n	800aaa8 <USB_DevInit+0x108>
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 800aadc:	692b      	ldr	r3, [r5, #16]
 800aade:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800aae2:	612b      	str	r3, [r5, #16]
  USBx->GINTMSK = 0U;
 800aae4:	2300      	movs	r3, #0
 800aae6:	61a3      	str	r3, [r4, #24]
  USBx->GINTSTS = 0xBFFFFFFFU;
 800aae8:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000
 800aaec:	6163      	str	r3, [r4, #20]
  if (cfg.dma_enable == 0U)
 800aaee:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800aaf0:	b91b      	cbnz	r3, 800aafa <USB_DevInit+0x15a>
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 800aaf2:	69a3      	ldr	r3, [r4, #24]
 800aaf4:	f043 0310 	orr.w	r3, r3, #16
 800aaf8:	61a3      	str	r3, [r4, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
 800aafa:	69a2      	ldr	r2, [r4, #24]
 800aafc:	4b0b      	ldr	r3, [pc, #44]	; (800ab2c <USB_DevInit+0x18c>)
 800aafe:	4313      	orrs	r3, r2
 800ab00:	61a3      	str	r3, [r4, #24]
  if (cfg.Sof_enable != 0U)
 800ab02:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800ab04:	b11b      	cbz	r3, 800ab0e <USB_DevInit+0x16e>
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 800ab06:	69a3      	ldr	r3, [r4, #24]
 800ab08:	f043 0308 	orr.w	r3, r3, #8
 800ab0c:	61a3      	str	r3, [r4, #24]
  if (cfg.vbus_sensing_enable == 1U)
 800ab0e:	2f01      	cmp	r7, #1
 800ab10:	d004      	beq.n	800ab1c <USB_DevInit+0x17c>
}
 800ab12:	4640      	mov	r0, r8
 800ab14:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800ab18:	b004      	add	sp, #16
 800ab1a:	4770      	bx	lr
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT);
 800ab1c:	69a3      	ldr	r3, [r4, #24]
 800ab1e:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800ab22:	f043 0304 	orr.w	r3, r3, #4
 800ab26:	61a3      	str	r3, [r4, #24]
 800ab28:	e7f3      	b.n	800ab12 <USB_DevInit+0x172>
 800ab2a:	bf00      	nop
 800ab2c:	803c3800 	.word	0x803c3800

0800ab30 <USB_GetDevSpeed>:
  uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
 800ab30:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
  if (DevEnumSpeed == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 800ab34:	f013 0306 	ands.w	r3, r3, #6
 800ab38:	d007      	beq.n	800ab4a <USB_GetDevSpeed+0x1a>
  else if ((DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ) ||
 800ab3a:	2b02      	cmp	r3, #2
 800ab3c:	d007      	beq.n	800ab4e <USB_GetDevSpeed+0x1e>
 800ab3e:	2b06      	cmp	r3, #6
 800ab40:	d001      	beq.n	800ab46 <USB_GetDevSpeed+0x16>
    speed = 0xFU;
 800ab42:	200f      	movs	r0, #15
}
 800ab44:	4770      	bx	lr
    speed = USBD_FS_SPEED;
 800ab46:	2002      	movs	r0, #2
 800ab48:	4770      	bx	lr
    speed = USBD_HS_SPEED;
 800ab4a:	2000      	movs	r0, #0
 800ab4c:	4770      	bx	lr
    speed = USBD_FS_SPEED;
 800ab4e:	2002      	movs	r0, #2
 800ab50:	4770      	bx	lr

0800ab52 <USB_ActivateEndpoint>:
{
 800ab52:	b510      	push	{r4, lr}
  uint32_t epnum = (uint32_t)ep->num;
 800ab54:	f891 c000 	ldrb.w	ip, [r1]
  if (ep->is_in == 1U)
 800ab58:	784b      	ldrb	r3, [r1, #1]
 800ab5a:	2b01      	cmp	r3, #1
 800ab5c:	d023      	beq.n	800aba6 <USB_ActivateEndpoint+0x54>
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
 800ab5e:	f500 6e00 	add.w	lr, r0, #2048	; 0x800
 800ab62:	f8d0 381c 	ldr.w	r3, [r0, #2076]	; 0x81c
 800ab66:	f00c 040f 	and.w	r4, ip, #15
 800ab6a:	2201      	movs	r2, #1
 800ab6c:	40a2      	lsls	r2, r4
 800ab6e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 800ab72:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 800ab76:	eb00 104c 	add.w	r0, r0, ip, lsl #5
 800ab7a:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 800ab7e:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 800ab82:	d10e      	bne.n	800aba2 <USB_ActivateEndpoint+0x50>
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 800ab84:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 800ab88:	688a      	ldr	r2, [r1, #8]
 800ab8a:	f3c2 020a 	ubfx	r2, r2, #0, #11
                                    ((uint32_t)ep->type << 18) |
 800ab8e:	78c9      	ldrb	r1, [r1, #3]
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 800ab90:	ea42 4281 	orr.w	r2, r2, r1, lsl #18
 800ab94:	4313      	orrs	r3, r2
 800ab96:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800ab9a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800ab9e:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
}
 800aba2:	2000      	movs	r0, #0
 800aba4:	bd10      	pop	{r4, pc}
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 800aba6:	f8d0 281c 	ldr.w	r2, [r0, #2076]	; 0x81c
 800abaa:	f00c 0e0f 	and.w	lr, ip, #15
 800abae:	fa03 f30e 	lsl.w	r3, r3, lr
 800abb2:	b29b      	uxth	r3, r3
 800abb4:	4313      	orrs	r3, r2
 800abb6:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 800abba:	eb00 104c 	add.w	r0, r0, ip, lsl #5
 800abbe:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 800abc2:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 800abc6:	d1ec      	bne.n	800aba2 <USB_ActivateEndpoint+0x50>
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 800abc8:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 800abcc:	688a      	ldr	r2, [r1, #8]
 800abce:	f3c2 020a 	ubfx	r2, r2, #0, #11
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 800abd2:	78c9      	ldrb	r1, [r1, #3]
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 800abd4:	ea42 4281 	orr.w	r2, r2, r1, lsl #18
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 800abd8:	ea42 528c 	orr.w	r2, r2, ip, lsl #22
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 800abdc:	4313      	orrs	r3, r2
 800abde:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800abe2:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800abe6:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
 800abea:	e7da      	b.n	800aba2 <USB_ActivateEndpoint+0x50>

0800abec <USB_DeactivateEndpoint>:
{
 800abec:	b430      	push	{r4, r5}
  uint32_t epnum = (uint32_t)ep->num;
 800abee:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 800abf0:	784a      	ldrb	r2, [r1, #1]
 800abf2:	2a01      	cmp	r2, #1
 800abf4:	d026      	beq.n	800ac44 <USB_DeactivateEndpoint+0x58>
    if ((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 800abf6:	eb00 1343 	add.w	r3, r0, r3, lsl #5
 800abfa:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 800abfe:	2a00      	cmp	r2, #0
 800ac00:	db52      	blt.n	800aca8 <USB_DeactivateEndpoint+0xbc>
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 800ac02:	f8d0 483c 	ldr.w	r4, [r0, #2108]	; 0x83c
 800ac06:	780a      	ldrb	r2, [r1, #0]
 800ac08:	f002 020f 	and.w	r2, r2, #15
 800ac0c:	f04f 0c01 	mov.w	ip, #1
 800ac10:	fa0c f202 	lsl.w	r2, ip, r2
 800ac14:	ea24 4202 	bic.w	r2, r4, r2, lsl #16
 800ac18:	f8c0 283c 	str.w	r2, [r0, #2108]	; 0x83c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 800ac1c:	f8d0 281c 	ldr.w	r2, [r0, #2076]	; 0x81c
 800ac20:	7809      	ldrb	r1, [r1, #0]
 800ac22:	f001 010f 	and.w	r1, r1, #15
 800ac26:	fa0c fc01 	lsl.w	ip, ip, r1
 800ac2a:	ea22 420c 	bic.w	r2, r2, ip, lsl #16
 800ac2e:	f8c0 281c 	str.w	r2, [r0, #2076]	; 0x81c
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 800ac32:	f8d3 1b00 	ldr.w	r1, [r3, #2816]	; 0xb00
 800ac36:	4a23      	ldr	r2, [pc, #140]	; (800acc4 <USB_DeactivateEndpoint+0xd8>)
 800ac38:	400a      	ands	r2, r1
 800ac3a:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
}
 800ac3e:	2000      	movs	r0, #0
 800ac40:	bc30      	pop	{r4, r5}
 800ac42:	4770      	bx	lr
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 800ac44:	eb00 1343 	add.w	r3, r0, r3, lsl #5
 800ac48:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 800ac4c:	2a00      	cmp	r2, #0
 800ac4e:	db1e      	blt.n	800ac8e <USB_DeactivateEndpoint+0xa2>
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 800ac50:	f8d0 583c 	ldr.w	r5, [r0, #2108]	; 0x83c
 800ac54:	780a      	ldrb	r2, [r1, #0]
 800ac56:	f002 020f 	and.w	r2, r2, #15
 800ac5a:	2401      	movs	r4, #1
 800ac5c:	fa04 f202 	lsl.w	r2, r4, r2
 800ac60:	b292      	uxth	r2, r2
 800ac62:	ea25 0202 	bic.w	r2, r5, r2
 800ac66:	f8c0 283c 	str.w	r2, [r0, #2108]	; 0x83c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 800ac6a:	f8d0 281c 	ldr.w	r2, [r0, #2076]	; 0x81c
 800ac6e:	7809      	ldrb	r1, [r1, #0]
 800ac70:	f001 010f 	and.w	r1, r1, #15
 800ac74:	408c      	lsls	r4, r1
 800ac76:	b2a4      	uxth	r4, r4
 800ac78:	ea22 0204 	bic.w	r2, r2, r4
 800ac7c:	f8c0 281c 	str.w	r2, [r0, #2076]	; 0x81c
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 800ac80:	f8d3 1900 	ldr.w	r1, [r3, #2304]	; 0x900
 800ac84:	4a10      	ldr	r2, [pc, #64]	; (800acc8 <USB_DeactivateEndpoint+0xdc>)
 800ac86:	400a      	ands	r2, r1
 800ac88:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 800ac8c:	e7d7      	b.n	800ac3e <USB_DeactivateEndpoint+0x52>
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SNAK;
 800ac8e:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 800ac92:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 800ac96:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_EPDIS;
 800ac9a:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 800ac9e:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 800aca2:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 800aca6:	e7d3      	b.n	800ac50 <USB_DeactivateEndpoint+0x64>
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 800aca8:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 800acac:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 800acb0:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_EPDIS;
 800acb4:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 800acb8:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 800acbc:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 800acc0:	e79f      	b.n	800ac02 <USB_DeactivateEndpoint+0x16>
 800acc2:	bf00      	nop
 800acc4:	eff37800 	.word	0xeff37800
 800acc8:	ec337800 	.word	0xec337800

0800accc <USB_EP0StartXfer>:
{
 800accc:	b470      	push	{r4, r5, r6}
  uint32_t epnum = (uint32_t)ep->num;
 800acce:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 800acd0:	784c      	ldrb	r4, [r1, #1]
 800acd2:	2c01      	cmp	r4, #1
 800acd4:	d027      	beq.n	800ad26 <USB_EP0StartXfer+0x5a>
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 800acd6:	eb00 1043 	add.w	r0, r0, r3, lsl #5
 800acda:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
 800acde:	691c      	ldr	r4, [r3, #16]
 800ace0:	0ce4      	lsrs	r4, r4, #19
 800ace2:	04e4      	lsls	r4, r4, #19
 800ace4:	611c      	str	r4, [r3, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 800ace6:	691c      	ldr	r4, [r3, #16]
 800ace8:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 800acec:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 800acf0:	611c      	str	r4, [r3, #16]
    if (ep->xfer_len > 0U)
 800acf2:	694c      	ldr	r4, [r1, #20]
 800acf4:	b10c      	cbz	r4, 800acfa <USB_EP0StartXfer+0x2e>
      ep->xfer_len = ep->maxpacket;
 800acf6:	688c      	ldr	r4, [r1, #8]
 800acf8:	614c      	str	r4, [r1, #20]
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 800acfa:	691c      	ldr	r4, [r3, #16]
 800acfc:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 800ad00:	611c      	str	r4, [r3, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket));
 800ad02:	691c      	ldr	r4, [r3, #16]
 800ad04:	688d      	ldr	r5, [r1, #8]
 800ad06:	f3c5 0c12 	ubfx	ip, r5, #0, #19
 800ad0a:	ea44 040c 	orr.w	r4, r4, ip
 800ad0e:	611c      	str	r4, [r3, #16]
    if (dma == 1U)
 800ad10:	2a01      	cmp	r2, #1
 800ad12:	d066      	beq.n	800ade2 <USB_EP0StartXfer+0x116>
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 800ad14:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 800ad18:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 800ad1c:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
}
 800ad20:	2000      	movs	r0, #0
 800ad22:	bc70      	pop	{r4, r5, r6}
 800ad24:	4770      	bx	lr
    if (ep->xfer_len == 0U)
 800ad26:	694c      	ldr	r4, [r1, #20]
 800ad28:	bb6c      	cbnz	r4, 800ad86 <USB_EP0StartXfer+0xba>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 800ad2a:	eb00 1443 	add.w	r4, r0, r3, lsl #5
 800ad2e:	f8d4 5910 	ldr.w	r5, [r4, #2320]	; 0x910
 800ad32:	f025 55ff 	bic.w	r5, r5, #534773760	; 0x1fe00000
 800ad36:	f425 15c0 	bic.w	r5, r5, #1572864	; 0x180000
 800ad3a:	f8c4 5910 	str.w	r5, [r4, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 800ad3e:	f8d4 5910 	ldr.w	r5, [r4, #2320]	; 0x910
 800ad42:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 800ad46:	f8c4 5910 	str.w	r5, [r4, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800ad4a:	f8d4 5910 	ldr.w	r5, [r4, #2320]	; 0x910
 800ad4e:	0ced      	lsrs	r5, r5, #19
 800ad50:	04ed      	lsls	r5, r5, #19
 800ad52:	f8c4 5910 	str.w	r5, [r4, #2320]	; 0x910
    if (dma == 1U)
 800ad56:	2a01      	cmp	r2, #1
 800ad58:	d034      	beq.n	800adc4 <USB_EP0StartXfer+0xf8>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 800ad5a:	eb00 1343 	add.w	r3, r0, r3, lsl #5
 800ad5e:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 800ad62:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 800ad66:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
      if (ep->xfer_len > 0U)
 800ad6a:	694b      	ldr	r3, [r1, #20]
 800ad6c:	2b00      	cmp	r3, #0
 800ad6e:	d0d7      	beq.n	800ad20 <USB_EP0StartXfer+0x54>
        USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 800ad70:	f8d0 3834 	ldr.w	r3, [r0, #2100]	; 0x834
 800ad74:	7809      	ldrb	r1, [r1, #0]
 800ad76:	f001 010f 	and.w	r1, r1, #15
 800ad7a:	2201      	movs	r2, #1
 800ad7c:	408a      	lsls	r2, r1
 800ad7e:	4313      	orrs	r3, r2
 800ad80:	f8c0 3834 	str.w	r3, [r0, #2100]	; 0x834
 800ad84:	e7cc      	b.n	800ad20 <USB_EP0StartXfer+0x54>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800ad86:	eb00 1443 	add.w	r4, r0, r3, lsl #5
 800ad8a:	f504 6410 	add.w	r4, r4, #2304	; 0x900
 800ad8e:	6925      	ldr	r5, [r4, #16]
 800ad90:	0ced      	lsrs	r5, r5, #19
 800ad92:	04ed      	lsls	r5, r5, #19
 800ad94:	6125      	str	r5, [r4, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 800ad96:	6925      	ldr	r5, [r4, #16]
 800ad98:	f025 55ff 	bic.w	r5, r5, #534773760	; 0x1fe00000
 800ad9c:	f425 15c0 	bic.w	r5, r5, #1572864	; 0x180000
 800ada0:	6125      	str	r5, [r4, #16]
      if (ep->xfer_len > ep->maxpacket)
 800ada2:	688d      	ldr	r5, [r1, #8]
 800ada4:	694e      	ldr	r6, [r1, #20]
 800ada6:	42ae      	cmp	r6, r5
 800ada8:	d900      	bls.n	800adac <USB_EP0StartXfer+0xe0>
        ep->xfer_len = ep->maxpacket;
 800adaa:	614d      	str	r5, [r1, #20]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 800adac:	6925      	ldr	r5, [r4, #16]
 800adae:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 800adb2:	6125      	str	r5, [r4, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 800adb4:	6925      	ldr	r5, [r4, #16]
 800adb6:	694e      	ldr	r6, [r1, #20]
 800adb8:	f3c6 0c12 	ubfx	ip, r6, #0, #19
 800adbc:	ea45 050c 	orr.w	r5, r5, ip
 800adc0:	6125      	str	r5, [r4, #16]
 800adc2:	e7c8      	b.n	800ad56 <USB_EP0StartXfer+0x8a>
      if ((uint32_t)ep->dma_addr != 0U)
 800adc4:	690a      	ldr	r2, [r1, #16]
 800adc6:	b11a      	cbz	r2, 800add0 <USB_EP0StartXfer+0x104>
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 800adc8:	eb00 1143 	add.w	r1, r0, r3, lsl #5
 800adcc:	f8c1 2914 	str.w	r2, [r1, #2324]	; 0x914
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 800add0:	eb00 1343 	add.w	r3, r0, r3, lsl #5
 800add4:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 800add8:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 800addc:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 800ade0:	e79e      	b.n	800ad20 <USB_EP0StartXfer+0x54>
      if ((uint32_t)ep->xfer_buff != 0U)
 800ade2:	68ca      	ldr	r2, [r1, #12]
 800ade4:	2a00      	cmp	r2, #0
 800ade6:	d095      	beq.n	800ad14 <USB_EP0StartXfer+0x48>
        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 800ade8:	615a      	str	r2, [r3, #20]
 800adea:	e793      	b.n	800ad14 <USB_EP0StartXfer+0x48>

0800adec <USB_WritePacket>:
{
 800adec:	b510      	push	{r4, lr}
 800adee:	f89d 4008 	ldrb.w	r4, [sp, #8]
  if (dma == 0U)
 800adf2:	b984      	cbnz	r4, 800ae16 <USB_WritePacket+0x2a>
    count32b = ((uint32_t)len + 3U) / 4U;
 800adf4:	3303      	adds	r3, #3
 800adf6:	ea4f 0e93 	mov.w	lr, r3, lsr #2
    for (i = 0U; i < count32b; i++)
 800adfa:	f04f 0c00 	mov.w	ip, #0
 800adfe:	e008      	b.n	800ae12 <USB_WritePacket+0x26>
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 800ae00:	eb00 3302 	add.w	r3, r0, r2, lsl #12
 800ae04:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800ae08:	f851 4b04 	ldr.w	r4, [r1], #4
 800ae0c:	601c      	str	r4, [r3, #0]
    for (i = 0U; i < count32b; i++)
 800ae0e:	f10c 0c01 	add.w	ip, ip, #1
 800ae12:	45f4      	cmp	ip, lr
 800ae14:	d3f4      	bcc.n	800ae00 <USB_WritePacket+0x14>
}
 800ae16:	2000      	movs	r0, #0
 800ae18:	bd10      	pop	{r4, pc}
	...

0800ae1c <USB_EPStartXfer>:
{
 800ae1c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ae1e:	b083      	sub	sp, #12
  uint32_t epnum = (uint32_t)ep->num;
 800ae20:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 800ae22:	784c      	ldrb	r4, [r1, #1]
 800ae24:	2c01      	cmp	r4, #1
 800ae26:	d033      	beq.n	800ae90 <USB_EPStartXfer+0x74>
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 800ae28:	eb00 1343 	add.w	r3, r0, r3, lsl #5
 800ae2c:	f503 6c30 	add.w	ip, r3, #2816	; 0xb00
 800ae30:	f8dc 4010 	ldr.w	r4, [ip, #16]
 800ae34:	0ce4      	lsrs	r4, r4, #19
 800ae36:	04e4      	lsls	r4, r4, #19
 800ae38:	f8cc 4010 	str.w	r4, [ip, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 800ae3c:	f8dc 4010 	ldr.w	r4, [ip, #16]
 800ae40:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 800ae44:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 800ae48:	f8cc 4010 	str.w	r4, [ip, #16]
    if (ep->xfer_len == 0U)
 800ae4c:	694c      	ldr	r4, [r1, #20]
 800ae4e:	2c00      	cmp	r4, #0
 800ae50:	f040 80c9 	bne.w	800afe6 <USB_EPStartXfer+0x1ca>
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 800ae54:	f8dc 4010 	ldr.w	r4, [ip, #16]
 800ae58:	688d      	ldr	r5, [r1, #8]
 800ae5a:	f3c5 0512 	ubfx	r5, r5, #0, #19
 800ae5e:	432c      	orrs	r4, r5
 800ae60:	f8cc 4010 	str.w	r4, [ip, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 800ae64:	f8dc 4010 	ldr.w	r4, [ip, #16]
 800ae68:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 800ae6c:	f8cc 4010 	str.w	r4, [ip, #16]
    if (dma == 1U)
 800ae70:	2a01      	cmp	r2, #1
 800ae72:	f000 80d2 	beq.w	800b01a <USB_EPStartXfer+0x1fe>
    if (ep->type == EP_TYPE_ISOC)
 800ae76:	78ca      	ldrb	r2, [r1, #3]
 800ae78:	2a01      	cmp	r2, #1
 800ae7a:	f000 80d5 	beq.w	800b028 <USB_EPStartXfer+0x20c>
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 800ae7e:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 800ae82:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 800ae86:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
}
 800ae8a:	2000      	movs	r0, #0
 800ae8c:	b003      	add	sp, #12
 800ae8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (ep->xfer_len == 0U)
 800ae90:	694c      	ldr	r4, [r1, #20]
 800ae92:	bb84      	cbnz	r4, 800aef6 <USB_EPStartXfer+0xda>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 800ae94:	eb00 1443 	add.w	r4, r0, r3, lsl #5
 800ae98:	f8d4 5910 	ldr.w	r5, [r4, #2320]	; 0x910
 800ae9c:	f025 55ff 	bic.w	r5, r5, #534773760	; 0x1fe00000
 800aea0:	f425 15c0 	bic.w	r5, r5, #1572864	; 0x180000
 800aea4:	f8c4 5910 	str.w	r5, [r4, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 800aea8:	f8d4 5910 	ldr.w	r5, [r4, #2320]	; 0x910
 800aeac:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 800aeb0:	f8c4 5910 	str.w	r5, [r4, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800aeb4:	f8d4 5910 	ldr.w	r5, [r4, #2320]	; 0x910
 800aeb8:	0ced      	lsrs	r5, r5, #19
 800aeba:	04ed      	lsls	r5, r5, #19
 800aebc:	f8c4 5910 	str.w	r5, [r4, #2320]	; 0x910
    if (dma == 1U)
 800aec0:	2a01      	cmp	r2, #1
 800aec2:	d04e      	beq.n	800af62 <USB_EPStartXfer+0x146>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 800aec4:	eb00 1343 	add.w	r3, r0, r3, lsl #5
 800aec8:	f8d3 4900 	ldr.w	r4, [r3, #2304]	; 0x900
 800aecc:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 800aed0:	f8c3 4900 	str.w	r4, [r3, #2304]	; 0x900
      if (ep->type != EP_TYPE_ISOC)
 800aed4:	78cc      	ldrb	r4, [r1, #3]
 800aed6:	2c01      	cmp	r4, #1
 800aed8:	d06c      	beq.n	800afb4 <USB_EPStartXfer+0x198>
        if (ep->xfer_len > 0U)
 800aeda:	694b      	ldr	r3, [r1, #20]
 800aedc:	2b00      	cmp	r3, #0
 800aede:	d0d4      	beq.n	800ae8a <USB_EPStartXfer+0x6e>
          USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 800aee0:	f8d0 3834 	ldr.w	r3, [r0, #2100]	; 0x834
 800aee4:	7809      	ldrb	r1, [r1, #0]
 800aee6:	f001 010f 	and.w	r1, r1, #15
 800aeea:	2201      	movs	r2, #1
 800aeec:	408a      	lsls	r2, r1
 800aeee:	4313      	orrs	r3, r2
 800aef0:	f8c0 3834 	str.w	r3, [r0, #2100]	; 0x834
 800aef4:	e7c9      	b.n	800ae8a <USB_EPStartXfer+0x6e>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800aef6:	eb00 1443 	add.w	r4, r0, r3, lsl #5
 800aefa:	f8d4 5910 	ldr.w	r5, [r4, #2320]	; 0x910
 800aefe:	0ced      	lsrs	r5, r5, #19
 800af00:	04ed      	lsls	r5, r5, #19
 800af02:	f8c4 5910 	str.w	r5, [r4, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 800af06:	f8d4 5910 	ldr.w	r5, [r4, #2320]	; 0x910
 800af0a:	f025 55ff 	bic.w	r5, r5, #534773760	; 0x1fe00000
 800af0e:	f425 15c0 	bic.w	r5, r5, #1572864	; 0x180000
 800af12:	f8c4 5910 	str.w	r5, [r4, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 800af16:	f8d4 5910 	ldr.w	r5, [r4, #2320]	; 0x910
 800af1a:	688e      	ldr	r6, [r1, #8]
 800af1c:	694f      	ldr	r7, [r1, #20]
 800af1e:	eb07 0c06 	add.w	ip, r7, r6
 800af22:	f10c 3cff 	add.w	ip, ip, #4294967295
 800af26:	fbbc fcf6 	udiv	ip, ip, r6
 800af2a:	4e49      	ldr	r6, [pc, #292]	; (800b050 <USB_EPStartXfer+0x234>)
 800af2c:	ea06 46cc 	and.w	r6, r6, ip, lsl #19
 800af30:	4335      	orrs	r5, r6
 800af32:	f8c4 5910 	str.w	r5, [r4, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 800af36:	f8d4 5910 	ldr.w	r5, [r4, #2320]	; 0x910
 800af3a:	694e      	ldr	r6, [r1, #20]
 800af3c:	f3c6 0612 	ubfx	r6, r6, #0, #19
 800af40:	4335      	orrs	r5, r6
 800af42:	f8c4 5910 	str.w	r5, [r4, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800af46:	f504 6410 	add.w	r4, r4, #2304	; 0x900
      if (ep->type == EP_TYPE_ISOC)
 800af4a:	78cd      	ldrb	r5, [r1, #3]
 800af4c:	2d01      	cmp	r5, #1
 800af4e:	d1b7      	bne.n	800aec0 <USB_EPStartXfer+0xa4>
        USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
 800af50:	6925      	ldr	r5, [r4, #16]
 800af52:	f025 45c0 	bic.w	r5, r5, #1610612736	; 0x60000000
 800af56:	6125      	str	r5, [r4, #16]
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29));
 800af58:	6925      	ldr	r5, [r4, #16]
 800af5a:	f045 5500 	orr.w	r5, r5, #536870912	; 0x20000000
 800af5e:	6125      	str	r5, [r4, #16]
 800af60:	e7ae      	b.n	800aec0 <USB_EPStartXfer+0xa4>
      if ((uint32_t)ep->dma_addr != 0U)
 800af62:	690a      	ldr	r2, [r1, #16]
 800af64:	b11a      	cbz	r2, 800af6e <USB_EPStartXfer+0x152>
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 800af66:	eb00 1443 	add.w	r4, r0, r3, lsl #5
 800af6a:	f8c4 2914 	str.w	r2, [r4, #2324]	; 0x914
      if (ep->type == EP_TYPE_ISOC)
 800af6e:	78ca      	ldrb	r2, [r1, #3]
 800af70:	2a01      	cmp	r2, #1
 800af72:	d008      	beq.n	800af86 <USB_EPStartXfer+0x16a>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 800af74:	eb00 1343 	add.w	r3, r0, r3, lsl #5
 800af78:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 800af7c:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 800af80:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 800af84:	e781      	b.n	800ae8a <USB_EPStartXfer+0x6e>
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 800af86:	f8d0 2808 	ldr.w	r2, [r0, #2056]	; 0x808
 800af8a:	f412 7f80 	tst.w	r2, #256	; 0x100
 800af8e:	d108      	bne.n	800afa2 <USB_EPStartXfer+0x186>
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 800af90:	eb00 1143 	add.w	r1, r0, r3, lsl #5
 800af94:	f8d1 2900 	ldr.w	r2, [r1, #2304]	; 0x900
 800af98:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 800af9c:	f8c1 2900 	str.w	r2, [r1, #2304]	; 0x900
 800afa0:	e7e8      	b.n	800af74 <USB_EPStartXfer+0x158>
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 800afa2:	eb00 1143 	add.w	r1, r0, r3, lsl #5
 800afa6:	f8d1 2900 	ldr.w	r2, [r1, #2304]	; 0x900
 800afaa:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800afae:	f8c1 2900 	str.w	r2, [r1, #2304]	; 0x900
 800afb2:	e7df      	b.n	800af74 <USB_EPStartXfer+0x158>
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 800afb4:	f8d0 4808 	ldr.w	r4, [r0, #2056]	; 0x808
 800afb8:	f414 7f80 	tst.w	r4, #256	; 0x100
 800afbc:	d10c      	bne.n	800afd8 <USB_EPStartXfer+0x1bc>
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 800afbe:	f8d3 4900 	ldr.w	r4, [r3, #2304]	; 0x900
 800afc2:	f044 5400 	orr.w	r4, r4, #536870912	; 0x20000000
 800afc6:	f8c3 4900 	str.w	r4, [r3, #2304]	; 0x900
        (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len, dma);
 800afca:	9200      	str	r2, [sp, #0]
 800afcc:	8a8b      	ldrh	r3, [r1, #20]
 800afce:	780a      	ldrb	r2, [r1, #0]
 800afd0:	68c9      	ldr	r1, [r1, #12]
 800afd2:	f7ff ff0b 	bl	800adec <USB_WritePacket>
 800afd6:	e758      	b.n	800ae8a <USB_EPStartXfer+0x6e>
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 800afd8:	f8d3 4900 	ldr.w	r4, [r3, #2304]	; 0x900
 800afdc:	f044 5480 	orr.w	r4, r4, #268435456	; 0x10000000
 800afe0:	f8c3 4900 	str.w	r4, [r3, #2304]	; 0x900
 800afe4:	e7f1      	b.n	800afca <USB_EPStartXfer+0x1ae>
      pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 800afe6:	688d      	ldr	r5, [r1, #8]
 800afe8:	442c      	add	r4, r5
 800afea:	3c01      	subs	r4, #1
 800afec:	fbb4 f4f5 	udiv	r4, r4, r5
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 800aff0:	f8dc 5010 	ldr.w	r5, [ip, #16]
 800aff4:	fa1f fe84 	uxth.w	lr, r4
 800aff8:	4e15      	ldr	r6, [pc, #84]	; (800b050 <USB_EPStartXfer+0x234>)
 800affa:	ea06 44c4 	and.w	r4, r6, r4, lsl #19
 800affe:	432c      	orrs	r4, r5
 800b000:	f8cc 4010 	str.w	r4, [ip, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt);
 800b004:	f8dc 5010 	ldr.w	r5, [ip, #16]
 800b008:	688c      	ldr	r4, [r1, #8]
 800b00a:	fb0e f404 	mul.w	r4, lr, r4
 800b00e:	f3c4 0412 	ubfx	r4, r4, #0, #19
 800b012:	432c      	orrs	r4, r5
 800b014:	f8cc 4010 	str.w	r4, [ip, #16]
 800b018:	e72a      	b.n	800ae70 <USB_EPStartXfer+0x54>
      if ((uint32_t)ep->xfer_buff != 0U)
 800b01a:	68ca      	ldr	r2, [r1, #12]
 800b01c:	2a00      	cmp	r2, #0
 800b01e:	f43f af2a 	beq.w	800ae76 <USB_EPStartXfer+0x5a>
        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 800b022:	f8cc 2014 	str.w	r2, [ip, #20]
 800b026:	e726      	b.n	800ae76 <USB_EPStartXfer+0x5a>
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 800b028:	f8d0 2808 	ldr.w	r2, [r0, #2056]	; 0x808
 800b02c:	f412 7f80 	tst.w	r2, #256	; 0x100
 800b030:	d106      	bne.n	800b040 <USB_EPStartXfer+0x224>
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 800b032:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 800b036:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 800b03a:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 800b03e:	e71e      	b.n	800ae7e <USB_EPStartXfer+0x62>
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 800b040:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 800b044:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800b048:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 800b04c:	e717      	b.n	800ae7e <USB_EPStartXfer+0x62>
 800b04e:	bf00      	nop
 800b050:	1ff80000 	.word	0x1ff80000

0800b054 <USB_ReadPacket>:
{
 800b054:	4684      	mov	ip, r0
 800b056:	4608      	mov	r0, r1
  uint32_t count32b = ((uint32_t)len + 3U) / 4U;
 800b058:	3203      	adds	r2, #3
 800b05a:	0892      	lsrs	r2, r2, #2
  for (i = 0U; i < count32b; i++)
 800b05c:	2300      	movs	r3, #0
 800b05e:	e005      	b.n	800b06c <USB_ReadPacket+0x18>
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 800b060:	f50c 5180 	add.w	r1, ip, #4096	; 0x1000
 800b064:	6809      	ldr	r1, [r1, #0]
 800b066:	f840 1b04 	str.w	r1, [r0], #4
  for (i = 0U; i < count32b; i++)
 800b06a:	3301      	adds	r3, #1
 800b06c:	4293      	cmp	r3, r2
 800b06e:	d3f7      	bcc.n	800b060 <USB_ReadPacket+0xc>
}
 800b070:	4770      	bx	lr

0800b072 <USB_EPSetStall>:
  uint32_t epnum = (uint32_t)ep->num;
 800b072:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 800b074:	784a      	ldrb	r2, [r1, #1]
 800b076:	2a01      	cmp	r2, #1
 800b078:	d014      	beq.n	800b0a4 <USB_EPSetStall+0x32>
    if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))
 800b07a:	eb00 1043 	add.w	r0, r0, r3, lsl #5
 800b07e:	f8d0 2b00 	ldr.w	r2, [r0, #2816]	; 0xb00
 800b082:	2a00      	cmp	r2, #0
 800b084:	db06      	blt.n	800b094 <USB_EPSetStall+0x22>
 800b086:	b12b      	cbz	r3, 800b094 <USB_EPSetStall+0x22>
      USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
 800b088:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 800b08c:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 800b090:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
    USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 800b094:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 800b098:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800b09c:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
}
 800b0a0:	2000      	movs	r0, #0
 800b0a2:	4770      	bx	lr
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 800b0a4:	eb00 1043 	add.w	r0, r0, r3, lsl #5
 800b0a8:	f8d0 2900 	ldr.w	r2, [r0, #2304]	; 0x900
 800b0ac:	2a00      	cmp	r2, #0
 800b0ae:	db06      	blt.n	800b0be <USB_EPSetStall+0x4c>
 800b0b0:	b12b      	cbz	r3, 800b0be <USB_EPSetStall+0x4c>
      USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);
 800b0b2:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 800b0b6:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 800b0ba:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 800b0be:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 800b0c2:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800b0c6:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
 800b0ca:	e7e9      	b.n	800b0a0 <USB_EPSetStall+0x2e>

0800b0cc <USB_EPClearStall>:
  uint32_t epnum = (uint32_t)ep->num;
 800b0cc:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 800b0ce:	784a      	ldrb	r2, [r1, #1]
 800b0d0:	2a01      	cmp	r2, #1
 800b0d2:	d00e      	beq.n	800b0f2 <USB_EPClearStall+0x26>
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 800b0d4:	eb00 1043 	add.w	r0, r0, r3, lsl #5
 800b0d8:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 800b0dc:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800b0e0:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 800b0e4:	78cb      	ldrb	r3, [r1, #3]
 800b0e6:	3b02      	subs	r3, #2
 800b0e8:	b2db      	uxtb	r3, r3
 800b0ea:	2b01      	cmp	r3, #1
 800b0ec:	d915      	bls.n	800b11a <USB_EPClearStall+0x4e>
}
 800b0ee:	2000      	movs	r0, #0
 800b0f0:	4770      	bx	lr
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 800b0f2:	eb00 1043 	add.w	r0, r0, r3, lsl #5
 800b0f6:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 800b0fa:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800b0fe:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 800b102:	78cb      	ldrb	r3, [r1, #3]
 800b104:	3b02      	subs	r3, #2
 800b106:	b2db      	uxtb	r3, r3
 800b108:	2b01      	cmp	r3, #1
 800b10a:	d8f0      	bhi.n	800b0ee <USB_EPClearStall+0x22>
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 800b10c:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 800b110:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800b114:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
 800b118:	e7e9      	b.n	800b0ee <USB_EPClearStall+0x22>
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 800b11a:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 800b11e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800b122:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
 800b126:	e7e2      	b.n	800b0ee <USB_EPClearStall+0x22>

0800b128 <USB_SetDevAddress>:
  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
 800b128:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 800b12c:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 800b130:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 800b134:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 800b138:	0109      	lsls	r1, r1, #4
 800b13a:	f401 61fe 	and.w	r1, r1, #2032	; 0x7f0
 800b13e:	430b      	orrs	r3, r1
 800b140:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
}
 800b144:	2000      	movs	r0, #0
 800b146:	4770      	bx	lr

0800b148 <USB_DevConnect>:
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 800b148:	f8d0 3e00 	ldr.w	r3, [r0, #3584]	; 0xe00
 800b14c:	f023 0303 	bic.w	r3, r3, #3
 800b150:	f8c0 3e00 	str.w	r3, [r0, #3584]	; 0xe00
  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
 800b154:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 800b158:	f023 0302 	bic.w	r3, r3, #2
 800b15c:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
}
 800b160:	2000      	movs	r0, #0
 800b162:	4770      	bx	lr

0800b164 <USB_DevDisconnect>:
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 800b164:	f8d0 3e00 	ldr.w	r3, [r0, #3584]	; 0xe00
 800b168:	f023 0303 	bic.w	r3, r3, #3
 800b16c:	f8c0 3e00 	str.w	r3, [r0, #3584]	; 0xe00
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 800b170:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 800b174:	f043 0302 	orr.w	r3, r3, #2
 800b178:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
}
 800b17c:	2000      	movs	r0, #0
 800b17e:	4770      	bx	lr

0800b180 <USB_ReadInterrupts>:
  tmpreg = USBx->GINTSTS;
 800b180:	6942      	ldr	r2, [r0, #20]
  tmpreg &= USBx->GINTMSK;
 800b182:	6980      	ldr	r0, [r0, #24]
}
 800b184:	4010      	ands	r0, r2
 800b186:	4770      	bx	lr

0800b188 <USB_ReadDevAllOutEpInterrupt>:
  tmpreg  = USBx_DEVICE->DAINT;
 800b188:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 800b18c:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  tmpreg &= USBx_DEVICE->DAINTMSK;
 800b190:	69c0      	ldr	r0, [r0, #28]
 800b192:	4018      	ands	r0, r3
}
 800b194:	0c00      	lsrs	r0, r0, #16
 800b196:	4770      	bx	lr

0800b198 <USB_ReadDevAllInEpInterrupt>:
  tmpreg  = USBx_DEVICE->DAINT;
 800b198:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 800b19c:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  tmpreg &= USBx_DEVICE->DAINTMSK;
 800b1a0:	69c0      	ldr	r0, [r0, #28]
 800b1a2:	4018      	ands	r0, r3
}
 800b1a4:	b280      	uxth	r0, r0
 800b1a6:	4770      	bx	lr

0800b1a8 <USB_ReadDevOutEPInterrupt>:
  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 800b1a8:	eb00 1141 	add.w	r1, r0, r1, lsl #5
 800b1ac:	f8d1 2b08 	ldr.w	r2, [r1, #2824]	; 0xb08
  tmpreg &= USBx_DEVICE->DOEPMSK;
 800b1b0:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 800b1b4:	6940      	ldr	r0, [r0, #20]
}
 800b1b6:	4010      	ands	r0, r2
 800b1b8:	4770      	bx	lr

0800b1ba <USB_ReadDevInEPInterrupt>:
  msk = USBx_DEVICE->DIEPMSK;
 800b1ba:	f8d0 2810 	ldr.w	r2, [r0, #2064]	; 0x810
  emp = USBx_DEVICE->DIEPEMPMSK;
 800b1be:	f8d0 3834 	ldr.w	r3, [r0, #2100]	; 0x834
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 800b1c2:	f001 0c0f 	and.w	ip, r1, #15
 800b1c6:	fa23 f30c 	lsr.w	r3, r3, ip
 800b1ca:	01db      	lsls	r3, r3, #7
 800b1cc:	b2db      	uxtb	r3, r3
 800b1ce:	4313      	orrs	r3, r2
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 800b1d0:	eb00 1041 	add.w	r0, r0, r1, lsl #5
 800b1d4:	f500 6010 	add.w	r0, r0, #2304	; 0x900
 800b1d8:	6880      	ldr	r0, [r0, #8]
}
 800b1da:	4018      	ands	r0, r3
 800b1dc:	4770      	bx	lr

0800b1de <USB_GetMode>:
  return ((USBx->GINTSTS) & 0x1U);
 800b1de:	6940      	ldr	r0, [r0, #20]
}
 800b1e0:	f000 0001 	and.w	r0, r0, #1
 800b1e4:	4770      	bx	lr

0800b1e6 <USB_ActivateSetup>:
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 800b1e6:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 800b1ea:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 800b1ee:	f023 0307 	bic.w	r3, r3, #7
 800b1f2:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 800b1f6:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 800b1fa:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800b1fe:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
}
 800b202:	2000      	movs	r0, #0
 800b204:	4770      	bx	lr
	...

0800b208 <USB_EP0_OutStart>:
{
 800b208:	b410      	push	{r4}
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 800b20a:	6c04      	ldr	r4, [r0, #64]	; 0x40
  if (gSNPSiD > USB_OTG_CORE_ID_300A)
 800b20c:	4b15      	ldr	r3, [pc, #84]	; (800b264 <USB_EP0_OutStart+0x5c>)
 800b20e:	429c      	cmp	r4, r3
 800b210:	d903      	bls.n	800b21a <USB_EP0_OutStart+0x12>
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 800b212:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 800b216:	2b00      	cmp	r3, #0
 800b218:	db16      	blt.n	800b248 <USB_EP0_OutStart+0x40>
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 800b21a:	2400      	movs	r4, #0
 800b21c:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 800b220:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
 800b224:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 800b228:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 800b22c:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
 800b230:	f044 0418 	orr.w	r4, r4, #24
 800b234:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
 800b238:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
 800b23c:	f044 44c0 	orr.w	r4, r4, #1610612736	; 0x60000000
 800b240:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  if (dma == 1U)
 800b244:	2901      	cmp	r1, #1
 800b246:	d003      	beq.n	800b250 <USB_EP0_OutStart+0x48>
}
 800b248:	2000      	movs	r0, #0
 800b24a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800b24e:	4770      	bx	lr
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
 800b250:	f8c0 2b14 	str.w	r2, [r0, #2836]	; 0xb14
    USBx_OUTEP(0U)->DOEPCTL |= USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_USBAEP;
 800b254:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 800b258:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 800b25c:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
 800b260:	e7f2      	b.n	800b248 <USB_EP0_OutStart+0x40>
 800b262:	bf00      	nop
 800b264:	4f54300a 	.word	0x4f54300a

0800b268 <USBD_CDC_EP0_RxReady>:
  *         Handle EP0 Rx Ready event
  * @param  pdev: device instance
  * @retval status
  */
static uint8_t USBD_CDC_EP0_RxReady(USBD_HandleTypeDef *pdev)
{
 800b268:	b510      	push	{r4, lr}
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 800b26a:	f8d0 42bc 	ldr.w	r4, [r0, #700]	; 0x2bc

  if ((pdev->pUserData != NULL) && (hcdc->CmdOpCode != 0xFFU))
 800b26e:	f8d0 32c0 	ldr.w	r3, [r0, #704]	; 0x2c0
 800b272:	b15b      	cbz	r3, 800b28c <USBD_CDC_EP0_RxReady+0x24>
 800b274:	f894 0200 	ldrb.w	r0, [r4, #512]	; 0x200
 800b278:	28ff      	cmp	r0, #255	; 0xff
 800b27a:	d007      	beq.n	800b28c <USBD_CDC_EP0_RxReady+0x24>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(hcdc->CmdOpCode,
 800b27c:	689b      	ldr	r3, [r3, #8]
 800b27e:	f894 2201 	ldrb.w	r2, [r4, #513]	; 0x201
 800b282:	4621      	mov	r1, r4
 800b284:	4798      	blx	r3
                                                      (uint8_t *)hcdc->data,
                                                      (uint16_t)hcdc->CmdLength);
    hcdc->CmdOpCode = 0xFFU;
 800b286:	23ff      	movs	r3, #255	; 0xff
 800b288:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200

  }

  return (uint8_t)USBD_OK;
}
 800b28c:	2000      	movs	r0, #0
 800b28e:	bd10      	pop	{r4, pc}

0800b290 <USBD_CDC_GetFSCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetFSCfgDesc(uint16_t *length)
{
  *length = (uint16_t)sizeof(USBD_CDC_CfgFSDesc);
 800b290:	2343      	movs	r3, #67	; 0x43
 800b292:	8003      	strh	r3, [r0, #0]

  return USBD_CDC_CfgFSDesc;
}
 800b294:	4800      	ldr	r0, [pc, #0]	; (800b298 <USBD_CDC_GetFSCfgDesc+0x8>)
 800b296:	4770      	bx	lr
 800b298:	20000040 	.word	0x20000040

0800b29c <USBD_CDC_GetHSCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetHSCfgDesc(uint16_t *length)
{
  *length = (uint16_t)sizeof(USBD_CDC_CfgHSDesc);
 800b29c:	2343      	movs	r3, #67	; 0x43
 800b29e:	8003      	strh	r3, [r0, #0]

  return USBD_CDC_CfgHSDesc;
}
 800b2a0:	4800      	ldr	r0, [pc, #0]	; (800b2a4 <USBD_CDC_GetHSCfgDesc+0x8>)
 800b2a2:	4770      	bx	lr
 800b2a4:	20000084 	.word	0x20000084

0800b2a8 <USBD_CDC_GetOtherSpeedCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetOtherSpeedCfgDesc(uint16_t *length)
{
  *length = (uint16_t)sizeof(USBD_CDC_OtherSpeedCfgDesc);
 800b2a8:	2343      	movs	r3, #67	; 0x43
 800b2aa:	8003      	strh	r3, [r0, #0]

  return USBD_CDC_OtherSpeedCfgDesc;
}
 800b2ac:	4800      	ldr	r0, [pc, #0]	; (800b2b0 <USBD_CDC_GetOtherSpeedCfgDesc+0x8>)
 800b2ae:	4770      	bx	lr
 800b2b0:	200000d4 	.word	0x200000d4

0800b2b4 <USBD_CDC_GetDeviceQualifierDescriptor>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t *USBD_CDC_GetDeviceQualifierDescriptor(uint16_t *length)
{
  *length = (uint16_t)sizeof(USBD_CDC_DeviceQualifierDesc);
 800b2b4:	230a      	movs	r3, #10
 800b2b6:	8003      	strh	r3, [r0, #0]

  return USBD_CDC_DeviceQualifierDesc;
}
 800b2b8:	4800      	ldr	r0, [pc, #0]	; (800b2bc <USBD_CDC_GetDeviceQualifierDescriptor+0x8>)
 800b2ba:	4770      	bx	lr
 800b2bc:	200000c8 	.word	0x200000c8

0800b2c0 <USBD_CDC_DataOut>:
{
 800b2c0:	b538      	push	{r3, r4, r5, lr}
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 800b2c2:	f8d0 52bc 	ldr.w	r5, [r0, #700]	; 0x2bc
  if (pdev->pClassData == NULL)
 800b2c6:	b175      	cbz	r5, 800b2e6 <USBD_CDC_DataOut+0x26>
 800b2c8:	4604      	mov	r4, r0
  hcdc->RxLength = USBD_LL_GetRxDataSize(pdev, epnum);
 800b2ca:	f003 fd30 	bl	800ed2e <USBD_LL_GetRxDataSize>
 800b2ce:	f8c5 020c 	str.w	r0, [r5, #524]	; 0x20c
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Receive(hcdc->RxBuffer, &hcdc->RxLength);
 800b2d2:	f8d4 32c0 	ldr.w	r3, [r4, #704]	; 0x2c0
 800b2d6:	68db      	ldr	r3, [r3, #12]
 800b2d8:	f505 7103 	add.w	r1, r5, #524	; 0x20c
 800b2dc:	f8d5 0204 	ldr.w	r0, [r5, #516]	; 0x204
 800b2e0:	4798      	blx	r3
  return (uint8_t)USBD_OK;
 800b2e2:	2000      	movs	r0, #0
}
 800b2e4:	bd38      	pop	{r3, r4, r5, pc}
    return (uint8_t)USBD_FAIL;
 800b2e6:	2003      	movs	r0, #3
 800b2e8:	e7fc      	b.n	800b2e4 <USBD_CDC_DataOut+0x24>

0800b2ea <USBD_CDC_DataIn>:
{
 800b2ea:	b538      	push	{r3, r4, r5, lr}
  PCD_HandleTypeDef *hpcd = pdev->pData;
 800b2ec:	f8d0 42c4 	ldr.w	r4, [r0, #708]	; 0x2c4
  if (pdev->pClassData == NULL)
 800b2f0:	f8d0 32bc 	ldr.w	r3, [r0, #700]	; 0x2bc
 800b2f4:	b34b      	cbz	r3, 800b34a <USBD_CDC_DataIn+0x60>
  if ((pdev->ep_in[epnum].total_length > 0U) &&
 800b2f6:	eb01 0281 	add.w	r2, r1, r1, lsl #2
 800b2fa:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 800b2fe:	6992      	ldr	r2, [r2, #24]
 800b300:	b14a      	cbz	r2, 800b316 <USBD_CDC_DataIn+0x2c>
      ((pdev->ep_in[epnum].total_length % hpcd->IN_ep[epnum].maxpacket) == 0U))
 800b302:	ebc1 05c1 	rsb	r5, r1, r1, lsl #3
 800b306:	eb04 0485 	add.w	r4, r4, r5, lsl #2
 800b30a:	6c64      	ldr	r4, [r4, #68]	; 0x44
 800b30c:	fbb2 f5f4 	udiv	r5, r2, r4
 800b310:	fb04 2215 	mls	r2, r4, r5, r2
  if ((pdev->ep_in[epnum].total_length > 0U) &&
 800b314:	b16a      	cbz	r2, 800b332 <USBD_CDC_DataIn+0x48>
    hcdc->TxState = 0U;
 800b316:	2400      	movs	r4, #0
 800b318:	f8c3 4214 	str.w	r4, [r3, #532]	; 0x214
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->TransmitCplt(hcdc->TxBuffer, &hcdc->TxLength, epnum);
 800b31c:	f8d0 22c0 	ldr.w	r2, [r0, #704]	; 0x2c0
 800b320:	6915      	ldr	r5, [r2, #16]
 800b322:	460a      	mov	r2, r1
 800b324:	f503 7104 	add.w	r1, r3, #528	; 0x210
 800b328:	f8d3 0208 	ldr.w	r0, [r3, #520]	; 0x208
 800b32c:	47a8      	blx	r5
  return (uint8_t)USBD_OK;
 800b32e:	4620      	mov	r0, r4
}
 800b330:	bd38      	pop	{r3, r4, r5, pc}
    pdev->ep_in[epnum].total_length = 0U;
 800b332:	eb01 0381 	add.w	r3, r1, r1, lsl #2
 800b336:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800b33a:	2400      	movs	r4, #0
 800b33c:	619c      	str	r4, [r3, #24]
    (void)USBD_LL_Transmit(pdev, epnum, NULL, 0U);
 800b33e:	4623      	mov	r3, r4
 800b340:	4622      	mov	r2, r4
 800b342:	f003 fd37 	bl	800edb4 <USBD_LL_Transmit>
  return (uint8_t)USBD_OK;
 800b346:	4620      	mov	r0, r4
    (void)USBD_LL_Transmit(pdev, epnum, NULL, 0U);
 800b348:	e7f2      	b.n	800b330 <USBD_CDC_DataIn+0x46>
    return (uint8_t)USBD_FAIL;
 800b34a:	2003      	movs	r0, #3
 800b34c:	e7f0      	b.n	800b330 <USBD_CDC_DataIn+0x46>

0800b34e <USBD_CDC_Setup>:
{
 800b34e:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b350:	b083      	sub	sp, #12
 800b352:	4606      	mov	r6, r0
 800b354:	460c      	mov	r4, r1
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 800b356:	f8d0 72bc 	ldr.w	r7, [r0, #700]	; 0x2bc
  uint8_t ifalt = 0U;
 800b35a:	2300      	movs	r3, #0
 800b35c:	f88d 3007 	strb.w	r3, [sp, #7]
  uint16_t status_info = 0U;
 800b360:	f8ad 3004 	strh.w	r3, [sp, #4]
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800b364:	780b      	ldrb	r3, [r1, #0]
 800b366:	f013 0560 	ands.w	r5, r3, #96	; 0x60
 800b36a:	d027      	beq.n	800b3bc <USBD_CDC_Setup+0x6e>
 800b36c:	2d20      	cmp	r5, #32
 800b36e:	d158      	bne.n	800b422 <USBD_CDC_Setup+0xd4>
    if (req->wLength != 0U)
 800b370:	88ca      	ldrh	r2, [r1, #6]
 800b372:	b1da      	cbz	r2, 800b3ac <USBD_CDC_Setup+0x5e>
      if ((req->bmRequest & 0x80U) != 0U)
 800b374:	f013 0f80 	tst.w	r3, #128	; 0x80
 800b378:	d00c      	beq.n	800b394 <USBD_CDC_Setup+0x46>
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 800b37a:	f8d0 32c0 	ldr.w	r3, [r0, #704]	; 0x2c0
 800b37e:	689b      	ldr	r3, [r3, #8]
 800b380:	4639      	mov	r1, r7
 800b382:	7860      	ldrb	r0, [r4, #1]
 800b384:	4798      	blx	r3
          (void)USBD_CtlSendData(pdev, (uint8_t *)hcdc->data, req->wLength);
 800b386:	88e2      	ldrh	r2, [r4, #6]
 800b388:	4639      	mov	r1, r7
 800b38a:	4630      	mov	r0, r6
 800b38c:	f000 fdd1 	bl	800bf32 <USBD_CtlSendData>
  USBD_StatusTypeDef ret = USBD_OK;
 800b390:	2500      	movs	r5, #0
 800b392:	e049      	b.n	800b428 <USBD_CDC_Setup+0xda>
        hcdc->CmdOpCode = req->bRequest;
 800b394:	784b      	ldrb	r3, [r1, #1]
 800b396:	f887 3200 	strb.w	r3, [r7, #512]	; 0x200
        hcdc->CmdLength = (uint8_t)req->wLength;
 800b39a:	798b      	ldrb	r3, [r1, #6]
 800b39c:	f887 3201 	strb.w	r3, [r7, #513]	; 0x201
        (void)USBD_CtlPrepareRx(pdev, (uint8_t *)hcdc->data, req->wLength);
 800b3a0:	88ca      	ldrh	r2, [r1, #6]
 800b3a2:	4639      	mov	r1, r7
 800b3a4:	f000 fdda 	bl	800bf5c <USBD_CtlPrepareRx>
  USBD_StatusTypeDef ret = USBD_OK;
 800b3a8:	2500      	movs	r5, #0
 800b3aa:	e03d      	b.n	800b428 <USBD_CDC_Setup+0xda>
      ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 800b3ac:	f8d0 32c0 	ldr.w	r3, [r0, #704]	; 0x2c0
 800b3b0:	689b      	ldr	r3, [r3, #8]
 800b3b2:	2200      	movs	r2, #0
 800b3b4:	7848      	ldrb	r0, [r1, #1]
 800b3b6:	4798      	blx	r3
  USBD_StatusTypeDef ret = USBD_OK;
 800b3b8:	2500      	movs	r5, #0
 800b3ba:	e035      	b.n	800b428 <USBD_CDC_Setup+0xda>
    switch (req->bRequest)
 800b3bc:	784f      	ldrb	r7, [r1, #1]
 800b3be:	2f0b      	cmp	r7, #11
 800b3c0:	d82b      	bhi.n	800b41a <USBD_CDC_Setup+0xcc>
 800b3c2:	e8df f007 	tbb	[pc, r7]
 800b3c6:	3106      	.short	0x3106
 800b3c8:	2a2a2a2a 	.word	0x2a2a2a2a
 800b3cc:	2a2a2a2a 	.word	0x2a2a2a2a
 800b3d0:	2214      	.short	0x2214
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800b3d2:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800b3d6:	2b03      	cmp	r3, #3
 800b3d8:	d003      	beq.n	800b3e2 <USBD_CDC_Setup+0x94>
        USBD_CtlError(pdev, req);
 800b3da:	f000 fa89 	bl	800b8f0 <USBD_CtlError>
        ret = USBD_FAIL;
 800b3de:	2503      	movs	r5, #3
 800b3e0:	e022      	b.n	800b428 <USBD_CDC_Setup+0xda>
        (void)USBD_CtlSendData(pdev, (uint8_t *)&status_info, 2U);
 800b3e2:	2202      	movs	r2, #2
 800b3e4:	a901      	add	r1, sp, #4
 800b3e6:	f000 fda4 	bl	800bf32 <USBD_CtlSendData>
  USBD_StatusTypeDef ret = USBD_OK;
 800b3ea:	463d      	mov	r5, r7
 800b3ec:	e01c      	b.n	800b428 <USBD_CDC_Setup+0xda>
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800b3ee:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800b3f2:	2b03      	cmp	r3, #3
 800b3f4:	d003      	beq.n	800b3fe <USBD_CDC_Setup+0xb0>
        USBD_CtlError(pdev, req);
 800b3f6:	f000 fa7b 	bl	800b8f0 <USBD_CtlError>
        ret = USBD_FAIL;
 800b3fa:	2503      	movs	r5, #3
 800b3fc:	e014      	b.n	800b428 <USBD_CDC_Setup+0xda>
        (void)USBD_CtlSendData(pdev, &ifalt, 1U);
 800b3fe:	2201      	movs	r2, #1
 800b400:	f10d 0107 	add.w	r1, sp, #7
 800b404:	f000 fd95 	bl	800bf32 <USBD_CtlSendData>
 800b408:	e00e      	b.n	800b428 <USBD_CDC_Setup+0xda>
      if (pdev->dev_state != USBD_STATE_CONFIGURED)
 800b40a:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800b40e:	2b03      	cmp	r3, #3
 800b410:	d00a      	beq.n	800b428 <USBD_CDC_Setup+0xda>
        USBD_CtlError(pdev, req);
 800b412:	f000 fa6d 	bl	800b8f0 <USBD_CtlError>
        ret = USBD_FAIL;
 800b416:	2503      	movs	r5, #3
 800b418:	e006      	b.n	800b428 <USBD_CDC_Setup+0xda>
      USBD_CtlError(pdev, req);
 800b41a:	f000 fa69 	bl	800b8f0 <USBD_CtlError>
      ret = USBD_FAIL;
 800b41e:	2503      	movs	r5, #3
      break;
 800b420:	e002      	b.n	800b428 <USBD_CDC_Setup+0xda>
    USBD_CtlError(pdev, req);
 800b422:	f000 fa65 	bl	800b8f0 <USBD_CtlError>
    ret = USBD_FAIL;
 800b426:	2503      	movs	r5, #3
}
 800b428:	4628      	mov	r0, r5
 800b42a:	b003      	add	sp, #12
 800b42c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800b42e <USBD_CDC_DeInit>:
{
 800b42e:	b538      	push	{r3, r4, r5, lr}
 800b430:	4604      	mov	r4, r0
  (void)USBD_LL_CloseEP(pdev, CDC_IN_EP);
 800b432:	2181      	movs	r1, #129	; 0x81
 800b434:	f003 fc9e 	bl	800ed74 <USBD_LL_CloseEP>
  pdev->ep_in[CDC_IN_EP & 0xFU].is_used = 0U;
 800b438:	2500      	movs	r5, #0
 800b43a:	8725      	strh	r5, [r4, #56]	; 0x38
  (void)USBD_LL_CloseEP(pdev, CDC_OUT_EP);
 800b43c:	2101      	movs	r1, #1
 800b43e:	4620      	mov	r0, r4
 800b440:	f003 fc98 	bl	800ed74 <USBD_LL_CloseEP>
  pdev->ep_out[CDC_OUT_EP & 0xFU].is_used = 0U;
 800b444:	f8a4 5178 	strh.w	r5, [r4, #376]	; 0x178
  (void)USBD_LL_CloseEP(pdev, CDC_CMD_EP);
 800b448:	2182      	movs	r1, #130	; 0x82
 800b44a:	4620      	mov	r0, r4
 800b44c:	f003 fc92 	bl	800ed74 <USBD_LL_CloseEP>
  pdev->ep_in[CDC_CMD_EP & 0xFU].is_used = 0U;
 800b450:	f8a4 504c 	strh.w	r5, [r4, #76]	; 0x4c
  pdev->ep_in[CDC_CMD_EP & 0xFU].bInterval = 0U;
 800b454:	f8a4 504e 	strh.w	r5, [r4, #78]	; 0x4e
  if (pdev->pClassData != NULL)
 800b458:	f8d4 32bc 	ldr.w	r3, [r4, #700]	; 0x2bc
 800b45c:	b14b      	cbz	r3, 800b472 <USBD_CDC_DeInit+0x44>
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->DeInit();
 800b45e:	f8d4 32c0 	ldr.w	r3, [r4, #704]	; 0x2c0
 800b462:	685b      	ldr	r3, [r3, #4]
 800b464:	4798      	blx	r3
    (void)USBD_free(pdev->pClassData);
 800b466:	f8d4 02bc 	ldr.w	r0, [r4, #700]	; 0x2bc
 800b46a:	f017 f829 	bl	80224c0 <free>
    pdev->pClassData = NULL;
 800b46e:	f8c4 52bc 	str.w	r5, [r4, #700]	; 0x2bc
}
 800b472:	2000      	movs	r0, #0
 800b474:	bd38      	pop	{r3, r4, r5, pc}

0800b476 <USBD_CDC_Init>:
{
 800b476:	b570      	push	{r4, r5, r6, lr}
 800b478:	4604      	mov	r4, r0
  hcdc = USBD_malloc(sizeof(USBD_CDC_HandleTypeDef));
 800b47a:	f44f 7007 	mov.w	r0, #540	; 0x21c
 800b47e:	f017 f817 	bl	80224b0 <malloc>
  if (hcdc == NULL)
 800b482:	2800      	cmp	r0, #0
 800b484:	d03c      	beq.n	800b500 <USBD_CDC_Init+0x8a>
 800b486:	4606      	mov	r6, r0
  pdev->pClassData = (void *)hcdc;
 800b488:	f8c4 02bc 	str.w	r0, [r4, #700]	; 0x2bc
  memset(pdev->pClassData,0,sizeof(USBD_CDC_HandleTypeDef)); // THIS LINE WAS ADDED
 800b48c:	f44f 7207 	mov.w	r2, #540	; 0x21c
 800b490:	2100      	movs	r1, #0
 800b492:	f017 fb70 	bl	8022b76 <memset>
  if (pdev->dev_speed == USBD_SPEED_HIGH)
 800b496:	7c23      	ldrb	r3, [r4, #16]
 800b498:	bbbb      	cbnz	r3, 800b50a <USBD_CDC_Init+0x94>
    (void)USBD_LL_OpenEP(pdev, CDC_IN_EP, USBD_EP_TYPE_BULK,
 800b49a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800b49e:	2202      	movs	r2, #2
 800b4a0:	2181      	movs	r1, #129	; 0x81
 800b4a2:	4620      	mov	r0, r4
 800b4a4:	f003 fc5b 	bl	800ed5e <USBD_LL_OpenEP>
     pdev->ep_in[CDC_IN_EP & 0xFU].is_used = 1U;
 800b4a8:	2501      	movs	r5, #1
 800b4aa:	8725      	strh	r5, [r4, #56]	; 0x38
     (void)USBD_LL_OpenEP(pdev, CDC_OUT_EP, USBD_EP_TYPE_BULK,
 800b4ac:	f44f 7300 	mov.w	r3, #512	; 0x200
 800b4b0:	2202      	movs	r2, #2
 800b4b2:	4629      	mov	r1, r5
 800b4b4:	4620      	mov	r0, r4
 800b4b6:	f003 fc52 	bl	800ed5e <USBD_LL_OpenEP>
      pdev->ep_out[CDC_OUT_EP & 0xFU].is_used = 1U;
 800b4ba:	f8a4 5178 	strh.w	r5, [r4, #376]	; 0x178
      pdev->ep_in[CDC_CMD_EP & 0xFU].bInterval = CDC_HS_BINTERVAL;
 800b4be:	2310      	movs	r3, #16
 800b4c0:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
  (void)USBD_LL_OpenEP(pdev, CDC_CMD_EP, USBD_EP_TYPE_INTR, CDC_CMD_PACKET_SIZE);
 800b4c4:	2308      	movs	r3, #8
 800b4c6:	2203      	movs	r2, #3
 800b4c8:	2182      	movs	r1, #130	; 0x82
 800b4ca:	4620      	mov	r0, r4
 800b4cc:	f003 fc47 	bl	800ed5e <USBD_LL_OpenEP>
  pdev->ep_in[CDC_CMD_EP & 0xFU].is_used = 1U;
 800b4d0:	2301      	movs	r3, #1
 800b4d2:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Init();
 800b4d6:	f8d4 32c0 	ldr.w	r3, [r4, #704]	; 0x2c0
 800b4da:	681b      	ldr	r3, [r3, #0]
 800b4dc:	4798      	blx	r3
  hcdc->TxState = 0U;
 800b4de:	2300      	movs	r3, #0
 800b4e0:	f8c6 3214 	str.w	r3, [r6, #532]	; 0x214
  hcdc->RxState = 0U;
 800b4e4:	f8c6 3218 	str.w	r3, [r6, #536]	; 0x218
  if (pdev->dev_speed == USBD_SPEED_HIGH)
 800b4e8:	7c25      	ldrb	r5, [r4, #16]
 800b4ea:	bb15      	cbnz	r5, 800b532 <USBD_CDC_Init+0xbc>
    (void)USBD_LL_PrepareReceive(pdev, CDC_OUT_EP, hcdc->RxBuffer,
 800b4ec:	f44f 7300 	mov.w	r3, #512	; 0x200
 800b4f0:	f8d6 2204 	ldr.w	r2, [r6, #516]	; 0x204
 800b4f4:	2101      	movs	r1, #1
 800b4f6:	4620      	mov	r0, r4
 800b4f8:	f003 fc64 	bl	800edc4 <USBD_LL_PrepareReceive>
}
 800b4fc:	4628      	mov	r0, r5
 800b4fe:	bd70      	pop	{r4, r5, r6, pc}
    pdev->pClassData = NULL;
 800b500:	2300      	movs	r3, #0
 800b502:	f8c4 32bc 	str.w	r3, [r4, #700]	; 0x2bc
    return (uint8_t)USBD_EMEM;
 800b506:	2502      	movs	r5, #2
 800b508:	e7f8      	b.n	800b4fc <USBD_CDC_Init+0x86>
    (void)USBD_LL_OpenEP(pdev, CDC_IN_EP, USBD_EP_TYPE_BULK,
 800b50a:	2340      	movs	r3, #64	; 0x40
 800b50c:	2202      	movs	r2, #2
 800b50e:	2181      	movs	r1, #129	; 0x81
 800b510:	4620      	mov	r0, r4
 800b512:	f003 fc24 	bl	800ed5e <USBD_LL_OpenEP>
     pdev->ep_in[CDC_IN_EP & 0xFU].is_used = 1U;
 800b516:	2501      	movs	r5, #1
 800b518:	8725      	strh	r5, [r4, #56]	; 0x38
     (void)USBD_LL_OpenEP(pdev, CDC_OUT_EP, USBD_EP_TYPE_BULK,
 800b51a:	2340      	movs	r3, #64	; 0x40
 800b51c:	2202      	movs	r2, #2
 800b51e:	4629      	mov	r1, r5
 800b520:	4620      	mov	r0, r4
 800b522:	f003 fc1c 	bl	800ed5e <USBD_LL_OpenEP>
      pdev->ep_out[CDC_OUT_EP & 0xFU].is_used = 1U;
 800b526:	f8a4 5178 	strh.w	r5, [r4, #376]	; 0x178
      pdev->ep_in[CDC_CMD_EP & 0xFU].bInterval = CDC_FS_BINTERVAL;
 800b52a:	2310      	movs	r3, #16
 800b52c:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
 800b530:	e7c8      	b.n	800b4c4 <USBD_CDC_Init+0x4e>
    (void)USBD_LL_PrepareReceive(pdev, CDC_OUT_EP, hcdc->RxBuffer,
 800b532:	2340      	movs	r3, #64	; 0x40
 800b534:	f8d6 2204 	ldr.w	r2, [r6, #516]	; 0x204
 800b538:	2101      	movs	r1, #1
 800b53a:	4620      	mov	r0, r4
 800b53c:	f003 fc42 	bl	800edc4 <USBD_LL_PrepareReceive>
  return (uint8_t)USBD_OK;
 800b540:	2500      	movs	r5, #0
 800b542:	e7db      	b.n	800b4fc <USBD_CDC_Init+0x86>

0800b544 <USBD_CDC_RegisterInterface>:
  * @retval status
  */
uint8_t USBD_CDC_RegisterInterface(USBD_HandleTypeDef *pdev,
                                   USBD_CDC_ItfTypeDef *fops)
{
  if (fops == NULL)
 800b544:	b119      	cbz	r1, 800b54e <USBD_CDC_RegisterInterface+0xa>
  {
    return (uint8_t)USBD_FAIL;
  }

  pdev->pUserData = fops;
 800b546:	f8c0 12c0 	str.w	r1, [r0, #704]	; 0x2c0

  return (uint8_t)USBD_OK;
 800b54a:	2000      	movs	r0, #0
 800b54c:	4770      	bx	lr
    return (uint8_t)USBD_FAIL;
 800b54e:	2003      	movs	r0, #3
}
 800b550:	4770      	bx	lr

0800b552 <USBD_CDC_SetTxBuffer>:
  * @retval status
  */
uint8_t USBD_CDC_SetTxBuffer(USBD_HandleTypeDef *pdev,
                             uint8_t *pbuff, uint32_t length)
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 800b552:	f8d0 32bc 	ldr.w	r3, [r0, #700]	; 0x2bc

  hcdc->TxBuffer = pbuff;
 800b556:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
  hcdc->TxLength = length;
 800b55a:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210

  return (uint8_t)USBD_OK;
}
 800b55e:	2000      	movs	r0, #0
 800b560:	4770      	bx	lr

0800b562 <USBD_CDC_SetRxBuffer>:
  * @param  pbuff: Rx Buffer
  * @retval status
  */
uint8_t USBD_CDC_SetRxBuffer(USBD_HandleTypeDef *pdev, uint8_t *pbuff)
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 800b562:	f8d0 32bc 	ldr.w	r3, [r0, #700]	; 0x2bc

  hcdc->RxBuffer = pbuff;
 800b566:	f8c3 1204 	str.w	r1, [r3, #516]	; 0x204

  return (uint8_t)USBD_OK;
}
 800b56a:	2000      	movs	r0, #0
 800b56c:	4770      	bx	lr

0800b56e <USBD_CDC_TransmitPacket>:
  * @param  pdev: device instance
  * @retval status
  */
uint8_t USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev)
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 800b56e:	f8d0 22bc 	ldr.w	r2, [r0, #700]	; 0x2bc
  USBD_StatusTypeDef ret = USBD_BUSY;

  if (pdev->pClassData == NULL)
 800b572:	b1a2      	cbz	r2, 800b59e <USBD_CDC_TransmitPacket+0x30>
{
 800b574:	b508      	push	{r3, lr}
  {
    return (uint8_t)USBD_FAIL;
  }

  if (hcdc->TxState == 0U)
 800b576:	f8d2 3214 	ldr.w	r3, [r2, #532]	; 0x214
 800b57a:	b10b      	cbz	r3, 800b580 <USBD_CDC_TransmitPacket+0x12>
  USBD_StatusTypeDef ret = USBD_BUSY;
 800b57c:	2001      	movs	r0, #1

    ret = USBD_OK;
  }

  return (uint8_t)ret;
}
 800b57e:	bd08      	pop	{r3, pc}
    hcdc->TxState = 1U;
 800b580:	2301      	movs	r3, #1
 800b582:	f8c2 3214 	str.w	r3, [r2, #532]	; 0x214
    pdev->ep_in[CDC_IN_EP & 0xFU].total_length = hcdc->TxLength;
 800b586:	f8d2 3210 	ldr.w	r3, [r2, #528]	; 0x210
 800b58a:	62c3      	str	r3, [r0, #44]	; 0x2c
    (void)USBD_LL_Transmit(pdev, CDC_IN_EP, hcdc->TxBuffer, hcdc->TxLength);
 800b58c:	f8d2 3210 	ldr.w	r3, [r2, #528]	; 0x210
 800b590:	f8d2 2208 	ldr.w	r2, [r2, #520]	; 0x208
 800b594:	2181      	movs	r1, #129	; 0x81
 800b596:	f003 fc0d 	bl	800edb4 <USBD_LL_Transmit>
    ret = USBD_OK;
 800b59a:	2000      	movs	r0, #0
 800b59c:	e7ef      	b.n	800b57e <USBD_CDC_TransmitPacket+0x10>
    return (uint8_t)USBD_FAIL;
 800b59e:	2003      	movs	r0, #3
}
 800b5a0:	4770      	bx	lr

0800b5a2 <USBD_CDC_ReceivePacket>:
  *         prepare OUT Endpoint for reception
  * @param  pdev: device instance
  * @retval status
  */
uint8_t USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
{
 800b5a2:	b510      	push	{r4, lr}
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 800b5a4:	f8d0 22bc 	ldr.w	r2, [r0, #700]	; 0x2bc

  if (pdev->pClassData == NULL)
 800b5a8:	b192      	cbz	r2, 800b5d0 <USBD_CDC_ReceivePacket+0x2e>
  {
    return (uint8_t)USBD_FAIL;
  }

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 800b5aa:	7c04      	ldrb	r4, [r0, #16]
 800b5ac:	b944      	cbnz	r4, 800b5c0 <USBD_CDC_ReceivePacket+0x1e>
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDC_OUT_EP, hcdc->RxBuffer,
 800b5ae:	f44f 7300 	mov.w	r3, #512	; 0x200
 800b5b2:	f8d2 2204 	ldr.w	r2, [r2, #516]	; 0x204
 800b5b6:	2101      	movs	r1, #1
 800b5b8:	f003 fc04 	bl	800edc4 <USBD_LL_PrepareReceive>
    (void)USBD_LL_PrepareReceive(pdev, CDC_OUT_EP, hcdc->RxBuffer,
                                 CDC_DATA_FS_OUT_PACKET_SIZE);
  }

  return (uint8_t)USBD_OK;
}
 800b5bc:	4620      	mov	r0, r4
 800b5be:	bd10      	pop	{r4, pc}
    (void)USBD_LL_PrepareReceive(pdev, CDC_OUT_EP, hcdc->RxBuffer,
 800b5c0:	2340      	movs	r3, #64	; 0x40
 800b5c2:	f8d2 2204 	ldr.w	r2, [r2, #516]	; 0x204
 800b5c6:	2101      	movs	r1, #1
 800b5c8:	f003 fbfc 	bl	800edc4 <USBD_LL_PrepareReceive>
  return (uint8_t)USBD_OK;
 800b5cc:	2400      	movs	r4, #0
 800b5ce:	e7f5      	b.n	800b5bc <USBD_CDC_ReceivePacket+0x1a>
    return (uint8_t)USBD_FAIL;
 800b5d0:	2403      	movs	r4, #3
 800b5d2:	e7f3      	b.n	800b5bc <USBD_CDC_ReceivePacket+0x1a>

0800b5d4 <USBD_Init>:
                             USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
  USBD_StatusTypeDef ret;

  /* Check whether the USB Host handle is valid */
  if (pdev == NULL)
 800b5d4:	b1c0      	cbz	r0, 800b608 <USBD_Init+0x34>
{
 800b5d6:	b508      	push	{r3, lr}
 800b5d8:	4603      	mov	r3, r0
#endif
    return USBD_FAIL;
  }

  /* Unlink previous class */
  if (pdev->pClass != NULL)
 800b5da:	f8d0 02b8 	ldr.w	r0, [r0, #696]	; 0x2b8
 800b5de:	b110      	cbz	r0, 800b5e6 <USBD_Init+0x12>
  {
    pdev->pClass = NULL;
 800b5e0:	2000      	movs	r0, #0
 800b5e2:	f8c3 02b8 	str.w	r0, [r3, #696]	; 0x2b8
  }

  if (pdev->pConfDesc != NULL)
 800b5e6:	f8d3 02cc 	ldr.w	r0, [r3, #716]	; 0x2cc
 800b5ea:	b110      	cbz	r0, 800b5f2 <USBD_Init+0x1e>
  {
    pdev->pConfDesc = NULL;
 800b5ec:	2000      	movs	r0, #0
 800b5ee:	f8c3 02cc 	str.w	r0, [r3, #716]	; 0x2cc
  }

  /* Assign USBD Descriptors */
  if (pdesc != NULL)
 800b5f2:	b109      	cbz	r1, 800b5f8 <USBD_Init+0x24>
  {
    pdev->pDesc = pdesc;
 800b5f4:	f8c3 12b4 	str.w	r1, [r3, #692]	; 0x2b4
  }

  /* Set Device initial State */
  pdev->dev_state = USBD_STATE_DEFAULT;
 800b5f8:	2101      	movs	r1, #1
 800b5fa:	f883 129c 	strb.w	r1, [r3, #668]	; 0x29c
  pdev->id = id;
 800b5fe:	701a      	strb	r2, [r3, #0]

  /* Initialize low level driver */
  ret = USBD_LL_Init(pdev);
 800b600:	4618      	mov	r0, r3
 800b602:	f003 fb49 	bl	800ec98 <USBD_LL_Init>

  return ret;
}
 800b606:	bd08      	pop	{r3, pc}
    return USBD_FAIL;
 800b608:	2003      	movs	r0, #3
}
 800b60a:	4770      	bx	lr

0800b60c <USBD_RegisterClass>:
  * @param  pDevice : Device Handle
  * @param  pclass: Class handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
 800b60c:	b510      	push	{r4, lr}
 800b60e:	b082      	sub	sp, #8
  uint16_t len = 0U;
 800b610:	2300      	movs	r3, #0
 800b612:	f8ad 3006 	strh.w	r3, [sp, #6]

  if (pclass == NULL)
 800b616:	b159      	cbz	r1, 800b630 <USBD_RegisterClass+0x24>
 800b618:	4604      	mov	r4, r0
#endif
    return USBD_FAIL;
  }

  /* link the class to the USB Device handle */
  pdev->pClass = pclass;
 800b61a:	f8c0 12b8 	str.w	r1, [r0, #696]	; 0x2b8

  /* Get Device Configuration Descriptor */
#ifdef USE_USB_FS
  pdev->pConfDesc = (void *)pdev->pClass->GetFSConfigDescriptor(&len);
#else /* USE_USB_HS */
  pdev->pConfDesc = (void *)pdev->pClass->GetHSConfigDescriptor(&len);
 800b61e:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 800b620:	f10d 0006 	add.w	r0, sp, #6
 800b624:	4798      	blx	r3
 800b626:	f8c4 02cc 	str.w	r0, [r4, #716]	; 0x2cc
#endif /* USE_USB_FS */


  return USBD_OK;
 800b62a:	2000      	movs	r0, #0
}
 800b62c:	b002      	add	sp, #8
 800b62e:	bd10      	pop	{r4, pc}
    return USBD_FAIL;
 800b630:	2003      	movs	r0, #3
 800b632:	e7fb      	b.n	800b62c <USBD_RegisterClass+0x20>

0800b634 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_Start(USBD_HandleTypeDef *pdev)
{
 800b634:	b508      	push	{r3, lr}
  /* Start the low level driver  */
  return USBD_LL_Start(pdev);
 800b636:	f003 fb8a 	bl	800ed4e <USBD_LL_Start>
}
 800b63a:	bd08      	pop	{r3, pc}

0800b63c <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 800b63c:	b508      	push	{r3, lr}
  USBD_StatusTypeDef ret = USBD_FAIL;

  if (pdev->pClass != NULL)
 800b63e:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 800b642:	b113      	cbz	r3, 800b64a <USBD_SetClassConfig+0xe>
  {
    /* Set configuration and Start the Class */
    ret = (USBD_StatusTypeDef)pdev->pClass->Init(pdev, cfgidx);
 800b644:	681b      	ldr	r3, [r3, #0]
 800b646:	4798      	blx	r3
  }

  return ret;
}
 800b648:	bd08      	pop	{r3, pc}
  USBD_StatusTypeDef ret = USBD_FAIL;
 800b64a:	2003      	movs	r0, #3
 800b64c:	e7fc      	b.n	800b648 <USBD_SetClassConfig+0xc>

0800b64e <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 800b64e:	b508      	push	{r3, lr}
  /* Clear configuration and De-initialize the Class process */
  if (pdev->pClass != NULL)
 800b650:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 800b654:	b10b      	cbz	r3, 800b65a <USBD_ClrClassConfig+0xc>
  {
    pdev->pClass->DeInit(pdev, cfgidx);
 800b656:	685b      	ldr	r3, [r3, #4]
 800b658:	4798      	blx	r3
  }

  return USBD_OK;
}
 800b65a:	2000      	movs	r0, #0
 800b65c:	bd08      	pop	{r3, pc}

0800b65e <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 800b65e:	b538      	push	{r3, r4, r5, lr}
 800b660:	4604      	mov	r4, r0
  USBD_StatusTypeDef ret;

  USBD_ParseSetupRequest(&pdev->request, psetup);
 800b662:	f200 25aa 	addw	r5, r0, #682	; 0x2aa
 800b666:	4628      	mov	r0, r5
 800b668:	f000 f92e 	bl	800b8c8 <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;
 800b66c:	2301      	movs	r3, #1
 800b66e:	f8c4 3294 	str.w	r3, [r4, #660]	; 0x294

  pdev->ep0_data_len = pdev->request.wLength;
 800b672:	f8b4 32b0 	ldrh.w	r3, [r4, #688]	; 0x2b0
 800b676:	f8c4 3298 	str.w	r3, [r4, #664]	; 0x298

  switch (pdev->request.bmRequest & 0x1FU)
 800b67a:	f894 12aa 	ldrb.w	r1, [r4, #682]	; 0x2aa
 800b67e:	f001 031f 	and.w	r3, r1, #31
 800b682:	2b01      	cmp	r3, #1
 800b684:	d00d      	beq.n	800b6a2 <USBD_LL_SetupStage+0x44>
 800b686:	2b02      	cmp	r3, #2
 800b688:	d010      	beq.n	800b6ac <USBD_LL_SetupStage+0x4e>
 800b68a:	b12b      	cbz	r3, 800b698 <USBD_LL_SetupStage+0x3a>
    case USB_REQ_RECIPIENT_ENDPOINT:
      ret = USBD_StdEPReq(pdev, &pdev->request);
      break;

    default:
      ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 800b68c:	f001 0180 	and.w	r1, r1, #128	; 0x80
 800b690:	4620      	mov	r0, r4
 800b692:	f003 fb77 	bl	800ed84 <USBD_LL_StallEP>
      break;
 800b696:	e003      	b.n	800b6a0 <USBD_LL_SetupStage+0x42>
      ret = USBD_StdDevReq(pdev, &pdev->request);
 800b698:	4629      	mov	r1, r5
 800b69a:	4620      	mov	r0, r4
 800b69c:	f000 face 	bl	800bc3c <USBD_StdDevReq>
  }

  return ret;
}
 800b6a0:	bd38      	pop	{r3, r4, r5, pc}
      ret = USBD_StdItfReq(pdev, &pdev->request);
 800b6a2:	4629      	mov	r1, r5
 800b6a4:	4620      	mov	r0, r4
 800b6a6:	f000 fb01 	bl	800bcac <USBD_StdItfReq>
      break;
 800b6aa:	e7f9      	b.n	800b6a0 <USBD_LL_SetupStage+0x42>
      ret = USBD_StdEPReq(pdev, &pdev->request);
 800b6ac:	4629      	mov	r1, r5
 800b6ae:	4620      	mov	r0, r4
 800b6b0:	f000 fb30 	bl	800bd14 <USBD_StdEPReq>
      break;
 800b6b4:	e7f4      	b.n	800b6a0 <USBD_LL_SetupStage+0x42>

0800b6b6 <USBD_LL_DataOutStage>:
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 800b6b6:	b538      	push	{r3, r4, r5, lr}
 800b6b8:	4604      	mov	r4, r0
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret;

  if (epnum == 0U)
 800b6ba:	460d      	mov	r5, r1
 800b6bc:	bb31      	cbnz	r1, 800b70c <USBD_LL_DataOutStage+0x56>
 800b6be:	4613      	mov	r3, r2
  {
    pep = &pdev->ep_out[0];

    if (pdev->ep0_state == USBD_EP0_DATA_OUT)
 800b6c0:	f8d0 2294 	ldr.w	r2, [r0, #660]	; 0x294
 800b6c4:	2a03      	cmp	r2, #3
 800b6c6:	d001      	beq.n	800b6cc <USBD_LL_DataOutStage+0x16>
  {
    /* should never be in this condition */
    return USBD_FAIL;
  }

  return USBD_OK;
 800b6c8:	4608      	mov	r0, r1
}
 800b6ca:	bd38      	pop	{r3, r4, r5, pc}
      if (pep->rem_length > pep->maxpacket)
 800b6cc:	f8d0 115c 	ldr.w	r1, [r0, #348]	; 0x15c
 800b6d0:	f8d0 2160 	ldr.w	r2, [r0, #352]	; 0x160
 800b6d4:	4291      	cmp	r1, r2
 800b6d6:	d80c      	bhi.n	800b6f2 <USBD_LL_DataOutStage+0x3c>
        if ((pdev->pClass->EP0_RxReady != NULL) &&
 800b6d8:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 800b6dc:	691b      	ldr	r3, [r3, #16]
 800b6de:	b11b      	cbz	r3, 800b6e8 <USBD_LL_DataOutStage+0x32>
            (pdev->dev_state == USBD_STATE_CONFIGURED))
 800b6e0:	f890 229c 	ldrb.w	r2, [r0, #668]	; 0x29c
        if ((pdev->pClass->EP0_RxReady != NULL) &&
 800b6e4:	2a03      	cmp	r2, #3
 800b6e6:	d00f      	beq.n	800b708 <USBD_LL_DataOutStage+0x52>
        (void)USBD_CtlSendStatus(pdev);
 800b6e8:	4620      	mov	r0, r4
 800b6ea:	f000 fc4e 	bl	800bf8a <USBD_CtlSendStatus>
  return USBD_OK;
 800b6ee:	4628      	mov	r0, r5
 800b6f0:	e7eb      	b.n	800b6ca <USBD_LL_DataOutStage+0x14>
        pep->rem_length -= pep->maxpacket;
 800b6f2:	1a89      	subs	r1, r1, r2
 800b6f4:	f8c0 115c 	str.w	r1, [r0, #348]	; 0x15c
        (void)USBD_CtlContinueRx(pdev, pdata, MIN(pep->rem_length, pep->maxpacket));
 800b6f8:	428a      	cmp	r2, r1
 800b6fa:	bf28      	it	cs
 800b6fc:	460a      	movcs	r2, r1
 800b6fe:	4619      	mov	r1, r3
 800b700:	f000 fc3b 	bl	800bf7a <USBD_CtlContinueRx>
  return USBD_OK;
 800b704:	4628      	mov	r0, r5
 800b706:	e7e0      	b.n	800b6ca <USBD_LL_DataOutStage+0x14>
          pdev->pClass->EP0_RxReady(pdev);
 800b708:	4798      	blx	r3
 800b70a:	e7ed      	b.n	800b6e8 <USBD_LL_DataOutStage+0x32>
  else if ((pdev->pClass->DataOut != NULL) &&
 800b70c:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 800b710:	699b      	ldr	r3, [r3, #24]
 800b712:	b12b      	cbz	r3, 800b720 <USBD_LL_DataOutStage+0x6a>
           (pdev->dev_state == USBD_STATE_CONFIGURED))
 800b714:	f890 229c 	ldrb.w	r2, [r0, #668]	; 0x29c
  else if ((pdev->pClass->DataOut != NULL) &&
 800b718:	2a03      	cmp	r2, #3
 800b71a:	d103      	bne.n	800b724 <USBD_LL_DataOutStage+0x6e>
    ret = (USBD_StatusTypeDef)pdev->pClass->DataOut(pdev, epnum);
 800b71c:	4798      	blx	r3
    if (ret != USBD_OK)
 800b71e:	e7d4      	b.n	800b6ca <USBD_LL_DataOutStage+0x14>
    return USBD_FAIL;
 800b720:	2003      	movs	r0, #3
 800b722:	e7d2      	b.n	800b6ca <USBD_LL_DataOutStage+0x14>
 800b724:	2003      	movs	r0, #3
 800b726:	e7d0      	b.n	800b6ca <USBD_LL_DataOutStage+0x14>

0800b728 <USBD_LL_DataInStage>:
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev,
                                       uint8_t epnum, uint8_t *pdata)
{
 800b728:	b538      	push	{r3, r4, r5, lr}
 800b72a:	4604      	mov	r4, r0
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret;

  if (epnum == 0U)
 800b72c:	460d      	mov	r5, r1
 800b72e:	2900      	cmp	r1, #0
 800b730:	d148      	bne.n	800b7c4 <USBD_LL_DataInStage+0x9c>
 800b732:	4613      	mov	r3, r2
  {
    pep = &pdev->ep_in[0];

    if (pdev->ep0_state == USBD_EP0_DATA_IN)
 800b734:	f8d0 2294 	ldr.w	r2, [r0, #660]	; 0x294
 800b738:	2a02      	cmp	r2, #2
 800b73a:	d005      	beq.n	800b748 <USBD_LL_DataInStage+0x20>
        (void)USBD_LL_StallEP(pdev, 0x80U);
      }
#endif
    }

    if (pdev->dev_test_mode == 1U)
 800b73c:	f894 32a0 	ldrb.w	r3, [r4, #672]	; 0x2a0
 800b740:	2b01      	cmp	r3, #1
 800b742:	d03a      	beq.n	800b7ba <USBD_LL_DataInStage+0x92>
  {
    /* should never be in this condition */
    return USBD_FAIL;
  }

  return USBD_OK;
 800b744:	4628      	mov	r0, r5
}
 800b746:	bd38      	pop	{r3, r4, r5, pc}
      if (pep->rem_length > pep->maxpacket)
 800b748:	69c2      	ldr	r2, [r0, #28]
 800b74a:	6a01      	ldr	r1, [r0, #32]
 800b74c:	428a      	cmp	r2, r1
 800b74e:	d811      	bhi.n	800b774 <USBD_LL_DataInStage+0x4c>
        if ((pep->maxpacket == pep->rem_length) &&
 800b750:	428a      	cmp	r2, r1
 800b752:	d01b      	beq.n	800b78c <USBD_LL_DataInStage+0x64>
          if ((pdev->pClass->EP0_TxSent != NULL) &&
 800b754:	f8d4 32b8 	ldr.w	r3, [r4, #696]	; 0x2b8
 800b758:	68db      	ldr	r3, [r3, #12]
 800b75a:	b11b      	cbz	r3, 800b764 <USBD_LL_DataInStage+0x3c>
              (pdev->dev_state == USBD_STATE_CONFIGURED))
 800b75c:	f894 229c 	ldrb.w	r2, [r4, #668]	; 0x29c
          if ((pdev->pClass->EP0_TxSent != NULL) &&
 800b760:	2a03      	cmp	r2, #3
 800b762:	d027      	beq.n	800b7b4 <USBD_LL_DataInStage+0x8c>
          (void)USBD_LL_StallEP(pdev, 0x80U);
 800b764:	2180      	movs	r1, #128	; 0x80
 800b766:	4620      	mov	r0, r4
 800b768:	f003 fb0c 	bl	800ed84 <USBD_LL_StallEP>
          (void)USBD_CtlReceiveStatus(pdev);
 800b76c:	4620      	mov	r0, r4
 800b76e:	f000 fc17 	bl	800bfa0 <USBD_CtlReceiveStatus>
 800b772:	e7e3      	b.n	800b73c <USBD_LL_DataInStage+0x14>
        pep->rem_length -= pep->maxpacket;
 800b774:	1a52      	subs	r2, r2, r1
 800b776:	61c2      	str	r2, [r0, #28]
        (void)USBD_CtlContinueSendData(pdev, pdata, pep->rem_length);
 800b778:	4619      	mov	r1, r3
 800b77a:	f000 fbe7 	bl	800bf4c <USBD_CtlContinueSendData>
       (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 800b77e:	2300      	movs	r3, #0
 800b780:	461a      	mov	r2, r3
 800b782:	4619      	mov	r1, r3
 800b784:	4620      	mov	r0, r4
 800b786:	f003 fb1d 	bl	800edc4 <USBD_LL_PrepareReceive>
 800b78a:	e7d7      	b.n	800b73c <USBD_LL_DataInStage+0x14>
            (pep->total_length >= pep->maxpacket) &&
 800b78c:	6983      	ldr	r3, [r0, #24]
        if ((pep->maxpacket == pep->rem_length) &&
 800b78e:	4299      	cmp	r1, r3
 800b790:	d8e0      	bhi.n	800b754 <USBD_LL_DataInStage+0x2c>
            (pep->total_length < pdev->ep0_data_len))
 800b792:	f8d0 2298 	ldr.w	r2, [r0, #664]	; 0x298
            (pep->total_length >= pep->maxpacket) &&
 800b796:	4293      	cmp	r3, r2
 800b798:	d2dc      	bcs.n	800b754 <USBD_LL_DataInStage+0x2c>
          (void)USBD_CtlContinueSendData(pdev, NULL, 0U);
 800b79a:	2200      	movs	r2, #0
 800b79c:	4611      	mov	r1, r2
 800b79e:	f000 fbd5 	bl	800bf4c <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0U;
 800b7a2:	2100      	movs	r1, #0
 800b7a4:	f8c4 1298 	str.w	r1, [r4, #664]	; 0x298
          (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 800b7a8:	460b      	mov	r3, r1
 800b7aa:	460a      	mov	r2, r1
 800b7ac:	4620      	mov	r0, r4
 800b7ae:	f003 fb09 	bl	800edc4 <USBD_LL_PrepareReceive>
 800b7b2:	e7c3      	b.n	800b73c <USBD_LL_DataInStage+0x14>
            pdev->pClass->EP0_TxSent(pdev);
 800b7b4:	4620      	mov	r0, r4
 800b7b6:	4798      	blx	r3
 800b7b8:	e7d4      	b.n	800b764 <USBD_LL_DataInStage+0x3c>
      pdev->dev_test_mode = 0U;
 800b7ba:	2300      	movs	r3, #0
 800b7bc:	f884 32a0 	strb.w	r3, [r4, #672]	; 0x2a0
  return USBD_OK;
 800b7c0:	4628      	mov	r0, r5
 800b7c2:	e7c0      	b.n	800b746 <USBD_LL_DataInStage+0x1e>
  else if ((pdev->pClass->DataIn != NULL) &&
 800b7c4:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 800b7c8:	695b      	ldr	r3, [r3, #20]
 800b7ca:	b12b      	cbz	r3, 800b7d8 <USBD_LL_DataInStage+0xb0>
           (pdev->dev_state == USBD_STATE_CONFIGURED))
 800b7cc:	f890 229c 	ldrb.w	r2, [r0, #668]	; 0x29c
  else if ((pdev->pClass->DataIn != NULL) &&
 800b7d0:	2a03      	cmp	r2, #3
 800b7d2:	d103      	bne.n	800b7dc <USBD_LL_DataInStage+0xb4>
    ret = (USBD_StatusTypeDef)pdev->pClass->DataIn(pdev, epnum);
 800b7d4:	4798      	blx	r3
    if (ret != USBD_OK)
 800b7d6:	e7b6      	b.n	800b746 <USBD_LL_DataInStage+0x1e>
    return USBD_FAIL;
 800b7d8:	2003      	movs	r0, #3
 800b7da:	e7b4      	b.n	800b746 <USBD_LL_DataInStage+0x1e>
 800b7dc:	2003      	movs	r0, #3
 800b7de:	e7b2      	b.n	800b746 <USBD_LL_DataInStage+0x1e>

0800b7e0 <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef *pdev)
{
 800b7e0:	b570      	push	{r4, r5, r6, lr}
 800b7e2:	4604      	mov	r4, r0
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 800b7e4:	2301      	movs	r3, #1
 800b7e6:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c
  pdev->ep0_state = USBD_EP0_IDLE;
 800b7ea:	2300      	movs	r3, #0
 800b7ec:	f8c0 3294 	str.w	r3, [r0, #660]	; 0x294
  pdev->dev_config = 0U;
 800b7f0:	6043      	str	r3, [r0, #4]
  pdev->dev_remote_wakeup = 0U;
 800b7f2:	f8c0 32a4 	str.w	r3, [r0, #676]	; 0x2a4

  if (pdev->pClassData != NULL)
 800b7f6:	f8d0 32bc 	ldr.w	r3, [r0, #700]	; 0x2bc
 800b7fa:	b123      	cbz	r3, 800b806 <USBD_LL_Reset+0x26>
  {
    pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 800b7fc:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 800b800:	685b      	ldr	r3, [r3, #4]
 800b802:	2100      	movs	r1, #0
 800b804:	4798      	blx	r3
  }

    /* Open EP0 OUT */
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 800b806:	2340      	movs	r3, #64	; 0x40
 800b808:	2200      	movs	r2, #0
 800b80a:	4611      	mov	r1, r2
 800b80c:	4620      	mov	r0, r4
 800b80e:	f003 faa6 	bl	800ed5e <USBD_LL_OpenEP>
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 800b812:	2601      	movs	r6, #1
 800b814:	f8a4 6164 	strh.w	r6, [r4, #356]	; 0x164

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 800b818:	2540      	movs	r5, #64	; 0x40
 800b81a:	f8c4 5160 	str.w	r5, [r4, #352]	; 0x160

  /* Open EP0 IN */
  (void)USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 800b81e:	462b      	mov	r3, r5
 800b820:	2200      	movs	r2, #0
 800b822:	2180      	movs	r1, #128	; 0x80
 800b824:	4620      	mov	r0, r4
 800b826:	f003 fa9a 	bl	800ed5e <USBD_LL_OpenEP>
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 800b82a:	84a6      	strh	r6, [r4, #36]	; 0x24

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 800b82c:	6225      	str	r5, [r4, #32]

  return USBD_OK;
}
 800b82e:	2000      	movs	r0, #0
 800b830:	bd70      	pop	{r4, r5, r6, pc}

0800b832 <USBD_LL_SetSpeed>:
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef *pdev,
                                    USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
 800b832:	7401      	strb	r1, [r0, #16]

  return USBD_OK;
}
 800b834:	2000      	movs	r0, #0
 800b836:	4770      	bx	lr

0800b838 <USBD_LL_Suspend>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef *pdev)
{
  pdev->dev_old_state = pdev->dev_state;
 800b838:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800b83c:	f880 329d 	strb.w	r3, [r0, #669]	; 0x29d
  pdev->dev_state = USBD_STATE_SUSPENDED;
 800b840:	2304      	movs	r3, #4
 800b842:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c

  return USBD_OK;
}
 800b846:	2000      	movs	r0, #0
 800b848:	4770      	bx	lr

0800b84a <USBD_LL_Resume>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef *pdev)
{
  if (pdev->dev_state == USBD_STATE_SUSPENDED)
 800b84a:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800b84e:	2b04      	cmp	r3, #4
 800b850:	d001      	beq.n	800b856 <USBD_LL_Resume+0xc>
  {
    pdev->dev_state = pdev->dev_old_state;
  }

  return USBD_OK;
}
 800b852:	2000      	movs	r0, #0
 800b854:	4770      	bx	lr
    pdev->dev_state = pdev->dev_old_state;
 800b856:	f890 329d 	ldrb.w	r3, [r0, #669]	; 0x29d
 800b85a:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c
 800b85e:	e7f8      	b.n	800b852 <USBD_LL_Resume+0x8>

0800b860 <USBD_LL_SOF>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef *pdev)
{
 800b860:	b508      	push	{r3, lr}
  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800b862:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800b866:	2b03      	cmp	r3, #3
 800b868:	d001      	beq.n	800b86e <USBD_LL_SOF+0xe>
      pdev->pClass->SOF(pdev);
    }
  }

  return USBD_OK;
}
 800b86a:	2000      	movs	r0, #0
 800b86c:	bd08      	pop	{r3, pc}
    if (pdev->pClass->SOF != NULL)
 800b86e:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 800b872:	69db      	ldr	r3, [r3, #28]
 800b874:	2b00      	cmp	r3, #0
 800b876:	d0f8      	beq.n	800b86a <USBD_LL_SOF+0xa>
      pdev->pClass->SOF(pdev);
 800b878:	4798      	blx	r3
 800b87a:	e7f6      	b.n	800b86a <USBD_LL_SOF+0xa>

0800b87c <USBD_LL_IsoINIncomplete>:
  /* Prevent unused arguments compilation warning */
  UNUSED(pdev);
  UNUSED(epnum);

  return USBD_OK;
}
 800b87c:	2000      	movs	r0, #0
 800b87e:	4770      	bx	lr

0800b880 <USBD_LL_IsoOUTIncomplete>:
  /* Prevent unused arguments compilation warning */
  UNUSED(pdev);
  UNUSED(epnum);

  return USBD_OK;
}
 800b880:	2000      	movs	r0, #0
 800b882:	4770      	bx	lr

0800b884 <USBD_LL_DevConnected>:
{
  /* Prevent unused argument compilation warning */
  UNUSED(pdev);

  return USBD_OK;
}
 800b884:	2000      	movs	r0, #0
 800b886:	4770      	bx	lr

0800b888 <USBD_LL_DevDisconnected>:
*         Handle device disconnection event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef *pdev)
{
 800b888:	b508      	push	{r3, lr}
  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
 800b88a:	2301      	movs	r3, #1
 800b88c:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c

  if (pdev->pClass != NULL)
 800b890:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 800b894:	b113      	cbz	r3, 800b89c <USBD_LL_DevDisconnected+0x14>
  {
    pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 800b896:	685b      	ldr	r3, [r3, #4]
 800b898:	7901      	ldrb	r1, [r0, #4]
 800b89a:	4798      	blx	r3
  }

  return USBD_OK;
}
 800b89c:	2000      	movs	r0, #0
 800b89e:	bd08      	pop	{r3, pc}

0800b8a0 <USBD_GetLen>:
  *         return the string length
   * @param  buf : pointer to the ascii string buffer
  * @retval string length
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
 800b8a0:	4603      	mov	r3, r0
  uint8_t  len = 0U;
 800b8a2:	2000      	movs	r0, #0
  uint8_t *pbuff = buf;

  while (*pbuff != (uint8_t)'\0')
 800b8a4:	e002      	b.n	800b8ac <USBD_GetLen+0xc>
  {
    len++;
 800b8a6:	3001      	adds	r0, #1
 800b8a8:	b2c0      	uxtb	r0, r0
    pbuff++;
 800b8aa:	3301      	adds	r3, #1
  while (*pbuff != (uint8_t)'\0')
 800b8ac:	781a      	ldrb	r2, [r3, #0]
 800b8ae:	2a00      	cmp	r2, #0
 800b8b0:	d1f9      	bne.n	800b8a6 <USBD_GetLen+0x6>
  }

  return len;
}
 800b8b2:	4770      	bx	lr

0800b8b4 <USBD_SetFeature>:
{
 800b8b4:	b508      	push	{r3, lr}
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 800b8b6:	884b      	ldrh	r3, [r1, #2]
 800b8b8:	2b01      	cmp	r3, #1
 800b8ba:	d000      	beq.n	800b8be <USBD_SetFeature+0xa>
}
 800b8bc:	bd08      	pop	{r3, pc}
    pdev->dev_remote_wakeup = 1U;
 800b8be:	f8c0 32a4 	str.w	r3, [r0, #676]	; 0x2a4
    (void)USBD_CtlSendStatus(pdev);
 800b8c2:	f000 fb62 	bl	800bf8a <USBD_CtlSendStatus>
}
 800b8c6:	e7f9      	b.n	800b8bc <USBD_SetFeature+0x8>

0800b8c8 <USBD_ParseSetupRequest>:
  req->bmRequest = *(uint8_t *)(pbuff);
 800b8c8:	780b      	ldrb	r3, [r1, #0]
 800b8ca:	7003      	strb	r3, [r0, #0]
  req->bRequest = *(uint8_t *)(pbuff);
 800b8cc:	784b      	ldrb	r3, [r1, #1]
 800b8ce:	7043      	strb	r3, [r0, #1]
__STATIC_INLINE uint16_t SWAPBYTE(uint8_t *addr)
{
  uint16_t _SwapVal, _Byte1, _Byte2;
  uint8_t *_pbuff = addr;

  _Byte1 = *(uint8_t *)_pbuff;
 800b8d0:	788b      	ldrb	r3, [r1, #2]
  _pbuff++;
  _Byte2 = *(uint8_t *)_pbuff;
 800b8d2:	78ca      	ldrb	r2, [r1, #3]

  _SwapVal = (_Byte2 << 8) | _Byte1;
 800b8d4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  req->wValue = SWAPBYTE(pbuff);
 800b8d8:	8043      	strh	r3, [r0, #2]
  _Byte1 = *(uint8_t *)_pbuff;
 800b8da:	790b      	ldrb	r3, [r1, #4]
  _Byte2 = *(uint8_t *)_pbuff;
 800b8dc:	794a      	ldrb	r2, [r1, #5]
  _SwapVal = (_Byte2 << 8) | _Byte1;
 800b8de:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  req->wIndex = SWAPBYTE(pbuff);
 800b8e2:	8083      	strh	r3, [r0, #4]
  _Byte1 = *(uint8_t *)_pbuff;
 800b8e4:	798b      	ldrb	r3, [r1, #6]
  _Byte2 = *(uint8_t *)_pbuff;
 800b8e6:	79ca      	ldrb	r2, [r1, #7]
  _SwapVal = (_Byte2 << 8) | _Byte1;
 800b8e8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  req->wLength = SWAPBYTE(pbuff);
 800b8ec:	80c3      	strh	r3, [r0, #6]
}
 800b8ee:	4770      	bx	lr

0800b8f0 <USBD_CtlError>:
{
 800b8f0:	b510      	push	{r4, lr}
 800b8f2:	4604      	mov	r4, r0
  (void)USBD_LL_StallEP(pdev, 0x80U);
 800b8f4:	2180      	movs	r1, #128	; 0x80
 800b8f6:	f003 fa45 	bl	800ed84 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 800b8fa:	2100      	movs	r1, #0
 800b8fc:	4620      	mov	r0, r4
 800b8fe:	f003 fa41 	bl	800ed84 <USBD_LL_StallEP>
}
 800b902:	bd10      	pop	{r4, pc}

0800b904 <USBD_GetDescriptor>:
{
 800b904:	b530      	push	{r4, r5, lr}
 800b906:	b083      	sub	sp, #12
 800b908:	4604      	mov	r4, r0
 800b90a:	460d      	mov	r5, r1
  uint16_t len = 0U;
 800b90c:	2300      	movs	r3, #0
 800b90e:	f8ad 3006 	strh.w	r3, [sp, #6]
  switch (req->wValue >> 8)
 800b912:	884a      	ldrh	r2, [r1, #2]
 800b914:	0a13      	lsrs	r3, r2, #8
 800b916:	3b01      	subs	r3, #1
 800b918:	2b06      	cmp	r3, #6
 800b91a:	f200 80ab 	bhi.w	800ba74 <USBD_GetDescriptor+0x170>
 800b91e:	e8df f003 	tbb	[pc, r3]
 800b922:	1f04      	.short	0x1f04
 800b924:	8da9a933 	.word	0x8da9a933
 800b928:	9a          	.byte	0x9a
 800b929:	00          	.byte	0x00
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 800b92a:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 800b92e:	681b      	ldr	r3, [r3, #0]
 800b930:	f10d 0106 	add.w	r1, sp, #6
 800b934:	7c00      	ldrb	r0, [r0, #16]
 800b936:	4798      	blx	r3
    if (req->wLength != 0U)
 800b938:	88ea      	ldrh	r2, [r5, #6]
 800b93a:	2a00      	cmp	r2, #0
 800b93c:	f000 80a3 	beq.w	800ba86 <USBD_GetDescriptor+0x182>
      if (len != 0U)
 800b940:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800b944:	2b00      	cmp	r3, #0
 800b946:	f000 8099 	beq.w	800ba7c <USBD_GetDescriptor+0x178>
        len = MIN(len, req->wLength);
 800b94a:	429a      	cmp	r2, r3
 800b94c:	bf28      	it	cs
 800b94e:	461a      	movcs	r2, r3
 800b950:	f8ad 2006 	strh.w	r2, [sp, #6]
        (void)USBD_CtlSendData(pdev, pbuf, len);
 800b954:	4601      	mov	r1, r0
 800b956:	4620      	mov	r0, r4
 800b958:	f000 faeb 	bl	800bf32 <USBD_CtlSendData>
}
 800b95c:	b003      	add	sp, #12
 800b95e:	bd30      	pop	{r4, r5, pc}
    if (pdev->dev_speed == USBD_SPEED_HIGH)
 800b960:	7c03      	ldrb	r3, [r0, #16]
 800b962:	b943      	cbnz	r3, 800b976 <USBD_GetDescriptor+0x72>
      pbuf = pdev->pClass->GetHSConfigDescriptor(&len);
 800b964:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 800b968:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b96a:	f10d 0006 	add.w	r0, sp, #6
 800b96e:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 800b970:	2302      	movs	r3, #2
 800b972:	7043      	strb	r3, [r0, #1]
  if (err != 0U)
 800b974:	e7e0      	b.n	800b938 <USBD_GetDescriptor+0x34>
      pbuf = pdev->pClass->GetFSConfigDescriptor(&len);
 800b976:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 800b97a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b97c:	f10d 0006 	add.w	r0, sp, #6
 800b980:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 800b982:	2302      	movs	r3, #2
 800b984:	7043      	strb	r3, [r0, #1]
  if (err != 0U)
 800b986:	e7d7      	b.n	800b938 <USBD_GetDescriptor+0x34>
    switch ((uint8_t)(req->wValue))
 800b988:	b2d2      	uxtb	r2, r2
 800b98a:	2a05      	cmp	r2, #5
 800b98c:	d852      	bhi.n	800ba34 <USBD_GetDescriptor+0x130>
 800b98e:	e8df f002 	tbb	[pc, r2]
 800b992:	1003      	.short	0x1003
 800b994:	44372a1d 	.word	0x44372a1d
      if (pdev->pDesc->GetLangIDStrDescriptor != NULL)
 800b998:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 800b99c:	685b      	ldr	r3, [r3, #4]
 800b99e:	b123      	cbz	r3, 800b9aa <USBD_GetDescriptor+0xa6>
        pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);
 800b9a0:	f10d 0106 	add.w	r1, sp, #6
 800b9a4:	7c00      	ldrb	r0, [r0, #16]
 800b9a6:	4798      	blx	r3
  if (err != 0U)
 800b9a8:	e7c6      	b.n	800b938 <USBD_GetDescriptor+0x34>
        USBD_CtlError(pdev, req);
 800b9aa:	4629      	mov	r1, r5
 800b9ac:	f7ff ffa0 	bl	800b8f0 <USBD_CtlError>
  if (err != 0U)
 800b9b0:	e7d4      	b.n	800b95c <USBD_GetDescriptor+0x58>
      if (pdev->pDesc->GetManufacturerStrDescriptor != NULL)
 800b9b2:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 800b9b6:	689b      	ldr	r3, [r3, #8]
 800b9b8:	b123      	cbz	r3, 800b9c4 <USBD_GetDescriptor+0xc0>
        pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 800b9ba:	f10d 0106 	add.w	r1, sp, #6
 800b9be:	7c00      	ldrb	r0, [r0, #16]
 800b9c0:	4798      	blx	r3
  if (err != 0U)
 800b9c2:	e7b9      	b.n	800b938 <USBD_GetDescriptor+0x34>
        USBD_CtlError(pdev, req);
 800b9c4:	4629      	mov	r1, r5
 800b9c6:	f7ff ff93 	bl	800b8f0 <USBD_CtlError>
  if (err != 0U)
 800b9ca:	e7c7      	b.n	800b95c <USBD_GetDescriptor+0x58>
      if (pdev->pDesc->GetProductStrDescriptor != NULL)
 800b9cc:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 800b9d0:	68db      	ldr	r3, [r3, #12]
 800b9d2:	b123      	cbz	r3, 800b9de <USBD_GetDescriptor+0xda>
        pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 800b9d4:	f10d 0106 	add.w	r1, sp, #6
 800b9d8:	7c00      	ldrb	r0, [r0, #16]
 800b9da:	4798      	blx	r3
  if (err != 0U)
 800b9dc:	e7ac      	b.n	800b938 <USBD_GetDescriptor+0x34>
        USBD_CtlError(pdev, req);
 800b9de:	4629      	mov	r1, r5
 800b9e0:	f7ff ff86 	bl	800b8f0 <USBD_CtlError>
  if (err != 0U)
 800b9e4:	e7ba      	b.n	800b95c <USBD_GetDescriptor+0x58>
      if (pdev->pDesc->GetSerialStrDescriptor != NULL)
 800b9e6:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 800b9ea:	691b      	ldr	r3, [r3, #16]
 800b9ec:	b123      	cbz	r3, 800b9f8 <USBD_GetDescriptor+0xf4>
        pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 800b9ee:	f10d 0106 	add.w	r1, sp, #6
 800b9f2:	7c00      	ldrb	r0, [r0, #16]
 800b9f4:	4798      	blx	r3
  if (err != 0U)
 800b9f6:	e79f      	b.n	800b938 <USBD_GetDescriptor+0x34>
        USBD_CtlError(pdev, req);
 800b9f8:	4629      	mov	r1, r5
 800b9fa:	f7ff ff79 	bl	800b8f0 <USBD_CtlError>
  if (err != 0U)
 800b9fe:	e7ad      	b.n	800b95c <USBD_GetDescriptor+0x58>
      if (pdev->pDesc->GetConfigurationStrDescriptor != NULL)
 800ba00:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 800ba04:	695b      	ldr	r3, [r3, #20]
 800ba06:	b123      	cbz	r3, 800ba12 <USBD_GetDescriptor+0x10e>
        pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 800ba08:	f10d 0106 	add.w	r1, sp, #6
 800ba0c:	7c00      	ldrb	r0, [r0, #16]
 800ba0e:	4798      	blx	r3
  if (err != 0U)
 800ba10:	e792      	b.n	800b938 <USBD_GetDescriptor+0x34>
        USBD_CtlError(pdev, req);
 800ba12:	4629      	mov	r1, r5
 800ba14:	f7ff ff6c 	bl	800b8f0 <USBD_CtlError>
  if (err != 0U)
 800ba18:	e7a0      	b.n	800b95c <USBD_GetDescriptor+0x58>
      if (pdev->pDesc->GetInterfaceStrDescriptor != NULL)
 800ba1a:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 800ba1e:	699b      	ldr	r3, [r3, #24]
 800ba20:	b123      	cbz	r3, 800ba2c <USBD_GetDescriptor+0x128>
        pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 800ba22:	f10d 0106 	add.w	r1, sp, #6
 800ba26:	7c00      	ldrb	r0, [r0, #16]
 800ba28:	4798      	blx	r3
  if (err != 0U)
 800ba2a:	e785      	b.n	800b938 <USBD_GetDescriptor+0x34>
        USBD_CtlError(pdev, req);
 800ba2c:	4629      	mov	r1, r5
 800ba2e:	f7ff ff5f 	bl	800b8f0 <USBD_CtlError>
  if (err != 0U)
 800ba32:	e793      	b.n	800b95c <USBD_GetDescriptor+0x58>
      USBD_CtlError(pdev, req);
 800ba34:	4629      	mov	r1, r5
 800ba36:	f7ff ff5b 	bl	800b8f0 <USBD_CtlError>
  if (err != 0U)
 800ba3a:	e78f      	b.n	800b95c <USBD_GetDescriptor+0x58>
    if (pdev->dev_speed == USBD_SPEED_HIGH)
 800ba3c:	7c03      	ldrb	r3, [r0, #16]
 800ba3e:	b933      	cbnz	r3, 800ba4e <USBD_GetDescriptor+0x14a>
      pbuf = pdev->pClass->GetDeviceQualifierDescriptor(&len);
 800ba40:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 800ba44:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800ba46:	f10d 0006 	add.w	r0, sp, #6
 800ba4a:	4798      	blx	r3
  if (err != 0U)
 800ba4c:	e774      	b.n	800b938 <USBD_GetDescriptor+0x34>
      USBD_CtlError(pdev, req);
 800ba4e:	4629      	mov	r1, r5
 800ba50:	f7ff ff4e 	bl	800b8f0 <USBD_CtlError>
  if (err != 0U)
 800ba54:	e782      	b.n	800b95c <USBD_GetDescriptor+0x58>
    if (pdev->dev_speed == USBD_SPEED_HIGH)
 800ba56:	7c03      	ldrb	r3, [r0, #16]
 800ba58:	b943      	cbnz	r3, 800ba6c <USBD_GetDescriptor+0x168>
      pbuf = pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 800ba5a:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 800ba5e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ba60:	f10d 0006 	add.w	r0, sp, #6
 800ba64:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 800ba66:	2307      	movs	r3, #7
 800ba68:	7043      	strb	r3, [r0, #1]
  if (err != 0U)
 800ba6a:	e765      	b.n	800b938 <USBD_GetDescriptor+0x34>
      USBD_CtlError(pdev, req);
 800ba6c:	4629      	mov	r1, r5
 800ba6e:	f7ff ff3f 	bl	800b8f0 <USBD_CtlError>
  if (err != 0U)
 800ba72:	e773      	b.n	800b95c <USBD_GetDescriptor+0x58>
    USBD_CtlError(pdev, req);
 800ba74:	4629      	mov	r1, r5
 800ba76:	f7ff ff3b 	bl	800b8f0 <USBD_CtlError>
    return;
 800ba7a:	e76f      	b.n	800b95c <USBD_GetDescriptor+0x58>
        USBD_CtlError(pdev, req);
 800ba7c:	4629      	mov	r1, r5
 800ba7e:	4620      	mov	r0, r4
 800ba80:	f7ff ff36 	bl	800b8f0 <USBD_CtlError>
 800ba84:	e76a      	b.n	800b95c <USBD_GetDescriptor+0x58>
      (void)USBD_CtlSendStatus(pdev);
 800ba86:	4620      	mov	r0, r4
 800ba88:	f000 fa7f 	bl	800bf8a <USBD_CtlSendStatus>
 800ba8c:	e766      	b.n	800b95c <USBD_GetDescriptor+0x58>

0800ba8e <USBD_SetAddress>:
{
 800ba8e:	b538      	push	{r3, r4, r5, lr}
 800ba90:	4604      	mov	r4, r0
  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 800ba92:	888b      	ldrh	r3, [r1, #4]
 800ba94:	b9f3      	cbnz	r3, 800bad4 <USBD_SetAddress+0x46>
 800ba96:	88cb      	ldrh	r3, [r1, #6]
 800ba98:	b9e3      	cbnz	r3, 800bad4 <USBD_SetAddress+0x46>
 800ba9a:	884b      	ldrh	r3, [r1, #2]
 800ba9c:	2b7f      	cmp	r3, #127	; 0x7f
 800ba9e:	d819      	bhi.n	800bad4 <USBD_SetAddress+0x46>
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 800baa0:	f003 057f 	and.w	r5, r3, #127	; 0x7f
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800baa4:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800baa8:	2b03      	cmp	r3, #3
 800baaa:	d00c      	beq.n	800bac6 <USBD_SetAddress+0x38>
      pdev->dev_address = dev_addr;
 800baac:	f880 529e 	strb.w	r5, [r0, #670]	; 0x29e
      (void)USBD_LL_SetUSBAddress(pdev, dev_addr);
 800bab0:	4629      	mov	r1, r5
 800bab2:	f003 f977 	bl	800eda4 <USBD_LL_SetUSBAddress>
      (void)USBD_CtlSendStatus(pdev);
 800bab6:	4620      	mov	r0, r4
 800bab8:	f000 fa67 	bl	800bf8a <USBD_CtlSendStatus>
      if (dev_addr != 0U)
 800babc:	b135      	cbz	r5, 800bacc <USBD_SetAddress+0x3e>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 800babe:	2302      	movs	r3, #2
 800bac0:	f884 329c 	strb.w	r3, [r4, #668]	; 0x29c
 800bac4:	e009      	b.n	800bada <USBD_SetAddress+0x4c>
      USBD_CtlError(pdev, req);
 800bac6:	f7ff ff13 	bl	800b8f0 <USBD_CtlError>
 800baca:	e006      	b.n	800bada <USBD_SetAddress+0x4c>
        pdev->dev_state = USBD_STATE_DEFAULT;
 800bacc:	2301      	movs	r3, #1
 800bace:	f884 329c 	strb.w	r3, [r4, #668]	; 0x29c
 800bad2:	e002      	b.n	800bada <USBD_SetAddress+0x4c>
    USBD_CtlError(pdev, req);
 800bad4:	4620      	mov	r0, r4
 800bad6:	f7ff ff0b 	bl	800b8f0 <USBD_CtlError>
}
 800bada:	bd38      	pop	{r3, r4, r5, pc}

0800badc <USBD_SetConfig>:
{
 800badc:	b570      	push	{r4, r5, r6, lr}
 800bade:	4604      	mov	r4, r0
 800bae0:	460e      	mov	r6, r1
  cfgidx = (uint8_t)(req->wValue);
 800bae2:	788d      	ldrb	r5, [r1, #2]
 800bae4:	4b2d      	ldr	r3, [pc, #180]	; (800bb9c <USBD_SetConfig+0xc0>)
 800bae6:	701d      	strb	r5, [r3, #0]
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 800bae8:	2d01      	cmp	r5, #1
 800baea:	d80f      	bhi.n	800bb0c <USBD_SetConfig+0x30>
  switch (pdev->dev_state)
 800baec:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800baf0:	2b02      	cmp	r3, #2
 800baf2:	d00f      	beq.n	800bb14 <USBD_SetConfig+0x38>
 800baf4:	2b03      	cmp	r3, #3
 800baf6:	d023      	beq.n	800bb40 <USBD_SetConfig+0x64>
    USBD_CtlError(pdev, req);
 800baf8:	f7ff fefa 	bl	800b8f0 <USBD_CtlError>
    (void)USBD_ClrClassConfig(pdev, cfgidx);
 800bafc:	4b27      	ldr	r3, [pc, #156]	; (800bb9c <USBD_SetConfig+0xc0>)
 800bafe:	7819      	ldrb	r1, [r3, #0]
 800bb00:	4620      	mov	r0, r4
 800bb02:	f7ff fda4 	bl	800b64e <USBD_ClrClassConfig>
    ret = USBD_FAIL;
 800bb06:	2503      	movs	r5, #3
}
 800bb08:	4628      	mov	r0, r5
 800bb0a:	bd70      	pop	{r4, r5, r6, pc}
    USBD_CtlError(pdev, req);
 800bb0c:	f7ff fef0 	bl	800b8f0 <USBD_CtlError>
    return USBD_FAIL;
 800bb10:	2503      	movs	r5, #3
 800bb12:	e7f9      	b.n	800bb08 <USBD_SetConfig+0x2c>
    if (cfgidx != 0U)
 800bb14:	b18d      	cbz	r5, 800bb3a <USBD_SetConfig+0x5e>
      pdev->dev_config = cfgidx;
 800bb16:	6045      	str	r5, [r0, #4]
      ret = USBD_SetClassConfig(pdev, cfgidx);
 800bb18:	4629      	mov	r1, r5
 800bb1a:	f7ff fd8f 	bl	800b63c <USBD_SetClassConfig>
      if (ret != USBD_OK)
 800bb1e:	4605      	mov	r5, r0
 800bb20:	b120      	cbz	r0, 800bb2c <USBD_SetConfig+0x50>
        USBD_CtlError(pdev, req);
 800bb22:	4631      	mov	r1, r6
 800bb24:	4620      	mov	r0, r4
 800bb26:	f7ff fee3 	bl	800b8f0 <USBD_CtlError>
 800bb2a:	e7ed      	b.n	800bb08 <USBD_SetConfig+0x2c>
        (void)USBD_CtlSendStatus(pdev);
 800bb2c:	4620      	mov	r0, r4
 800bb2e:	f000 fa2c 	bl	800bf8a <USBD_CtlSendStatus>
        pdev->dev_state = USBD_STATE_CONFIGURED;
 800bb32:	2303      	movs	r3, #3
 800bb34:	f884 329c 	strb.w	r3, [r4, #668]	; 0x29c
 800bb38:	e7e6      	b.n	800bb08 <USBD_SetConfig+0x2c>
      (void)USBD_CtlSendStatus(pdev);
 800bb3a:	f000 fa26 	bl	800bf8a <USBD_CtlSendStatus>
 800bb3e:	e7e3      	b.n	800bb08 <USBD_SetConfig+0x2c>
    if (cfgidx == 0U)
 800bb40:	b1cd      	cbz	r5, 800bb76 <USBD_SetConfig+0x9a>
    else if (cfgidx != pdev->dev_config)
 800bb42:	6841      	ldr	r1, [r0, #4]
 800bb44:	428d      	cmp	r5, r1
 800bb46:	d025      	beq.n	800bb94 <USBD_SetConfig+0xb8>
      (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 800bb48:	b2c9      	uxtb	r1, r1
 800bb4a:	f7ff fd80 	bl	800b64e <USBD_ClrClassConfig>
      pdev->dev_config = cfgidx;
 800bb4e:	4b13      	ldr	r3, [pc, #76]	; (800bb9c <USBD_SetConfig+0xc0>)
 800bb50:	7819      	ldrb	r1, [r3, #0]
 800bb52:	6061      	str	r1, [r4, #4]
      ret = USBD_SetClassConfig(pdev, cfgidx);
 800bb54:	4620      	mov	r0, r4
 800bb56:	f7ff fd71 	bl	800b63c <USBD_SetClassConfig>
      if (ret != USBD_OK)
 800bb5a:	4605      	mov	r5, r0
 800bb5c:	b1b0      	cbz	r0, 800bb8c <USBD_SetConfig+0xb0>
        USBD_CtlError(pdev, req);
 800bb5e:	4631      	mov	r1, r6
 800bb60:	4620      	mov	r0, r4
 800bb62:	f7ff fec5 	bl	800b8f0 <USBD_CtlError>
        (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 800bb66:	7921      	ldrb	r1, [r4, #4]
 800bb68:	4620      	mov	r0, r4
 800bb6a:	f7ff fd70 	bl	800b64e <USBD_ClrClassConfig>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 800bb6e:	2302      	movs	r3, #2
 800bb70:	f884 329c 	strb.w	r3, [r4, #668]	; 0x29c
 800bb74:	e7c8      	b.n	800bb08 <USBD_SetConfig+0x2c>
      pdev->dev_state = USBD_STATE_ADDRESSED;
 800bb76:	2302      	movs	r3, #2
 800bb78:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c
      pdev->dev_config = cfgidx;
 800bb7c:	6045      	str	r5, [r0, #4]
      (void)USBD_ClrClassConfig(pdev, cfgidx);
 800bb7e:	4629      	mov	r1, r5
 800bb80:	f7ff fd65 	bl	800b64e <USBD_ClrClassConfig>
      (void)USBD_CtlSendStatus(pdev);
 800bb84:	4620      	mov	r0, r4
 800bb86:	f000 fa00 	bl	800bf8a <USBD_CtlSendStatus>
 800bb8a:	e7bd      	b.n	800bb08 <USBD_SetConfig+0x2c>
        (void)USBD_CtlSendStatus(pdev);
 800bb8c:	4620      	mov	r0, r4
 800bb8e:	f000 f9fc 	bl	800bf8a <USBD_CtlSendStatus>
 800bb92:	e7b9      	b.n	800bb08 <USBD_SetConfig+0x2c>
      (void)USBD_CtlSendStatus(pdev);
 800bb94:	f000 f9f9 	bl	800bf8a <USBD_CtlSendStatus>
  USBD_StatusTypeDef ret = USBD_OK;
 800bb98:	2500      	movs	r5, #0
 800bb9a:	e7b5      	b.n	800bb08 <USBD_SetConfig+0x2c>
 800bb9c:	20000670 	.word	0x20000670

0800bba0 <USBD_GetConfig>:
{
 800bba0:	b508      	push	{r3, lr}
  if (req->wLength != 1U)
 800bba2:	88cb      	ldrh	r3, [r1, #6]
 800bba4:	2b01      	cmp	r3, #1
 800bba6:	d10a      	bne.n	800bbbe <USBD_GetConfig+0x1e>
    switch (pdev->dev_state)
 800bba8:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800bbac:	2b02      	cmp	r3, #2
 800bbae:	d909      	bls.n	800bbc4 <USBD_GetConfig+0x24>
 800bbb0:	2b03      	cmp	r3, #3
 800bbb2:	d109      	bne.n	800bbc8 <USBD_GetConfig+0x28>
      (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config, 1U);
 800bbb4:	2201      	movs	r2, #1
 800bbb6:	1d01      	adds	r1, r0, #4
 800bbb8:	f000 f9bb 	bl	800bf32 <USBD_CtlSendData>
      break;
 800bbbc:	e001      	b.n	800bbc2 <USBD_GetConfig+0x22>
    USBD_CtlError(pdev, req);
 800bbbe:	f7ff fe97 	bl	800b8f0 <USBD_CtlError>
}
 800bbc2:	bd08      	pop	{r3, pc}
    switch (pdev->dev_state)
 800bbc4:	b25b      	sxtb	r3, r3
 800bbc6:	b913      	cbnz	r3, 800bbce <USBD_GetConfig+0x2e>
      USBD_CtlError(pdev, req);
 800bbc8:	f7ff fe92 	bl	800b8f0 <USBD_CtlError>
}
 800bbcc:	e7f9      	b.n	800bbc2 <USBD_GetConfig+0x22>
      pdev->dev_default_config = 0U;
 800bbce:	4601      	mov	r1, r0
 800bbd0:	2300      	movs	r3, #0
 800bbd2:	f841 3f08 	str.w	r3, [r1, #8]!
      (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_default_config, 1U);
 800bbd6:	2201      	movs	r2, #1
 800bbd8:	f000 f9ab 	bl	800bf32 <USBD_CtlSendData>
      break;
 800bbdc:	e7f1      	b.n	800bbc2 <USBD_GetConfig+0x22>

0800bbde <USBD_GetStatus>:
{
 800bbde:	b508      	push	{r3, lr}
  switch (pdev->dev_state)
 800bbe0:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800bbe4:	3b01      	subs	r3, #1
 800bbe6:	2b02      	cmp	r3, #2
 800bbe8:	d812      	bhi.n	800bc10 <USBD_GetStatus+0x32>
    if (req->wLength != 0x2U)
 800bbea:	88cb      	ldrh	r3, [r1, #6]
 800bbec:	2b02      	cmp	r3, #2
 800bbee:	d10c      	bne.n	800bc0a <USBD_GetStatus+0x2c>
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
 800bbf0:	2301      	movs	r3, #1
 800bbf2:	60c3      	str	r3, [r0, #12]
    if (pdev->dev_remote_wakeup != 0U)
 800bbf4:	f8d0 32a4 	ldr.w	r3, [r0, #676]	; 0x2a4
 800bbf8:	b10b      	cbz	r3, 800bbfe <USBD_GetStatus+0x20>
      pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 800bbfa:	2303      	movs	r3, #3
 800bbfc:	60c3      	str	r3, [r0, #12]
    (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config_status, 2U);
 800bbfe:	2202      	movs	r2, #2
 800bc00:	f100 010c 	add.w	r1, r0, #12
 800bc04:	f000 f995 	bl	800bf32 <USBD_CtlSendData>
}
 800bc08:	bd08      	pop	{r3, pc}
      USBD_CtlError(pdev, req);
 800bc0a:	f7ff fe71 	bl	800b8f0 <USBD_CtlError>
      break;
 800bc0e:	e7fb      	b.n	800bc08 <USBD_GetStatus+0x2a>
    USBD_CtlError(pdev, req);
 800bc10:	f7ff fe6e 	bl	800b8f0 <USBD_CtlError>
}
 800bc14:	e7f8      	b.n	800bc08 <USBD_GetStatus+0x2a>

0800bc16 <USBD_ClrFeature>:
{
 800bc16:	b508      	push	{r3, lr}
  switch (pdev->dev_state)
 800bc18:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800bc1c:	3b01      	subs	r3, #1
 800bc1e:	2b02      	cmp	r3, #2
 800bc20:	d809      	bhi.n	800bc36 <USBD_ClrFeature+0x20>
      if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 800bc22:	884b      	ldrh	r3, [r1, #2]
 800bc24:	2b01      	cmp	r3, #1
 800bc26:	d000      	beq.n	800bc2a <USBD_ClrFeature+0x14>
}
 800bc28:	bd08      	pop	{r3, pc}
        pdev->dev_remote_wakeup = 0U;
 800bc2a:	2300      	movs	r3, #0
 800bc2c:	f8c0 32a4 	str.w	r3, [r0, #676]	; 0x2a4
        (void)USBD_CtlSendStatus(pdev);
 800bc30:	f000 f9ab 	bl	800bf8a <USBD_CtlSendStatus>
 800bc34:	e7f8      	b.n	800bc28 <USBD_ClrFeature+0x12>
      USBD_CtlError(pdev, req);
 800bc36:	f7ff fe5b 	bl	800b8f0 <USBD_CtlError>
}
 800bc3a:	e7f5      	b.n	800bc28 <USBD_ClrFeature+0x12>

0800bc3c <USBD_StdDevReq>:
{
 800bc3c:	b538      	push	{r3, r4, r5, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800bc3e:	780c      	ldrb	r4, [r1, #0]
 800bc40:	f004 0460 	and.w	r4, r4, #96	; 0x60
 800bc44:	2c20      	cmp	r4, #32
 800bc46:	d006      	beq.n	800bc56 <USBD_StdDevReq+0x1a>
 800bc48:	2c40      	cmp	r4, #64	; 0x40
 800bc4a:	d004      	beq.n	800bc56 <USBD_StdDevReq+0x1a>
 800bc4c:	b154      	cbz	r4, 800bc64 <USBD_StdDevReq+0x28>
    USBD_CtlError(pdev, req);
 800bc4e:	f7ff fe4f 	bl	800b8f0 <USBD_CtlError>
  USBD_StatusTypeDef ret = USBD_OK;
 800bc52:	2400      	movs	r4, #0
    break;
 800bc54:	e004      	b.n	800bc60 <USBD_StdDevReq+0x24>
    ret = (USBD_StatusTypeDef)pdev->pClass->Setup(pdev, req);
 800bc56:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 800bc5a:	689b      	ldr	r3, [r3, #8]
 800bc5c:	4798      	blx	r3
 800bc5e:	4604      	mov	r4, r0
}
 800bc60:	4620      	mov	r0, r4
 800bc62:	bd38      	pop	{r3, r4, r5, pc}
    switch (req->bRequest)
 800bc64:	784d      	ldrb	r5, [r1, #1]
 800bc66:	2d09      	cmp	r5, #9
 800bc68:	d81d      	bhi.n	800bca6 <USBD_StdDevReq+0x6a>
 800bc6a:	e8df f005 	tbb	[pc, r5]
 800bc6e:	1912      	.short	0x1912
 800bc70:	081c161c 	.word	0x081c161c
 800bc74:	0b0f1c05 	.word	0x0b0f1c05
      USBD_GetDescriptor(pdev, req);
 800bc78:	f7ff fe44 	bl	800b904 <USBD_GetDescriptor>
      break;
 800bc7c:	e7f0      	b.n	800bc60 <USBD_StdDevReq+0x24>
      USBD_SetAddress(pdev, req);
 800bc7e:	f7ff ff06 	bl	800ba8e <USBD_SetAddress>
      break;
 800bc82:	e7ed      	b.n	800bc60 <USBD_StdDevReq+0x24>
      ret = USBD_SetConfig(pdev, req);
 800bc84:	f7ff ff2a 	bl	800badc <USBD_SetConfig>
 800bc88:	4604      	mov	r4, r0
      break;
 800bc8a:	e7e9      	b.n	800bc60 <USBD_StdDevReq+0x24>
      USBD_GetConfig(pdev, req);
 800bc8c:	f7ff ff88 	bl	800bba0 <USBD_GetConfig>
      break;
 800bc90:	e7e6      	b.n	800bc60 <USBD_StdDevReq+0x24>
      USBD_GetStatus(pdev, req);
 800bc92:	f7ff ffa4 	bl	800bbde <USBD_GetStatus>
  USBD_StatusTypeDef ret = USBD_OK;
 800bc96:	462c      	mov	r4, r5
      break;
 800bc98:	e7e2      	b.n	800bc60 <USBD_StdDevReq+0x24>
      USBD_SetFeature(pdev, req);
 800bc9a:	f7ff fe0b 	bl	800b8b4 <USBD_SetFeature>
      break;
 800bc9e:	e7df      	b.n	800bc60 <USBD_StdDevReq+0x24>
      USBD_ClrFeature(pdev, req);
 800bca0:	f7ff ffb9 	bl	800bc16 <USBD_ClrFeature>
      break;
 800bca4:	e7dc      	b.n	800bc60 <USBD_StdDevReq+0x24>
      USBD_CtlError(pdev, req);
 800bca6:	f7ff fe23 	bl	800b8f0 <USBD_CtlError>
      break;
 800bcaa:	e7d9      	b.n	800bc60 <USBD_StdDevReq+0x24>

0800bcac <USBD_StdItfReq>:
{
 800bcac:	b570      	push	{r4, r5, r6, lr}
 800bcae:	4605      	mov	r5, r0
 800bcb0:	460c      	mov	r4, r1
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800bcb2:	780b      	ldrb	r3, [r1, #0]
 800bcb4:	f003 0360 	and.w	r3, r3, #96	; 0x60
 800bcb8:	2b20      	cmp	r3, #32
 800bcba:	d007      	beq.n	800bccc <USBD_StdItfReq+0x20>
 800bcbc:	2b40      	cmp	r3, #64	; 0x40
 800bcbe:	d005      	beq.n	800bccc <USBD_StdItfReq+0x20>
 800bcc0:	b123      	cbz	r3, 800bccc <USBD_StdItfReq+0x20>
    USBD_CtlError(pdev, req);
 800bcc2:	f7ff fe15 	bl	800b8f0 <USBD_CtlError>
  USBD_StatusTypeDef ret = USBD_OK;
 800bcc6:	2600      	movs	r6, #0
}
 800bcc8:	4630      	mov	r0, r6
 800bcca:	bd70      	pop	{r4, r5, r6, pc}
    switch (pdev->dev_state)
 800bccc:	f895 329c 	ldrb.w	r3, [r5, #668]	; 0x29c
 800bcd0:	3b01      	subs	r3, #1
 800bcd2:	2b02      	cmp	r3, #2
 800bcd4:	d818      	bhi.n	800bd08 <USBD_StdItfReq+0x5c>
      if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 800bcd6:	7923      	ldrb	r3, [r4, #4]
 800bcd8:	2b01      	cmp	r3, #1
 800bcda:	d80f      	bhi.n	800bcfc <USBD_StdItfReq+0x50>
        ret = (USBD_StatusTypeDef)pdev->pClass->Setup(pdev, req);
 800bcdc:	f8d5 32b8 	ldr.w	r3, [r5, #696]	; 0x2b8
 800bce0:	689b      	ldr	r3, [r3, #8]
 800bce2:	4621      	mov	r1, r4
 800bce4:	4628      	mov	r0, r5
 800bce6:	4798      	blx	r3
 800bce8:	4606      	mov	r6, r0
        if ((req->wLength == 0U) && (ret == USBD_OK))
 800bcea:	88e3      	ldrh	r3, [r4, #6]
 800bcec:	2b00      	cmp	r3, #0
 800bcee:	d1eb      	bne.n	800bcc8 <USBD_StdItfReq+0x1c>
 800bcf0:	2800      	cmp	r0, #0
 800bcf2:	d1e9      	bne.n	800bcc8 <USBD_StdItfReq+0x1c>
          (void)USBD_CtlSendStatus(pdev);
 800bcf4:	4628      	mov	r0, r5
 800bcf6:	f000 f948 	bl	800bf8a <USBD_CtlSendStatus>
 800bcfa:	e7e5      	b.n	800bcc8 <USBD_StdItfReq+0x1c>
        USBD_CtlError(pdev, req);
 800bcfc:	4621      	mov	r1, r4
 800bcfe:	4628      	mov	r0, r5
 800bd00:	f7ff fdf6 	bl	800b8f0 <USBD_CtlError>
  USBD_StatusTypeDef ret = USBD_OK;
 800bd04:	2600      	movs	r6, #0
 800bd06:	e7df      	b.n	800bcc8 <USBD_StdItfReq+0x1c>
      USBD_CtlError(pdev, req);
 800bd08:	4621      	mov	r1, r4
 800bd0a:	4628      	mov	r0, r5
 800bd0c:	f7ff fdf0 	bl	800b8f0 <USBD_CtlError>
  USBD_StatusTypeDef ret = USBD_OK;
 800bd10:	2600      	movs	r6, #0
      break;
 800bd12:	e7d9      	b.n	800bcc8 <USBD_StdItfReq+0x1c>

0800bd14 <USBD_StdEPReq>:
{
 800bd14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800bd16:	4606      	mov	r6, r0
 800bd18:	460d      	mov	r5, r1
  ep_addr = LOBYTE(req->wIndex);
 800bd1a:	888b      	ldrh	r3, [r1, #4]
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800bd1c:	780c      	ldrb	r4, [r1, #0]
 800bd1e:	f004 0460 	and.w	r4, r4, #96	; 0x60
 800bd22:	2c20      	cmp	r4, #32
 800bd24:	d008      	beq.n	800bd38 <USBD_StdEPReq+0x24>
 800bd26:	b2d9      	uxtb	r1, r3
 800bd28:	2c40      	cmp	r4, #64	; 0x40
 800bd2a:	d005      	beq.n	800bd38 <USBD_StdEPReq+0x24>
 800bd2c:	b16c      	cbz	r4, 800bd4a <USBD_StdEPReq+0x36>
    USBD_CtlError(pdev, req);
 800bd2e:	4629      	mov	r1, r5
 800bd30:	f7ff fdde 	bl	800b8f0 <USBD_CtlError>
  USBD_StatusTypeDef ret = USBD_OK;
 800bd34:	2400      	movs	r4, #0
    break;
 800bd36:	e006      	b.n	800bd46 <USBD_StdEPReq+0x32>
    ret = (USBD_StatusTypeDef)pdev->pClass->Setup(pdev, req);
 800bd38:	f8d6 32b8 	ldr.w	r3, [r6, #696]	; 0x2b8
 800bd3c:	689b      	ldr	r3, [r3, #8]
 800bd3e:	4629      	mov	r1, r5
 800bd40:	4630      	mov	r0, r6
 800bd42:	4798      	blx	r3
 800bd44:	4604      	mov	r4, r0
}
 800bd46:	4620      	mov	r0, r4
 800bd48:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch (req->bRequest)
 800bd4a:	786f      	ldrb	r7, [r5, #1]
 800bd4c:	2f01      	cmp	r7, #1
 800bd4e:	d02e      	beq.n	800bdae <USBD_StdEPReq+0x9a>
 800bd50:	2f03      	cmp	r7, #3
 800bd52:	d005      	beq.n	800bd60 <USBD_StdEPReq+0x4c>
 800bd54:	2f00      	cmp	r7, #0
 800bd56:	d056      	beq.n	800be06 <USBD_StdEPReq+0xf2>
      USBD_CtlError(pdev, req);
 800bd58:	4629      	mov	r1, r5
 800bd5a:	f7ff fdc9 	bl	800b8f0 <USBD_CtlError>
      break;
 800bd5e:	e7f2      	b.n	800bd46 <USBD_StdEPReq+0x32>
      switch (pdev->dev_state)
 800bd60:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800bd64:	2b02      	cmp	r3, #2
 800bd66:	d005      	beq.n	800bd74 <USBD_StdEPReq+0x60>
 800bd68:	2b03      	cmp	r3, #3
 800bd6a:	d012      	beq.n	800bd92 <USBD_StdEPReq+0x7e>
        USBD_CtlError(pdev, req);
 800bd6c:	4629      	mov	r1, r5
 800bd6e:	f7ff fdbf 	bl	800b8f0 <USBD_CtlError>
        break;
 800bd72:	e7e8      	b.n	800bd46 <USBD_StdEPReq+0x32>
        if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 800bd74:	b109      	cbz	r1, 800bd7a <USBD_StdEPReq+0x66>
 800bd76:	2980      	cmp	r1, #128	; 0x80
 800bd78:	d104      	bne.n	800bd84 <USBD_StdEPReq+0x70>
          USBD_CtlError(pdev, req);
 800bd7a:	4629      	mov	r1, r5
 800bd7c:	4630      	mov	r0, r6
 800bd7e:	f7ff fdb7 	bl	800b8f0 <USBD_CtlError>
 800bd82:	e7e0      	b.n	800bd46 <USBD_StdEPReq+0x32>
          (void)USBD_LL_StallEP(pdev, ep_addr);
 800bd84:	f002 fffe 	bl	800ed84 <USBD_LL_StallEP>
          (void)USBD_LL_StallEP(pdev, 0x80U);
 800bd88:	2180      	movs	r1, #128	; 0x80
 800bd8a:	4630      	mov	r0, r6
 800bd8c:	f002 fffa 	bl	800ed84 <USBD_LL_StallEP>
 800bd90:	e7d9      	b.n	800bd46 <USBD_StdEPReq+0x32>
        if (req->wValue == USB_FEATURE_EP_HALT)
 800bd92:	886b      	ldrh	r3, [r5, #2]
 800bd94:	b923      	cbnz	r3, 800bda0 <USBD_StdEPReq+0x8c>
          if ((ep_addr != 0x00U) && (ep_addr != 0x80U) && (req->wLength == 0x00U))
 800bd96:	b119      	cbz	r1, 800bda0 <USBD_StdEPReq+0x8c>
 800bd98:	2980      	cmp	r1, #128	; 0x80
 800bd9a:	d001      	beq.n	800bda0 <USBD_StdEPReq+0x8c>
 800bd9c:	88eb      	ldrh	r3, [r5, #6]
 800bd9e:	b11b      	cbz	r3, 800bda8 <USBD_StdEPReq+0x94>
        (void)USBD_CtlSendStatus(pdev);
 800bda0:	4630      	mov	r0, r6
 800bda2:	f000 f8f2 	bl	800bf8a <USBD_CtlSendStatus>
        break;
 800bda6:	e7ce      	b.n	800bd46 <USBD_StdEPReq+0x32>
            (void)USBD_LL_StallEP(pdev, ep_addr);
 800bda8:	f002 ffec 	bl	800ed84 <USBD_LL_StallEP>
 800bdac:	e7f8      	b.n	800bda0 <USBD_StdEPReq+0x8c>
      switch (pdev->dev_state)
 800bdae:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800bdb2:	2b02      	cmp	r3, #2
 800bdb4:	d005      	beq.n	800bdc2 <USBD_StdEPReq+0xae>
 800bdb6:	2b03      	cmp	r3, #3
 800bdb8:	d012      	beq.n	800bde0 <USBD_StdEPReq+0xcc>
        USBD_CtlError(pdev, req);
 800bdba:	4629      	mov	r1, r5
 800bdbc:	f7ff fd98 	bl	800b8f0 <USBD_CtlError>
        break;
 800bdc0:	e7c1      	b.n	800bd46 <USBD_StdEPReq+0x32>
        if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 800bdc2:	b109      	cbz	r1, 800bdc8 <USBD_StdEPReq+0xb4>
 800bdc4:	2980      	cmp	r1, #128	; 0x80
 800bdc6:	d104      	bne.n	800bdd2 <USBD_StdEPReq+0xbe>
          USBD_CtlError(pdev, req);
 800bdc8:	4629      	mov	r1, r5
 800bdca:	4630      	mov	r0, r6
 800bdcc:	f7ff fd90 	bl	800b8f0 <USBD_CtlError>
 800bdd0:	e7b9      	b.n	800bd46 <USBD_StdEPReq+0x32>
          (void)USBD_LL_StallEP(pdev, ep_addr);
 800bdd2:	f002 ffd7 	bl	800ed84 <USBD_LL_StallEP>
          (void)USBD_LL_StallEP(pdev, 0x80U);
 800bdd6:	2180      	movs	r1, #128	; 0x80
 800bdd8:	4630      	mov	r0, r6
 800bdda:	f002 ffd3 	bl	800ed84 <USBD_LL_StallEP>
 800bdde:	e7b2      	b.n	800bd46 <USBD_StdEPReq+0x32>
        if (req->wValue == USB_FEATURE_EP_HALT)
 800bde0:	886b      	ldrh	r3, [r5, #2]
 800bde2:	2b00      	cmp	r3, #0
 800bde4:	d1af      	bne.n	800bd46 <USBD_StdEPReq+0x32>
          if ((ep_addr & 0x7FU) != 0x00U)
 800bde6:	f011 0f7f 	tst.w	r1, #127	; 0x7f
 800bdea:	d109      	bne.n	800be00 <USBD_StdEPReq+0xec>
          (void)USBD_CtlSendStatus(pdev);
 800bdec:	4630      	mov	r0, r6
 800bdee:	f000 f8cc 	bl	800bf8a <USBD_CtlSendStatus>
          (USBD_StatusTypeDef)pdev->pClass->Setup(pdev, req);
 800bdf2:	f8d6 32b8 	ldr.w	r3, [r6, #696]	; 0x2b8
 800bdf6:	689b      	ldr	r3, [r3, #8]
 800bdf8:	4629      	mov	r1, r5
 800bdfa:	4630      	mov	r0, r6
 800bdfc:	4798      	blx	r3
 800bdfe:	e7a2      	b.n	800bd46 <USBD_StdEPReq+0x32>
            (void)USBD_LL_ClearStallEP(pdev, ep_addr);
 800be00:	f002 ffc8 	bl	800ed94 <USBD_LL_ClearStallEP>
 800be04:	e7f2      	b.n	800bdec <USBD_StdEPReq+0xd8>
      switch (pdev->dev_state)
 800be06:	f890 229c 	ldrb.w	r2, [r0, #668]	; 0x29c
 800be0a:	2a02      	cmp	r2, #2
 800be0c:	d006      	beq.n	800be1c <USBD_StdEPReq+0x108>
 800be0e:	2a03      	cmp	r2, #3
 800be10:	d029      	beq.n	800be66 <USBD_StdEPReq+0x152>
        USBD_CtlError(pdev, req);
 800be12:	4629      	mov	r1, r5
 800be14:	f7ff fd6c 	bl	800b8f0 <USBD_CtlError>
  USBD_StatusTypeDef ret = USBD_OK;
 800be18:	463c      	mov	r4, r7
        break;
 800be1a:	e794      	b.n	800bd46 <USBD_StdEPReq+0x32>
        if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 800be1c:	b109      	cbz	r1, 800be22 <USBD_StdEPReq+0x10e>
 800be1e:	2980      	cmp	r1, #128	; 0x80
 800be20:	d113      	bne.n	800be4a <USBD_StdEPReq+0x136>
        pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 800be22:	f013 0f80 	tst.w	r3, #128	; 0x80
 800be26:	d115      	bne.n	800be54 <USBD_StdEPReq+0x140>
              &pdev->ep_out[ep_addr & 0x7FU];
 800be28:	f001 017f 	and.w	r1, r1, #127	; 0x7f
        pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 800be2c:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 800be30:	0089      	lsls	r1, r1, #2
 800be32:	f501 71a8 	add.w	r1, r1, #336	; 0x150
 800be36:	4431      	add	r1, r6
 800be38:	3104      	adds	r1, #4
        pep->status = 0x0000U;
 800be3a:	2300      	movs	r3, #0
 800be3c:	600b      	str	r3, [r1, #0]
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 800be3e:	2202      	movs	r2, #2
 800be40:	4630      	mov	r0, r6
 800be42:	f000 f876 	bl	800bf32 <USBD_CtlSendData>
  USBD_StatusTypeDef ret = USBD_OK;
 800be46:	463c      	mov	r4, r7
        break;
 800be48:	e77d      	b.n	800bd46 <USBD_StdEPReq+0x32>
          USBD_CtlError(pdev, req);
 800be4a:	4629      	mov	r1, r5
 800be4c:	f7ff fd50 	bl	800b8f0 <USBD_CtlError>
  USBD_StatusTypeDef ret = USBD_OK;
 800be50:	463c      	mov	r4, r7
          break;
 800be52:	e778      	b.n	800bd46 <USBD_StdEPReq+0x32>
        pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 800be54:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 800be58:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 800be5c:	0089      	lsls	r1, r1, #2
 800be5e:	3110      	adds	r1, #16
 800be60:	4431      	add	r1, r6
 800be62:	3104      	adds	r1, #4
 800be64:	e7e9      	b.n	800be3a <USBD_StdEPReq+0x126>
        if ((ep_addr & 0x80U) == 0x80U)
 800be66:	b25b      	sxtb	r3, r3
 800be68:	2b00      	cmp	r3, #0
 800be6a:	db1f      	blt.n	800beac <USBD_StdEPReq+0x198>
          if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 800be6c:	f001 020f 	and.w	r2, r1, #15
 800be70:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800be74:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 800be78:	f8b2 2164 	ldrh.w	r2, [r2, #356]	; 0x164
 800be7c:	b322      	cbz	r2, 800bec8 <USBD_StdEPReq+0x1b4>
        pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 800be7e:	2b00      	cmp	r3, #0
 800be80:	db27      	blt.n	800bed2 <USBD_StdEPReq+0x1be>
              &pdev->ep_out[ep_addr & 0x7FU];
 800be82:	f001 037f 	and.w	r3, r1, #127	; 0x7f
        pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 800be86:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800be8a:	009c      	lsls	r4, r3, #2
 800be8c:	f504 74a8 	add.w	r4, r4, #336	; 0x150
 800be90:	4434      	add	r4, r6
 800be92:	3404      	adds	r4, #4
          if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 800be94:	b109      	cbz	r1, 800be9a <USBD_StdEPReq+0x186>
 800be96:	2980      	cmp	r1, #128	; 0x80
 800be98:	d124      	bne.n	800bee4 <USBD_StdEPReq+0x1d0>
            pep->status = 0x0000U;
 800be9a:	2300      	movs	r3, #0
 800be9c:	6023      	str	r3, [r4, #0]
          (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 800be9e:	2202      	movs	r2, #2
 800bea0:	4621      	mov	r1, r4
 800bea2:	4630      	mov	r0, r6
 800bea4:	f000 f845 	bl	800bf32 <USBD_CtlSendData>
  USBD_StatusTypeDef ret = USBD_OK;
 800bea8:	463c      	mov	r4, r7
          break;
 800beaa:	e74c      	b.n	800bd46 <USBD_StdEPReq+0x32>
          if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 800beac:	f001 020f 	and.w	r2, r1, #15
 800beb0:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800beb4:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 800beb8:	8c92      	ldrh	r2, [r2, #36]	; 0x24
 800beba:	2a00      	cmp	r2, #0
 800bebc:	d1df      	bne.n	800be7e <USBD_StdEPReq+0x16a>
            USBD_CtlError(pdev, req);
 800bebe:	4629      	mov	r1, r5
 800bec0:	f7ff fd16 	bl	800b8f0 <USBD_CtlError>
  USBD_StatusTypeDef ret = USBD_OK;
 800bec4:	463c      	mov	r4, r7
            break;
 800bec6:	e73e      	b.n	800bd46 <USBD_StdEPReq+0x32>
            USBD_CtlError(pdev, req);
 800bec8:	4629      	mov	r1, r5
 800beca:	f7ff fd11 	bl	800b8f0 <USBD_CtlError>
  USBD_StatusTypeDef ret = USBD_OK;
 800bece:	463c      	mov	r4, r7
            break;
 800bed0:	e739      	b.n	800bd46 <USBD_StdEPReq+0x32>
        pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 800bed2:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 800bed6:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800beda:	009c      	lsls	r4, r3, #2
 800bedc:	3410      	adds	r4, #16
 800bede:	4434      	add	r4, r6
 800bee0:	3404      	adds	r4, #4
 800bee2:	e7d7      	b.n	800be94 <USBD_StdEPReq+0x180>
          else if (USBD_LL_IsStallEP(pdev, ep_addr) != 0U)
 800bee4:	4630      	mov	r0, r6
 800bee6:	f002 ff0b 	bl	800ed00 <USBD_LL_IsStallEP>
 800beea:	b110      	cbz	r0, 800bef2 <USBD_StdEPReq+0x1de>
            pep->status = 0x0001U;
 800beec:	2301      	movs	r3, #1
 800beee:	6023      	str	r3, [r4, #0]
 800bef0:	e7d5      	b.n	800be9e <USBD_StdEPReq+0x18a>
            pep->status = 0x0000U;
 800bef2:	2300      	movs	r3, #0
 800bef4:	6023      	str	r3, [r4, #0]
 800bef6:	e7d2      	b.n	800be9e <USBD_StdEPReq+0x18a>

0800bef8 <USBD_GetString>:
  if (desc == NULL)
 800bef8:	b1d0      	cbz	r0, 800bf30 <USBD_GetString+0x38>
{
 800befa:	b570      	push	{r4, r5, r6, lr}
 800befc:	460d      	mov	r5, r1
 800befe:	4616      	mov	r6, r2
 800bf00:	4604      	mov	r4, r0
  *len = ((uint16_t)USBD_GetLen(pdesc) * 2U) + 2U;
 800bf02:	f7ff fccd 	bl	800b8a0 <USBD_GetLen>
 800bf06:	1c43      	adds	r3, r0, #1
 800bf08:	005b      	lsls	r3, r3, #1
 800bf0a:	b29b      	uxth	r3, r3
 800bf0c:	8033      	strh	r3, [r6, #0]
  unicode[idx] = *(uint8_t *)len;
 800bf0e:	702b      	strb	r3, [r5, #0]
  unicode[idx] = USB_DESC_TYPE_STRING;
 800bf10:	2303      	movs	r3, #3
 800bf12:	706b      	strb	r3, [r5, #1]
  idx++;
 800bf14:	2302      	movs	r3, #2
  while (*pdesc != (uint8_t)'\0')
 800bf16:	e007      	b.n	800bf28 <USBD_GetString+0x30>
    unicode[idx] = *pdesc;
 800bf18:	54ea      	strb	r2, [r5, r3]
    pdesc++;
 800bf1a:	3401      	adds	r4, #1
    idx++;
 800bf1c:	1c5a      	adds	r2, r3, #1
 800bf1e:	b2d2      	uxtb	r2, r2
    unicode[idx] = 0U;
 800bf20:	2100      	movs	r1, #0
 800bf22:	54a9      	strb	r1, [r5, r2]
    idx++;
 800bf24:	3302      	adds	r3, #2
 800bf26:	b2db      	uxtb	r3, r3
  while (*pdesc != (uint8_t)'\0')
 800bf28:	7822      	ldrb	r2, [r4, #0]
 800bf2a:	2a00      	cmp	r2, #0
 800bf2c:	d1f4      	bne.n	800bf18 <USBD_GetString+0x20>
}
 800bf2e:	bd70      	pop	{r4, r5, r6, pc}
 800bf30:	4770      	bx	lr

0800bf32 <USBD_CtlSendData>:
* @param  len: length of data to be sent
* @retval status
*/
USBD_StatusTypeDef USBD_CtlSendData(USBD_HandleTypeDef *pdev,
                                    uint8_t *pbuf, uint32_t len)
{
 800bf32:	b508      	push	{r3, lr}
 800bf34:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 800bf36:	2202      	movs	r2, #2
 800bf38:	f8c0 2294 	str.w	r2, [r0, #660]	; 0x294
  pdev->ep_in[0].total_length = len;
 800bf3c:	6183      	str	r3, [r0, #24]
  pdev->ep_in[0].rem_length = len;
 800bf3e:	61c3      	str	r3, [r0, #28]

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 800bf40:	460a      	mov	r2, r1
 800bf42:	2100      	movs	r1, #0
 800bf44:	f002 ff36 	bl	800edb4 <USBD_LL_Transmit>

  return USBD_OK;
}
 800bf48:	2000      	movs	r0, #0
 800bf4a:	bd08      	pop	{r3, pc}

0800bf4c <USBD_CtlContinueSendData>:
* @param  len: length of data to be sent
* @retval status
*/
USBD_StatusTypeDef USBD_CtlContinueSendData(USBD_HandleTypeDef *pdev,
                                            uint8_t *pbuf, uint32_t len)
{
 800bf4c:	b508      	push	{r3, lr}
 800bf4e:	4613      	mov	r3, r2
  /* Start the next transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 800bf50:	460a      	mov	r2, r1
 800bf52:	2100      	movs	r1, #0
 800bf54:	f002 ff2e 	bl	800edb4 <USBD_LL_Transmit>

  return USBD_OK;
}
 800bf58:	2000      	movs	r0, #0
 800bf5a:	bd08      	pop	{r3, pc}

0800bf5c <USBD_CtlPrepareRx>:
* @param  len: length of data to be received
* @retval status
*/
USBD_StatusTypeDef USBD_CtlPrepareRx(USBD_HandleTypeDef *pdev,
                                     uint8_t *pbuf, uint32_t len)
{
 800bf5c:	b508      	push	{r3, lr}
 800bf5e:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 800bf60:	2203      	movs	r2, #3
 800bf62:	f8c0 2294 	str.w	r2, [r0, #660]	; 0x294
  pdev->ep_out[0].total_length = len;
 800bf66:	f8c0 3158 	str.w	r3, [r0, #344]	; 0x158
  pdev->ep_out[0].rem_length = len;
 800bf6a:	f8c0 315c 	str.w	r3, [r0, #348]	; 0x15c

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 800bf6e:	460a      	mov	r2, r1
 800bf70:	2100      	movs	r1, #0
 800bf72:	f002 ff27 	bl	800edc4 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 800bf76:	2000      	movs	r0, #0
 800bf78:	bd08      	pop	{r3, pc}

0800bf7a <USBD_CtlContinueRx>:
* @param  len: length of data to be received
* @retval status
*/
USBD_StatusTypeDef USBD_CtlContinueRx(USBD_HandleTypeDef *pdev,
                                      uint8_t *pbuf, uint32_t len)
{
 800bf7a:	b508      	push	{r3, lr}
 800bf7c:	4613      	mov	r3, r2
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 800bf7e:	460a      	mov	r2, r1
 800bf80:	2100      	movs	r1, #0
 800bf82:	f002 ff1f 	bl	800edc4 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 800bf86:	2000      	movs	r0, #0
 800bf88:	bd08      	pop	{r3, pc}

0800bf8a <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_CtlSendStatus(USBD_HandleTypeDef *pdev)
{
 800bf8a:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 800bf8c:	2304      	movs	r3, #4
 800bf8e:	f8c0 3294 	str.w	r3, [r0, #660]	; 0x294

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 800bf92:	2300      	movs	r3, #0
 800bf94:	461a      	mov	r2, r3
 800bf96:	4619      	mov	r1, r3
 800bf98:	f002 ff0c 	bl	800edb4 <USBD_LL_Transmit>

  return USBD_OK;
}
 800bf9c:	2000      	movs	r0, #0
 800bf9e:	bd08      	pop	{r3, pc}

0800bfa0 <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_CtlReceiveStatus(USBD_HandleTypeDef *pdev)
{
 800bfa0:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 800bfa2:	2305      	movs	r3, #5
 800bfa4:	f8c0 3294 	str.w	r3, [r0, #660]	; 0x294

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 800bfa8:	2300      	movs	r3, #0
 800bfaa:	461a      	mov	r2, r3
 800bfac:	4619      	mov	r1, r3
 800bfae:	f002 ff09 	bl	800edc4 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 800bfb2:	2000      	movs	r0, #0
 800bfb4:	bd08      	pop	{r3, pc}

0800bfb6 <__enable_irq>:
  __ASM volatile ("cpsie i" : : : "memory");
 800bfb6:	b662      	cpsie	i
}
 800bfb8:	4770      	bx	lr

0800bfba <__disable_irq>:
  __ASM volatile ("cpsid i" : : : "memory");
 800bfba:	b672      	cpsid	i
}
 800bfbc:	4770      	bx	lr

0800bfbe <motor_iterator>:

static void motor_iterator (motor_iterator_callback_ptr callback)
{
    motor_map_t motor;

    if(callback) for(motor.id = 0; motor.id < N_AXIS + N_GANGED; motor.id++)
 800bfbe:	b180      	cbz	r0, 800bfe2 <motor_iterator+0x24>
{
 800bfc0:	b570      	push	{r4, r5, r6, lr}
 800bfc2:	4606      	mov	r6, r0
    if(callback) for(motor.id = 0; motor.id < N_AXIS + N_GANGED; motor.id++)
 800bfc4:	2500      	movs	r5, #0
 800bfc6:	f36f 0507 	bfc	r5, #0, #8
 800bfca:	e006      	b.n	800bfda <motor_iterator+0x1c>
    {
        if(motor.id < N_AXIS)
            motor.axis = motor.id;
 800bfcc:	f364 250f 	bfi	r5, r4, #8, #8
            case Z2_MOTOR:
                motor.axis = Z_AXIS;
                break;
#endif
        }
        callback(motor);
 800bfd0:	4628      	mov	r0, r5
 800bfd2:	47b0      	blx	r6
    if(callback) for(motor.id = 0; motor.id < N_AXIS + N_GANGED; motor.id++)
 800bfd4:	3401      	adds	r4, #1
 800bfd6:	f364 0507 	bfi	r5, r4, #0, #8
 800bfda:	b2ec      	uxtb	r4, r5
 800bfdc:	2c02      	cmp	r4, #2
 800bfde:	d9f5      	bls.n	800bfcc <motor_iterator+0xe>
    }
}
 800bfe0:	bd70      	pop	{r4, r5, r6, pc}
 800bfe2:	4770      	bx	lr

0800bfe4 <get_limits_cap>:

static limit_signals_t get_limits_cap (void)
{
 800bfe4:	b082      	sub	sp, #8
    limit_signals_t limits = {0};
 800bfe6:	2000      	movs	r0, #0
 800bfe8:	9000      	str	r0, [sp, #0]

#if X_LIMIT_BIT
    limits.min.x = On;
 800bfea:	f89d 3000 	ldrb.w	r3, [sp]
 800bfee:	f043 0301 	orr.w	r3, r3, #1
 800bff2:	f88d 3000 	strb.w	r3, [sp]
#endif
#if Y_LIMIT_BIT
    limits.min.y = On;
 800bff6:	b2db      	uxtb	r3, r3
 800bff8:	f043 0302 	orr.w	r3, r3, #2
 800bffc:	f88d 3000 	strb.w	r3, [sp]
#endif
#if Z_LIMIT_BIT
    limits.min.z = On;
 800c000:	b2db      	uxtb	r3, r3
 800c002:	f043 0304 	orr.w	r3, r3, #4
 800c006:	f88d 3000 	strb.w	r3, [sp]
#endif
#if V_LIMIT_BIT_MAX
    limits.max.v = On;
#endif

    return limits;
 800c00a:	9b00      	ldr	r3, [sp, #0]
 800c00c:	9301      	str	r3, [sp, #4]
 800c00e:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800c012:	f363 0007 	bfi	r0, r3, #0, #8
 800c016:	f89d 3005 	ldrb.w	r3, [sp, #5]
 800c01a:	f363 200f 	bfi	r0, r3, #8, #8
 800c01e:	f89d 3006 	ldrb.w	r3, [sp, #6]
 800c022:	f363 4017 	bfi	r0, r3, #16, #8
 800c026:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800c02a:	f363 601f 	bfi	r0, r3, #24, #8
}
 800c02e:	b002      	add	sp, #8
 800c030:	4770      	bx	lr
	...

0800c034 <stepdirmap_init>:
{
    uint_fast8_t i;

#if STEP_OUTMODE == GPIO_MAP

    i = sizeof(step_outmap) / sizeof(uint32_t);
 800c034:	2308      	movs	r3, #8
    do {
        i--;
 800c036:	3b01      	subs	r3, #1
        step_outmap[i] = c_step_outmap[i ^ settings->steppers.step_invert.value];
 800c038:	f890 20e8 	ldrb.w	r2, [r0, #232]	; 0xe8
 800c03c:	405a      	eors	r2, r3
 800c03e:	490b      	ldr	r1, [pc, #44]	; (800c06c <stepdirmap_init+0x38>)
 800c040:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
 800c044:	4a0a      	ldr	r2, [pc, #40]	; (800c070 <stepdirmap_init+0x3c>)
 800c046:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    } while(i);
 800c04a:	2b00      	cmp	r3, #0
 800c04c:	d1f3      	bne.n	800c036 <stepdirmap_init+0x2>
#endif

#if DIRECTION_OUTMODE == GPIO_MAP
    i = sizeof(dir_outmap) / sizeof(uint32_t);
 800c04e:	2308      	movs	r3, #8
    do {
        i--;
 800c050:	3b01      	subs	r3, #1
        dir_outmap[i] = c_dir_outmap[i ^ settings->steppers.dir_invert.value];
 800c052:	f890 20e9 	ldrb.w	r2, [r0, #233]	; 0xe9
 800c056:	405a      	eors	r2, r3
 800c058:	4906      	ldr	r1, [pc, #24]	; (800c074 <stepdirmap_init+0x40>)
 800c05a:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
 800c05e:	4a06      	ldr	r2, [pc, #24]	; (800c078 <stepdirmap_init+0x44>)
 800c060:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    } while(i);
 800c064:	2b00      	cmp	r3, #0
 800c066:	d1f3      	bne.n	800c050 <stepdirmap_init+0x1c>
#endif
}
 800c068:	4770      	bx	lr
 800c06a:	bf00      	nop
 800c06c:	08025408 	.word	0x08025408
 800c070:	2000074c 	.word	0x2000074c
 800c074:	080253e8 	.word	0x080253e8
 800c078:	20000694 	.word	0x20000694

0800c07c <stepperEnable>:
}

// Enable/disable stepper motors
static void stepperEnable (axes_signals_t enable)
{
    enable.mask ^= settings.steppers.enable_invert.mask;
 800c07c:	4b04      	ldr	r3, [pc, #16]	; (800c090 <stepperEnable+0x14>)
 800c07e:	f893 30eb 	ldrb.w	r3, [r3, #235]	; 0xeb
 800c082:	4043      	eors	r3, r0
#if !TRINAMIC_MOTOR_ENABLE
  #ifdef STEPPERS_ENABLE_PORT
    DIGITAL_OUT(STEPPERS_ENABLE_PORT, STEPPERS_ENABLE_PIN, enable.x);
 800c084:	f3c3 0300 	ubfx	r3, r3, #0, #1
 800c088:	4a02      	ldr	r2, [pc, #8]	; (800c094 <stepperEnable+0x18>)
 800c08a:	f882 30bc 	strb.w	r3, [r2, #188]	; 0xbc
   #ifdef C_ENABLE_PORT
    DIGITAL_OUT(C_ENABLE_PORT, C_ENABLE_PIN, enable.c);
   #endif
  #endif
#endif
}
 800c08e:	4770      	bx	lr
 800c090:	20003b14 	.word	0x20003b14
 800c094:	42400200 	.word	0x42400200

0800c098 <stepperWakeUp>:

// Starts stepper driver ISR timer and forces a stepper driver interrupt callback
static void stepperWakeUp (void)
{
 800c098:	b508      	push	{r3, lr}
    stepperEnable((axes_signals_t){AXES_BITMASK});
 800c09a:	f04f 0007 	mov.w	r0, #7
 800c09e:	f7ff ffed 	bl	800c07c <stepperEnable>

    STEPPER_TIMER->ARR = hal.f_step_timer / 500; // ~2ms delay to allow drivers time to wake up.
 800c0a2:	4b09      	ldr	r3, [pc, #36]	; (800c0c8 <stepperWakeUp+0x30>)
 800c0a4:	69da      	ldr	r2, [r3, #28]
 800c0a6:	4b09      	ldr	r3, [pc, #36]	; (800c0cc <stepperWakeUp+0x34>)
 800c0a8:	fba3 3202 	umull	r3, r2, r3, r2
 800c0ac:	0952      	lsrs	r2, r2, #5
 800c0ae:	4b08      	ldr	r3, [pc, #32]	; (800c0d0 <stepperWakeUp+0x38>)
 800c0b0:	62da      	str	r2, [r3, #44]	; 0x2c
    STEPPER_TIMER->EGR = TIM_EGR_UG;
 800c0b2:	2201      	movs	r2, #1
 800c0b4:	615a      	str	r2, [r3, #20]
    STEPPER_TIMER->SR = ~TIM_SR_UIF;
 800c0b6:	f06f 0201 	mvn.w	r2, #1
 800c0ba:	611a      	str	r2, [r3, #16]
    STEPPER_TIMER->CR1 |= TIM_CR1_CEN;
 800c0bc:	681a      	ldr	r2, [r3, #0]
 800c0be:	f042 0201 	orr.w	r2, r2, #1
 800c0c2:	601a      	str	r2, [r3, #0]
}
 800c0c4:	bd08      	pop	{r3, pc}
 800c0c6:	bf00      	nop
 800c0c8:	2000350c 	.word	0x2000350c
 800c0cc:	10624dd3 	.word	0x10624dd3
 800c0d0:	40000c00 	.word	0x40000c00

0800c0d4 <stepperGoIdle>:

// Disables stepper driver interrupts
static void stepperGoIdle (bool clear_signals)
{
    STEPPER_TIMER->CR1 &= ~TIM_CR1_CEN;
 800c0d4:	4b03      	ldr	r3, [pc, #12]	; (800c0e4 <stepperGoIdle+0x10>)
 800c0d6:	681a      	ldr	r2, [r3, #0]
 800c0d8:	f022 0201 	bic.w	r2, r2, #1
 800c0dc:	601a      	str	r2, [r3, #0]
    STEPPER_TIMER->CNT = 0;
 800c0de:	2200      	movs	r2, #0
 800c0e0:	625a      	str	r2, [r3, #36]	; 0x24
}
 800c0e2:	4770      	bx	lr
 800c0e4:	40000c00 	.word	0x40000c00

0800c0e8 <stepperCyclesPerTick>:

// Sets up stepper driver interrupt timeout, "Normal" version
static void stepperCyclesPerTick (uint32_t cycles_per_tick)
{
    STEPPER_TIMER->ARR = cycles_per_tick < (1UL << 20) ? cycles_per_tick : 0x000FFFFFUL;
 800c0e8:	4b03      	ldr	r3, [pc, #12]	; (800c0f8 <stepperCyclesPerTick+0x10>)
 800c0ea:	4298      	cmp	r0, r3
 800c0ec:	bf28      	it	cs
 800c0ee:	4618      	movcs	r0, r3
 800c0f0:	4b02      	ldr	r3, [pc, #8]	; (800c0fc <stepperCyclesPerTick+0x14>)
 800c0f2:	62d8      	str	r0, [r3, #44]	; 0x2c
}
 800c0f4:	4770      	bx	lr
 800c0f6:	bf00      	nop
 800c0f8:	000fffff 	.word	0x000fffff
 800c0fc:	40000c00 	.word	0x40000c00

0800c100 <stepperPulseStart>:
        hal.stepper.pulse_start(stepper);
        return;
    }
#endif

    if(stepper->dir_change)
 800c100:	7b43      	ldrb	r3, [r0, #13]
 800c102:	b153      	cbz	r3, 800c11a <stepperPulseStart+0x1a>
    DIRECTION_PORT->ODR = (DIRECTION_PORT->ODR & ~DIRECTION_MASK) | dir_outmap[dir_outbits.value];
 800c104:	4a0e      	ldr	r2, [pc, #56]	; (800c140 <stepperPulseStart+0x40>)
 800c106:	6953      	ldr	r3, [r2, #20]
 800c108:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800c10c:	f890 c00f 	ldrb.w	ip, [r0, #15]
 800c110:	490c      	ldr	r1, [pc, #48]	; (800c144 <stepperPulseStart+0x44>)
 800c112:	f851 102c 	ldr.w	r1, [r1, ip, lsl #2]
 800c116:	430b      	orrs	r3, r1
 800c118:	6153      	str	r3, [r2, #20]
        stepperSetDirOutputs(stepper->dir_outbits);

    if(stepper->step_outbits.value) {
 800c11a:	7b82      	ldrb	r2, [r0, #14]
 800c11c:	b17a      	cbz	r2, 800c13e <stepperPulseStart+0x3e>
    STEP_PORT->ODR = (STEP_PORT->ODR & ~STEP_MASK) | step_outmap[step_outbits.value];
 800c11e:	4908      	ldr	r1, [pc, #32]	; (800c140 <stepperPulseStart+0x40>)
 800c120:	694b      	ldr	r3, [r1, #20]
 800c122:	f023 0307 	bic.w	r3, r3, #7
 800c126:	4808      	ldr	r0, [pc, #32]	; (800c148 <stepperPulseStart+0x48>)
 800c128:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 800c12c:	4313      	orrs	r3, r2
 800c12e:	614b      	str	r3, [r1, #20]
        stepperSetStepOutputs(stepper->step_outbits);
        PULSE_TIMER->EGR = TIM_EGR_UG;
 800c130:	4b06      	ldr	r3, [pc, #24]	; (800c14c <stepperPulseStart+0x4c>)
 800c132:	2201      	movs	r2, #1
 800c134:	615a      	str	r2, [r3, #20]
        PULSE_TIMER->CR1 |= TIM_CR1_CEN;
 800c136:	681a      	ldr	r2, [r3, #0]
 800c138:	f042 0201 	orr.w	r2, r2, #1
 800c13c:	601a      	str	r2, [r3, #0]
    }
}
 800c13e:	4770      	bx	lr
 800c140:	40020000 	.word	0x40020000
 800c144:	20000694 	.word	0x20000694
 800c148:	2000074c 	.word	0x2000074c
 800c14c:	40000800 	.word	0x40000800

0800c150 <stepperPulseStartDelayed>:
        hal.stepper.pulse_start(stepper);
        return;
    }
#endif

    if(stepper->dir_change) {
 800c150:	7b43      	ldrb	r3, [r0, #13]
 800c152:	b993      	cbnz	r3, 800c17a <stepperPulseStartDelayed+0x2a>
        }

        return;
    }

    if(stepper->step_outbits.value) {
 800c154:	7b82      	ldrb	r2, [r0, #14]
 800c156:	b17a      	cbz	r2, 800c178 <stepperPulseStartDelayed+0x28>
    STEP_PORT->ODR = (STEP_PORT->ODR & ~STEP_MASK) | step_outmap[step_outbits.value];
 800c158:	4916      	ldr	r1, [pc, #88]	; (800c1b4 <stepperPulseStartDelayed+0x64>)
 800c15a:	694b      	ldr	r3, [r1, #20]
 800c15c:	f023 0307 	bic.w	r3, r3, #7
 800c160:	4815      	ldr	r0, [pc, #84]	; (800c1b8 <stepperPulseStartDelayed+0x68>)
 800c162:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 800c166:	4313      	orrs	r3, r2
 800c168:	614b      	str	r3, [r1, #20]
        stepperSetStepOutputs(stepper->step_outbits);
        PULSE_TIMER->EGR = TIM_EGR_UG;
 800c16a:	4b14      	ldr	r3, [pc, #80]	; (800c1bc <stepperPulseStartDelayed+0x6c>)
 800c16c:	2201      	movs	r2, #1
 800c16e:	615a      	str	r2, [r3, #20]
        PULSE_TIMER->CR1 |= TIM_CR1_CEN;
 800c170:	681a      	ldr	r2, [r3, #0]
 800c172:	f042 0201 	orr.w	r2, r2, #1
 800c176:	601a      	str	r2, [r3, #0]
    }
}
 800c178:	4770      	bx	lr
    DIRECTION_PORT->ODR = (DIRECTION_PORT->ODR & ~DIRECTION_MASK) | dir_outmap[dir_outbits.value];
 800c17a:	4a0e      	ldr	r2, [pc, #56]	; (800c1b4 <stepperPulseStartDelayed+0x64>)
 800c17c:	6953      	ldr	r3, [r2, #20]
 800c17e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800c182:	f890 c00f 	ldrb.w	ip, [r0, #15]
 800c186:	490e      	ldr	r1, [pc, #56]	; (800c1c0 <stepperPulseStartDelayed+0x70>)
 800c188:	f851 102c 	ldr.w	r1, [r1, ip, lsl #2]
 800c18c:	430b      	orrs	r3, r1
 800c18e:	6153      	str	r3, [r2, #20]
        if(stepper->step_outbits.value) {
 800c190:	7b83      	ldrb	r3, [r0, #14]
 800c192:	2b00      	cmp	r3, #0
 800c194:	d0f0      	beq.n	800c178 <stepperPulseStartDelayed+0x28>
            next_step_outbits = stepper->step_outbits; // Store out_bits
 800c196:	461a      	mov	r2, r3
 800c198:	4b0a      	ldr	r3, [pc, #40]	; (800c1c4 <stepperPulseStartDelayed+0x74>)
 800c19a:	701a      	strb	r2, [r3, #0]
            PULSE_TIMER->ARR = pulse_delay;
 800c19c:	4b0a      	ldr	r3, [pc, #40]	; (800c1c8 <stepperPulseStartDelayed+0x78>)
 800c19e:	681a      	ldr	r2, [r3, #0]
 800c1a0:	4b06      	ldr	r3, [pc, #24]	; (800c1bc <stepperPulseStartDelayed+0x6c>)
 800c1a2:	62da      	str	r2, [r3, #44]	; 0x2c
            PULSE_TIMER->EGR = TIM_EGR_UG;
 800c1a4:	2201      	movs	r2, #1
 800c1a6:	615a      	str	r2, [r3, #20]
            PULSE_TIMER->CR1 |= TIM_CR1_CEN;
 800c1a8:	681a      	ldr	r2, [r3, #0]
 800c1aa:	f042 0201 	orr.w	r2, r2, #1
 800c1ae:	601a      	str	r2, [r3, #0]
        return;
 800c1b0:	4770      	bx	lr
 800c1b2:	bf00      	nop
 800c1b4:	40020000 	.word	0x40020000
 800c1b8:	2000074c 	.word	0x2000074c
 800c1bc:	40000800 	.word	0x40000800
 800c1c0:	20000694 	.word	0x20000694
 800c1c4:	200006b8 	.word	0x200006b8
 800c1c8:	200006ec 	.word	0x200006ec

0800c1cc <limitsEnable>:
#endif

// Enable/disable limit pins interrupt
static void limitsEnable (bool on, bool homing)
{
    if((limits_irq_enabled = on)) {
 800c1cc:	4b09      	ldr	r3, [pc, #36]	; (800c1f4 <limitsEnable+0x28>)
 800c1ce:	7018      	strb	r0, [r3, #0]
 800c1d0:	b148      	cbz	r0, 800c1e6 <limitsEnable+0x1a>
        EXTI->PR |= LIMIT_MASK;     // Clear any pending limit interrupts
 800c1d2:	4b09      	ldr	r3, [pc, #36]	; (800c1f8 <limitsEnable+0x2c>)
 800c1d4:	695a      	ldr	r2, [r3, #20]
 800c1d6:	f442 42e0 	orr.w	r2, r2, #28672	; 0x7000
 800c1da:	615a      	str	r2, [r3, #20]
        EXTI->IMR |= LIMIT_MASK;    // and enable
 800c1dc:	681a      	ldr	r2, [r3, #0]
 800c1de:	f442 42e0 	orr.w	r2, r2, #28672	; 0x7000
 800c1e2:	601a      	str	r2, [r3, #0]
 800c1e4:	4770      	bx	lr
    } else
        EXTI->IMR &= ~LIMIT_MASK;
 800c1e6:	4a04      	ldr	r2, [pc, #16]	; (800c1f8 <limitsEnable+0x2c>)
 800c1e8:	6813      	ldr	r3, [r2, #0]
 800c1ea:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800c1ee:	6013      	str	r3, [r2, #0]
}
 800c1f0:	4770      	bx	lr
 800c1f2:	bf00      	nop
 800c1f4:	200006b4 	.word	0x200006b4
 800c1f8:	40013c00 	.word	0x40013c00

0800c1fc <limitsGetState>:

// Returns limit state as an axes_signals_t variable.
// Each bitfield bit indicates an axis limit, where triggered is 1 and not triggered is 0.
inline static limit_signals_t limitsGetState (void)
{
 800c1fc:	b082      	sub	sp, #8
    limit_signals_t signals = {0};
 800c1fe:	2300      	movs	r3, #0
 800c200:	9300      	str	r3, [sp, #0]

    signals.min.mask = settings.limits.invert.mask;
 800c202:	4b12      	ldr	r3, [pc, #72]	; (800c24c <limitsGetState+0x50>)
 800c204:	f893 3125 	ldrb.w	r3, [r3, #293]	; 0x125
 800c208:	f88d 3000 	strb.w	r3, [sp]
  #endif
  #ifdef C_LIMIT_PIN
    signals.min.c = !!(bits & C_LIMIT_BIT);
  #endif
#else
    signals.min.value = (uint8_t)((LIMIT_PORT->IDR & LIMIT_MASK) >> LIMIT_INMODE);
 800c20c:	4a10      	ldr	r2, [pc, #64]	; (800c250 <limitsGetState+0x54>)
 800c20e:	6912      	ldr	r2, [r2, #16]
 800c210:	f3c2 3202 	ubfx	r2, r2, #12, #3
 800c214:	f88d 2000 	strb.w	r2, [sp]
#endif
#ifdef Z_LIMIT_PIN_MAX
    signals.max.z = DIGITAL_IN(Z_LIMIT_PORT_MAX, Z_LIMIT_PIN_MAX);
#endif

    if (settings.limits.invert.mask) {
 800c218:	b113      	cbz	r3, 800c220 <limitsGetState+0x24>
        signals.min.value ^= settings.limits.invert.mask;
 800c21a:	4053      	eors	r3, r2
 800c21c:	f88d 3000 	strb.w	r3, [sp]
#ifdef MAX_LIMIT_SWITCHES
        signals.max.value ^= settings.limits.invert.mask;
#endif
    }

    return signals;
 800c220:	9b00      	ldr	r3, [sp, #0]
 800c222:	9301      	str	r3, [sp, #4]
 800c224:	2000      	movs	r0, #0
 800c226:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800c22a:	f363 0007 	bfi	r0, r3, #0, #8
 800c22e:	f89d 3005 	ldrb.w	r3, [sp, #5]
 800c232:	f363 200f 	bfi	r0, r3, #8, #8
 800c236:	f89d 3006 	ldrb.w	r3, [sp, #6]
 800c23a:	f363 4017 	bfi	r0, r3, #16, #8
 800c23e:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800c242:	f363 601f 	bfi	r0, r3, #24, #8
}
 800c246:	b002      	add	sp, #8
 800c248:	4770      	bx	lr
 800c24a:	bf00      	nop
 800c24c:	20003b14 	.word	0x20003b14
 800c250:	40020400 	.word	0x40020400

0800c254 <systemGetState>:
// Each bitfield bit indicates a control signal, where triggered is 1 and not triggered is 0.
static control_signals_t systemGetState (void)
{
    control_signals_t signals;

    signals.mask = settings.control_invert.mask;
 800c254:	4b09      	ldr	r3, [pc, #36]	; (800c27c <systemGetState+0x28>)
 800c256:	f8b3 206c 	ldrh.w	r2, [r3, #108]	; 0x6c
    signals.cycle_start = !!(bits & CYCLE_START_BIT);
  #ifdef SAFETY_DOOR_PIN
    signals.safety_door_ajar = !!(bits & SAFETY_DOOR_BIT);
  #endif
#else
    signals.value = (uint8_t)((CONTROL_PORT->IDR & CONTROL_MASK) >> CONTROL_INMODE);
 800c25a:	4909      	ldr	r1, [pc, #36]	; (800c280 <systemGetState+0x2c>)
 800c25c:	6908      	ldr	r0, [r1, #16]
 800c25e:	f3c0 1042 	ubfx	r0, r0, #5, #3
  #ifndef SAFETY_DOOR_PIN
    signals.safety_door_ajar = settings.control_invert.safety_door_ajar;
 800c262:	f893 306c 	ldrb.w	r3, [r3, #108]	; 0x6c
 800c266:	f3c3 01c0 	ubfx	r1, r3, #3, #1
 800c26a:	f361 00c3 	bfi	r0, r1, #3, #1
  #endif
  #if ESTOP_ENABLE
    signals.e_stop = signals.reset;
 800c26e:	f360 1086 	bfi	r0, r0, #6, #1
    signals.reset = settings.control_invert.reset;
 800c272:	f363 0000 	bfi	r0, r3, #0, #1
  #endif
#endif

    if(settings.control_invert.mask)
 800c276:	b102      	cbz	r2, 800c27a <systemGetState+0x26>
        signals.value ^= settings.control_invert.mask;
 800c278:	4050      	eors	r0, r2

    return signals;
}
 800c27a:	4770      	bx	lr
 800c27c:	20003b14 	.word	0x20003b14
 800c280:	40020400 	.word	0x40020400

0800c284 <probeConnectedToggle>:
#ifdef PROBE_PIN

// Toggle probe connected status. Used when no input pin is available.
static void probeConnectedToggle (void)
{
    probe.connected = !probe.connected;
 800c284:	4904      	ldr	r1, [pc, #16]	; (800c298 <probeConnectedToggle+0x14>)
 800c286:	780b      	ldrb	r3, [r1, #0]
 800c288:	085a      	lsrs	r2, r3, #1
 800c28a:	f082 0201 	eor.w	r2, r2, #1
 800c28e:	f362 0341 	bfi	r3, r2, #1, #1
 800c292:	700b      	strb	r3, [r1, #0]
}
 800c294:	4770      	bx	lr
 800c296:	bf00      	nop
 800c298:	20000328 	.word	0x20000328

0800c29c <probeConfigure>:
// Sets up the probe pin invert mask to
// appropriately set the pin logic according to setting for normal-high/normal-low operation
// and the probing cycle modes for toward-workpiece/away-from-workpiece.
static void probeConfigure (bool is_probe_away, bool probing)
{
    probe.inverted = is_probe_away ? !settings.probe.invert_probe_pin : settings.probe.invert_probe_pin;
 800c29c:	b1a0      	cbz	r0, 800c2c8 <probeConfigure+0x2c>
 800c29e:	4b0d      	ldr	r3, [pc, #52]	; (800c2d4 <probeConfigure+0x38>)
 800c2a0:	f893 2100 	ldrb.w	r2, [r3, #256]	; 0x100
 800c2a4:	f082 0201 	eor.w	r2, r2, #1
 800c2a8:	f002 0201 	and.w	r2, r2, #1
 800c2ac:	4b0a      	ldr	r3, [pc, #40]	; (800c2d8 <probeConfigure+0x3c>)
 800c2ae:	7818      	ldrb	r0, [r3, #0]
 800c2b0:	f362 0082 	bfi	r0, r2, #2, #1
 800c2b4:	7018      	strb	r0, [r3, #0]
#if PROBE_IRQ_BIT
    probe.triggered = hal.probe.get_state().triggered;
    gpio_irq_enable(probe_input, probing && !probe.triggered ? (probe.inverted ? IRQ_Mode_Falling : IRQ_Mode_Rising) : IRQ_Mode_None);
#else
    probe.triggered = Off;
 800c2b6:	b2c2      	uxtb	r2, r0
 800c2b8:	f36f 0200 	bfc	r2, #0, #1
 800c2bc:	701a      	strb	r2, [r3, #0]
#endif
    probe.is_probing = probing;
 800c2be:	b2d2      	uxtb	r2, r2
 800c2c0:	f361 02c3 	bfi	r2, r1, #3, #1
 800c2c4:	701a      	strb	r2, [r3, #0]
}
 800c2c6:	4770      	bx	lr
    probe.inverted = is_probe_away ? !settings.probe.invert_probe_pin : settings.probe.invert_probe_pin;
 800c2c8:	4b02      	ldr	r3, [pc, #8]	; (800c2d4 <probeConfigure+0x38>)
 800c2ca:	f893 2100 	ldrb.w	r2, [r3, #256]	; 0x100
 800c2ce:	f002 0201 	and.w	r2, r2, #1
 800c2d2:	e7eb      	b.n	800c2ac <probeConfigure+0x10>
 800c2d4:	20003b14 	.word	0x20003b14
 800c2d8:	20000328 	.word	0x20000328

0800c2dc <probeGetState>:

// Returns the probe connected and triggered pin states.
static probe_state_t probeGetState (void)
{
    probe_state_t state = {0};
 800c2dc:	f04f 0000 	mov.w	r0, #0

    state.connected = probe.connected;
 800c2e0:	4b06      	ldr	r3, [pc, #24]	; (800c2fc <probeGetState+0x20>)
 800c2e2:	781b      	ldrb	r3, [r3, #0]
 800c2e4:	f3c3 0240 	ubfx	r2, r3, #1, #1
 800c2e8:	f362 0041 	bfi	r0, r2, #1, #1
#if PROBE_IRQ_BIT
    state.triggered = probe.is_probing ? probe.triggered : DIGITAL_IN(PROBE_PORT, PROBE_PIN) ^ probe.inverted;
#else
    state.triggered = DIGITAL_IN(PROBE_PORT, PROBE_PIN) ^ probe.inverted;
 800c2ec:	4a04      	ldr	r2, [pc, #16]	; (800c300 <probeGetState+0x24>)
 800c2ee:	7f12      	ldrb	r2, [r2, #28]
 800c2f0:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800c2f4:	4053      	eors	r3, r2
 800c2f6:	f363 0000 	bfi	r0, r3, #0, #1
#endif
    return state;
}
 800c2fa:	4770      	bx	lr
 800c2fc:	20000328 	.word	0x20000328
 800c300:	42400200 	.word	0x42400200

0800c304 <spindleSetState>:
#endif

// Start or stop spindle
static void spindleSetState (spindle_state_t state, float rpm)
{
    if (!state.on)
 800c304:	f010 0f01 	tst.w	r0, #1
 800c308:	d108      	bne.n	800c31c <spindleSetState+0x18>
    DIGITAL_OUT(SPINDLE_ENABLE_PORT, SPINDLE_ENABLE_PIN, settings.spindle.invert.on);
 800c30a:	4b0e      	ldr	r3, [pc, #56]	; (800c344 <spindleSetState+0x40>)
 800c30c:	f893 30e6 	ldrb.w	r3, [r3, #230]	; 0xe6
 800c310:	f3c3 0300 	ubfx	r3, r3, #0, #1
 800c314:	4a0c      	ldr	r2, [pc, #48]	; (800c348 <spindleSetState+0x44>)
 800c316:	f882 3084 	strb.w	r3, [r2, #132]	; 0x84
}
 800c31a:	4770      	bx	lr
        spindle_off();
    else {
#ifdef SPINDLE_DIRECTION_PIN
        spindle_dir(state.ccw);
 800c31c:	f3c0 0040 	ubfx	r0, r0, #1, #1
    DIGITAL_OUT(SPINDLE_DIRECTION_PORT, SPINDLE_DIRECTION_PIN, ccw ^ settings.spindle.invert.ccw);
 800c320:	4908      	ldr	r1, [pc, #32]	; (800c344 <spindleSetState+0x40>)
 800c322:	f891 30e6 	ldrb.w	r3, [r1, #230]	; 0xe6
 800c326:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800c32a:	4058      	eors	r0, r3
 800c32c:	4a06      	ldr	r2, [pc, #24]	; (800c348 <spindleSetState+0x44>)
 800c32e:	f882 0080 	strb.w	r0, [r2, #128]	; 0x80
    DIGITAL_OUT(SPINDLE_ENABLE_PORT, SPINDLE_ENABLE_PIN, !settings.spindle.invert.on);
 800c332:	f891 30e6 	ldrb.w	r3, [r1, #230]	; 0xe6
 800c336:	f083 0301 	eor.w	r3, r3, #1
 800c33a:	f003 0301 	and.w	r3, r3, #1
 800c33e:	f882 3084 	strb.w	r3, [r2, #132]	; 0x84
#endif
        spindle_on();
    }
}
 800c342:	4770      	bx	lr
 800c344:	20003b14 	.word	0x20003b14
 800c348:	42408200 	.word	0x42408200

0800c34c <spindle_set_speed>:
#ifdef SPINDLE_PWM_TIMER_N

// Sets spindle speed
static void spindle_set_speed (uint_fast16_t pwm_value)
{
    if (pwm_value == spindle_pwm.off_value) {
 800c34c:	4b1f      	ldr	r3, [pc, #124]	; (800c3cc <spindle_set_speed+0x80>)
 800c34e:	685b      	ldr	r3, [r3, #4]
 800c350:	4283      	cmp	r3, r0
 800c352:	d016      	beq.n	800c382 <spindle_set_speed+0x36>
            SPINDLE_PWM_TIMER->BDTR &= ~TIM_BDTR_MOE; // Set PWM output low
#else
            SPINDLE_PWM_TIMER_CCR = 0;
#endif
    } else {
        if(!pwmEnabled) {
 800c354:	4b1e      	ldr	r3, [pc, #120]	; (800c3d0 <spindle_set_speed+0x84>)
 800c356:	781b      	ldrb	r3, [r3, #0]
 800c358:	b963      	cbnz	r3, 800c374 <spindle_set_speed+0x28>
    DIGITAL_OUT(SPINDLE_ENABLE_PORT, SPINDLE_ENABLE_PIN, !settings.spindle.invert.on);
 800c35a:	4b1e      	ldr	r3, [pc, #120]	; (800c3d4 <spindle_set_speed+0x88>)
 800c35c:	f893 30e6 	ldrb.w	r3, [r3, #230]	; 0xe6
 800c360:	f083 0301 	eor.w	r3, r3, #1
 800c364:	f003 0301 	and.w	r3, r3, #1
 800c368:	4a1b      	ldr	r2, [pc, #108]	; (800c3d8 <spindle_set_speed+0x8c>)
 800c36a:	f882 3084 	strb.w	r3, [r2, #132]	; 0x84
            spindle_on();
            pwmEnabled = true;
 800c36e:	4b18      	ldr	r3, [pc, #96]	; (800c3d0 <spindle_set_speed+0x84>)
 800c370:	2201      	movs	r2, #1
 800c372:	701a      	strb	r2, [r3, #0]
        }
        SPINDLE_PWM_TIMER_CCR = pwm_value;
 800c374:	4b19      	ldr	r3, [pc, #100]	; (800c3dc <spindle_set_speed+0x90>)
 800c376:	6358      	str	r0, [r3, #52]	; 0x34
#if SPINDLE_PWM_TIMER_N == 1
        SPINDLE_PWM_TIMER->BDTR |= TIM_BDTR_MOE;
 800c378:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800c37a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800c37e:	645a      	str	r2, [r3, #68]	; 0x44
#endif
    }
}
 800c380:	4770      	bx	lr
        pwmEnabled = false;
 800c382:	4b13      	ldr	r3, [pc, #76]	; (800c3d0 <spindle_set_speed+0x84>)
 800c384:	2200      	movs	r2, #0
 800c386:	701a      	strb	r2, [r3, #0]
        if(settings.spindle.flags.enable_rpm_controlled)
 800c388:	4b12      	ldr	r3, [pc, #72]	; (800c3d4 <spindle_set_speed+0x88>)
 800c38a:	f893 30e7 	ldrb.w	r3, [r3, #231]	; 0xe7
 800c38e:	f013 0f01 	tst.w	r3, #1
 800c392:	d007      	beq.n	800c3a4 <spindle_set_speed+0x58>
    DIGITAL_OUT(SPINDLE_ENABLE_PORT, SPINDLE_ENABLE_PIN, settings.spindle.invert.on);
 800c394:	4b0f      	ldr	r3, [pc, #60]	; (800c3d4 <spindle_set_speed+0x88>)
 800c396:	f893 30e6 	ldrb.w	r3, [r3, #230]	; 0xe6
 800c39a:	f3c3 0300 	ubfx	r3, r3, #0, #1
 800c39e:	4a0e      	ldr	r2, [pc, #56]	; (800c3d8 <spindle_set_speed+0x8c>)
 800c3a0:	f882 3084 	strb.w	r3, [r2, #132]	; 0x84
        if(spindle_pwm.always_on) {
 800c3a4:	4b09      	ldr	r3, [pc, #36]	; (800c3cc <spindle_set_speed+0x80>)
 800c3a6:	7e5b      	ldrb	r3, [r3, #25]
 800c3a8:	b14b      	cbz	r3, 800c3be <spindle_set_speed+0x72>
            SPINDLE_PWM_TIMER_CCR = spindle_pwm.off_value;
 800c3aa:	4b08      	ldr	r3, [pc, #32]	; (800c3cc <spindle_set_speed+0x80>)
 800c3ac:	685a      	ldr	r2, [r3, #4]
 800c3ae:	4b0b      	ldr	r3, [pc, #44]	; (800c3dc <spindle_set_speed+0x90>)
 800c3b0:	635a      	str	r2, [r3, #52]	; 0x34
            SPINDLE_PWM_TIMER->BDTR |= TIM_BDTR_MOE;
 800c3b2:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800c3b4:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800c3b8:	645a      	str	r2, [r3, #68]	; 0x44
            SPINDLE_PWM_TIMER_CCR = pwm_value;
 800c3ba:	6358      	str	r0, [r3, #52]	; 0x34
 800c3bc:	4770      	bx	lr
            SPINDLE_PWM_TIMER->BDTR &= ~TIM_BDTR_MOE; // Set PWM output low
 800c3be:	4a07      	ldr	r2, [pc, #28]	; (800c3dc <spindle_set_speed+0x90>)
 800c3c0:	6c53      	ldr	r3, [r2, #68]	; 0x44
 800c3c2:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800c3c6:	6453      	str	r3, [r2, #68]	; 0x44
 800c3c8:	4770      	bx	lr
 800c3ca:	bf00      	nop
 800c3cc:	200006f8 	.word	0x200006f8
 800c3d0:	200006f4 	.word	0x200006f4
 800c3d4:	20003b14 	.word	0x20003b14
 800c3d8:	42408200 	.word	0x42408200
 800c3dc:	40010000 	.word	0x40010000

0800c3e0 <spindleGetState>:
#endif // SPINDLE_PWM_TIMER_N

// Returns spindle state in a spindle_state_t variable
static spindle_state_t spindleGetState (void)
{
    spindle_state_t state = {settings.spindle.invert.mask};
 800c3e0:	4b06      	ldr	r3, [pc, #24]	; (800c3fc <spindleGetState+0x1c>)
 800c3e2:	f893 00e6 	ldrb.w	r0, [r3, #230]	; 0xe6
 800c3e6:	4603      	mov	r3, r0

#ifdef SPINDLE_ENABLE_PIN
    state.on = DIGITAL_IN(SPINDLE_ENABLE_PORT, SPINDLE_ENABLE_PIN);
 800c3e8:	4a05      	ldr	r2, [pc, #20]	; (800c400 <spindleGetState+0x20>)
 800c3ea:	7911      	ldrb	r1, [r2, #4]
 800c3ec:	f361 0300 	bfi	r3, r1, #0, #1
#endif
#ifdef SPINDLE_DIRECTION_PIN
    state.ccw = DIGITAL_IN(SPINDLE_DIRECTION_PORT, SPINDLE_DIRECTION_PIN);
 800c3f0:	7812      	ldrb	r2, [r2, #0]
 800c3f2:	f362 0341 	bfi	r3, r2, #1, #1
#endif
    state.value ^= settings.spindle.invert.mask;
 800c3f6:	4058      	eors	r0, r3
    state.at_speed = settings.spindle.at_speed_tolerance <= 0.0f || (rpm >= spindle_data.rpm_low_limit && rpm <= spindle_data.rpm_high_limit);
    state.encoder_error = spindle_encoder.error_count > 0;
#endif

    return state;
}
 800c3f8:	4770      	bx	lr
 800c3fa:	bf00      	nop
 800c3fc:	20003b14 	.word	0x20003b14
 800c400:	42408200 	.word	0x42408200

0800c404 <coolantSetState>:
#endif // DRIVER_SPINDLE

// Start/stop coolant (and mist if enabled)
static void coolantSetState (coolant_state_t mode)
{
    mode.value ^= settings.coolant_invert.mask;
 800c404:	4b06      	ldr	r3, [pc, #24]	; (800c420 <coolantSetState+0x1c>)
 800c406:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
 800c40a:	4058      	eors	r0, r3
    DIGITAL_OUT(COOLANT_FLOOD_PORT, COOLANT_FLOOD_PIN, mode.flood);
 800c40c:	f3c0 0200 	ubfx	r2, r0, #0, #1
 800c410:	4b04      	ldr	r3, [pc, #16]	; (800c424 <coolantSetState+0x20>)
 800c412:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90
#ifdef COOLANT_MIST_PIN
    DIGITAL_OUT(COOLANT_MIST_PORT, COOLANT_MIST_PIN, mode.mist);
 800c416:	f3c0 0040 	ubfx	r0, r0, #1, #1
 800c41a:	f883 008c 	strb.w	r0, [r3, #140]	; 0x8c
#endif
}
 800c41e:	4770      	bx	lr
 800c420:	20003b14 	.word	0x20003b14
 800c424:	42408200 	.word	0x42408200

0800c428 <coolantGetState>:

// Returns coolant state in a coolant_state_t variable
static coolant_state_t coolantGetState (void)
{
    coolant_state_t state = (coolant_state_t){settings.coolant_invert.mask};
 800c428:	4b06      	ldr	r3, [pc, #24]	; (800c444 <coolantGetState+0x1c>)
 800c42a:	f893 0070 	ldrb.w	r0, [r3, #112]	; 0x70
 800c42e:	4603      	mov	r3, r0

    state.flood = DIGITAL_IN(COOLANT_FLOOD_PORT, COOLANT_FLOOD_PIN);
 800c430:	4a05      	ldr	r2, [pc, #20]	; (800c448 <coolantGetState+0x20>)
 800c432:	7c11      	ldrb	r1, [r2, #16]
 800c434:	f361 0300 	bfi	r3, r1, #0, #1
#ifdef COOLANT_MIST_PIN
    state.mist  = DIGITAL_IN(COOLANT_MIST_PORT, COOLANT_MIST_PIN);
 800c438:	7b12      	ldrb	r2, [r2, #12]
 800c43a:	f362 0341 	bfi	r3, r2, #1, #1
#endif
    state.value ^= settings.coolant_invert.mask;
 800c43e:	4058      	eors	r0, r3

    return state;
}
 800c440:	4770      	bx	lr
 800c442:	bf00      	nop
 800c444:	20003b14 	.word	0x20003b14
 800c448:	42408200 	.word	0x42408200

0800c44c <bitsSetAtomic>:
  __ASM volatile ("cpsid i" : : : "memory");
 800c44c:	b672      	cpsid	i

// Helper functions for setting/clearing/inverting individual bits atomically (uninterruptable)
static void bitsSetAtomic (volatile uint_fast16_t *ptr, uint_fast16_t bits)
{
    __disable_irq();
    *ptr |= bits;
 800c44e:	6803      	ldr	r3, [r0, #0]
 800c450:	4319      	orrs	r1, r3
 800c452:	6001      	str	r1, [r0, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 800c454:	b662      	cpsie	i
    __enable_irq();
}
 800c456:	4770      	bx	lr

0800c458 <bitsClearAtomic>:

static uint_fast16_t bitsClearAtomic (volatile uint_fast16_t *ptr, uint_fast16_t bits)
{
 800c458:	4603      	mov	r3, r0
  __ASM volatile ("cpsid i" : : : "memory");
 800c45a:	b672      	cpsid	i
    __disable_irq();
    uint_fast16_t prev = *ptr;
 800c45c:	6800      	ldr	r0, [r0, #0]
    *ptr &= ~bits;
 800c45e:	681a      	ldr	r2, [r3, #0]
 800c460:	ea22 0101 	bic.w	r1, r2, r1
 800c464:	6019      	str	r1, [r3, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 800c466:	b662      	cpsie	i
    __enable_irq();
    return prev;
}
 800c468:	4770      	bx	lr

0800c46a <valueSetAtomic>:

static uint_fast16_t valueSetAtomic (volatile uint_fast16_t *ptr, uint_fast16_t value)
{
 800c46a:	4603      	mov	r3, r0
  __ASM volatile ("cpsid i" : : : "memory");
 800c46c:	b672      	cpsid	i
    __disable_irq();
    uint_fast16_t prev = *ptr;
 800c46e:	6800      	ldr	r0, [r0, #0]
    *ptr = value;
 800c470:	6019      	str	r1, [r3, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 800c472:	b662      	cpsie	i
    __enable_irq();
    return prev;
}
 800c474:	4770      	bx	lr
	...

0800c478 <getElapsedTicks>:

#endif

static uint32_t getElapsedTicks (void)
{
    return uwTick;
 800c478:	4b01      	ldr	r3, [pc, #4]	; (800c480 <getElapsedTicks+0x8>)
 800c47a:	6818      	ldr	r0, [r3, #0]
}
 800c47c:	4770      	bx	lr
 800c47e:	bf00      	nop
 800c480:	2000064c 	.word	0x2000064c

0800c484 <port2char>:

static char *port2char (GPIO_TypeDef *port)
{
    static char name[3] = "P?";

    name[1] = 'A' + GPIO_GET_INDEX(port);
 800c484:	4b19      	ldr	r3, [pc, #100]	; (800c4ec <port2char+0x68>)
 800c486:	4298      	cmp	r0, r3
 800c488:	d01f      	beq.n	800c4ca <port2char+0x46>
 800c48a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800c48e:	4298      	cmp	r0, r3
 800c490:	d01f      	beq.n	800c4d2 <port2char+0x4e>
 800c492:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800c496:	4298      	cmp	r0, r3
 800c498:	d01d      	beq.n	800c4d6 <port2char+0x52>
 800c49a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800c49e:	4298      	cmp	r0, r3
 800c4a0:	d01b      	beq.n	800c4da <port2char+0x56>
 800c4a2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800c4a6:	4298      	cmp	r0, r3
 800c4a8:	d019      	beq.n	800c4de <port2char+0x5a>
 800c4aa:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800c4ae:	4298      	cmp	r0, r3
 800c4b0:	d017      	beq.n	800c4e2 <port2char+0x5e>
 800c4b2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800c4b6:	4298      	cmp	r0, r3
 800c4b8:	d015      	beq.n	800c4e6 <port2char+0x62>
 800c4ba:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800c4be:	4298      	cmp	r0, r3
 800c4c0:	d001      	beq.n	800c4c6 <port2char+0x42>
 800c4c2:	2349      	movs	r3, #73	; 0x49
 800c4c4:	e002      	b.n	800c4cc <port2char+0x48>
 800c4c6:	2348      	movs	r3, #72	; 0x48
 800c4c8:	e000      	b.n	800c4cc <port2char+0x48>
 800c4ca:	2341      	movs	r3, #65	; 0x41
 800c4cc:	4808      	ldr	r0, [pc, #32]	; (800c4f0 <port2char+0x6c>)
 800c4ce:	7043      	strb	r3, [r0, #1]

    return name;
}
 800c4d0:	4770      	bx	lr
    name[1] = 'A' + GPIO_GET_INDEX(port);
 800c4d2:	2342      	movs	r3, #66	; 0x42
 800c4d4:	e7fa      	b.n	800c4cc <port2char+0x48>
 800c4d6:	2343      	movs	r3, #67	; 0x43
 800c4d8:	e7f8      	b.n	800c4cc <port2char+0x48>
 800c4da:	2344      	movs	r3, #68	; 0x44
 800c4dc:	e7f6      	b.n	800c4cc <port2char+0x48>
 800c4de:	2345      	movs	r3, #69	; 0x45
 800c4e0:	e7f4      	b.n	800c4cc <port2char+0x48>
 800c4e2:	2346      	movs	r3, #70	; 0x46
 800c4e4:	e7f2      	b.n	800c4cc <port2char+0x48>
 800c4e6:	2347      	movs	r3, #71	; 0x47
 800c4e8:	e7f0      	b.n	800c4cc <port2char+0x48>
 800c4ea:	bf00      	nop
 800c4ec:	40020000 	.word	0x40020000
 800c4f0:	2000021c 	.word	0x2000021c

0800c4f4 <enumeratePins>:

static void enumeratePins (bool low_level, pin_info_ptr pin_info, void *data)
{
 800c4f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c4f6:	4605      	mov	r5, r0
 800c4f8:	460e      	mov	r6, r1
 800c4fa:	4617      	mov	r7, r2
    static xbar_t pin = {0};
    uint32_t i = sizeof(inputpin) / sizeof(input_signal_t);

    pin.mode.input = On;
 800c4fc:	4a47      	ldr	r2, [pc, #284]	; (800c61c <enumeratePins+0x128>)
 800c4fe:	7e13      	ldrb	r3, [r2, #24]
 800c500:	f043 0301 	orr.w	r3, r3, #1
 800c504:	7613      	strb	r3, [r2, #24]

    for(i = 0; i < sizeof(inputpin) / sizeof(input_signal_t); i++) {
 800c506:	2400      	movs	r4, #0
 800c508:	e01d      	b.n	800c546 <enumeratePins+0x52>
        pin.pin = inputpin[i].pin;
        pin.function = inputpin[i].id;
        pin.group = inputpin[i].group;
        pin.port = low_level ? (void *)inputpin[i].port : (void *)port2char(inputpin[i].port);
 800c50a:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
 800c50e:	4b44      	ldr	r3, [pc, #272]	; (800c620 <enumeratePins+0x12c>)
 800c510:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800c514:	6858      	ldr	r0, [r3, #4]
 800c516:	f7ff ffb5 	bl	800c484 <port2char>
 800c51a:	4603      	mov	r3, r0
 800c51c:	483f      	ldr	r0, [pc, #252]	; (800c61c <enumeratePins+0x128>)
 800c51e:	6083      	str	r3, [r0, #8]
        pin.description = inputpin[i].description;
 800c520:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
 800c524:	4b3e      	ldr	r3, [pc, #248]	; (800c620 <enumeratePins+0x12c>)
 800c526:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800c52a:	6a1b      	ldr	r3, [r3, #32]
 800c52c:	60c3      	str	r3, [r0, #12]
        pin.mode.pwm = pin.group == PinGroup_SpindlePWM;
 800c52e:	6843      	ldr	r3, [r0, #4]
 800c530:	2b01      	cmp	r3, #1
 800c532:	bf14      	ite	ne
 800c534:	2300      	movne	r3, #0
 800c536:	2301      	moveq	r3, #1
 800c538:	7e42      	ldrb	r2, [r0, #25]
 800c53a:	f363 0282 	bfi	r2, r3, #2, #1
 800c53e:	7642      	strb	r2, [r0, #25]

        pin_info(&pin, data);
 800c540:	4639      	mov	r1, r7
 800c542:	47b0      	blx	r6
    for(i = 0; i < sizeof(inputpin) / sizeof(input_signal_t); i++) {
 800c544:	3401      	adds	r4, #1
 800c546:	2c06      	cmp	r4, #6
 800c548:	d815      	bhi.n	800c576 <enumeratePins+0x82>
        pin.pin = inputpin[i].pin;
 800c54a:	4935      	ldr	r1, [pc, #212]	; (800c620 <enumeratePins+0x12c>)
 800c54c:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 800c550:	eb01 0280 	add.w	r2, r1, r0, lsl #2
 800c554:	f892 c008 	ldrb.w	ip, [r2, #8]
 800c558:	4b30      	ldr	r3, [pc, #192]	; (800c61c <enumeratePins+0x128>)
 800c55a:	f8c3 c010 	str.w	ip, [r3, #16]
        pin.function = inputpin[i].id;
 800c55e:	f811 1020 	ldrb.w	r1, [r1, r0, lsl #2]
 800c562:	7019      	strb	r1, [r3, #0]
        pin.group = inputpin[i].group;
 800c564:	6912      	ldr	r2, [r2, #16]
 800c566:	605a      	str	r2, [r3, #4]
        pin.port = low_level ? (void *)inputpin[i].port : (void *)port2char(inputpin[i].port);
 800c568:	2d00      	cmp	r5, #0
 800c56a:	d0ce      	beq.n	800c50a <enumeratePins+0x16>
 800c56c:	4b2c      	ldr	r3, [pc, #176]	; (800c620 <enumeratePins+0x12c>)
 800c56e:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800c572:	685b      	ldr	r3, [r3, #4]
 800c574:	e7d2      	b.n	800c51c <enumeratePins+0x28>
    };

    pin.mode.mask = 0;
 800c576:	4b29      	ldr	r3, [pc, #164]	; (800c61c <enumeratePins+0x128>)
 800c578:	2400      	movs	r4, #0
 800c57a:	831c      	strh	r4, [r3, #24]
    pin.mode.output = On;
 800c57c:	7e1a      	ldrb	r2, [r3, #24]
 800c57e:	f042 0202 	orr.w	r2, r2, #2
 800c582:	761a      	strb	r2, [r3, #24]

    for(i = 0; i < sizeof(outputpin) / sizeof(output_signal_t); i++) {
 800c584:	e014      	b.n	800c5b0 <enumeratePins+0xbc>
        pin.pin = outputpin[i].pin;
        pin.function = outputpin[i].id;
        pin.group = outputpin[i].group;
        pin.port = low_level ? (void *)outputpin[i].port : (void *)port2char(outputpin[i].port);
 800c586:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 800c58a:	4b26      	ldr	r3, [pc, #152]	; (800c624 <enumeratePins+0x130>)
 800c58c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800c590:	6858      	ldr	r0, [r3, #4]
 800c592:	f7ff ff77 	bl	800c484 <port2char>
 800c596:	4603      	mov	r3, r0
 800c598:	4820      	ldr	r0, [pc, #128]	; (800c61c <enumeratePins+0x128>)
 800c59a:	6083      	str	r3, [r0, #8]
        pin.description = outputpin[i].description;
 800c59c:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 800c5a0:	4b20      	ldr	r3, [pc, #128]	; (800c624 <enumeratePins+0x130>)
 800c5a2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800c5a6:	695b      	ldr	r3, [r3, #20]
 800c5a8:	60c3      	str	r3, [r0, #12]

        pin_info(&pin, data);
 800c5aa:	4639      	mov	r1, r7
 800c5ac:	47b0      	blx	r6
    for(i = 0; i < sizeof(outputpin) / sizeof(output_signal_t); i++) {
 800c5ae:	3401      	adds	r4, #1
 800c5b0:	2c0a      	cmp	r4, #10
 800c5b2:	d815      	bhi.n	800c5e0 <enumeratePins+0xec>
        pin.pin = outputpin[i].pin;
 800c5b4:	491b      	ldr	r1, [pc, #108]	; (800c624 <enumeratePins+0x130>)
 800c5b6:	eb04 0044 	add.w	r0, r4, r4, lsl #1
 800c5ba:	eb01 02c0 	add.w	r2, r1, r0, lsl #3
 800c5be:	f892 c008 	ldrb.w	ip, [r2, #8]
 800c5c2:	4b16      	ldr	r3, [pc, #88]	; (800c61c <enumeratePins+0x128>)
 800c5c4:	f8c3 c010 	str.w	ip, [r3, #16]
        pin.function = outputpin[i].id;
 800c5c8:	f811 1030 	ldrb.w	r1, [r1, r0, lsl #3]
 800c5cc:	7019      	strb	r1, [r3, #0]
        pin.group = outputpin[i].group;
 800c5ce:	68d2      	ldr	r2, [r2, #12]
 800c5d0:	605a      	str	r2, [r3, #4]
        pin.port = low_level ? (void *)outputpin[i].port : (void *)port2char(outputpin[i].port);
 800c5d2:	2d00      	cmp	r5, #0
 800c5d4:	d0d7      	beq.n	800c586 <enumeratePins+0x92>
 800c5d6:	4b13      	ldr	r3, [pc, #76]	; (800c624 <enumeratePins+0x130>)
 800c5d8:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 800c5dc:	685b      	ldr	r3, [r3, #4]
 800c5de:	e7db      	b.n	800c598 <enumeratePins+0xa4>
    };

    periph_signal_t *ppin = periph_pins;
 800c5e0:	4b11      	ldr	r3, [pc, #68]	; (800c628 <enumeratePins+0x134>)
 800c5e2:	681c      	ldr	r4, [r3, #0]

    if(ppin) do {
 800c5e4:	b97c      	cbnz	r4, 800c606 <enumeratePins+0x112>

        pin_info(&pin, data);

        ppin = ppin->next;
    } while(ppin);
}
 800c5e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        pin.port = low_level ? ppin->pin.port : (void *)port2char(ppin->pin.port);
 800c5e8:	68a0      	ldr	r0, [r4, #8]
 800c5ea:	f7ff ff4b 	bl	800c484 <port2char>
 800c5ee:	4603      	mov	r3, r0
 800c5f0:	480a      	ldr	r0, [pc, #40]	; (800c61c <enumeratePins+0x128>)
 800c5f2:	6083      	str	r3, [r0, #8]
        pin.mode = ppin->pin.mode;
 800c5f4:	8a23      	ldrh	r3, [r4, #16]
 800c5f6:	8303      	strh	r3, [r0, #24]
        pin.description = ppin->pin.description;
 800c5f8:	6963      	ldr	r3, [r4, #20]
 800c5fa:	60c3      	str	r3, [r0, #12]
        pin_info(&pin, data);
 800c5fc:	4639      	mov	r1, r7
 800c5fe:	47b0      	blx	r6
        ppin = ppin->next;
 800c600:	69a4      	ldr	r4, [r4, #24]
    } while(ppin);
 800c602:	2c00      	cmp	r4, #0
 800c604:	d0ef      	beq.n	800c5e6 <enumeratePins+0xf2>
        pin.pin = ppin->pin.pin;
 800c606:	68e2      	ldr	r2, [r4, #12]
 800c608:	4b04      	ldr	r3, [pc, #16]	; (800c61c <enumeratePins+0x128>)
 800c60a:	611a      	str	r2, [r3, #16]
        pin.function = ppin->pin.function;
 800c60c:	7822      	ldrb	r2, [r4, #0]
 800c60e:	701a      	strb	r2, [r3, #0]
        pin.group = ppin->pin.group;
 800c610:	6862      	ldr	r2, [r4, #4]
 800c612:	605a      	str	r2, [r3, #4]
        pin.port = low_level ? ppin->pin.port : (void *)port2char(ppin->pin.port);
 800c614:	2d00      	cmp	r5, #0
 800c616:	d0e7      	beq.n	800c5e8 <enumeratePins+0xf4>
 800c618:	68a3      	ldr	r3, [r4, #8]
 800c61a:	e7e9      	b.n	800c5f0 <enumeratePins+0xfc>
 800c61c:	200006c0 	.word	0x200006c0
 800c620:	20000120 	.word	0x20000120
 800c624:	20000220 	.word	0x20000220
 800c628:	200006bc 	.word	0x200006bc

0800c62c <setPeriphPinDescription>:
    }
}

void setPeriphPinDescription (const pin_function_t function, const pin_group_t group, const char *description)
{
    periph_signal_t *ppin = periph_pins;
 800c62c:	4b0d      	ldr	r3, [pc, #52]	; (800c664 <setPeriphPinDescription+0x38>)
 800c62e:	681b      	ldr	r3, [r3, #0]

    if(ppin) do {
 800c630:	b933      	cbnz	r3, 800c640 <setPeriphPinDescription+0x14>
 800c632:	4770      	bx	lr
        if(ppin->pin.function == function && ppin->pin.group == group) {
            ppin->pin.description = description;
 800c634:	615a      	str	r2, [r3, #20]
            ppin = NULL;
        } else
            ppin = ppin->next;
    } while(ppin);
}
 800c636:	f85d 4b04 	ldr.w	r4, [sp], #4
 800c63a:	4770      	bx	lr
            ppin = ppin->next;
 800c63c:	699b      	ldr	r3, [r3, #24]
    } while(ppin);
 800c63e:	b17b      	cbz	r3, 800c660 <setPeriphPinDescription+0x34>
        if(ppin->pin.function == function && ppin->pin.group == group) {
 800c640:	f893 c000 	ldrb.w	ip, [r3]
 800c644:	4584      	cmp	ip, r0
 800c646:	d1f9      	bne.n	800c63c <setPeriphPinDescription+0x10>
{
 800c648:	b410      	push	{r4}
        if(ppin->pin.function == function && ppin->pin.group == group) {
 800c64a:	685c      	ldr	r4, [r3, #4]
 800c64c:	428c      	cmp	r4, r1
 800c64e:	d0f1      	beq.n	800c634 <setPeriphPinDescription+0x8>
            ppin = ppin->next;
 800c650:	699b      	ldr	r3, [r3, #24]
    } while(ppin);
 800c652:	2b00      	cmp	r3, #0
 800c654:	d0ef      	beq.n	800c636 <setPeriphPinDescription+0xa>
        if(ppin->pin.function == function && ppin->pin.group == group) {
 800c656:	f893 c000 	ldrb.w	ip, [r3]
 800c65a:	4584      	cmp	ip, r0
 800c65c:	d1f8      	bne.n	800c650 <setPeriphPinDescription+0x24>
 800c65e:	e7f4      	b.n	800c64a <setPeriphPinDescription+0x1e>
 800c660:	4770      	bx	lr
 800c662:	bf00      	nop
 800c664:	200006bc 	.word	0x200006bc

0800c668 <spindleConfig>:
    if(spindle == NULL)
 800c668:	2800      	cmp	r0, #0
 800c66a:	f000 80a1 	beq.w	800c7b0 <spindleConfig+0x148>
{
 800c66e:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c670:	b08d      	sub	sp, #52	; 0x34
 800c672:	4605      	mov	r5, r0
    HAL_RCC_GetClockConfig(&clock, &latency);
 800c674:	a906      	add	r1, sp, #24
 800c676:	a807      	add	r0, sp, #28
 800c678:	f7fd ffe8 	bl	800a64c <HAL_RCC_GetClockConfig>
    if((spindle->cap.variable = !settings.spindle.flags.pwm_disable && spindle_precompute_pwm_values(spindle, &spindle_pwm, (HAL_RCC_GetPCLK2Freq() * TIMER_CLOCK_MUL(clock.APB2CLKDivider)) / prescaler))) {
 800c67c:	4b4d      	ldr	r3, [pc, #308]	; (800c7b4 <spindleConfig+0x14c>)
 800c67e:	f993 30e7 	ldrsb.w	r3, [r3, #231]	; 0xe7
 800c682:	2b00      	cmp	r3, #0
 800c684:	da12      	bge.n	800c6ac <spindleConfig+0x44>
 800c686:	2300      	movs	r3, #0
 800c688:	7a6a      	ldrb	r2, [r5, #9]
 800c68a:	f363 0200 	bfi	r2, r3, #0, #1
 800c68e:	726a      	strb	r2, [r5, #9]
 800c690:	2b00      	cmp	r3, #0
 800c692:	d134      	bne.n	800c6fe <spindleConfig+0x96>
        if(pwmEnabled)
 800c694:	4b48      	ldr	r3, [pc, #288]	; (800c7b8 <spindleConfig+0x150>)
 800c696:	781b      	ldrb	r3, [r3, #0]
 800c698:	b12b      	cbz	r3, 800c6a6 <spindleConfig+0x3e>
            spindle->set_state((spindle_state_t){0}, 0.0f);
 800c69a:	69eb      	ldr	r3, [r5, #28]
 800c69c:	ed9f 0a47 	vldr	s0, [pc, #284]	; 800c7bc <spindleConfig+0x154>
 800c6a0:	f04f 0000 	mov.w	r0, #0
 800c6a4:	4798      	blx	r3
        spindle->set_state = spindleSetState;
 800c6a6:	4b46      	ldr	r3, [pc, #280]	; (800c7c0 <spindleConfig+0x158>)
 800c6a8:	61eb      	str	r3, [r5, #28]
 800c6aa:	e06a      	b.n	800c782 <spindleConfig+0x11a>
    if((spindle->cap.variable = !settings.spindle.flags.pwm_disable && spindle_precompute_pwm_values(spindle, &spindle_pwm, (HAL_RCC_GetPCLK2Freq() * TIMER_CLOCK_MUL(clock.APB2CLKDivider)) / prescaler))) {
 800c6ac:	f7fd ffbe 	bl	800a62c <HAL_RCC_GetPCLK2Freq>
 800c6b0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800c6b2:	b94b      	cbnz	r3, 800c6c8 <spindleConfig+0x60>
 800c6b4:	2201      	movs	r2, #1
 800c6b6:	fb00 f202 	mul.w	r2, r0, r2
 800c6ba:	4942      	ldr	r1, [pc, #264]	; (800c7c4 <spindleConfig+0x15c>)
 800c6bc:	4628      	mov	r0, r5
 800c6be:	f011 fb59 	bl	801dd74 <spindle_precompute_pwm_values>
 800c6c2:	b118      	cbz	r0, 800c6cc <spindleConfig+0x64>
 800c6c4:	2301      	movs	r3, #1
 800c6c6:	e7df      	b.n	800c688 <spindleConfig+0x20>
 800c6c8:	2202      	movs	r2, #2
 800c6ca:	e7f4      	b.n	800c6b6 <spindleConfig+0x4e>
 800c6cc:	2300      	movs	r3, #0
 800c6ce:	e7db      	b.n	800c688 <spindleConfig+0x20>
            spindle_precompute_pwm_values(spindle, &spindle_pwm, (HAL_RCC_GetPCLK2Freq() * TIMER_CLOCK_MUL(clock.APB2CLKDivider)) / prescaler);
 800c6d0:	2302      	movs	r3, #2
 800c6d2:	fb03 f200 	mul.w	r2, r3, r0
 800c6d6:	fbb2 f2f4 	udiv	r2, r2, r4
 800c6da:	493a      	ldr	r1, [pc, #232]	; (800c7c4 <spindleConfig+0x15c>)
 800c6dc:	4628      	mov	r0, r5
 800c6de:	f011 fb49 	bl	801dd74 <spindle_precompute_pwm_values>
        while(spindle_pwm.period > 65534) {
 800c6e2:	4b38      	ldr	r3, [pc, #224]	; (800c7c4 <spindleConfig+0x15c>)
 800c6e4:	681a      	ldr	r2, [r3, #0]
 800c6e6:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 800c6ea:	429a      	cmp	r2, r3
 800c6ec:	d909      	bls.n	800c702 <spindleConfig+0x9a>
            prescaler++;
 800c6ee:	3401      	adds	r4, #1
            spindle_precompute_pwm_values(spindle, &spindle_pwm, (HAL_RCC_GetPCLK2Freq() * TIMER_CLOCK_MUL(clock.APB2CLKDivider)) / prescaler);
 800c6f0:	f7fd ff9c 	bl	800a62c <HAL_RCC_GetPCLK2Freq>
 800c6f4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800c6f6:	2b00      	cmp	r3, #0
 800c6f8:	d1ea      	bne.n	800c6d0 <spindleConfig+0x68>
 800c6fa:	2301      	movs	r3, #1
 800c6fc:	e7e9      	b.n	800c6d2 <spindleConfig+0x6a>
    uint32_t latency, prescaler = 1;
 800c6fe:	2401      	movs	r4, #1
 800c700:	e7ef      	b.n	800c6e2 <spindleConfig+0x7a>
        spindle->set_state = spindleSetStateVariable;
 800c702:	4b31      	ldr	r3, [pc, #196]	; (800c7c8 <spindleConfig+0x160>)
 800c704:	61eb      	str	r3, [r5, #28]
        SPINDLE_PWM_TIMER->CR1 &= ~TIM_CR1_CEN;
 800c706:	4e31      	ldr	r6, [pc, #196]	; (800c7cc <spindleConfig+0x164>)
 800c708:	6833      	ldr	r3, [r6, #0]
 800c70a:	f023 0301 	bic.w	r3, r3, #1
 800c70e:	6033      	str	r3, [r6, #0]
        TIM_Base_InitTypeDef timerInitStructure = {
 800c710:	2700      	movs	r7, #0
 800c712:	9700      	str	r7, [sp, #0]
 800c714:	9701      	str	r7, [sp, #4]
 800c716:	9702      	str	r7, [sp, #8]
 800c718:	9703      	str	r7, [sp, #12]
 800c71a:	9704      	str	r7, [sp, #16]
 800c71c:	9705      	str	r7, [sp, #20]
            .Prescaler = prescaler - 1,
 800c71e:	3c01      	subs	r4, #1
        TIM_Base_InitTypeDef timerInitStructure = {
 800c720:	9400      	str	r4, [sp, #0]
            .Period = spindle_pwm.period - 1,
 800c722:	4b28      	ldr	r3, [pc, #160]	; (800c7c4 <spindleConfig+0x15c>)
 800c724:	681b      	ldr	r3, [r3, #0]
 800c726:	3b01      	subs	r3, #1
        TIM_Base_InitTypeDef timerInitStructure = {
 800c728:	9302      	str	r3, [sp, #8]
        TIM_Base_SetConfig(SPINDLE_PWM_TIMER, &timerInitStructure);
 800c72a:	4669      	mov	r1, sp
 800c72c:	4630      	mov	r0, r6
 800c72e:	f7fd ffab 	bl	800a688 <TIM_Base_SetConfig>
        SPINDLE_PWM_TIMER->CCER &= ~SPINDLE_PWM_CCER_EN;
 800c732:	6a33      	ldr	r3, [r6, #32]
 800c734:	f023 0301 	bic.w	r3, r3, #1
 800c738:	6233      	str	r3, [r6, #32]
        SPINDLE_PWM_TIMER_CCMR &= ~SPINDLE_PWM_CCMR_OCM_CLR;
 800c73a:	69b3      	ldr	r3, [r6, #24]
 800c73c:	f023 0373 	bic.w	r3, r3, #115	; 0x73
 800c740:	61b3      	str	r3, [r6, #24]
        SPINDLE_PWM_TIMER_CCMR |= SPINDLE_PWM_CCMR_OCM_SET;
 800c742:	69b3      	ldr	r3, [r6, #24]
 800c744:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 800c748:	61b3      	str	r3, [r6, #24]
        SPINDLE_PWM_TIMER_CCR = 0;
 800c74a:	6377      	str	r7, [r6, #52]	; 0x34
        SPINDLE_PWM_TIMER->BDTR |= TIM_BDTR_OSSR|TIM_BDTR_OSSI;
 800c74c:	6c73      	ldr	r3, [r6, #68]	; 0x44
 800c74e:	f443 6340 	orr.w	r3, r3, #3072	; 0xc00
 800c752:	6473      	str	r3, [r6, #68]	; 0x44
        if(settings.spindle.invert.pwm) {
 800c754:	4b17      	ldr	r3, [pc, #92]	; (800c7b4 <spindleConfig+0x14c>)
 800c756:	f893 30e6 	ldrb.w	r3, [r3, #230]	; 0xe6
 800c75a:	f013 0f04 	tst.w	r3, #4
 800c75e:	d01b      	beq.n	800c798 <spindleConfig+0x130>
            SPINDLE_PWM_TIMER->CCER |= SPINDLE_PWM_CCER_POL;
 800c760:	6a32      	ldr	r2, [r6, #32]
 800c762:	f042 0202 	orr.w	r2, r2, #2
 800c766:	6232      	str	r2, [r6, #32]
            SPINDLE_PWM_TIMER->CR2 |= SPINDLE_PWM_CR2_OIS;
 800c768:	6872      	ldr	r2, [r6, #4]
 800c76a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800c76e:	6072      	str	r2, [r6, #4]
        SPINDLE_PWM_TIMER->CCER |= SPINDLE_PWM_CCER_EN;
 800c770:	4b16      	ldr	r3, [pc, #88]	; (800c7cc <spindleConfig+0x164>)
 800c772:	6a1a      	ldr	r2, [r3, #32]
 800c774:	f042 0201 	orr.w	r2, r2, #1
 800c778:	621a      	str	r2, [r3, #32]
        SPINDLE_PWM_TIMER->CR1 |= TIM_CR1_CEN;
 800c77a:	681a      	ldr	r2, [r3, #0]
 800c77c:	f042 0201 	orr.w	r2, r2, #1
 800c780:	601a      	str	r2, [r3, #0]
    spindle_update_caps(spindle, spindle->cap.variable ? &spindle_pwm : NULL);
 800c782:	7a6b      	ldrb	r3, [r5, #9]
 800c784:	f013 0f01 	tst.w	r3, #1
 800c788:	d010      	beq.n	800c7ac <spindleConfig+0x144>
 800c78a:	490e      	ldr	r1, [pc, #56]	; (800c7c4 <spindleConfig+0x15c>)
 800c78c:	4628      	mov	r0, r5
 800c78e:	f011 f84b 	bl	801d828 <spindle_update_caps>
    return true;
 800c792:	2001      	movs	r0, #1
}
 800c794:	b00d      	add	sp, #52	; 0x34
 800c796:	bdf0      	pop	{r4, r5, r6, r7, pc}
            SPINDLE_PWM_TIMER->CCER &= ~SPINDLE_PWM_CCER_POL;
 800c798:	4b0c      	ldr	r3, [pc, #48]	; (800c7cc <spindleConfig+0x164>)
 800c79a:	6a1a      	ldr	r2, [r3, #32]
 800c79c:	f022 0202 	bic.w	r2, r2, #2
 800c7a0:	621a      	str	r2, [r3, #32]
            SPINDLE_PWM_TIMER->CR2 &= ~SPINDLE_PWM_CR2_OIS;
 800c7a2:	685a      	ldr	r2, [r3, #4]
 800c7a4:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800c7a8:	605a      	str	r2, [r3, #4]
 800c7aa:	e7e1      	b.n	800c770 <spindleConfig+0x108>
    spindle_update_caps(spindle, spindle->cap.variable ? &spindle_pwm : NULL);
 800c7ac:	2100      	movs	r1, #0
 800c7ae:	e7ed      	b.n	800c78c <spindleConfig+0x124>
        return false;
 800c7b0:	2000      	movs	r0, #0
}
 800c7b2:	4770      	bx	lr
 800c7b4:	20003b14 	.word	0x20003b14
 800c7b8:	200006f4 	.word	0x200006f4
 800c7bc:	00000000 	.word	0x00000000
 800c7c0:	0800c305 	.word	0x0800c305
 800c7c4:	200006f8 	.word	0x200006f8
 800c7c8:	0800ce1d 	.word	0x0800ce1d
 800c7cc:	40010000 	.word	0x40010000

0800c7d0 <settings_changed>:
{
 800c7d0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800c7d4:	b087      	sub	sp, #28
 800c7d6:	4606      	mov	r6, r0
 800c7d8:	460c      	mov	r4, r1
    stepdirmap_init(settings);
 800c7da:	f7ff fc2b 	bl	800c034 <stepdirmap_init>
    if(IOInitDone) {
 800c7de:	4bb5      	ldr	r3, [pc, #724]	; (800cab4 <settings_changed+0x2e4>)
 800c7e0:	781f      	ldrb	r7, [r3, #0]
 800c7e2:	2f00      	cmp	r7, #0
 800c7e4:	f000 82d7 	beq.w	800cd96 <settings_changed+0x5c6>
        GPIO_InitTypeDef GPIO_Init = {
 800c7e8:	2300      	movs	r3, #0
 800c7ea:	9301      	str	r3, [sp, #4]
 800c7ec:	9302      	str	r3, [sp, #8]
 800c7ee:	9303      	str	r3, [sp, #12]
 800c7f0:	9304      	str	r3, [sp, #16]
 800c7f2:	9305      	str	r3, [sp, #20]
 800c7f4:	2302      	movs	r3, #2
 800c7f6:	9304      	str	r3, [sp, #16]
    STEP_PORT->ODR = (STEP_PORT->ODR & ~STEP_MASK) | step_outmap[step_outbits.value];
 800c7f8:	4aaf      	ldr	r2, [pc, #700]	; (800cab8 <settings_changed+0x2e8>)
 800c7fa:	6953      	ldr	r3, [r2, #20]
 800c7fc:	f023 0307 	bic.w	r3, r3, #7
 800c800:	49ae      	ldr	r1, [pc, #696]	; (800cabc <settings_changed+0x2ec>)
 800c802:	6809      	ldr	r1, [r1, #0]
 800c804:	430b      	orrs	r3, r1
 800c806:	6153      	str	r3, [r2, #20]
    DIRECTION_PORT->ODR = (DIRECTION_PORT->ODR & ~DIRECTION_MASK) | dir_outmap[dir_outbits.value];
 800c808:	6953      	ldr	r3, [r2, #20]
 800c80a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800c80e:	49ac      	ldr	r1, [pc, #688]	; (800cac0 <settings_changed+0x2f0>)
 800c810:	6809      	ldr	r1, [r1, #0]
 800c812:	430b      	orrs	r3, r1
 800c814:	6153      	str	r3, [r2, #20]
        if(changed.spindle) {
 800c816:	f014 0f01 	tst.w	r4, #1
 800c81a:	d134      	bne.n	800c886 <settings_changed+0xb6>
        pulse_length = (uint32_t)(10.0f * (settings->steppers.pulse_microseconds - STEP_PULSE_LATENCY)) - 1;
 800c81c:	edd6 7a3c 	vldr	s15, [r6, #240]	; 0xf0
 800c820:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 800c824:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800c828:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 800c82c:	ee67 7a87 	vmul.f32	s15, s15, s14
 800c830:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800c834:	ee17 3a90 	vmov	r3, s15
 800c838:	3b01      	subs	r3, #1
 800c83a:	4aa2      	ldr	r2, [pc, #648]	; (800cac4 <settings_changed+0x2f4>)
 800c83c:	6013      	str	r3, [r2, #0]
        if(hal.driver_cap.step_pulse_delay && settings->steppers.pulse_delay_microseconds > 0.0f) {
 800c83e:	4aa2      	ldr	r2, [pc, #648]	; (800cac8 <settings_changed+0x2f8>)
 800c840:	f892 21a4 	ldrb.w	r2, [r2, #420]	; 0x1a4
 800c844:	f012 0f04 	tst.w	r2, #4
 800c848:	d037      	beq.n	800c8ba <settings_changed+0xea>
 800c84a:	edd6 7a3d 	vldr	s15, [r6, #244]	; 0xf4
 800c84e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800c852:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c856:	dd30      	ble.n	800c8ba <settings_changed+0xea>
            pulse_delay = (uint32_t)(10.0f * (settings->steppers.pulse_delay_microseconds - 1.0f));
 800c858:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 800c85c:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800c860:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 800c864:	ee67 7a87 	vmul.f32	s15, s15, s14
 800c868:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800c86c:	ee17 2a90 	vmov	r2, s15
 800c870:	4996      	ldr	r1, [pc, #600]	; (800cacc <settings_changed+0x2fc>)
 800c872:	edc1 7a00 	vstr	s15, [r1]
            if(pulse_delay < 2)
 800c876:	2a01      	cmp	r2, #1
 800c878:	d917      	bls.n	800c8aa <settings_changed+0xda>
            else if(pulse_delay == pulse_length)
 800c87a:	4293      	cmp	r3, r2
 800c87c:	d118      	bne.n	800c8b0 <settings_changed+0xe0>
                pulse_delay++;
 800c87e:	3201      	adds	r2, #1
 800c880:	4992      	ldr	r1, [pc, #584]	; (800cacc <settings_changed+0x2fc>)
 800c882:	600a      	str	r2, [r1, #0]
 800c884:	e014      	b.n	800c8b0 <settings_changed+0xe0>
            spindleConfig(spindle_get_hal(spindle_id, SpindleHAL_Configured));
 800c886:	4c92      	ldr	r4, [pc, #584]	; (800cad0 <settings_changed+0x300>)
 800c888:	2101      	movs	r1, #1
 800c88a:	f994 0000 	ldrsb.w	r0, [r4]
 800c88e:	f010 ff69 	bl	801d764 <spindle_get_hal>
 800c892:	f7ff fee9 	bl	800c668 <spindleConfig>
            if(spindle_id == spindle_get_default())
 800c896:	f010 ff95 	bl	801d7c4 <spindle_get_default>
 800c89a:	f994 3000 	ldrsb.w	r3, [r4]
 800c89e:	4298      	cmp	r0, r3
 800c8a0:	d1bc      	bne.n	800c81c <settings_changed+0x4c>
                spindle_select(spindle_id);
 800c8a2:	4618      	mov	r0, r3
 800c8a4:	f011 f890 	bl	801d9c8 <spindle_select>
 800c8a8:	e7b8      	b.n	800c81c <settings_changed+0x4c>
                pulse_delay = 2;
 800c8aa:	460a      	mov	r2, r1
 800c8ac:	2102      	movs	r1, #2
 800c8ae:	6011      	str	r1, [r2, #0]
            hal.stepper.pulse_start = &stepperPulseStartDelayed;
 800c8b0:	4a85      	ldr	r2, [pc, #532]	; (800cac8 <settings_changed+0x2f8>)
 800c8b2:	4988      	ldr	r1, [pc, #544]	; (800cad4 <settings_changed+0x304>)
 800c8b4:	f8c2 1094 	str.w	r1, [r2, #148]	; 0x94
 800c8b8:	e006      	b.n	800c8c8 <settings_changed+0xf8>
            pulse_delay = 0;
 800c8ba:	4a84      	ldr	r2, [pc, #528]	; (800cacc <settings_changed+0x2fc>)
 800c8bc:	2100      	movs	r1, #0
 800c8be:	6011      	str	r1, [r2, #0]
            hal.stepper.pulse_start = &stepperPulseStart;
 800c8c0:	4a81      	ldr	r2, [pc, #516]	; (800cac8 <settings_changed+0x2f8>)
 800c8c2:	4985      	ldr	r1, [pc, #532]	; (800cad8 <settings_changed+0x308>)
 800c8c4:	f8c2 1094 	str.w	r1, [r2, #148]	; 0x94
        PULSE_TIMER->ARR = pulse_length;
 800c8c8:	4a84      	ldr	r2, [pc, #528]	; (800cadc <settings_changed+0x30c>)
 800c8ca:	62d3      	str	r3, [r2, #44]	; 0x2c
        PULSE_TIMER->EGR = TIM_EGR_UG;
 800c8cc:	2301      	movs	r3, #1
 800c8ce:	6153      	str	r3, [r2, #20]
        HAL_NVIC_DisableIRQ(EXTI9_5_IRQn);
 800c8d0:	2017      	movs	r0, #23
 800c8d2:	f7fc faff 	bl	8008ed4 <HAL_NVIC_DisableIRQ>
        HAL_NVIC_DisableIRQ(EXTI15_10_IRQn);
 800c8d6:	2028      	movs	r0, #40	; 0x28
 800c8d8:	f7fc fafc 	bl	8008ed4 <HAL_NVIC_DisableIRQ>
        control_fei.mask = settings->control_disable_pullup.mask ^ settings->control_invert.mask;
 800c8dc:	f8b6 906e 	ldrh.w	r9, [r6, #110]	; 0x6e
 800c8e0:	f8b6 306c 	ldrh.w	r3, [r6, #108]	; 0x6c
 800c8e4:	ea89 0903 	eor.w	r9, r9, r3
        limit_fei.mask = settings->limits.disable_pullup.mask ^ settings->limits.invert.mask;
 800c8e8:	f896 8126 	ldrb.w	r8, [r6, #294]	; 0x126
 800c8ec:	f896 3125 	ldrb.w	r3, [r6, #293]	; 0x125
 800c8f0:	ea88 0803 	eor.w	r8, r8, r3
        uint32_t i = sizeof(inputpin) / sizeof(input_signal_t);
 800c8f4:	2407      	movs	r4, #7
 800c8f6:	e1a7      	b.n	800cc48 <settings_changed+0x478>
                    pullup = !settings->control_disable_pullup.reset;
 800c8f8:	f896 106e 	ldrb.w	r1, [r6, #110]	; 0x6e
 800c8fc:	f011 0f01 	tst.w	r1, #1
 800c900:	bf0c      	ite	eq
 800c902:	2101      	moveq	r1, #1
 800c904:	2100      	movne	r1, #0
                    input->irq_mode = control_fei.reset ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 800c906:	f019 0f01 	tst.w	r9, #1
 800c90a:	d000      	beq.n	800c90e <settings_changed+0x13e>
 800c90c:	2302      	movs	r3, #2
 800c90e:	eb04 05c4 	add.w	r5, r4, r4, lsl #3
 800c912:	4873      	ldr	r0, [pc, #460]	; (800cae0 <settings_changed+0x310>)
 800c914:	eb00 0085 	add.w	r0, r0, r5, lsl #2
 800c918:	7583      	strb	r3, [r0, #22]
                    break;
 800c91a:	e108      	b.n	800cb2e <settings_changed+0x35e>
                    pullup = !settings->control_disable_pullup.e_stop;
 800c91c:	f896 306e 	ldrb.w	r3, [r6, #110]	; 0x6e
 800c920:	f013 0f40 	tst.w	r3, #64	; 0x40
 800c924:	bf0c      	ite	eq
 800c926:	2101      	moveq	r1, #1
 800c928:	2100      	movne	r1, #0
                    input->irq_mode = control_fei.e_stop ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 800c92a:	f019 0f40 	tst.w	r9, #64	; 0x40
 800c92e:	d007      	beq.n	800c940 <settings_changed+0x170>
 800c930:	2502      	movs	r5, #2
 800c932:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 800c936:	4b6a      	ldr	r3, [pc, #424]	; (800cae0 <settings_changed+0x310>)
 800c938:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800c93c:	759d      	strb	r5, [r3, #22]
                    break;
 800c93e:	e0f6      	b.n	800cb2e <settings_changed+0x35e>
                    input->irq_mode = control_fei.e_stop ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 800c940:	2501      	movs	r5, #1
 800c942:	e7f6      	b.n	800c932 <settings_changed+0x162>
                    pullup = !settings->control_disable_pullup.feed_hold;
 800c944:	f896 106e 	ldrb.w	r1, [r6, #110]	; 0x6e
 800c948:	f011 0f02 	tst.w	r1, #2
 800c94c:	bf0c      	ite	eq
 800c94e:	2101      	moveq	r1, #1
 800c950:	2100      	movne	r1, #0
                    input->irq_mode = control_fei.feed_hold ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 800c952:	f019 0f02 	tst.w	r9, #2
 800c956:	d100      	bne.n	800c95a <settings_changed+0x18a>
 800c958:	2301      	movs	r3, #1
 800c95a:	eb04 05c4 	add.w	r5, r4, r4, lsl #3
 800c95e:	4860      	ldr	r0, [pc, #384]	; (800cae0 <settings_changed+0x310>)
 800c960:	eb00 0085 	add.w	r0, r0, r5, lsl #2
 800c964:	7583      	strb	r3, [r0, #22]
                    break;
 800c966:	e0e2      	b.n	800cb2e <settings_changed+0x35e>
                    pullup = !settings->control_disable_pullup.cycle_start;
 800c968:	f896 306e 	ldrb.w	r3, [r6, #110]	; 0x6e
 800c96c:	f013 0f04 	tst.w	r3, #4
 800c970:	bf0c      	ite	eq
 800c972:	2101      	moveq	r1, #1
 800c974:	2100      	movne	r1, #0
                    input->irq_mode = control_fei.cycle_start ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 800c976:	f019 0f04 	tst.w	r9, #4
 800c97a:	d007      	beq.n	800c98c <settings_changed+0x1bc>
 800c97c:	2502      	movs	r5, #2
 800c97e:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 800c982:	4b57      	ldr	r3, [pc, #348]	; (800cae0 <settings_changed+0x310>)
 800c984:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800c988:	759d      	strb	r5, [r3, #22]
                    break;
 800c98a:	e0d0      	b.n	800cb2e <settings_changed+0x35e>
                    input->irq_mode = control_fei.cycle_start ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 800c98c:	2501      	movs	r5, #1
 800c98e:	e7f6      	b.n	800c97e <settings_changed+0x1ae>
                    pullup = !settings->control_disable_pullup.safety_door_ajar;
 800c990:	f896 306e 	ldrb.w	r3, [r6, #110]	; 0x6e
 800c994:	f013 0f08 	tst.w	r3, #8
 800c998:	bf0c      	ite	eq
 800c99a:	2101      	moveq	r1, #1
 800c99c:	2100      	movne	r1, #0
                    input->irq_mode = control_fei.safety_door_ajar ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 800c99e:	f019 0f08 	tst.w	r9, #8
 800c9a2:	d007      	beq.n	800c9b4 <settings_changed+0x1e4>
 800c9a4:	2502      	movs	r5, #2
 800c9a6:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 800c9aa:	4b4d      	ldr	r3, [pc, #308]	; (800cae0 <settings_changed+0x310>)
 800c9ac:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800c9b0:	759d      	strb	r5, [r3, #22]
                    break;
 800c9b2:	e0bc      	b.n	800cb2e <settings_changed+0x35e>
                    input->irq_mode = control_fei.safety_door_ajar ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 800c9b4:	2501      	movs	r5, #1
 800c9b6:	e7f6      	b.n	800c9a6 <settings_changed+0x1d6>
                   pullup = hal.driver_cap.probe_pull_up;
 800c9b8:	4b43      	ldr	r3, [pc, #268]	; (800cac8 <settings_changed+0x2f8>)
 800c9ba:	f893 11a4 	ldrb.w	r1, [r3, #420]	; 0x1a4
 800c9be:	f3c1 1140 	ubfx	r1, r1, #5, #1
                   break;
 800c9c2:	e0b4      	b.n	800cb2e <settings_changed+0x35e>
                    pullup = !settings->limits.disable_pullup.x;
 800c9c4:	f896 3126 	ldrb.w	r3, [r6, #294]	; 0x126
 800c9c8:	f013 0f01 	tst.w	r3, #1
 800c9cc:	bf0c      	ite	eq
 800c9ce:	2101      	moveq	r1, #1
 800c9d0:	2100      	movne	r1, #0
                    input->irq_mode = limit_fei.x ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 800c9d2:	f018 0f01 	tst.w	r8, #1
 800c9d6:	d007      	beq.n	800c9e8 <settings_changed+0x218>
 800c9d8:	2502      	movs	r5, #2
 800c9da:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 800c9de:	4b40      	ldr	r3, [pc, #256]	; (800cae0 <settings_changed+0x310>)
 800c9e0:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800c9e4:	759d      	strb	r5, [r3, #22]
                    break;
 800c9e6:	e0a2      	b.n	800cb2e <settings_changed+0x35e>
                    input->irq_mode = limit_fei.x ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 800c9e8:	2501      	movs	r5, #1
 800c9ea:	e7f6      	b.n	800c9da <settings_changed+0x20a>
                    pullup = !settings->limits.disable_pullup.y;
 800c9ec:	f896 3126 	ldrb.w	r3, [r6, #294]	; 0x126
 800c9f0:	f013 0f02 	tst.w	r3, #2
 800c9f4:	bf0c      	ite	eq
 800c9f6:	2101      	moveq	r1, #1
 800c9f8:	2100      	movne	r1, #0
                    input->irq_mode = limit_fei.y ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 800c9fa:	f018 0f02 	tst.w	r8, #2
 800c9fe:	d007      	beq.n	800ca10 <settings_changed+0x240>
 800ca00:	2502      	movs	r5, #2
 800ca02:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 800ca06:	4b36      	ldr	r3, [pc, #216]	; (800cae0 <settings_changed+0x310>)
 800ca08:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800ca0c:	759d      	strb	r5, [r3, #22]
                    break;
 800ca0e:	e08e      	b.n	800cb2e <settings_changed+0x35e>
                    input->irq_mode = limit_fei.y ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 800ca10:	2501      	movs	r5, #1
 800ca12:	e7f6      	b.n	800ca02 <settings_changed+0x232>
                    pullup = !settings->limits.disable_pullup.z;
 800ca14:	f896 3126 	ldrb.w	r3, [r6, #294]	; 0x126
 800ca18:	f013 0f04 	tst.w	r3, #4
 800ca1c:	bf0c      	ite	eq
 800ca1e:	2101      	moveq	r1, #1
 800ca20:	2100      	movne	r1, #0
                    input->irq_mode = limit_fei.z ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 800ca22:	f018 0f04 	tst.w	r8, #4
 800ca26:	d007      	beq.n	800ca38 <settings_changed+0x268>
 800ca28:	2502      	movs	r5, #2
 800ca2a:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 800ca2e:	4b2c      	ldr	r3, [pc, #176]	; (800cae0 <settings_changed+0x310>)
 800ca30:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800ca34:	759d      	strb	r5, [r3, #22]
                    break;
 800ca36:	e07a      	b.n	800cb2e <settings_changed+0x35e>
                    input->irq_mode = limit_fei.z ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 800ca38:	2501      	movs	r5, #1
 800ca3a:	e7f6      	b.n	800ca2a <settings_changed+0x25a>
                    pullup = !settings->limits.disable_pullup.a;
 800ca3c:	f896 3126 	ldrb.w	r3, [r6, #294]	; 0x126
 800ca40:	f013 0f08 	tst.w	r3, #8
 800ca44:	bf0c      	ite	eq
 800ca46:	2101      	moveq	r1, #1
 800ca48:	2100      	movne	r1, #0
                    input->irq_mode = limit_fei.a ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 800ca4a:	f018 0f08 	tst.w	r8, #8
 800ca4e:	d007      	beq.n	800ca60 <settings_changed+0x290>
 800ca50:	2502      	movs	r5, #2
 800ca52:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 800ca56:	4b22      	ldr	r3, [pc, #136]	; (800cae0 <settings_changed+0x310>)
 800ca58:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800ca5c:	759d      	strb	r5, [r3, #22]
                    break;
 800ca5e:	e066      	b.n	800cb2e <settings_changed+0x35e>
                    input->irq_mode = limit_fei.a ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 800ca60:	2501      	movs	r5, #1
 800ca62:	e7f6      	b.n	800ca52 <settings_changed+0x282>
                    pullup = !settings->limits.disable_pullup.b;
 800ca64:	f896 3126 	ldrb.w	r3, [r6, #294]	; 0x126
 800ca68:	f013 0f10 	tst.w	r3, #16
 800ca6c:	bf0c      	ite	eq
 800ca6e:	2101      	moveq	r1, #1
 800ca70:	2100      	movne	r1, #0
                    input->irq_mode = limit_fei.b ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 800ca72:	f018 0f10 	tst.w	r8, #16
 800ca76:	d007      	beq.n	800ca88 <settings_changed+0x2b8>
 800ca78:	2502      	movs	r5, #2
 800ca7a:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 800ca7e:	4b18      	ldr	r3, [pc, #96]	; (800cae0 <settings_changed+0x310>)
 800ca80:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800ca84:	759d      	strb	r5, [r3, #22]
                    break;
 800ca86:	e052      	b.n	800cb2e <settings_changed+0x35e>
                    input->irq_mode = limit_fei.b ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 800ca88:	2501      	movs	r5, #1
 800ca8a:	e7f6      	b.n	800ca7a <settings_changed+0x2aa>
                    pullup = !settings->limits.disable_pullup.c;
 800ca8c:	f896 3126 	ldrb.w	r3, [r6, #294]	; 0x126
 800ca90:	f013 0f20 	tst.w	r3, #32
 800ca94:	bf0c      	ite	eq
 800ca96:	2101      	moveq	r1, #1
 800ca98:	2100      	movne	r1, #0
                    input->irq_mode = limit_fei.c ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 800ca9a:	f018 0f20 	tst.w	r8, #32
 800ca9e:	d007      	beq.n	800cab0 <settings_changed+0x2e0>
 800caa0:	2502      	movs	r5, #2
 800caa2:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 800caa6:	4b0e      	ldr	r3, [pc, #56]	; (800cae0 <settings_changed+0x310>)
 800caa8:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800caac:	759d      	strb	r5, [r3, #22]
                    break;
 800caae:	e03e      	b.n	800cb2e <settings_changed+0x35e>
                    input->irq_mode = limit_fei.c ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 800cab0:	2501      	movs	r5, #1
 800cab2:	e7f6      	b.n	800caa2 <settings_changed+0x2d2>
 800cab4:	20000671 	.word	0x20000671
 800cab8:	40020000 	.word	0x40020000
 800cabc:	2000074c 	.word	0x2000074c
 800cac0:	20000694 	.word	0x20000694
 800cac4:	200006f0 	.word	0x200006f0
 800cac8:	2000350c 	.word	0x2000350c
 800cacc:	200006ec 	.word	0x200006ec
 800cad0:	20000329 	.word	0x20000329
 800cad4:	0800c151 	.word	0x0800c151
 800cad8:	0800c101 	.word	0x0800c101
 800cadc:	40000800 	.word	0x40000800
 800cae0:	20000120 	.word	0x20000120
                    input->irq_mode = IRQ_Mode_Change;
 800cae4:	eb04 01c4 	add.w	r1, r4, r4, lsl #3
 800cae8:	4bc3      	ldr	r3, [pc, #780]	; (800cdf8 <settings_changed+0x628>)
 800caea:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 800caee:	2104      	movs	r1, #4
 800caf0:	7599      	strb	r1, [r3, #22]
                    pullup = true;
 800caf2:	4639      	mov	r1, r7
                    break;
 800caf4:	e01b      	b.n	800cb2e <settings_changed+0x35e>
                    input->irq_mode = IRQ_Mode_Change;
 800caf6:	eb04 01c4 	add.w	r1, r4, r4, lsl #3
 800cafa:	4bbf      	ldr	r3, [pc, #764]	; (800cdf8 <settings_changed+0x628>)
 800cafc:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 800cb00:	2104      	movs	r1, #4
 800cb02:	7599      	strb	r1, [r3, #22]
                    pullup = true;
 800cb04:	4639      	mov	r1, r7
                    break;
 800cb06:	e012      	b.n	800cb2e <settings_changed+0x35e>
                    input->irq_mode = IRQ_Mode_Falling;
 800cb08:	eb04 01c4 	add.w	r1, r4, r4, lsl #3
 800cb0c:	4bba      	ldr	r3, [pc, #744]	; (800cdf8 <settings_changed+0x628>)
 800cb0e:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 800cb12:	2102      	movs	r1, #2
 800cb14:	7599      	strb	r1, [r3, #22]
                    pullup = true;
 800cb16:	4639      	mov	r1, r7
                    break;
 800cb18:	e009      	b.n	800cb2e <settings_changed+0x35e>
                    input->irq_mode = IRQ_Mode_Falling;
 800cb1a:	eb04 01c4 	add.w	r1, r4, r4, lsl #3
 800cb1e:	4bb6      	ldr	r3, [pc, #728]	; (800cdf8 <settings_changed+0x628>)
 800cb20:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 800cb24:	2102      	movs	r1, #2
 800cb26:	7599      	strb	r1, [r3, #22]
                    pullup = true;
 800cb28:	4639      	mov	r1, r7
                    break;
 800cb2a:	e000      	b.n	800cb2e <settings_changed+0x35e>
            switch(input->id) {
 800cb2c:	2100      	movs	r1, #0
            if(input->group == PinGroup_AuxInput) {
 800cb2e:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
 800cb32:	d01d      	beq.n	800cb70 <settings_changed+0x3a0>
            GPIO_Init.Pin = 1 << input->pin;
 800cb34:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
 800cb38:	4baf      	ldr	r3, [pc, #700]	; (800cdf8 <settings_changed+0x628>)
 800cb3a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800cb3e:	7a1a      	ldrb	r2, [r3, #8]
 800cb40:	2301      	movs	r3, #1
 800cb42:	4093      	lsls	r3, r2
 800cb44:	9301      	str	r3, [sp, #4]
            GPIO_Init.Pull = pullup ? GPIO_PULLUP : GPIO_NOPULL;
 800cb46:	2900      	cmp	r1, #0
 800cb48:	d06d      	beq.n	800cc26 <settings_changed+0x456>
 800cb4a:	2301      	movs	r3, #1
 800cb4c:	9303      	str	r3, [sp, #12]
            switch(input->irq_mode) {
 800cb4e:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
 800cb52:	4ba9      	ldr	r3, [pc, #676]	; (800cdf8 <settings_changed+0x628>)
 800cb54:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800cb58:	7d9b      	ldrb	r3, [r3, #22]
 800cb5a:	2b02      	cmp	r3, #2
 800cb5c:	f000 80e6 	beq.w	800cd2c <settings_changed+0x55c>
 800cb60:	2b04      	cmp	r3, #4
 800cb62:	f000 80e6 	beq.w	800cd32 <settings_changed+0x562>
 800cb66:	2b01      	cmp	r3, #1
 800cb68:	d05f      	beq.n	800cc2a <settings_changed+0x45a>
                    GPIO_Init.Mode = GPIO_MODE_INPUT;
 800cb6a:	2300      	movs	r3, #0
 800cb6c:	9302      	str	r3, [sp, #8]
                    break;
 800cb6e:	e05e      	b.n	800cc2e <settings_changed+0x45e>
                if(input->cap.irq_mode != IRQ_Mode_None) {
 800cb70:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
 800cb74:	4ba0      	ldr	r3, [pc, #640]	; (800cdf8 <settings_changed+0x628>)
 800cb76:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800cb7a:	8b1b      	ldrh	r3, [r3, #24]
 800cb7c:	f403 7378 	and.w	r3, r3, #992	; 0x3e0
 800cb80:	2b00      	cmp	r3, #0
 800cb82:	d04e      	beq.n	800cc22 <settings_changed+0x452>
                    aux_irq |= input->bit;
 800cb84:	499c      	ldr	r1, [pc, #624]	; (800cdf8 <settings_changed+0x628>)
 800cb86:	eb01 0182 	add.w	r1, r1, r2, lsl #2
 800cb8a:	68c8      	ldr	r0, [r1, #12]
 800cb8c:	4a9b      	ldr	r2, [pc, #620]	; (800cdfc <settings_changed+0x62c>)
 800cb8e:	6813      	ldr	r3, [r2, #0]
 800cb90:	4303      	orrs	r3, r0
 800cb92:	6013      	str	r3, [r2, #0]
                    uint32_t extireg = SYSCFG->EXTICR[input->pin >> 2] & ~(0b1111 << ((input->pin & 0b11) << 2));
 800cb94:	7a0b      	ldrb	r3, [r1, #8]
 800cb96:	0898      	lsrs	r0, r3, #2
 800cb98:	1c85      	adds	r5, r0, #2
 800cb9a:	4a99      	ldr	r2, [pc, #612]	; (800ce00 <settings_changed+0x630>)
 800cb9c:	f852 5025 	ldr.w	r5, [r2, r5, lsl #2]
 800cba0:	009b      	lsls	r3, r3, #2
 800cba2:	f003 030c 	and.w	r3, r3, #12
 800cba6:	220f      	movs	r2, #15
 800cba8:	409a      	lsls	r2, r3
 800cbaa:	ea25 0502 	bic.w	r5, r5, r2
                    extireg |= ((uint32_t)(GPIO_GET_INDEX(input->port)) << ((input->pin & 0b11) << 2));
 800cbae:	684a      	ldr	r2, [r1, #4]
 800cbb0:	4994      	ldr	r1, [pc, #592]	; (800ce04 <settings_changed+0x634>)
 800cbb2:	428a      	cmp	r2, r1
 800cbb4:	d01f      	beq.n	800cbf6 <settings_changed+0x426>
 800cbb6:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800cbba:	428a      	cmp	r2, r1
 800cbbc:	d025      	beq.n	800cc0a <settings_changed+0x43a>
 800cbbe:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800cbc2:	428a      	cmp	r2, r1
 800cbc4:	d023      	beq.n	800cc0e <settings_changed+0x43e>
 800cbc6:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800cbca:	428a      	cmp	r2, r1
 800cbcc:	d021      	beq.n	800cc12 <settings_changed+0x442>
 800cbce:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800cbd2:	428a      	cmp	r2, r1
 800cbd4:	d01f      	beq.n	800cc16 <settings_changed+0x446>
 800cbd6:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800cbda:	428a      	cmp	r2, r1
 800cbdc:	d01d      	beq.n	800cc1a <settings_changed+0x44a>
 800cbde:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800cbe2:	428a      	cmp	r2, r1
 800cbe4:	d01b      	beq.n	800cc1e <settings_changed+0x44e>
 800cbe6:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800cbea:	428a      	cmp	r2, r1
 800cbec:	d001      	beq.n	800cbf2 <settings_changed+0x422>
 800cbee:	2208      	movs	r2, #8
 800cbf0:	e002      	b.n	800cbf8 <settings_changed+0x428>
 800cbf2:	2207      	movs	r2, #7
 800cbf4:	e000      	b.n	800cbf8 <settings_changed+0x428>
 800cbf6:	2200      	movs	r2, #0
 800cbf8:	fa02 f303 	lsl.w	r3, r2, r3
 800cbfc:	432b      	orrs	r3, r5
                    SYSCFG->EXTICR[input->pin >> 2] = extireg;
 800cbfe:	1c82      	adds	r2, r0, #2
 800cc00:	497f      	ldr	r1, [pc, #508]	; (800ce00 <settings_changed+0x630>)
 800cc02:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
                pullup = true;
 800cc06:	4639      	mov	r1, r7
 800cc08:	e794      	b.n	800cb34 <settings_changed+0x364>
                    extireg |= ((uint32_t)(GPIO_GET_INDEX(input->port)) << ((input->pin & 0b11) << 2));
 800cc0a:	2201      	movs	r2, #1
 800cc0c:	e7f4      	b.n	800cbf8 <settings_changed+0x428>
 800cc0e:	2202      	movs	r2, #2
 800cc10:	e7f2      	b.n	800cbf8 <settings_changed+0x428>
 800cc12:	2203      	movs	r2, #3
 800cc14:	e7f0      	b.n	800cbf8 <settings_changed+0x428>
 800cc16:	2204      	movs	r2, #4
 800cc18:	e7ee      	b.n	800cbf8 <settings_changed+0x428>
 800cc1a:	2205      	movs	r2, #5
 800cc1c:	e7ec      	b.n	800cbf8 <settings_changed+0x428>
 800cc1e:	2206      	movs	r2, #6
 800cc20:	e7ea      	b.n	800cbf8 <settings_changed+0x428>
                pullup = true;
 800cc22:	4639      	mov	r1, r7
 800cc24:	e786      	b.n	800cb34 <settings_changed+0x364>
            GPIO_Init.Pull = pullup ? GPIO_PULLUP : GPIO_NOPULL;
 800cc26:	2300      	movs	r3, #0
 800cc28:	e790      	b.n	800cb4c <settings_changed+0x37c>
                    GPIO_Init.Mode = GPIO_MODE_IT_RISING;
 800cc2a:	4b77      	ldr	r3, [pc, #476]	; (800ce08 <settings_changed+0x638>)
 800cc2c:	9302      	str	r3, [sp, #8]
            HAL_GPIO_Init(input->port, &GPIO_Init);
 800cc2e:	eb04 03c4 	add.w	r3, r4, r4, lsl #3
 800cc32:	4d71      	ldr	r5, [pc, #452]	; (800cdf8 <settings_changed+0x628>)
 800cc34:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 800cc38:	a901      	add	r1, sp, #4
 800cc3a:	6868      	ldr	r0, [r5, #4]
 800cc3c:	f7fc fb44 	bl	80092c8 <HAL_GPIO_Init>
            input->debounce = false;
 800cc40:	2300      	movs	r3, #0
 800cc42:	756b      	strb	r3, [r5, #21]
        } while(i);
 800cc44:	2c00      	cmp	r4, #0
 800cc46:	d077      	beq.n	800cd38 <settings_changed+0x568>
            input = &inputpin[--i];
 800cc48:	3c01      	subs	r4, #1
            if(input->group != PinGroup_AuxInput) {
 800cc4a:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
 800cc4e:	4b6a      	ldr	r3, [pc, #424]	; (800cdf8 <settings_changed+0x628>)
 800cc50:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800cc54:	691a      	ldr	r2, [r3, #16]
 800cc56:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
 800cc5a:	d00a      	beq.n	800cc72 <settings_changed+0x4a2>
                input->irq_mode = IRQ_Mode_None;
 800cc5c:	eb04 01c4 	add.w	r1, r4, r4, lsl #3
 800cc60:	4b65      	ldr	r3, [pc, #404]	; (800cdf8 <settings_changed+0x628>)
 800cc62:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 800cc66:	2100      	movs	r1, #0
 800cc68:	7599      	strb	r1, [r3, #22]
                input->bit = 1 << input->pin;
 800cc6a:	7a18      	ldrb	r0, [r3, #8]
 800cc6c:	2101      	movs	r1, #1
 800cc6e:	4081      	lsls	r1, r0
 800cc70:	60d9      	str	r1, [r3, #12]
            switch(input->id) {
 800cc72:	eb04 03c4 	add.w	r3, r4, r4, lsl #3
 800cc76:	4960      	ldr	r1, [pc, #384]	; (800cdf8 <settings_changed+0x628>)
 800cc78:	f811 3023 	ldrb.w	r3, [r1, r3, lsl #2]
 800cc7c:	2b28      	cmp	r3, #40	; 0x28
 800cc7e:	f63f af55 	bhi.w	800cb2c <settings_changed+0x35c>
 800cc82:	a101      	add	r1, pc, #4	; (adr r1, 800cc88 <settings_changed+0x4b8>)
 800cc84:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 800cc88:	0800c9b9 	.word	0x0800c9b9
 800cc8c:	0800c8f9 	.word	0x0800c8f9
 800cc90:	0800c945 	.word	0x0800c945
 800cc94:	0800c969 	.word	0x0800c969
 800cc98:	0800c991 	.word	0x0800c991
 800cc9c:	0800cb2d 	.word	0x0800cb2d
 800cca0:	0800c91d 	.word	0x0800c91d
 800cca4:	0800cb2d 	.word	0x0800cb2d
 800cca8:	0800cb2d 	.word	0x0800cb2d
 800ccac:	0800cb2d 	.word	0x0800cb2d
 800ccb0:	0800cb2d 	.word	0x0800cb2d
 800ccb4:	0800cae5 	.word	0x0800cae5
 800ccb8:	0800c9c5 	.word	0x0800c9c5
 800ccbc:	0800c9c5 	.word	0x0800c9c5
 800ccc0:	0800c9c5 	.word	0x0800c9c5
 800ccc4:	0800c9ed 	.word	0x0800c9ed
 800ccc8:	0800c9ed 	.word	0x0800c9ed
 800cccc:	0800c9ed 	.word	0x0800c9ed
 800ccd0:	0800ca15 	.word	0x0800ca15
 800ccd4:	0800ca15 	.word	0x0800ca15
 800ccd8:	0800ca15 	.word	0x0800ca15
 800ccdc:	0800ca3d 	.word	0x0800ca3d
 800cce0:	0800ca3d 	.word	0x0800ca3d
 800cce4:	0800ca65 	.word	0x0800ca65
 800cce8:	0800ca65 	.word	0x0800ca65
 800ccec:	0800ca8d 	.word	0x0800ca8d
 800ccf0:	0800ca8d 	.word	0x0800ca8d
 800ccf4:	0800cb2d 	.word	0x0800cb2d
 800ccf8:	0800cb2d 	.word	0x0800cb2d
 800ccfc:	0800cb2d 	.word	0x0800cb2d
 800cd00:	0800cb2d 	.word	0x0800cb2d
 800cd04:	0800cb2d 	.word	0x0800cb2d
 800cd08:	0800cb09 	.word	0x0800cb09
 800cd0c:	0800cb2d 	.word	0x0800cb2d
 800cd10:	0800cb2d 	.word	0x0800cb2d
 800cd14:	0800caf7 	.word	0x0800caf7
 800cd18:	0800cb2d 	.word	0x0800cb2d
 800cd1c:	0800cb2d 	.word	0x0800cb2d
 800cd20:	0800cb2d 	.word	0x0800cb2d
 800cd24:	0800cb2d 	.word	0x0800cb2d
 800cd28:	0800cb1b 	.word	0x0800cb1b
                    GPIO_Init.Mode = GPIO_MODE_IT_FALLING;
 800cd2c:	4b37      	ldr	r3, [pc, #220]	; (800ce0c <settings_changed+0x63c>)
 800cd2e:	9302      	str	r3, [sp, #8]
                    break;
 800cd30:	e77d      	b.n	800cc2e <settings_changed+0x45e>
                    GPIO_Init.Mode = GPIO_MODE_IT_RISING_FALLING;
 800cd32:	4b37      	ldr	r3, [pc, #220]	; (800ce10 <settings_changed+0x640>)
 800cd34:	9302      	str	r3, [sp, #8]
                    break;
 800cd36:	e77a      	b.n	800cc2e <settings_changed+0x45e>
        uint32_t irq_mask = DRIVER_IRQMASK|PROBE_IRQ_BIT|aux_irq;
 800cd38:	4b30      	ldr	r3, [pc, #192]	; (800cdfc <settings_changed+0x62c>)
 800cd3a:	681c      	ldr	r4, [r3, #0]
 800cd3c:	f444 43e1 	orr.w	r3, r4, #28800	; 0x7080
 800cd40:	f043 0360 	orr.w	r3, r3, #96	; 0x60
        __HAL_GPIO_EXTI_CLEAR_IT(irq_mask);
 800cd44:	4a33      	ldr	r2, [pc, #204]	; (800ce14 <settings_changed+0x644>)
 800cd46:	6153      	str	r3, [r2, #20]
        if(irq_mask & (1<<0)) {
 800cd48:	f014 0f01 	tst.w	r4, #1
 800cd4c:	d126      	bne.n	800cd9c <settings_changed+0x5cc>
        if(irq_mask & (1<<1)) {
 800cd4e:	f014 0f02 	tst.w	r4, #2
 800cd52:	d12c      	bne.n	800cdae <settings_changed+0x5de>
        if(irq_mask & (1<<2)) {
 800cd54:	f014 0f04 	tst.w	r4, #4
 800cd58:	d132      	bne.n	800cdc0 <settings_changed+0x5f0>
        if(irq_mask & (1<<3)) {
 800cd5a:	f014 0f08 	tst.w	r4, #8
 800cd5e:	d138      	bne.n	800cdd2 <settings_changed+0x602>
        if(irq_mask & (1<<4)) {
 800cd60:	f014 0f10 	tst.w	r4, #16
 800cd64:	d13e      	bne.n	800cde4 <settings_changed+0x614>
            HAL_NVIC_SetPriority(EXTI9_5_IRQn, 2, 0);
 800cd66:	2200      	movs	r2, #0
 800cd68:	2102      	movs	r1, #2
 800cd6a:	2017      	movs	r0, #23
 800cd6c:	f7fc f86c 	bl	8008e48 <HAL_NVIC_SetPriority>
            HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
 800cd70:	2017      	movs	r0, #23
 800cd72:	f7fc f8a1 	bl	8008eb8 <HAL_NVIC_EnableIRQ>
            HAL_NVIC_SetPriority(EXTI15_10_IRQn, 2, 0);
 800cd76:	2200      	movs	r2, #0
 800cd78:	2102      	movs	r1, #2
 800cd7a:	2028      	movs	r0, #40	; 0x28
 800cd7c:	f7fc f864 	bl	8008e48 <HAL_NVIC_SetPriority>
            HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
 800cd80:	2028      	movs	r0, #40	; 0x28
 800cd82:	f7fc f899 	bl	8008eb8 <HAL_NVIC_EnableIRQ>
        hal.limits.enable(settings->limits.flags.hard_enabled, false);
 800cd86:	4b24      	ldr	r3, [pc, #144]	; (800ce18 <settings_changed+0x648>)
 800cd88:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800cd8a:	f896 0124 	ldrb.w	r0, [r6, #292]	; 0x124
 800cd8e:	2100      	movs	r1, #0
 800cd90:	f000 0001 	and.w	r0, r0, #1
 800cd94:	4798      	blx	r3
}
 800cd96:	b007      	add	sp, #28
 800cd98:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            HAL_NVIC_SetPriority(EXTI0_IRQn, 2, 0);
 800cd9c:	2200      	movs	r2, #0
 800cd9e:	2102      	movs	r1, #2
 800cda0:	2006      	movs	r0, #6
 800cda2:	f7fc f851 	bl	8008e48 <HAL_NVIC_SetPriority>
            HAL_NVIC_EnableIRQ(EXTI0_IRQn);
 800cda6:	2006      	movs	r0, #6
 800cda8:	f7fc f886 	bl	8008eb8 <HAL_NVIC_EnableIRQ>
 800cdac:	e7cf      	b.n	800cd4e <settings_changed+0x57e>
            HAL_NVIC_SetPriority(EXTI1_IRQn, 2, 0);
 800cdae:	2200      	movs	r2, #0
 800cdb0:	2102      	movs	r1, #2
 800cdb2:	2007      	movs	r0, #7
 800cdb4:	f7fc f848 	bl	8008e48 <HAL_NVIC_SetPriority>
            HAL_NVIC_EnableIRQ(EXTI1_IRQn);
 800cdb8:	2007      	movs	r0, #7
 800cdba:	f7fc f87d 	bl	8008eb8 <HAL_NVIC_EnableIRQ>
 800cdbe:	e7c9      	b.n	800cd54 <settings_changed+0x584>
            HAL_NVIC_SetPriority(EXTI2_IRQn, 2, 0);
 800cdc0:	2200      	movs	r2, #0
 800cdc2:	2102      	movs	r1, #2
 800cdc4:	2008      	movs	r0, #8
 800cdc6:	f7fc f83f 	bl	8008e48 <HAL_NVIC_SetPriority>
            HAL_NVIC_EnableIRQ(EXTI2_IRQn);
 800cdca:	2008      	movs	r0, #8
 800cdcc:	f7fc f874 	bl	8008eb8 <HAL_NVIC_EnableIRQ>
 800cdd0:	e7c3      	b.n	800cd5a <settings_changed+0x58a>
            HAL_NVIC_SetPriority(EXTI3_IRQn, 2, 0);
 800cdd2:	2200      	movs	r2, #0
 800cdd4:	2102      	movs	r1, #2
 800cdd6:	2009      	movs	r0, #9
 800cdd8:	f7fc f836 	bl	8008e48 <HAL_NVIC_SetPriority>
            HAL_NVIC_EnableIRQ(EXTI3_IRQn);
 800cddc:	2009      	movs	r0, #9
 800cdde:	f7fc f86b 	bl	8008eb8 <HAL_NVIC_EnableIRQ>
 800cde2:	e7bd      	b.n	800cd60 <settings_changed+0x590>
            HAL_NVIC_SetPriority(EXTI4_IRQn, 2, 0);
 800cde4:	2200      	movs	r2, #0
 800cde6:	2102      	movs	r1, #2
 800cde8:	200a      	movs	r0, #10
 800cdea:	f7fc f82d 	bl	8008e48 <HAL_NVIC_SetPriority>
            HAL_NVIC_EnableIRQ(EXTI4_IRQn);
 800cdee:	200a      	movs	r0, #10
 800cdf0:	f7fc f862 	bl	8008eb8 <HAL_NVIC_EnableIRQ>
 800cdf4:	e7b7      	b.n	800cd66 <settings_changed+0x596>
 800cdf6:	bf00      	nop
 800cdf8:	20000120 	.word	0x20000120
 800cdfc:	2000068c 	.word	0x2000068c
 800ce00:	40013800 	.word	0x40013800
 800ce04:	40020000 	.word	0x40020000
 800ce08:	10110000 	.word	0x10110000
 800ce0c:	10210000 	.word	0x10210000
 800ce10:	10310000 	.word	0x10310000
 800ce14:	40013c00 	.word	0x40013c00
 800ce18:	2000350c 	.word	0x2000350c

0800ce1c <spindleSetStateVariable>:
{
 800ce1c:	b508      	push	{r3, lr}
    if(state.on)
 800ce1e:	f010 0f01 	tst.w	r0, #1
 800ce22:	d00a      	beq.n	800ce3a <spindleSetStateVariable+0x1e>
        spindle_dir(state.ccw);
 800ce24:	f3c0 0340 	ubfx	r3, r0, #1, #1
    DIGITAL_OUT(SPINDLE_DIRECTION_PORT, SPINDLE_DIRECTION_PIN, ccw ^ settings.spindle.invert.ccw);
 800ce28:	4a18      	ldr	r2, [pc, #96]	; (800ce8c <spindleSetStateVariable+0x70>)
 800ce2a:	f892 20e6 	ldrb.w	r2, [r2, #230]	; 0xe6
 800ce2e:	f3c2 0240 	ubfx	r2, r2, #1, #1
 800ce32:	4053      	eors	r3, r2
 800ce34:	4a16      	ldr	r2, [pc, #88]	; (800ce90 <spindleSetStateVariable+0x74>)
 800ce36:	f882 3080 	strb.w	r3, [r2, #128]	; 0x80
    if(!settings.spindle.flags.enable_rpm_controlled) {
 800ce3a:	4b14      	ldr	r3, [pc, #80]	; (800ce8c <spindleSetStateVariable+0x70>)
 800ce3c:	f893 30e7 	ldrb.w	r3, [r3, #231]	; 0xe7
 800ce40:	f013 0f01 	tst.w	r3, #1
 800ce44:	d10c      	bne.n	800ce60 <spindleSetStateVariable+0x44>
        if(state.on)
 800ce46:	f010 0f01 	tst.w	r0, #1
 800ce4a:	d011      	beq.n	800ce70 <spindleSetStateVariable+0x54>
    DIGITAL_OUT(SPINDLE_ENABLE_PORT, SPINDLE_ENABLE_PIN, !settings.spindle.invert.on);
 800ce4c:	4b0f      	ldr	r3, [pc, #60]	; (800ce8c <spindleSetStateVariable+0x70>)
 800ce4e:	f893 30e6 	ldrb.w	r3, [r3, #230]	; 0xe6
 800ce52:	f083 0301 	eor.w	r3, r3, #1
 800ce56:	f003 0301 	and.w	r3, r3, #1
 800ce5a:	4a0d      	ldr	r2, [pc, #52]	; (800ce90 <spindleSetStateVariable+0x74>)
 800ce5c:	f882 3084 	strb.w	r3, [r2, #132]	; 0x84
    spindle_set_speed(state.on ? spindle_compute_pwm_value(&spindle_pwm, rpm, false) : spindle_pwm.off_value);
 800ce60:	f010 0f01 	tst.w	r0, #1
 800ce64:	d10d      	bne.n	800ce82 <spindleSetStateVariable+0x66>
 800ce66:	4b0b      	ldr	r3, [pc, #44]	; (800ce94 <spindleSetStateVariable+0x78>)
 800ce68:	6858      	ldr	r0, [r3, #4]
 800ce6a:	f7ff fa6f 	bl	800c34c <spindle_set_speed>
}
 800ce6e:	bd08      	pop	{r3, pc}
    DIGITAL_OUT(SPINDLE_ENABLE_PORT, SPINDLE_ENABLE_PIN, settings.spindle.invert.on);
 800ce70:	4b06      	ldr	r3, [pc, #24]	; (800ce8c <spindleSetStateVariable+0x70>)
 800ce72:	f893 30e6 	ldrb.w	r3, [r3, #230]	; 0xe6
 800ce76:	f3c3 0300 	ubfx	r3, r3, #0, #1
 800ce7a:	4a05      	ldr	r2, [pc, #20]	; (800ce90 <spindleSetStateVariable+0x74>)
 800ce7c:	f882 3084 	strb.w	r3, [r2, #132]	; 0x84
}
 800ce80:	e7ee      	b.n	800ce60 <spindleSetStateVariable+0x44>
    spindle_set_speed(state.on ? spindle_compute_pwm_value(&spindle_pwm, rpm, false) : spindle_pwm.off_value);
 800ce82:	2100      	movs	r1, #0
 800ce84:	4803      	ldr	r0, [pc, #12]	; (800ce94 <spindleSetStateVariable+0x78>)
 800ce86:	f010 fff9 	bl	801de7c <spindle_compute_pwm_value>
 800ce8a:	e7ee      	b.n	800ce6a <spindleSetStateVariable+0x4e>
 800ce8c:	20003b14 	.word	0x20003b14
 800ce90:	42408200 	.word	0x42408200
 800ce94:	200006f8 	.word	0x200006f8

0800ce98 <spindleGetPWM>:
{
 800ce98:	b508      	push	{r3, lr}
    return spindle_compute_pwm_value(&spindle_pwm, rpm, false);
 800ce9a:	2100      	movs	r1, #0
 800ce9c:	4801      	ldr	r0, [pc, #4]	; (800cea4 <spindleGetPWM+0xc>)
 800ce9e:	f010 ffed 	bl	801de7c <spindle_compute_pwm_value>
}
 800cea2:	bd08      	pop	{r3, pc}
 800cea4:	200006f8 	.word	0x200006f8

0800cea8 <registerPeriphPin>:
{
 800cea8:	b510      	push	{r4, lr}
 800ceaa:	4604      	mov	r4, r0
    periph_signal_t *add_pin = malloc(sizeof(periph_signal_t));
 800ceac:	201c      	movs	r0, #28
 800ceae:	f015 faff 	bl	80224b0 <malloc>
    if(!add_pin)
 800ceb2:	b1c0      	cbz	r0, 800cee6 <registerPeriphPin+0x3e>
 800ceb4:	4602      	mov	r2, r0
    memcpy(&add_pin->pin, pin, sizeof(periph_pin_t));
 800ceb6:	6821      	ldr	r1, [r4, #0]
 800ceb8:	6863      	ldr	r3, [r4, #4]
 800ceba:	f8d4 c008 	ldr.w	ip, [r4, #8]
 800cebe:	68e0      	ldr	r0, [r4, #12]
 800cec0:	6011      	str	r1, [r2, #0]
 800cec2:	6053      	str	r3, [r2, #4]
 800cec4:	f8c2 c008 	str.w	ip, [r2, #8]
 800cec8:	60d0      	str	r0, [r2, #12]
 800ceca:	6921      	ldr	r1, [r4, #16]
 800cecc:	6963      	ldr	r3, [r4, #20]
 800cece:	6111      	str	r1, [r2, #16]
 800ced0:	6153      	str	r3, [r2, #20]
    add_pin->next = NULL;
 800ced2:	2300      	movs	r3, #0
 800ced4:	6193      	str	r3, [r2, #24]
    if(periph_pins == NULL) {
 800ced6:	4b06      	ldr	r3, [pc, #24]	; (800cef0 <registerPeriphPin+0x48>)
 800ced8:	681b      	ldr	r3, [r3, #0]
 800ceda:	b12b      	cbz	r3, 800cee8 <registerPeriphPin+0x40>
        while(last->next)
 800cedc:	4619      	mov	r1, r3
 800cede:	699b      	ldr	r3, [r3, #24]
 800cee0:	2b00      	cmp	r3, #0
 800cee2:	d1fb      	bne.n	800cedc <registerPeriphPin+0x34>
        last->next = add_pin;
 800cee4:	618a      	str	r2, [r1, #24]
}
 800cee6:	bd10      	pop	{r4, pc}
        periph_pins = add_pin;
 800cee8:	4b01      	ldr	r3, [pc, #4]	; (800cef0 <registerPeriphPin+0x48>)
 800ceea:	601a      	str	r2, [r3, #0]
 800ceec:	e7fb      	b.n	800cee6 <registerPeriphPin+0x3e>
 800ceee:	bf00      	nop
 800cef0:	200006bc 	.word	0x200006bc

0800cef4 <get_free_mem>:
}

#endif

uint32_t get_free_mem (void)
{
 800cef4:	b510      	push	{r4, lr}
 800cef6:	b08a      	sub	sp, #40	; 0x28
    extern uint8_t _end; /* Symbol defined in the linker script */
    extern uint8_t _estack; /* Symbol defined in the linker script */
    extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
    const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;

    return stack_limit - (uint32_t)&_end - mallinfo().uordblks;
 800cef8:	4c05      	ldr	r4, [pc, #20]	; (800cf10 <get_free_mem+0x1c>)
 800cefa:	4668      	mov	r0, sp
 800cefc:	f015 fb94 	bl	8022628 <mallinfo>
 800cf00:	4b04      	ldr	r3, [pc, #16]	; (800cf14 <get_free_mem+0x20>)
 800cf02:	9a07      	ldr	r2, [sp, #28]
 800cf04:	4413      	add	r3, r2
}
 800cf06:	4804      	ldr	r0, [pc, #16]	; (800cf18 <get_free_mem+0x24>)
 800cf08:	1a20      	subs	r0, r4, r0
 800cf0a:	1ac0      	subs	r0, r0, r3
 800cf0c:	b00a      	add	sp, #40	; 0x28
 800cf0e:	bd10      	pop	{r4, pc}
 800cf10:	20020000 	.word	0x20020000
 800cf14:	00001000 	.word	0x00001000
 800cf18:	200049b0 	.word	0x200049b0

0800cf1c <driver_setup>:
{
 800cf1c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800cf1e:	b097      	sub	sp, #92	; 0x5c
 800cf20:	4605      	mov	r5, r0
    HAL_RCC_GetClockConfig(&clock_cfg, &latency);
 800cf22:	a915      	add	r1, sp, #84	; 0x54
 800cf24:	a810      	add	r0, sp, #64	; 0x40
 800cf26:	f7fd fb91 	bl	800a64c <HAL_RCC_GetClockConfig>
    __HAL_RCC_TIM1_CLK_ENABLE();
 800cf2a:	2400      	movs	r4, #0
 800cf2c:	9401      	str	r4, [sp, #4]
 800cf2e:	4ba2      	ldr	r3, [pc, #648]	; (800d1b8 <driver_setup+0x29c>)
 800cf30:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800cf32:	f042 0201 	orr.w	r2, r2, #1
 800cf36:	645a      	str	r2, [r3, #68]	; 0x44
 800cf38:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800cf3a:	f002 0201 	and.w	r2, r2, #1
 800cf3e:	9201      	str	r2, [sp, #4]
 800cf40:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_TIM2_CLK_ENABLE();
 800cf42:	9402      	str	r4, [sp, #8]
 800cf44:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800cf46:	f042 0201 	orr.w	r2, r2, #1
 800cf4a:	641a      	str	r2, [r3, #64]	; 0x40
 800cf4c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800cf4e:	f002 0201 	and.w	r2, r2, #1
 800cf52:	9202      	str	r2, [sp, #8]
 800cf54:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_TIM3_CLK_ENABLE();
 800cf56:	9403      	str	r4, [sp, #12]
 800cf58:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800cf5a:	f042 0202 	orr.w	r2, r2, #2
 800cf5e:	641a      	str	r2, [r3, #64]	; 0x40
 800cf60:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800cf62:	f002 0202 	and.w	r2, r2, #2
 800cf66:	9203      	str	r2, [sp, #12]
 800cf68:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_TIM4_CLK_ENABLE();
 800cf6a:	9404      	str	r4, [sp, #16]
 800cf6c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800cf6e:	f042 0204 	orr.w	r2, r2, #4
 800cf72:	641a      	str	r2, [r3, #64]	; 0x40
 800cf74:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800cf76:	f002 0204 	and.w	r2, r2, #4
 800cf7a:	9204      	str	r2, [sp, #16]
 800cf7c:	9a04      	ldr	r2, [sp, #16]
    __HAL_RCC_TIM5_CLK_ENABLE();
 800cf7e:	9405      	str	r4, [sp, #20]
 800cf80:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800cf82:	f042 0208 	orr.w	r2, r2, #8
 800cf86:	641a      	str	r2, [r3, #64]	; 0x40
 800cf88:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800cf8a:	f002 0208 	and.w	r2, r2, #8
 800cf8e:	9205      	str	r2, [sp, #20]
 800cf90:	9a05      	ldr	r2, [sp, #20]
    __HAL_RCC_TIM9_CLK_ENABLE();
 800cf92:	9406      	str	r4, [sp, #24]
 800cf94:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800cf96:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800cf9a:	645a      	str	r2, [r3, #68]	; 0x44
 800cf9c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800cf9e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800cfa2:	9306      	str	r3, [sp, #24]
 800cfa4:	9b06      	ldr	r3, [sp, #24]
    GPIO_InitTypeDef GPIO_Init = {
 800cfa6:	940b      	str	r4, [sp, #44]	; 0x2c
 800cfa8:	940c      	str	r4, [sp, #48]	; 0x30
 800cfaa:	940d      	str	r4, [sp, #52]	; 0x34
 800cfac:	940e      	str	r4, [sp, #56]	; 0x38
 800cfae:	940f      	str	r4, [sp, #60]	; 0x3c
 800cfb0:	2301      	movs	r3, #1
 800cfb2:	930c      	str	r3, [sp, #48]	; 0x30
 800cfb4:	2302      	movs	r3, #2
 800cfb6:	930e      	str	r3, [sp, #56]	; 0x38
    for(i = 0 ; i < sizeof(outputpin) / sizeof(output_signal_t); i++) {
 800cfb8:	e013      	b.n	800cfe2 <driver_setup+0xc6>
            GPIO_Init.Mode = outputpin[i].mode.open_drain ? GPIO_MODE_OUTPUT_OD : GPIO_MODE_OUTPUT_PP;
 800cfba:	2301      	movs	r3, #1
 800cfbc:	930c      	str	r3, [sp, #48]	; 0x30
            HAL_GPIO_Init(outputpin[i].port, &GPIO_Init);
 800cfbe:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 800cfc2:	4e7e      	ldr	r6, [pc, #504]	; (800d1bc <driver_setup+0x2a0>)
 800cfc4:	eb06 06c3 	add.w	r6, r6, r3, lsl #3
 800cfc8:	a90b      	add	r1, sp, #44	; 0x2c
 800cfca:	6870      	ldr	r0, [r6, #4]
 800cfcc:	f7fc f97c 	bl	80092c8 <HAL_GPIO_Init>
            DIGITAL_OUT(outputpin[i].port, outputpin[i].pin, 1);
 800cfd0:	6872      	ldr	r2, [r6, #4]
 800cfd2:	4b7b      	ldr	r3, [pc, #492]	; (800d1c0 <driver_setup+0x2a4>)
 800cfd4:	4413      	add	r3, r2
 800cfd6:	015b      	lsls	r3, r3, #5
 800cfd8:	7a32      	ldrb	r2, [r6, #8]
 800cfda:	2101      	movs	r1, #1
 800cfdc:	f803 1022 	strb.w	r1, [r3, r2, lsl #2]
    for(i = 0 ; i < sizeof(outputpin) / sizeof(output_signal_t); i++) {
 800cfe0:	3401      	adds	r4, #1
 800cfe2:	2c0a      	cmp	r4, #10
 800cfe4:	d814      	bhi.n	800d010 <driver_setup+0xf4>
        if(outputpin[i].group == PinGroup_StepperPower) {
 800cfe6:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 800cfea:	4b74      	ldr	r3, [pc, #464]	; (800d1bc <driver_setup+0x2a0>)
 800cfec:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800cff0:	68db      	ldr	r3, [r3, #12]
 800cff2:	2b05      	cmp	r3, #5
 800cff4:	d1f4      	bne.n	800cfe0 <driver_setup+0xc4>
            GPIO_Init.Pin = 1 << outputpin[i].pin;
 800cff6:	4b71      	ldr	r3, [pc, #452]	; (800d1bc <driver_setup+0x2a0>)
 800cff8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800cffc:	7a19      	ldrb	r1, [r3, #8]
 800cffe:	2201      	movs	r2, #1
 800d000:	408a      	lsls	r2, r1
 800d002:	920b      	str	r2, [sp, #44]	; 0x2c
            GPIO_Init.Mode = outputpin[i].mode.open_drain ? GPIO_MODE_OUTPUT_OD : GPIO_MODE_OUTPUT_PP;
 800d004:	7c1b      	ldrb	r3, [r3, #16]
 800d006:	f013 0f04 	tst.w	r3, #4
 800d00a:	d0d6      	beq.n	800cfba <driver_setup+0x9e>
 800d00c:	2311      	movs	r3, #17
 800d00e:	e7d5      	b.n	800cfbc <driver_setup+0xa0>
    hal.delay_ms(100, NULL);
 800d010:	4b6c      	ldr	r3, [pc, #432]	; (800d1c4 <driver_setup+0x2a8>)
 800d012:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800d014:	2100      	movs	r1, #0
 800d016:	2064      	movs	r0, #100	; 0x64
 800d018:	4798      	blx	r3
    for(i = 0 ; i < sizeof(outputpin) / sizeof(output_signal_t); i++) {
 800d01a:	2400      	movs	r4, #0
 800d01c:	e00f      	b.n	800d03e <driver_setup+0x122>
            GPIO_Init.Mode = outputpin[i].mode.open_drain ? GPIO_MODE_OUTPUT_OD : GPIO_MODE_OUTPUT_PP;
 800d01e:	2301      	movs	r3, #1
 800d020:	e025      	b.n	800d06e <driver_setup+0x152>
                DIGITAL_OUT(outputpin[i].port, outputpin[i].pin, 1);
 800d022:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 800d026:	4a65      	ldr	r2, [pc, #404]	; (800d1bc <driver_setup+0x2a0>)
 800d028:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 800d02c:	6851      	ldr	r1, [r2, #4]
 800d02e:	4b64      	ldr	r3, [pc, #400]	; (800d1c0 <driver_setup+0x2a4>)
 800d030:	440b      	add	r3, r1
 800d032:	015b      	lsls	r3, r3, #5
 800d034:	7a12      	ldrb	r2, [r2, #8]
 800d036:	2101      	movs	r1, #1
 800d038:	f803 1022 	strb.w	r1, [r3, r2, lsl #2]
    for(i = 0 ; i < sizeof(outputpin) / sizeof(output_signal_t); i++) {
 800d03c:	3401      	adds	r4, #1
 800d03e:	2c0a      	cmp	r4, #10
 800d040:	d82b      	bhi.n	800d09a <driver_setup+0x17e>
        if(!(outputpin[i].group == PinGroup_StepperPower || outputpin[i].group == PinGroup_AuxOutputAnalog)) {
 800d042:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 800d046:	4b5d      	ldr	r3, [pc, #372]	; (800d1bc <driver_setup+0x2a0>)
 800d048:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800d04c:	68db      	ldr	r3, [r3, #12]
 800d04e:	2b05      	cmp	r3, #5
 800d050:	d0f4      	beq.n	800d03c <driver_setup+0x120>
 800d052:	2b0b      	cmp	r3, #11
 800d054:	d0f2      	beq.n	800d03c <driver_setup+0x120>
            GPIO_Init.Pin = 1 << outputpin[i].pin;
 800d056:	4b59      	ldr	r3, [pc, #356]	; (800d1bc <driver_setup+0x2a0>)
 800d058:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800d05c:	7a19      	ldrb	r1, [r3, #8]
 800d05e:	2201      	movs	r2, #1
 800d060:	408a      	lsls	r2, r1
 800d062:	920b      	str	r2, [sp, #44]	; 0x2c
            GPIO_Init.Mode = outputpin[i].mode.open_drain ? GPIO_MODE_OUTPUT_OD : GPIO_MODE_OUTPUT_PP;
 800d064:	7c1b      	ldrb	r3, [r3, #16]
 800d066:	f013 0f04 	tst.w	r3, #4
 800d06a:	d0d8      	beq.n	800d01e <driver_setup+0x102>
 800d06c:	2311      	movs	r3, #17
 800d06e:	930c      	str	r3, [sp, #48]	; 0x30
            HAL_GPIO_Init(outputpin[i].port, &GPIO_Init);
 800d070:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 800d074:	4e51      	ldr	r6, [pc, #324]	; (800d1bc <driver_setup+0x2a0>)
 800d076:	eb06 06c3 	add.w	r6, r6, r3, lsl #3
 800d07a:	a90b      	add	r1, sp, #44	; 0x2c
 800d07c:	6870      	ldr	r0, [r6, #4]
 800d07e:	f7fc f923 	bl	80092c8 <HAL_GPIO_Init>
            if(outputpin[i].group == PinGroup_MotorChipSelect || outputpin[i].group == PinGroup_MotorUART || outputpin[i].id == Output_SPICS)
 800d082:	68f3      	ldr	r3, [r6, #12]
 800d084:	3b0d      	subs	r3, #13
 800d086:	2b01      	cmp	r3, #1
 800d088:	d9cb      	bls.n	800d022 <driver_setup+0x106>
 800d08a:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 800d08e:	4a4b      	ldr	r2, [pc, #300]	; (800d1bc <driver_setup+0x2a0>)
 800d090:	f812 3033 	ldrb.w	r3, [r2, r3, lsl #3]
 800d094:	2b71      	cmp	r3, #113	; 0x71
 800d096:	d1d1      	bne.n	800d03c <driver_setup+0x120>
 800d098:	e7c3      	b.n	800d022 <driver_setup+0x106>
    GPIO_Init.Mode = GPIO_MODE_OUTPUT_PP;
 800d09a:	2301      	movs	r3, #1
 800d09c:	930c      	str	r3, [sp, #48]	; 0x30
    STEPPER_TIMER_CLOCK_ENA();
 800d09e:	2600      	movs	r6, #0
 800d0a0:	9607      	str	r6, [sp, #28]
 800d0a2:	4c45      	ldr	r4, [pc, #276]	; (800d1b8 <driver_setup+0x29c>)
 800d0a4:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800d0a6:	f043 0308 	orr.w	r3, r3, #8
 800d0aa:	6423      	str	r3, [r4, #64]	; 0x40
 800d0ac:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800d0ae:	f003 0308 	and.w	r3, r3, #8
 800d0b2:	9307      	str	r3, [sp, #28]
 800d0b4:	9b07      	ldr	r3, [sp, #28]
    STEPPER_TIMER->CR1 &= ~TIM_CR1_CEN;
 800d0b6:	4b44      	ldr	r3, [pc, #272]	; (800d1c8 <driver_setup+0x2ac>)
 800d0b8:	681a      	ldr	r2, [r3, #0]
 800d0ba:	f022 0201 	bic.w	r2, r2, #1
 800d0be:	601a      	str	r2, [r3, #0]
    STEPPER_TIMER->SR &= ~TIM_SR_UIF;
 800d0c0:	691a      	ldr	r2, [r3, #16]
 800d0c2:	f022 0201 	bic.w	r2, r2, #1
 800d0c6:	611a      	str	r2, [r3, #16]
    STEPPER_TIMER->PSC = STEPPER_TIMER_DIV - 1;
 800d0c8:	2203      	movs	r2, #3
 800d0ca:	629a      	str	r2, [r3, #40]	; 0x28
    STEPPER_TIMER->CNT = 0;
 800d0cc:	625e      	str	r6, [r3, #36]	; 0x24
    STEPPER_TIMER->CR1 |= TIM_CR1_DIR;
 800d0ce:	681a      	ldr	r2, [r3, #0]
 800d0d0:	f042 0210 	orr.w	r2, r2, #16
 800d0d4:	601a      	str	r2, [r3, #0]
    STEPPER_TIMER->DIER |= TIM_DIER_UIE;
 800d0d6:	68da      	ldr	r2, [r3, #12]
 800d0d8:	f042 0201 	orr.w	r2, r2, #1
 800d0dc:	60da      	str	r2, [r3, #12]
    HAL_NVIC_SetPriority(STEPPER_TIMER_IRQn, 0, 2);
 800d0de:	2202      	movs	r2, #2
 800d0e0:	4631      	mov	r1, r6
 800d0e2:	2032      	movs	r0, #50	; 0x32
 800d0e4:	f7fb feb0 	bl	8008e48 <HAL_NVIC_SetPriority>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800d0e8:	4b38      	ldr	r3, [pc, #224]	; (800d1cc <driver_setup+0x2b0>)
 800d0ea:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 800d0ee:	605a      	str	r2, [r3, #4]
    PULSE_TIMER_CLOCK_ENA();
 800d0f0:	9608      	str	r6, [sp, #32]
 800d0f2:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800d0f4:	f043 0304 	orr.w	r3, r3, #4
 800d0f8:	6423      	str	r3, [r4, #64]	; 0x40
 800d0fa:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800d0fc:	f003 0304 	and.w	r3, r3, #4
 800d100:	9308      	str	r3, [sp, #32]
 800d102:	9b08      	ldr	r3, [sp, #32]
    PULSE_TIMER->CR1 |= TIM_CR1_OPM|TIM_CR1_DIR|TIM_CR1_CKD_1|TIM_CR1_ARPE|TIM_CR1_URS;
 800d104:	4a32      	ldr	r2, [pc, #200]	; (800d1d0 <driver_setup+0x2b4>)
 800d106:	6813      	ldr	r3, [r2, #0]
 800d108:	f443 7327 	orr.w	r3, r3, #668	; 0x29c
 800d10c:	6013      	str	r3, [r2, #0]
    PULSE_TIMER->PSC = (HAL_RCC_GetPCLK1Freq() * TIMER_CLOCK_MUL(clock_cfg.APB1CLKDivider) / 10000000UL) - 1;
 800d10e:	f7fd fa7d 	bl	800a60c <HAL_RCC_GetPCLK1Freq>
 800d112:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800d114:	2b00      	cmp	r3, #0
 800d116:	d14d      	bne.n	800d1b4 <driver_setup+0x298>
 800d118:	2301      	movs	r3, #1
 800d11a:	fb00 f303 	mul.w	r3, r0, r3
 800d11e:	4a2d      	ldr	r2, [pc, #180]	; (800d1d4 <driver_setup+0x2b8>)
 800d120:	fba2 2303 	umull	r2, r3, r2, r3
 800d124:	0d9b      	lsrs	r3, r3, #22
 800d126:	3b01      	subs	r3, #1
 800d128:	4a29      	ldr	r2, [pc, #164]	; (800d1d0 <driver_setup+0x2b4>)
 800d12a:	6293      	str	r3, [r2, #40]	; 0x28
    PULSE_TIMER->SR &= ~(TIM_SR_UIF|TIM_SR_CC1IF);
 800d12c:	6913      	ldr	r3, [r2, #16]
 800d12e:	f023 0303 	bic.w	r3, r3, #3
 800d132:	6113      	str	r3, [r2, #16]
    PULSE_TIMER->CNT = 0;
 800d134:	2100      	movs	r1, #0
 800d136:	6251      	str	r1, [r2, #36]	; 0x24
    PULSE_TIMER->DIER |= TIM_DIER_UIE;
 800d138:	68d3      	ldr	r3, [r2, #12]
 800d13a:	f043 0301 	orr.w	r3, r3, #1
 800d13e:	60d3      	str	r3, [r2, #12]
    HAL_NVIC_SetPriority(PULSE_TIMER_IRQn, 0, 1);
 800d140:	2201      	movs	r2, #1
 800d142:	201e      	movs	r0, #30
 800d144:	f7fb fe80 	bl	8008e48 <HAL_NVIC_SetPriority>
 800d148:	4b20      	ldr	r3, [pc, #128]	; (800d1cc <driver_setup+0x2b0>)
 800d14a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800d14e:	601a      	str	r2, [r3, #0]
    if(hal.driver_cap.software_debounce) {
 800d150:	4b1c      	ldr	r3, [pc, #112]	; (800d1c4 <driver_setup+0x2a8>)
 800d152:	f893 31a4 	ldrb.w	r3, [r3, #420]	; 0x1a4
 800d156:	f013 0f02 	tst.w	r3, #2
 800d15a:	d143      	bne.n	800d1e4 <driver_setup+0x2c8>
    SPINDLE_PWM_CLOCK_ENA();
 800d15c:	2400      	movs	r4, #0
 800d15e:	940a      	str	r4, [sp, #40]	; 0x28
 800d160:	4b15      	ldr	r3, [pc, #84]	; (800d1b8 <driver_setup+0x29c>)
 800d162:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800d164:	f042 0201 	orr.w	r2, r2, #1
 800d168:	645a      	str	r2, [r3, #68]	; 0x44
 800d16a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800d16c:	f003 0301 	and.w	r3, r3, #1
 800d170:	930a      	str	r3, [sp, #40]	; 0x28
 800d172:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    GPIO_Init.Pin = (1 << SPINDLE_PWM_PIN);
 800d174:	f44f 7380 	mov.w	r3, #256	; 0x100
 800d178:	930b      	str	r3, [sp, #44]	; 0x2c
    GPIO_Init.Mode = GPIO_MODE_AF_PP;
 800d17a:	2302      	movs	r3, #2
 800d17c:	930c      	str	r3, [sp, #48]	; 0x30
    GPIO_Init.Pull = GPIO_NOPULL;
 800d17e:	940d      	str	r4, [sp, #52]	; 0x34
    GPIO_Init.Alternate = SPINDLE_PWM_AF;
 800d180:	2301      	movs	r3, #1
 800d182:	930f      	str	r3, [sp, #60]	; 0x3c
    HAL_GPIO_Init(SPINDLE_PWM_PORT, &GPIO_Init);
 800d184:	a90b      	add	r1, sp, #44	; 0x2c
 800d186:	4814      	ldr	r0, [pc, #80]	; (800d1d8 <driver_setup+0x2bc>)
 800d188:	f7fc f89e 	bl	80092c8 <HAL_GPIO_Init>
    hal.periph_port.register_pin(&pwm);
 800d18c:	4f0d      	ldr	r7, [pc, #52]	; (800d1c4 <driver_setup+0x2a8>)
 800d18e:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 800d192:	4812      	ldr	r0, [pc, #72]	; (800d1dc <driver_setup+0x2c0>)
 800d194:	4798      	blx	r3
    IOInitDone = settings->version == 22;
 800d196:	682b      	ldr	r3, [r5, #0]
 800d198:	2b16      	cmp	r3, #22
 800d19a:	bf14      	ite	ne
 800d19c:	2300      	movne	r3, #0
 800d19e:	2301      	moveq	r3, #1
 800d1a0:	4e0f      	ldr	r6, [pc, #60]	; (800d1e0 <driver_setup+0x2c4>)
 800d1a2:	7033      	strb	r3, [r6, #0]
    hal.settings_changed(settings, (settings_changed_flags_t){0});
 800d1a4:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800d1a8:	4621      	mov	r1, r4
 800d1aa:	4628      	mov	r0, r5
 800d1ac:	4798      	blx	r3
}
 800d1ae:	7830      	ldrb	r0, [r6, #0]
 800d1b0:	b017      	add	sp, #92	; 0x5c
 800d1b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PULSE_TIMER->PSC = (HAL_RCC_GetPCLK1Freq() * TIMER_CLOCK_MUL(clock_cfg.APB1CLKDivider) / 10000000UL) - 1;
 800d1b4:	2302      	movs	r3, #2
 800d1b6:	e7b0      	b.n	800d11a <driver_setup+0x1fe>
 800d1b8:	40023800 	.word	0x40023800
 800d1bc:	20000220 	.word	0x20000220
 800d1c0:	c2100014 	.word	0xc2100014
 800d1c4:	2000350c 	.word	0x2000350c
 800d1c8:	40000c00 	.word	0x40000c00
 800d1cc:	e000e100 	.word	0xe000e100
 800d1d0:	40000800 	.word	0x40000800
 800d1d4:	6b5fca6b 	.word	0x6b5fca6b
 800d1d8:	40020000 	.word	0x40020000
 800d1dc:	08025428 	.word	0x08025428
 800d1e0:	20000671 	.word	0x20000671
        DEBOUNCE_TIMER_CLOCK_ENA();
 800d1e4:	2300      	movs	r3, #0
 800d1e6:	9309      	str	r3, [sp, #36]	; 0x24
 800d1e8:	4b16      	ldr	r3, [pc, #88]	; (800d244 <driver_setup+0x328>)
 800d1ea:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800d1ec:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800d1f0:	645a      	str	r2, [r3, #68]	; 0x44
 800d1f2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800d1f4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800d1f8:	9309      	str	r3, [sp, #36]	; 0x24
 800d1fa:	9b09      	ldr	r3, [sp, #36]	; 0x24
        DEBOUNCE_TIMER->CR1 |= TIM_CR1_OPM|TIM_CR1_DIR|TIM_CR1_CKD_1|TIM_CR1_ARPE|TIM_CR1_URS;
 800d1fc:	4a12      	ldr	r2, [pc, #72]	; (800d248 <driver_setup+0x32c>)
 800d1fe:	6813      	ldr	r3, [r2, #0]
 800d200:	f443 7327 	orr.w	r3, r3, #668	; 0x29c
 800d204:	6013      	str	r3, [r2, #0]
        DEBOUNCE_TIMER->PSC = HAL_RCC_GetPCLK2Freq() * TIMER_CLOCK_MUL(clock_cfg.APB2CLKDivider) / 10000UL - 1;
 800d206:	f7fd fa11 	bl	800a62c <HAL_RCC_GetPCLK2Freq>
 800d20a:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800d20c:	b9c3      	cbnz	r3, 800d240 <driver_setup+0x324>
 800d20e:	2301      	movs	r3, #1
 800d210:	fb00 f303 	mul.w	r3, r0, r3
 800d214:	4a0d      	ldr	r2, [pc, #52]	; (800d24c <driver_setup+0x330>)
 800d216:	fba2 2303 	umull	r2, r3, r2, r3
 800d21a:	0b5b      	lsrs	r3, r3, #13
 800d21c:	3b01      	subs	r3, #1
 800d21e:	4a0a      	ldr	r2, [pc, #40]	; (800d248 <driver_setup+0x32c>)
 800d220:	6293      	str	r3, [r2, #40]	; 0x28
        DEBOUNCE_TIMER->SR &= ~TIM_SR_UIF;
 800d222:	6913      	ldr	r3, [r2, #16]
 800d224:	f023 0301 	bic.w	r3, r3, #1
 800d228:	6113      	str	r3, [r2, #16]
        DEBOUNCE_TIMER->ARR = 400; // 40 ms timeout
 800d22a:	f44f 73c8 	mov.w	r3, #400	; 0x190
 800d22e:	62d3      	str	r3, [r2, #44]	; 0x2c
        DEBOUNCE_TIMER->DIER |= TIM_DIER_UIE;
 800d230:	68d3      	ldr	r3, [r2, #12]
 800d232:	f043 0301 	orr.w	r3, r3, #1
 800d236:	60d3      	str	r3, [r2, #12]
        HAL_NVIC_EnableIRQ(DEBOUNCE_TIMER_IRQn); // Enable debounce interrupt
 800d238:	2018      	movs	r0, #24
 800d23a:	f7fb fe3d 	bl	8008eb8 <HAL_NVIC_EnableIRQ>
 800d23e:	e78d      	b.n	800d15c <driver_setup+0x240>
        DEBOUNCE_TIMER->PSC = HAL_RCC_GetPCLK2Freq() * TIMER_CLOCK_MUL(clock_cfg.APB2CLKDivider) / 10000UL - 1;
 800d240:	2302      	movs	r3, #2
 800d242:	e7e5      	b.n	800d210 <driver_setup+0x2f4>
 800d244:	40023800 	.word	0x40023800
 800d248:	40014000 	.word	0x40014000
 800d24c:	d1b71759 	.word	0xd1b71759

0800d250 <driver_delay>:
{
 800d250:	b510      	push	{r4, lr}
    if((delay.ms = ms) > 0) {
 800d252:	4b0b      	ldr	r3, [pc, #44]	; (800d280 <driver_delay+0x30>)
 800d254:	6018      	str	r0, [r3, #0]
 800d256:	b160      	cbz	r0, 800d272 <driver_delay+0x22>
        if(!(delay.callback = callback)) {
 800d258:	6059      	str	r1, [r3, #4]
 800d25a:	b129      	cbz	r1, 800d268 <driver_delay+0x18>
}
 800d25c:	bd10      	pop	{r4, pc}
                grbl.on_execute_delay(state_get());
 800d25e:	4b09      	ldr	r3, [pc, #36]	; (800d284 <driver_delay+0x34>)
 800d260:	6b9c      	ldr	r4, [r3, #56]	; 0x38
 800d262:	f011 f9bf 	bl	801e5e4 <state_get>
 800d266:	47a0      	blx	r4
            while(delay.ms)
 800d268:	4b05      	ldr	r3, [pc, #20]	; (800d280 <driver_delay+0x30>)
 800d26a:	681b      	ldr	r3, [r3, #0]
 800d26c:	2b00      	cmp	r3, #0
 800d26e:	d1f6      	bne.n	800d25e <driver_delay+0xe>
 800d270:	e7f4      	b.n	800d25c <driver_delay+0xc>
        delay.callback = NULL;
 800d272:	4b03      	ldr	r3, [pc, #12]	; (800d280 <driver_delay+0x30>)
 800d274:	2200      	movs	r2, #0
 800d276:	605a      	str	r2, [r3, #4]
        if(callback)
 800d278:	2900      	cmp	r1, #0
 800d27a:	d0ef      	beq.n	800d25c <driver_delay+0xc>
            callback();
 800d27c:	4788      	blx	r1
}
 800d27e:	e7ed      	b.n	800d25c <driver_delay+0xc>
 800d280:	20000118 	.word	0x20000118
 800d284:	2000343c 	.word	0x2000343c

0800d288 <driver_init>:

// Initialize HAL pointers, setup serial comms and enable EEPROM
// NOTE: grblHAL is not yet configured (from EEPROM data), driver_setup() will be called when done

bool driver_init (void)
{
 800d288:	b510      	push	{r4, lr}
 800d28a:	b086      	sub	sp, #24
#endif

    uint32_t latency;
    RCC_ClkInitTypeDef clock_cfg;

    HAL_RCC_GetClockConfig(&clock_cfg, &latency);
 800d28c:	a905      	add	r1, sp, #20
 800d28e:	4668      	mov	r0, sp
 800d290:	f7fd f9dc 	bl	800a64c <HAL_RCC_GetClockConfig>
#ifdef STM32F446xx
    hal.info = "STM32F446";
#elif defined(STM32F411xE)
    hal.info = "STM32F411";
#elif defined(STM32F407xx)
    hal.info = "STM32F407";
 800d294:	4b97      	ldr	r3, [pc, #604]	; (800d4f4 <driver_init+0x26c>)
 800d296:	4a98      	ldr	r2, [pc, #608]	; (800d4f8 <driver_init+0x270>)
 800d298:	605a      	str	r2, [r3, #4]
#else
    hal.info = "STM32F401CC";
#endif
    hal.driver_version = "230807";
 800d29a:	4a98      	ldr	r2, [pc, #608]	; (800d4fc <driver_init+0x274>)
 800d29c:	609a      	str	r2, [r3, #8]
    hal.driver_url = GRBL_URL "/STM32F4xx";
 800d29e:	4a98      	ldr	r2, [pc, #608]	; (800d500 <driver_init+0x278>)
 800d2a0:	611a      	str	r2, [r3, #16]
    hal.board = BOARD_NAME;
#endif
#ifdef BOARD_URL
    hal.board_url = BOARD_URL;
#endif
    hal.driver_setup = driver_setup;
 800d2a2:	4a98      	ldr	r2, [pc, #608]	; (800d504 <driver_init+0x27c>)
 800d2a4:	635a      	str	r2, [r3, #52]	; 0x34
    hal.f_step_timer = HAL_RCC_GetPCLK1Freq() * TIMER_CLOCK_MUL(clock_cfg.APB1CLKDivider) / STEPPER_TIMER_DIV;
 800d2a6:	f7fd f9b1 	bl	800a60c <HAL_RCC_GetPCLK1Freq>
 800d2aa:	9b03      	ldr	r3, [sp, #12]
 800d2ac:	2b00      	cmp	r3, #0
 800d2ae:	f040 809c 	bne.w	800d3ea <driver_init+0x162>
 800d2b2:	2301      	movs	r3, #1
 800d2b4:	fb00 f303 	mul.w	r3, r0, r3
 800d2b8:	089b      	lsrs	r3, r3, #2
 800d2ba:	4c8e      	ldr	r4, [pc, #568]	; (800d4f4 <driver_init+0x26c>)
 800d2bc:	61e3      	str	r3, [r4, #28]
    hal.rx_buffer_size = RX_BUFFER_SIZE;
 800d2be:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800d2c2:	6263      	str	r3, [r4, #36]	; 0x24
    hal.get_free_mem = get_free_mem;
 800d2c4:	4b90      	ldr	r3, [pc, #576]	; (800d508 <driver_init+0x280>)
 800d2c6:	6323      	str	r3, [r4, #48]	; 0x30
    hal.delay_ms = &driver_delay;
 800d2c8:	4b90      	ldr	r3, [pc, #576]	; (800d50c <driver_init+0x284>)
 800d2ca:	63a3      	str	r3, [r4, #56]	; 0x38
    hal.settings_changed = settings_changed;
 800d2cc:	4b90      	ldr	r3, [pc, #576]	; (800d510 <driver_init+0x288>)
 800d2ce:	f8c4 30f4 	str.w	r3, [r4, #244]	; 0xf4

    hal.stepper.wake_up = stepperWakeUp;
 800d2d2:	4b90      	ldr	r3, [pc, #576]	; (800d514 <driver_init+0x28c>)
 800d2d4:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
    hal.stepper.go_idle = stepperGoIdle;
 800d2d8:	4b8f      	ldr	r3, [pc, #572]	; (800d518 <driver_init+0x290>)
 800d2da:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
    hal.stepper.enable = stepperEnable;
 800d2de:	4b8f      	ldr	r3, [pc, #572]	; (800d51c <driver_init+0x294>)
 800d2e0:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
    hal.stepper.cycles_per_tick = stepperCyclesPerTick;
 800d2e4:	4b8e      	ldr	r3, [pc, #568]	; (800d520 <driver_init+0x298>)
 800d2e6:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
    hal.stepper.pulse_start = stepperPulseStart;
 800d2ea:	4b8e      	ldr	r3, [pc, #568]	; (800d524 <driver_init+0x29c>)
 800d2ec:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
    hal.stepper.motor_iterator = motor_iterator;
 800d2f0:	4b8d      	ldr	r3, [pc, #564]	; (800d528 <driver_init+0x2a0>)
 800d2f2:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4
#endif
#ifdef SQUARING_ENABLED
    hal.stepper.disable_motors = StepperDisableMotors;
#endif

    hal.limits.enable = limitsEnable;
 800d2f6:	4b8d      	ldr	r3, [pc, #564]	; (800d52c <driver_init+0x2a4>)
 800d2f8:	6563      	str	r3, [r4, #84]	; 0x54
    hal.limits.get_state = limitsGetState;
 800d2fa:	4b8d      	ldr	r3, [pc, #564]	; (800d530 <driver_init+0x2a8>)
 800d2fc:	65a3      	str	r3, [r4, #88]	; 0x58

    hal.coolant.set_state = coolantSetState;
 800d2fe:	4b8d      	ldr	r3, [pc, #564]	; (800d534 <driver_init+0x2ac>)
 800d300:	6723      	str	r3, [r4, #112]	; 0x70
    hal.coolant.get_state = coolantGetState;
 800d302:	4b8d      	ldr	r3, [pc, #564]	; (800d538 <driver_init+0x2b0>)
 800d304:	6763      	str	r3, [r4, #116]	; 0x74

#ifdef PROBE_PIN
    hal.probe.get_state = probeGetState;
 800d306:	4b8d      	ldr	r3, [pc, #564]	; (800d53c <driver_init+0x2b4>)
 800d308:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
    hal.probe.configure = probeConfigure;
 800d30c:	4b8c      	ldr	r3, [pc, #560]	; (800d540 <driver_init+0x2b8>)
 800d30e:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8
    hal.probe.connected_toggle = probeConnectedToggle;
 800d312:	4b8c      	ldr	r3, [pc, #560]	; (800d544 <driver_init+0x2bc>)
 800d314:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
#endif

    hal.control.get_state = systemGetState;
 800d318:	4b8b      	ldr	r3, [pc, #556]	; (800d548 <driver_init+0x2c0>)
 800d31a:	66a3      	str	r3, [r4, #104]	; 0x68

    hal.irq_enable = __enable_irq;
 800d31c:	4b8b      	ldr	r3, [pc, #556]	; (800d54c <driver_init+0x2c4>)
 800d31e:	64a3      	str	r3, [r4, #72]	; 0x48
    hal.irq_disable = __disable_irq;
 800d320:	4b8b      	ldr	r3, [pc, #556]	; (800d550 <driver_init+0x2c8>)
 800d322:	64e3      	str	r3, [r4, #76]	; 0x4c
#if I2C_STROBE_ENABLE || defined(SPI_IRQ_PIN)
    hal.irq_claim = irq_claim;
#endif
    hal.set_bits_atomic = bitsSetAtomic;
 800d324:	4b8b      	ldr	r3, [pc, #556]	; (800d554 <driver_init+0x2cc>)
 800d326:	63e3      	str	r3, [r4, #60]	; 0x3c
    hal.clear_bits_atomic = bitsClearAtomic;
 800d328:	4b8b      	ldr	r3, [pc, #556]	; (800d558 <driver_init+0x2d0>)
 800d32a:	6423      	str	r3, [r4, #64]	; 0x40
    hal.set_value_atomic = valueSetAtomic;
 800d32c:	4b8b      	ldr	r3, [pc, #556]	; (800d55c <driver_init+0x2d4>)
 800d32e:	6463      	str	r3, [r4, #68]	; 0x44
    hal.get_elapsed_ticks = getElapsedTicks;
 800d330:	4b8b      	ldr	r3, [pc, #556]	; (800d560 <driver_init+0x2d8>)
 800d332:	f8c4 3178 	str.w	r3, [r4, #376]	; 0x178
    hal.enumerate_pins = enumeratePins;
 800d336:	4b8b      	ldr	r3, [pc, #556]	; (800d564 <driver_init+0x2dc>)
 800d338:	f8c4 3170 	str.w	r3, [r4, #368]	; 0x170
    hal.periph_port.register_pin = registerPeriphPin;
 800d33c:	4b8a      	ldr	r3, [pc, #552]	; (800d568 <driver_init+0x2e0>)
 800d33e:	f8c4 3138 	str.w	r3, [r4, #312]	; 0x138
    hal.periph_port.set_pin_description = setPeriphPinDescription;
 800d342:	4b8a      	ldr	r3, [pc, #552]	; (800d56c <driver_init+0x2e4>)
 800d344:	f8c4 313c 	str.w	r3, [r4, #316]	; 0x13c
#if RTC_ENABLE
    hal.rtc.get_datetime = get_rtc_time;
    hal.rtc.set_datetime = set_rtc_time;
#endif

    serialRegisterStreams();
 800d348:	f000 fefa 	bl	800e140 <serialRegisterStreams>

#if USB_SERIAL_CDC
    stream_connect(usbInit());	//NULL
 800d34c:	f001 fa7e 	bl	800e84c <usbInit>
 800d350:	f012 ff04 	bl	802015c <stream_connect>
#endif

#if EEPROM_ENABLE
    i2c_eeprom_init();
#elif FLASH_ENABLE
    hal.nvs.type = NVS_Flash;
 800d354:	2303      	movs	r3, #3
 800d356:	f884 3144 	strb.w	r3, [r4, #324]	; 0x144
    hal.nvs.memcpy_from_flash = memcpy_from_flash;
 800d35a:	4b85      	ldr	r3, [pc, #532]	; (800d570 <driver_init+0x2e8>)
 800d35c:	f8c4 3168 	str.w	r3, [r4, #360]	; 0x168
    hal.nvs.memcpy_to_flash = memcpy_to_flash;
 800d360:	4b84      	ldr	r3, [pc, #528]	; (800d574 <driver_init+0x2ec>)
 800d362:	f8c4 316c 	str.w	r3, [r4, #364]	; 0x16c
        .set_state = spindleSetState,
        .get_state = spindleGetState
    };

#ifdef SPINDLE_PWM_TIMER_N
    spindle_id = spindle_register(&spindle, "PWM");
 800d366:	4984      	ldr	r1, [pc, #528]	; (800d578 <driver_init+0x2f0>)
 800d368:	4884      	ldr	r0, [pc, #528]	; (800d57c <driver_init+0x2f4>)
 800d36a:	f010 f985 	bl	801d678 <spindle_register>
 800d36e:	4b84      	ldr	r3, [pc, #528]	; (800d580 <driver_init+0x2f8>)
 800d370:	7018      	strb	r0, [r3, #0]
#endif // DRIVER_SPINDLE

// driver capabilities, used for announcing and negotiating (with the core) driver functionality

#if ESTOP_ENABLE
    hal.signals_cap.e_stop = On;
 800d372:	f894 31a8 	ldrb.w	r3, [r4, #424]	; 0x1a8
 800d376:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800d37a:	f884 31a8 	strb.w	r3, [r4, #424]	; 0x1a8
#endif
#ifdef SAFETY_DOOR_PIN
    hal.signals_cap.safety_door_ajar = On;
#endif
    hal.limits_cap = get_limits_cap();
 800d37e:	f7fe fe31 	bl	800bfe4 <get_limits_cap>
 800d382:	f884 01aa 	strb.w	r0, [r4, #426]	; 0x1aa
 800d386:	f3c0 2307 	ubfx	r3, r0, #8, #8
 800d38a:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
 800d38e:	f3c0 4307 	ubfx	r3, r0, #16, #8
 800d392:	f884 31ac 	strb.w	r3, [r4, #428]	; 0x1ac
 800d396:	f3c0 6007 	ubfx	r0, r0, #24, #8
 800d39a:	f884 01ad 	strb.w	r0, [r4, #429]	; 0x1ad

#if SPINDLE_SYNC_ENABLE
    hal.driver_cap.spindle_sync = On;
#endif
#ifdef COOLANT_MIST_PIN
    hal.driver_cap.mist_control = On;
 800d39e:	f894 31a4 	ldrb.w	r3, [r4, #420]	; 0x1a4
 800d3a2:	f043 0301 	orr.w	r3, r3, #1
 800d3a6:	f884 31a4 	strb.w	r3, [r4, #420]	; 0x1a4
#endif
    hal.driver_cap.software_debounce = On;
 800d3aa:	b2db      	uxtb	r3, r3
 800d3ac:	f043 0302 	orr.w	r3, r3, #2
 800d3b0:	f884 31a4 	strb.w	r3, [r4, #420]	; 0x1a4
    hal.driver_cap.step_pulse_delay = On;
 800d3b4:	b2db      	uxtb	r3, r3
 800d3b6:	f043 0304 	orr.w	r3, r3, #4
 800d3ba:	f884 31a4 	strb.w	r3, [r4, #420]	; 0x1a4
    hal.driver_cap.amass_level = 3;
 800d3be:	b2db      	uxtb	r3, r3
 800d3c0:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800d3c4:	f884 31a4 	strb.w	r3, [r4, #420]	; 0x1a4
    hal.driver_cap.control_pull_up = On;
 800d3c8:	b2db      	uxtb	r3, r3
 800d3ca:	f043 0310 	orr.w	r3, r3, #16
 800d3ce:	f884 31a4 	strb.w	r3, [r4, #420]	; 0x1a4
    hal.driver_cap.limits_pull_up = On;
 800d3d2:	b2db      	uxtb	r3, r3
 800d3d4:	f043 0308 	orr.w	r3, r3, #8
 800d3d8:	f884 31a4 	strb.w	r3, [r4, #420]	; 0x1a4
#ifdef PROBE_PIN
    hal.driver_cap.probe_pull_up = On;
 800d3dc:	b2db      	uxtb	r3, r3
 800d3de:	f043 0320 	orr.w	r3, r3, #32
 800d3e2:	f884 31a4 	strb.w	r3, [r4, #420]	; 0x1a4

    uint32_t i;
    input_signal_t *input;
    static pin_group_pins_t aux_digital_in = {0}, aux_digital_out = {0}, aux_analog_out = {0};

    for(i = 0 ; i < sizeof(inputpin) / sizeof(input_signal_t); i++) {
 800d3e6:	2300      	movs	r3, #0
 800d3e8:	e00f      	b.n	800d40a <driver_init+0x182>
    hal.f_step_timer = HAL_RCC_GetPCLK1Freq() * TIMER_CLOCK_MUL(clock_cfg.APB1CLKDivider) / STEPPER_TIMER_DIV;
 800d3ea:	2302      	movs	r3, #2
 800d3ec:	e762      	b.n	800d2b4 <driver_init+0x2c>
        input = &inputpin[i];
        if(input->group == PinGroup_AuxInput) {
            if(aux_digital_in.pins.inputs == NULL)
                aux_digital_in.pins.inputs = input;
 800d3ee:	4965      	ldr	r1, [pc, #404]	; (800d584 <driver_init+0x2fc>)
 800d3f0:	604a      	str	r2, [r1, #4]
 800d3f2:	e019      	b.n	800d428 <driver_init+0x1a0>
            input->id = (pin_function_t)(Input_Aux0 + aux_digital_in.n_pins++);
            input->bit = 1 << input->pin;
            input->cap.pull_mode = PullMode_UpDown;
            input->cap.irq_mode = ((DRIVER_IRQMASK|PROBE_IRQ_BIT) & input->bit) ? IRQ_Mode_None : IRQ_Mode_Edges;
 800d3f4:	2007      	movs	r0, #7
 800d3f6:	eb03 01c3 	add.w	r1, r3, r3, lsl #3
 800d3fa:	4a63      	ldr	r2, [pc, #396]	; (800d588 <driver_init+0x300>)
 800d3fc:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 800d400:	8b11      	ldrh	r1, [r2, #24]
 800d402:	f360 1149 	bfi	r1, r0, #5, #5
 800d406:	8311      	strh	r1, [r2, #24]
    for(i = 0 ; i < sizeof(inputpin) / sizeof(input_signal_t); i++) {
 800d408:	3301      	adds	r3, #1
 800d40a:	2b06      	cmp	r3, #6
 800d40c:	d826      	bhi.n	800d45c <driver_init+0x1d4>
        input = &inputpin[i];
 800d40e:	eb03 01c3 	add.w	r1, r3, r3, lsl #3
 800d412:	4a5d      	ldr	r2, [pc, #372]	; (800d588 <driver_init+0x300>)
 800d414:	eb02 0281 	add.w	r2, r2, r1, lsl #2
        if(input->group == PinGroup_AuxInput) {
 800d418:	6911      	ldr	r1, [r2, #16]
 800d41a:	f5b1 2f80 	cmp.w	r1, #262144	; 0x40000
 800d41e:	d1f3      	bne.n	800d408 <driver_init+0x180>
            if(aux_digital_in.pins.inputs == NULL)
 800d420:	4958      	ldr	r1, [pc, #352]	; (800d584 <driver_init+0x2fc>)
 800d422:	6849      	ldr	r1, [r1, #4]
 800d424:	2900      	cmp	r1, #0
 800d426:	d0e2      	beq.n	800d3ee <driver_init+0x166>
            input->id = (pin_function_t)(Input_Aux0 + aux_digital_in.n_pins++);
 800d428:	4956      	ldr	r1, [pc, #344]	; (800d584 <driver_init+0x2fc>)
 800d42a:	780a      	ldrb	r2, [r1, #0]
 800d42c:	1c50      	adds	r0, r2, #1
 800d42e:	7008      	strb	r0, [r1, #0]
 800d430:	322a      	adds	r2, #42	; 0x2a
 800d432:	4855      	ldr	r0, [pc, #340]	; (800d588 <driver_init+0x300>)
 800d434:	eb03 04c3 	add.w	r4, r3, r3, lsl #3
 800d438:	eb00 0184 	add.w	r1, r0, r4, lsl #2
 800d43c:	f800 2024 	strb.w	r2, [r0, r4, lsl #2]
            input->bit = 1 << input->pin;
 800d440:	7a08      	ldrb	r0, [r1, #8]
 800d442:	2201      	movs	r2, #1
 800d444:	4082      	lsls	r2, r0
 800d446:	60ca      	str	r2, [r1, #12]
            input->cap.pull_mode = PullMode_UpDown;
 800d448:	7e08      	ldrb	r0, [r1, #24]
 800d44a:	f040 0018 	orr.w	r0, r0, #24
 800d44e:	7608      	strb	r0, [r1, #24]
            input->cap.irq_mode = ((DRIVER_IRQMASK|PROBE_IRQ_BIT) & input->bit) ? IRQ_Mode_None : IRQ_Mode_Edges;
 800d450:	f247 01e0 	movw	r1, #28896	; 0x70e0
 800d454:	420a      	tst	r2, r1
 800d456:	d0cd      	beq.n	800d3f4 <driver_init+0x16c>
 800d458:	2000      	movs	r0, #0
 800d45a:	e7cc      	b.n	800d3f6 <driver_init+0x16e>
            probe_input = input;
#endif
    }

    output_signal_t *output;
    for(i = 0 ; i < sizeof(outputpin) / sizeof(output_signal_t); i++) {
 800d45c:	2300      	movs	r3, #0
 800d45e:	e00d      	b.n	800d47c <driver_init+0x1f4>
        output = &outputpin[i];
        if(output->group == PinGroup_AuxOutput) {
            if(aux_digital_out.pins.outputs == NULL)
 800d460:	494a      	ldr	r1, [pc, #296]	; (800d58c <driver_init+0x304>)
 800d462:	6849      	ldr	r1, [r1, #4]
 800d464:	b321      	cbz	r1, 800d4b0 <driver_init+0x228>
                aux_digital_out.pins.outputs = output;
            output->id = (pin_function_t)(Output_Aux0 + aux_digital_out.n_pins++);
 800d466:	4949      	ldr	r1, [pc, #292]	; (800d58c <driver_init+0x304>)
 800d468:	780a      	ldrb	r2, [r1, #0]
 800d46a:	1c50      	adds	r0, r2, #1
 800d46c:	7008      	strb	r0, [r1, #0]
 800d46e:	3273      	adds	r2, #115	; 0x73
 800d470:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 800d474:	4846      	ldr	r0, [pc, #280]	; (800d590 <driver_init+0x308>)
 800d476:	f800 2031 	strb.w	r2, [r0, r1, lsl #3]
    for(i = 0 ; i < sizeof(outputpin) / sizeof(output_signal_t); i++) {
 800d47a:	3301      	adds	r3, #1
 800d47c:	2b0a      	cmp	r3, #10
 800d47e:	d81d      	bhi.n	800d4bc <driver_init+0x234>
        output = &outputpin[i];
 800d480:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 800d484:	4a42      	ldr	r2, [pc, #264]	; (800d590 <driver_init+0x308>)
 800d486:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
        if(output->group == PinGroup_AuxOutput) {
 800d48a:	68d1      	ldr	r1, [r2, #12]
 800d48c:	2909      	cmp	r1, #9
 800d48e:	d0e7      	beq.n	800d460 <driver_init+0x1d8>
        } else if(output->group == PinGroup_AuxOutputAnalog) {
 800d490:	290b      	cmp	r1, #11
 800d492:	d1f2      	bne.n	800d47a <driver_init+0x1f2>
            if(aux_analog_out.pins.outputs == NULL)
 800d494:	493f      	ldr	r1, [pc, #252]	; (800d594 <driver_init+0x30c>)
 800d496:	6849      	ldr	r1, [r1, #4]
 800d498:	b169      	cbz	r1, 800d4b6 <driver_init+0x22e>
                aux_analog_out.pins.outputs = output;
            output->id = (pin_function_t)(Output_Analog_Aux0 + aux_analog_out.n_pins++);
 800d49a:	493e      	ldr	r1, [pc, #248]	; (800d594 <driver_init+0x30c>)
 800d49c:	780a      	ldrb	r2, [r1, #0]
 800d49e:	1c50      	adds	r0, r2, #1
 800d4a0:	7008      	strb	r0, [r1, #0]
 800d4a2:	327b      	adds	r2, #123	; 0x7b
 800d4a4:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 800d4a8:	4839      	ldr	r0, [pc, #228]	; (800d590 <driver_init+0x308>)
 800d4aa:	f800 2031 	strb.w	r2, [r0, r1, lsl #3]
 800d4ae:	e7e4      	b.n	800d47a <driver_init+0x1f2>
                aux_digital_out.pins.outputs = output;
 800d4b0:	4936      	ldr	r1, [pc, #216]	; (800d58c <driver_init+0x304>)
 800d4b2:	604a      	str	r2, [r1, #4]
 800d4b4:	e7d7      	b.n	800d466 <driver_init+0x1de>
                aux_analog_out.pins.outputs = output;
 800d4b6:	4937      	ldr	r1, [pc, #220]	; (800d594 <driver_init+0x30c>)
 800d4b8:	604a      	str	r2, [r1, #4]
 800d4ba:	e7ee      	b.n	800d49a <driver_init+0x212>
  #else
    if((hal.driver_cap.mpg_mode = stream_mpg_register(stream_open_instance(MPG_STREAM, 115200, NULL), false, NULL)))
        protocol_enqueue_rt_command(mpg_enable);
  #endif
#elif MPG_MODE == 2
    hal.driver_cap.mpg_mode = stream_mpg_register(stream_open_instance(MPG_STREAM, 115200, NULL), false, keypad_enqueue_keycode);
 800d4bc:	2200      	movs	r2, #0
 800d4be:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
 800d4c2:	4610      	mov	r0, r2
 800d4c4:	f012 fe70 	bl	80201a8 <stream_open_instance>
 800d4c8:	4a33      	ldr	r2, [pc, #204]	; (800d598 <driver_init+0x310>)
 800d4ca:	2100      	movs	r1, #0
 800d4cc:	f012 fe84 	bl	80201d8 <stream_mpg_register>
 800d4d0:	4c08      	ldr	r4, [pc, #32]	; (800d4f4 <driver_init+0x26c>)
 800d4d2:	f894 31a5 	ldrb.w	r3, [r4, #421]	; 0x1a5
 800d4d6:	f360 1386 	bfi	r3, r0, #6, #1
 800d4da:	f884 31a5 	strb.w	r3, [r4, #421]	; 0x1a5
    bluetooth_init();
#endif

#if KEYPAD_ENABLE
    extern bool keypad_init (void);
    keypad_init();
 800d4de:	f014 ff7f 	bl	80223e0 <keypad_init>
    extern void embroidery_init (void);
    embroidery_init();
#endif

    extern void my_plugin_init (void);
    my_plugin_init();
 800d4e2:	f007 fd7f 	bl	8014fe4 <my_plugin_init>

#include "grbl/plugins_init.h"

    // No need to move version check before init.
    // Compiler will fail any signature mismatch for existing entries.
    return hal.version == 10;
 800d4e6:	6820      	ldr	r0, [r4, #0]
}
 800d4e8:	280a      	cmp	r0, #10
 800d4ea:	bf14      	ite	ne
 800d4ec:	2000      	movne	r0, #0
 800d4ee:	2001      	moveq	r0, #1
 800d4f0:	b006      	add	sp, #24
 800d4f2:	bd10      	pop	{r4, pc}
 800d4f4:	2000350c 	.word	0x2000350c
 800d4f8:	080253ac 	.word	0x080253ac
 800d4fc:	080253b8 	.word	0x080253b8
 800d500:	080253c0 	.word	0x080253c0
 800d504:	0800cf1d 	.word	0x0800cf1d
 800d508:	0800cef5 	.word	0x0800cef5
 800d50c:	0800d251 	.word	0x0800d251
 800d510:	0800c7d1 	.word	0x0800c7d1
 800d514:	0800c099 	.word	0x0800c099
 800d518:	0800c0d5 	.word	0x0800c0d5
 800d51c:	0800c07d 	.word	0x0800c07d
 800d520:	0800c0e9 	.word	0x0800c0e9
 800d524:	0800c101 	.word	0x0800c101
 800d528:	0800bfbf 	.word	0x0800bfbf
 800d52c:	0800c1cd 	.word	0x0800c1cd
 800d530:	0800c1fd 	.word	0x0800c1fd
 800d534:	0800c405 	.word	0x0800c405
 800d538:	0800c429 	.word	0x0800c429
 800d53c:	0800c2dd 	.word	0x0800c2dd
 800d540:	0800c29d 	.word	0x0800c29d
 800d544:	0800c285 	.word	0x0800c285
 800d548:	0800c255 	.word	0x0800c255
 800d54c:	0800bfb7 	.word	0x0800bfb7
 800d550:	0800bfbb 	.word	0x0800bfbb
 800d554:	0800c44d 	.word	0x0800c44d
 800d558:	0800c459 	.word	0x0800c459
 800d55c:	0800c46b 	.word	0x0800c46b
 800d560:	0800c479 	.word	0x0800c479
 800d564:	0800c4f5 	.word	0x0800c4f5
 800d568:	0800cea9 	.word	0x0800cea9
 800d56c:	0800c62d 	.word	0x0800c62d
 800d570:	0800d7c1 	.word	0x0800d7c1
 800d574:	0800d7dd 	.word	0x0800d7dd
 800d578:	08027ea0 	.word	0x08027ea0
 800d57c:	08025440 	.word	0x08025440
 800d580:	20000329 	.word	0x20000329
 800d584:	2000067c 	.word	0x2000067c
 800d588:	20000120 	.word	0x20000120
 800d58c:	20000684 	.word	0x20000684
 800d590:	20000220 	.word	0x20000220
 800d594:	20000674 	.word	0x20000674
 800d598:	08022369 	.word	0x08022369

0800d59c <TIM5_IRQHandler>:

/* interrupt handlers */

// Main stepper driver
void STEPPER_TIMER_IRQHandler (void)
{
 800d59c:	b508      	push	{r3, lr}
    if ((STEPPER_TIMER->SR & TIM_SR_UIF) != 0)                  // check interrupt source
 800d59e:	4b07      	ldr	r3, [pc, #28]	; (800d5bc <TIM5_IRQHandler+0x20>)
 800d5a0:	691b      	ldr	r3, [r3, #16]
 800d5a2:	f013 0f01 	tst.w	r3, #1
 800d5a6:	d007      	beq.n	800d5b8 <TIM5_IRQHandler+0x1c>
    {
        STEPPER_TIMER->SR = ~TIM_SR_UIF; // clear UIF flag
 800d5a8:	4b04      	ldr	r3, [pc, #16]	; (800d5bc <TIM5_IRQHandler+0x20>)
 800d5aa:	f06f 0201 	mvn.w	r2, #1
 800d5ae:	611a      	str	r2, [r3, #16]
        hal.stepper.interrupt_callback();
 800d5b0:	4b03      	ldr	r3, [pc, #12]	; (800d5c0 <TIM5_IRQHandler+0x24>)
 800d5b2:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800d5b6:	4798      	blx	r3
    }
}
 800d5b8:	bd08      	pop	{r3, pc}
 800d5ba:	bf00      	nop
 800d5bc:	40000c00 	.word	0x40000c00
 800d5c0:	2000350c 	.word	0x2000350c

0800d5c4 <TIM4_IRQHandler>:
// This interrupt is enabled when Grbl sets the motor port bits to execute
// a step. This ISR resets the motor port after a short period (settings.pulse_microseconds)
// completing one step cycle.
void PULSE_TIMER_IRQHandler (void)
{
    PULSE_TIMER->SR &= ~TIM_SR_UIF;                 // Clear UIF flag
 800d5c4:	4b14      	ldr	r3, [pc, #80]	; (800d618 <TIM4_IRQHandler+0x54>)
 800d5c6:	691a      	ldr	r2, [r3, #16]
 800d5c8:	f022 0201 	bic.w	r2, r2, #1
 800d5cc:	611a      	str	r2, [r3, #16]

    if (PULSE_TIMER->ARR == pulse_delay)            // Delayed step pulse?
 800d5ce:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800d5d0:	4b12      	ldr	r3, [pc, #72]	; (800d61c <TIM4_IRQHandler+0x58>)
 800d5d2:	681b      	ldr	r3, [r3, #0]
 800d5d4:	429a      	cmp	r2, r3
 800d5d6:	d008      	beq.n	800d5ea <TIM4_IRQHandler+0x26>
    STEP_PORT->ODR = (STEP_PORT->ODR & ~STEP_MASK) | step_outmap[step_outbits.value];
 800d5d8:	4a11      	ldr	r2, [pc, #68]	; (800d620 <TIM4_IRQHandler+0x5c>)
 800d5da:	6953      	ldr	r3, [r2, #20]
 800d5dc:	f023 0307 	bic.w	r3, r3, #7
 800d5e0:	4910      	ldr	r1, [pc, #64]	; (800d624 <TIM4_IRQHandler+0x60>)
 800d5e2:	6809      	ldr	r1, [r1, #0]
 800d5e4:	430b      	orrs	r3, r1
 800d5e6:	6153      	str	r3, [r2, #20]
        stepperSetStepOutputs(next_step_outbits);   // begin step pulse
        PULSE_TIMER->EGR = TIM_EGR_UG;
        PULSE_TIMER->CR1 |= TIM_CR1_CEN;
    } else
        stepperSetStepOutputs((axes_signals_t){0}); // end step pulse
}
 800d5e8:	4770      	bx	lr
        PULSE_TIMER->ARR = pulse_length;
 800d5ea:	4b0f      	ldr	r3, [pc, #60]	; (800d628 <TIM4_IRQHandler+0x64>)
 800d5ec:	681b      	ldr	r3, [r3, #0]
 800d5ee:	4a0a      	ldr	r2, [pc, #40]	; (800d618 <TIM4_IRQHandler+0x54>)
 800d5f0:	62d3      	str	r3, [r2, #44]	; 0x2c
    STEP_PORT->ODR = (STEP_PORT->ODR & ~STEP_MASK) | step_outmap[step_outbits.value];
 800d5f2:	490b      	ldr	r1, [pc, #44]	; (800d620 <TIM4_IRQHandler+0x5c>)
 800d5f4:	694b      	ldr	r3, [r1, #20]
 800d5f6:	f023 0307 	bic.w	r3, r3, #7
 800d5fa:	480c      	ldr	r0, [pc, #48]	; (800d62c <TIM4_IRQHandler+0x68>)
 800d5fc:	f890 c000 	ldrb.w	ip, [r0]
 800d600:	4808      	ldr	r0, [pc, #32]	; (800d624 <TIM4_IRQHandler+0x60>)
 800d602:	f850 002c 	ldr.w	r0, [r0, ip, lsl #2]
 800d606:	4303      	orrs	r3, r0
 800d608:	614b      	str	r3, [r1, #20]
        PULSE_TIMER->EGR = TIM_EGR_UG;
 800d60a:	2301      	movs	r3, #1
 800d60c:	6153      	str	r3, [r2, #20]
        PULSE_TIMER->CR1 |= TIM_CR1_CEN;
 800d60e:	6813      	ldr	r3, [r2, #0]
 800d610:	f043 0301 	orr.w	r3, r3, #1
 800d614:	6013      	str	r3, [r2, #0]
 800d616:	4770      	bx	lr
 800d618:	40000800 	.word	0x40000800
 800d61c:	200006ec 	.word	0x200006ec
 800d620:	40020000 	.word	0x40020000
 800d624:	2000074c 	.word	0x2000074c
 800d628:	200006f0 	.word	0x200006f0
 800d62c:	200006b8 	.word	0x200006b8

0800d630 <TIM1_BRK_TIM9_IRQHandler>:
    return hal.driver_cap.software_debounce;
}

// Debounce timer interrupt handler
void DEBOUNCE_TIMER_IRQHandler (void)
{
 800d630:	b500      	push	{lr}
 800d632:	b083      	sub	sp, #12
    DEBOUNCE_TIMER->SR = ~TIM_SR_UIF; // clear UIF flag;
 800d634:	4b22      	ldr	r3, [pc, #136]	; (800d6c0 <TIM1_BRK_TIM9_IRQHandler+0x90>)
 800d636:	f06f 0201 	mvn.w	r2, #1
 800d63a:	611a      	str	r2, [r3, #16]

    if(debounce.limits) {
 800d63c:	4b21      	ldr	r3, [pc, #132]	; (800d6c4 <TIM1_BRK_TIM9_IRQHandler+0x94>)
 800d63e:	781b      	ldrb	r3, [r3, #0]
 800d640:	f013 0f01 	tst.w	r3, #1
 800d644:	d10b      	bne.n	800d65e <TIM1_BRK_TIM9_IRQHandler+0x2e>
        limit_signals_t state = limitsGetState();
        if(limit_signals_merge(state).value) //TODO: add check for limit switches having same state as when limit_isr were invoked?
            hal.limits.interrupt_callback(state);
    }

    if(debounce.door) {
 800d646:	4b1f      	ldr	r3, [pc, #124]	; (800d6c4 <TIM1_BRK_TIM9_IRQHandler+0x94>)
 800d648:	781b      	ldrb	r3, [r3, #0]
 800d64a:	f013 0f02 	tst.w	r3, #2
 800d64e:	d128      	bne.n	800d6a2 <TIM1_BRK_TIM9_IRQHandler+0x72>
        debounce.door = Off;
        control_signals_t state = systemGetState();
        if(state.safety_door_ajar)
            hal.control.interrupt_callback(state);
    }
    DIGITAL_OUT(COOLANT_FLOOD_PORT, COOLANT_FLOOD_PIN, 0);
 800d650:	4b1d      	ldr	r3, [pc, #116]	; (800d6c8 <TIM1_BRK_TIM9_IRQHandler+0x98>)
 800d652:	2200      	movs	r2, #0
 800d654:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90
        debounce.qei_select = Off;
        qei_select_handler();
    }

#endif
}
 800d658:	b003      	add	sp, #12
 800d65a:	f85d fb04 	ldr.w	pc, [sp], #4
        debounce.limits = Off;
 800d65e:	4b19      	ldr	r3, [pc, #100]	; (800d6c4 <TIM1_BRK_TIM9_IRQHandler+0x94>)
 800d660:	781a      	ldrb	r2, [r3, #0]
 800d662:	f36f 0200 	bfc	r2, #0, #1
 800d666:	701a      	strb	r2, [r3, #0]
    limit_signals_t signals = {0};
 800d668:	2300      	movs	r3, #0
 800d66a:	9300      	str	r3, [sp, #0]
    signals.min.mask = settings.limits.invert.mask;
 800d66c:	4b17      	ldr	r3, [pc, #92]	; (800d6cc <TIM1_BRK_TIM9_IRQHandler+0x9c>)
 800d66e:	f893 3125 	ldrb.w	r3, [r3, #293]	; 0x125
 800d672:	f88d 3000 	strb.w	r3, [sp]
    signals.min.value = (uint8_t)((LIMIT_PORT->IDR & LIMIT_MASK) >> LIMIT_INMODE);
 800d676:	4a16      	ldr	r2, [pc, #88]	; (800d6d0 <TIM1_BRK_TIM9_IRQHandler+0xa0>)
 800d678:	6912      	ldr	r2, [r2, #16]
 800d67a:	f3c2 3202 	ubfx	r2, r2, #12, #3
 800d67e:	f88d 2000 	strb.w	r2, [sp]
    if (settings.limits.invert.mask) {
 800d682:	b113      	cbz	r3, 800d68a <TIM1_BRK_TIM9_IRQHandler+0x5a>
        signals.min.value ^= settings.limits.invert.mask;
 800d684:	4053      	eors	r3, r2
 800d686:	f88d 3000 	strb.w	r3, [sp]
    return signals;
 800d68a:	9800      	ldr	r0, [sp, #0]
 800d68c:	9001      	str	r0, [sp, #4]
        if(limit_signals_merge(state).value) //TODO: add check for limit switches having same state as when limit_isr were invoked?
 800d68e:	f005 fe33 	bl	80132f8 <limit_signals_merge>
 800d692:	b2c0      	uxtb	r0, r0
 800d694:	2800      	cmp	r0, #0
 800d696:	d0d6      	beq.n	800d646 <TIM1_BRK_TIM9_IRQHandler+0x16>
            hal.limits.interrupt_callback(state);
 800d698:	4b0e      	ldr	r3, [pc, #56]	; (800d6d4 <TIM1_BRK_TIM9_IRQHandler+0xa4>)
 800d69a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800d69c:	9800      	ldr	r0, [sp, #0]
 800d69e:	4798      	blx	r3
 800d6a0:	e7d1      	b.n	800d646 <TIM1_BRK_TIM9_IRQHandler+0x16>
        debounce.door = Off;
 800d6a2:	4b08      	ldr	r3, [pc, #32]	; (800d6c4 <TIM1_BRK_TIM9_IRQHandler+0x94>)
 800d6a4:	781a      	ldrb	r2, [r3, #0]
 800d6a6:	f36f 0241 	bfc	r2, #1, #1
 800d6aa:	701a      	strb	r2, [r3, #0]
        control_signals_t state = systemGetState();
 800d6ac:	f7fe fdd2 	bl	800c254 <systemGetState>
        if(state.safety_door_ajar)
 800d6b0:	f010 0f08 	tst.w	r0, #8
 800d6b4:	d0cc      	beq.n	800d650 <TIM1_BRK_TIM9_IRQHandler+0x20>
            hal.control.interrupt_callback(state);
 800d6b6:	4b07      	ldr	r3, [pc, #28]	; (800d6d4 <TIM1_BRK_TIM9_IRQHandler+0xa4>)
 800d6b8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800d6ba:	4798      	blx	r3
 800d6bc:	e7c8      	b.n	800d650 <TIM1_BRK_TIM9_IRQHandler+0x20>
 800d6be:	bf00      	nop
 800d6c0:	40014000 	.word	0x40014000
 800d6c4:	20000690 	.word	0x20000690
 800d6c8:	42408200 	.word	0x42408200
 800d6cc:	20003b14 	.word	0x20003b14
 800d6d0:	40020400 	.word	0x40020400
 800d6d4:	2000350c 	.word	0x2000350c

0800d6d8 <EXTI9_5_IRQHandler>:

#if ((DRIVER_IRQMASK|PROBE_IRQ_BIT|AUXINPUT_MASK) & 0x03E0)

void EXTI9_5_IRQHandler(void)
{
    uint32_t ifg = __HAL_GPIO_EXTI_GET_IT(0x03E0);
 800d6d8:	4b08      	ldr	r3, [pc, #32]	; (800d6fc <EXTI9_5_IRQHandler+0x24>)
 800d6da:	695b      	ldr	r3, [r3, #20]

    if(ifg) {
 800d6dc:	f413 7278 	ands.w	r2, r3, #992	; 0x3e0
 800d6e0:	d004      	beq.n	800d6ec <EXTI9_5_IRQHandler+0x14>
        __HAL_GPIO_EXTI_CLEAR_IT(ifg);
 800d6e2:	4906      	ldr	r1, [pc, #24]	; (800d6fc <EXTI9_5_IRQHandler+0x24>)
 800d6e4:	614a      	str	r2, [r1, #20]
            if(!(debounce.qei_select = debounce_start()))
                qei_select_handler();
        }
#endif
#if CONTROL_MASK & 0x03E0
        if(ifg & CONTROL_MASK) {
 800d6e6:	f013 0fe0 	tst.w	r3, #224	; 0xe0
 800d6ea:	d100      	bne.n	800d6ee <EXTI9_5_IRQHandler+0x16>
 800d6ec:	4770      	bx	lr
{
 800d6ee:	b510      	push	{r4, lr}
  #if SAFETY_DOOR_BIT & 0x03E0
            if(!(ifg & SAFETY_DOOR_BIT) || !(debounce.door = debounce_start()))
  #endif
            hal.control.interrupt_callback(systemGetState());
 800d6f0:	4b03      	ldr	r3, [pc, #12]	; (800d700 <EXTI9_5_IRQHandler+0x28>)
 800d6f2:	6edc      	ldr	r4, [r3, #108]	; 0x6c
 800d6f4:	f7fe fdae 	bl	800c254 <systemGetState>
 800d6f8:	47a0      	blx	r4
#if AUXINPUT_MASK & 0x03E0
        if(ifg & aux_irq)
            ioports_event(ifg & aux_irq);
#endif
    }
}
 800d6fa:	bd10      	pop	{r4, pc}
 800d6fc:	40013c00 	.word	0x40013c00
 800d700:	2000350c 	.word	0x2000350c

0800d704 <EXTI15_10_IRQHandler>:

#if (DRIVER_IRQMASK|PROBE_IRQ_BIT|AUXINPUT_MASK) & (0xFC00)

void EXTI15_10_IRQHandler(void)
{
    uint32_t ifg = __HAL_GPIO_EXTI_GET_IT(0xFC00);
 800d704:	4b1f      	ldr	r3, [pc, #124]	; (800d784 <EXTI15_10_IRQHandler+0x80>)
 800d706:	695b      	ldr	r3, [r3, #20]

    if(ifg) {
 800d708:	f413 427c 	ands.w	r2, r3, #64512	; 0xfc00
 800d70c:	d004      	beq.n	800d718 <EXTI15_10_IRQHandler+0x14>
        __HAL_GPIO_EXTI_CLEAR_IT(ifg);
 800d70e:	491d      	ldr	r1, [pc, #116]	; (800d784 <EXTI15_10_IRQHandler+0x80>)
 800d710:	614a      	str	r2, [r1, #20]
  #endif
            hal.control.interrupt_callback(systemGetState());
        }
#endif
#if LIMIT_MASK & 0xFC00
        if(ifg & LIMIT_MASK) {
 800d712:	f413 4fe0 	tst.w	r3, #28672	; 0x7000
 800d716:	d100      	bne.n	800d71a <EXTI15_10_IRQHandler+0x16>
 800d718:	4770      	bx	lr
    if(hal.driver_cap.software_debounce) {
 800d71a:	4b1b      	ldr	r3, [pc, #108]	; (800d788 <EXTI15_10_IRQHandler+0x84>)
 800d71c:	f893 31a4 	ldrb.w	r3, [r3, #420]	; 0x1a4
 800d720:	f013 0f02 	tst.w	r3, #2
 800d724:	d006      	beq.n	800d734 <EXTI15_10_IRQHandler+0x30>
        DEBOUNCE_TIMER->EGR = TIM_EGR_UG;
 800d726:	4b19      	ldr	r3, [pc, #100]	; (800d78c <EXTI15_10_IRQHandler+0x88>)
 800d728:	2201      	movs	r2, #1
 800d72a:	615a      	str	r2, [r3, #20]
        DEBOUNCE_TIMER->CR1 |= TIM_CR1_CEN; // Start debounce timer (40ms)
 800d72c:	681a      	ldr	r2, [r3, #0]
 800d72e:	f042 0201 	orr.w	r2, r2, #1
 800d732:	601a      	str	r2, [r3, #0]
    return hal.driver_cap.software_debounce;
 800d734:	4b14      	ldr	r3, [pc, #80]	; (800d788 <EXTI15_10_IRQHandler+0x84>)
 800d736:	f893 31a4 	ldrb.w	r3, [r3, #420]	; 0x1a4
 800d73a:	f3c3 0340 	ubfx	r3, r3, #1, #1
            if(!(debounce.limits = debounce_start()))
 800d73e:	4a14      	ldr	r2, [pc, #80]	; (800d790 <EXTI15_10_IRQHandler+0x8c>)
 800d740:	7811      	ldrb	r1, [r2, #0]
 800d742:	f363 0100 	bfi	r1, r3, #0, #1
 800d746:	7011      	strb	r1, [r2, #0]
 800d748:	2b00      	cmp	r3, #0
 800d74a:	d1e5      	bne.n	800d718 <EXTI15_10_IRQHandler+0x14>
{
 800d74c:	b500      	push	{lr}
 800d74e:	b085      	sub	sp, #20
                hal.limits.interrupt_callback(limitsGetState());
 800d750:	4b0d      	ldr	r3, [pc, #52]	; (800d788 <EXTI15_10_IRQHandler+0x84>)
 800d752:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
    limit_signals_t signals = {0};
 800d754:	2300      	movs	r3, #0
 800d756:	9301      	str	r3, [sp, #4]
    signals.min.mask = settings.limits.invert.mask;
 800d758:	4b0e      	ldr	r3, [pc, #56]	; (800d794 <EXTI15_10_IRQHandler+0x90>)
 800d75a:	f893 3125 	ldrb.w	r3, [r3, #293]	; 0x125
 800d75e:	f88d 3004 	strb.w	r3, [sp, #4]
    signals.min.value = (uint8_t)((LIMIT_PORT->IDR & LIMIT_MASK) >> LIMIT_INMODE);
 800d762:	4a0d      	ldr	r2, [pc, #52]	; (800d798 <EXTI15_10_IRQHandler+0x94>)
 800d764:	6912      	ldr	r2, [r2, #16]
 800d766:	f3c2 3202 	ubfx	r2, r2, #12, #3
 800d76a:	f88d 2004 	strb.w	r2, [sp, #4]
    if (settings.limits.invert.mask) {
 800d76e:	b113      	cbz	r3, 800d776 <EXTI15_10_IRQHandler+0x72>
        signals.min.value ^= settings.limits.invert.mask;
 800d770:	4053      	eors	r3, r2
 800d772:	f88d 3004 	strb.w	r3, [sp, #4]
    return signals;
 800d776:	9801      	ldr	r0, [sp, #4]
 800d778:	9003      	str	r0, [sp, #12]
 800d77a:	9002      	str	r0, [sp, #8]
                hal.limits.interrupt_callback(limitsGetState());
 800d77c:	4788      	blx	r1
#if AUXINPUT_MASK & 0xFC00
        if(ifg & aux_irq)
            ioports_event(ifg & aux_irq);
#endif
    }
}
 800d77e:	b005      	add	sp, #20
 800d780:	f85d fb04 	ldr.w	pc, [sp], #4
 800d784:	40013c00 	.word	0x40013c00
 800d788:	2000350c 	.word	0x2000350c
 800d78c:	40014000 	.word	0x40014000
 800d790:	20000690 	.word	0x20000690
 800d794:	20003b14 	.word	0x20003b14
 800d798:	40020400 	.word	0x40020400

0800d79c <Driver_IncTick>:

#endif

// Interrupt handler for 1 ms interval timer
void Driver_IncTick (void)
{
 800d79c:	b508      	push	{r3, lr}
        disk_timerproc();
        fatfs_ticks = 10;
    }
#endif

    if(delay.ms && !(--delay.ms)) {
 800d79e:	4b07      	ldr	r3, [pc, #28]	; (800d7bc <Driver_IncTick+0x20>)
 800d7a0:	681b      	ldr	r3, [r3, #0]
 800d7a2:	b153      	cbz	r3, 800d7ba <Driver_IncTick+0x1e>
 800d7a4:	4a05      	ldr	r2, [pc, #20]	; (800d7bc <Driver_IncTick+0x20>)
 800d7a6:	6813      	ldr	r3, [r2, #0]
 800d7a8:	3b01      	subs	r3, #1
 800d7aa:	6013      	str	r3, [r2, #0]
 800d7ac:	b92b      	cbnz	r3, 800d7ba <Driver_IncTick+0x1e>
        if(delay.callback) {
 800d7ae:	6853      	ldr	r3, [r2, #4]
 800d7b0:	b11b      	cbz	r3, 800d7ba <Driver_IncTick+0x1e>
            delay.callback();
 800d7b2:	4798      	blx	r3
            delay.callback = NULL;
 800d7b4:	4b01      	ldr	r3, [pc, #4]	; (800d7bc <Driver_IncTick+0x20>)
 800d7b6:	2200      	movs	r2, #0
 800d7b8:	605a      	str	r2, [r3, #4]
        }
    }
}
 800d7ba:	bd08      	pop	{r3, pc}
 800d7bc:	20000118 	.word	0x20000118

0800d7c0 <memcpy_from_flash>:

extern void *_EEPROM_Emul_Start;
extern uint8_t _EEPROM_Emul_Sector;

bool memcpy_from_flash (uint8_t *dest)
{
 800d7c0:	b508      	push	{r3, lr}
    memcpy(dest, &_EEPROM_Emul_Start, hal.nvs.size);
 800d7c2:	4b04      	ldr	r3, [pc, #16]	; (800d7d4 <memcpy_from_flash+0x14>)
 800d7c4:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
 800d7c8:	4903      	ldr	r1, [pc, #12]	; (800d7d8 <memcpy_from_flash+0x18>)
 800d7ca:	f015 fb31 	bl	8022e30 <memcpy>

    return true;
}
 800d7ce:	2001      	movs	r0, #1
 800d7d0:	bd08      	pop	{r3, pc}
 800d7d2:	bf00      	nop
 800d7d4:	2000350c 	.word	0x2000350c
 800d7d8:	08004000 	.word	0x08004000

0800d7dc <memcpy_to_flash>:

bool memcpy_to_flash (uint8_t *source)
{
 800d7dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d7e0:	b082      	sub	sp, #8
 800d7e2:	4605      	mov	r5, r0
    if (!memcmp(source, &_EEPROM_Emul_Start, hal.nvs.size))
 800d7e4:	4b21      	ldr	r3, [pc, #132]	; (800d86c <memcpy_to_flash+0x90>)
 800d7e6:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
 800d7ea:	4921      	ldr	r1, [pc, #132]	; (800d870 <memcpy_to_flash+0x94>)
 800d7ec:	f015 f9b3 	bl	8022b56 <memcmp>
 800d7f0:	b918      	cbnz	r0, 800d7fa <memcpy_to_flash+0x1e>
        return true;
 800d7f2:	2001      	movs	r0, #1

        HAL_FLASH_Lock();
    }

    return status == HAL_OK;
}
 800d7f4:	b002      	add	sp, #8
 800d7f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if((status = HAL_FLASH_Unlock()) == HAL_OK) {
 800d7fa:	f7fb fc23 	bl	8009044 <HAL_FLASH_Unlock>
 800d7fe:	4604      	mov	r4, r0
 800d800:	b118      	cbz	r0, 800d80a <memcpy_to_flash+0x2e>
    return status == HAL_OK;
 800d802:	fab4 f084 	clz	r0, r4
 800d806:	0940      	lsrs	r0, r0, #5
 800d808:	e7f4      	b.n	800d7f4 <memcpy_to_flash+0x18>
        if((status = HAL_FLASHEx_Erase(&erase, &error)) != HAL_OK)
 800d80a:	a901      	add	r1, sp, #4
 800d80c:	4819      	ldr	r0, [pc, #100]	; (800d874 <memcpy_to_flash+0x98>)
 800d80e:	f7fb fd11 	bl	8009234 <HAL_FLASHEx_Erase>
 800d812:	4604      	mov	r4, r0
 800d814:	b920      	cbnz	r0, 800d820 <memcpy_to_flash+0x44>
        uint32_t address = (uint32_t)&_EEPROM_Emul_Start, remaining = (uint32_t)hal.nvs.size;
 800d816:	4f16      	ldr	r7, [pc, #88]	; (800d870 <memcpy_to_flash+0x94>)
 800d818:	4b14      	ldr	r3, [pc, #80]	; (800d86c <memcpy_to_flash+0x90>)
 800d81a:	f8d3 8148 	ldr.w	r8, [r3, #328]	; 0x148
        while(remaining && status == HAL_OK) {
 800d81e:	e009      	b.n	800d834 <memcpy_to_flash+0x58>
            status = HAL_FLASHEx_Erase(&erase, &error);
 800d820:	a901      	add	r1, sp, #4
 800d822:	4814      	ldr	r0, [pc, #80]	; (800d874 <memcpy_to_flash+0x98>)
 800d824:	f7fb fd06 	bl	8009234 <HAL_FLASHEx_Erase>
 800d828:	4604      	mov	r4, r0
 800d82a:	e7f4      	b.n	800d816 <memcpy_to_flash+0x3a>
            address += 4;
 800d82c:	3704      	adds	r7, #4
            remaining -= 4;
 800d82e:	f1a8 0804 	sub.w	r8, r8, #4
 800d832:	4635      	mov	r5, r6
        while(remaining && status == HAL_OK) {
 800d834:	f1b8 0f00 	cmp.w	r8, #0
 800d838:	d014      	beq.n	800d864 <memcpy_to_flash+0x88>
 800d83a:	b99c      	cbnz	r4, 800d864 <memcpy_to_flash+0x88>
            if((status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, address, *data++)) == HAL_OK)
 800d83c:	462e      	mov	r6, r5
 800d83e:	f836 2b02 	ldrh.w	r2, [r6], #2
 800d842:	2300      	movs	r3, #0
 800d844:	4639      	mov	r1, r7
 800d846:	2001      	movs	r0, #1
 800d848:	f7fb fc4e 	bl	80090e8 <HAL_FLASH_Program>
 800d84c:	4604      	mov	r4, r0
 800d84e:	2800      	cmp	r0, #0
 800d850:	d1ec      	bne.n	800d82c <memcpy_to_flash+0x50>
                status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, address + 2, *data++);
 800d852:	1d2e      	adds	r6, r5, #4
 800d854:	886a      	ldrh	r2, [r5, #2]
 800d856:	2300      	movs	r3, #0
 800d858:	1cb9      	adds	r1, r7, #2
 800d85a:	2001      	movs	r0, #1
 800d85c:	f7fb fc44 	bl	80090e8 <HAL_FLASH_Program>
 800d860:	4604      	mov	r4, r0
 800d862:	e7e3      	b.n	800d82c <memcpy_to_flash+0x50>
        HAL_FLASH_Lock();
 800d864:	f7fb fc06 	bl	8009074 <HAL_FLASH_Lock>
 800d868:	e7cb      	b.n	800d802 <memcpy_to_flash+0x26>
 800d86a:	bf00      	nop
 800d86c:	2000350c 	.word	0x2000350c
 800d870:	08004000 	.word	0x08004000
 800d874:	2000032c 	.word	0x2000032c

0800d878 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 800d878:	b088      	sub	sp, #32
  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800d87a:	2200      	movs	r2, #0
 800d87c:	9200      	str	r2, [sp, #0]
 800d87e:	4b29      	ldr	r3, [pc, #164]	; (800d924 <MX_GPIO_Init+0xac>)
 800d880:	6b19      	ldr	r1, [r3, #48]	; 0x30
 800d882:	f041 0101 	orr.w	r1, r1, #1
 800d886:	6319      	str	r1, [r3, #48]	; 0x30
 800d888:	6b19      	ldr	r1, [r3, #48]	; 0x30
 800d88a:	f001 0101 	and.w	r1, r1, #1
 800d88e:	9100      	str	r1, [sp, #0]
 800d890:	9900      	ldr	r1, [sp, #0]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 800d892:	9201      	str	r2, [sp, #4]
 800d894:	6b19      	ldr	r1, [r3, #48]	; 0x30
 800d896:	f041 0102 	orr.w	r1, r1, #2
 800d89a:	6319      	str	r1, [r3, #48]	; 0x30
 800d89c:	6b19      	ldr	r1, [r3, #48]	; 0x30
 800d89e:	f001 0102 	and.w	r1, r1, #2
 800d8a2:	9101      	str	r1, [sp, #4]
 800d8a4:	9901      	ldr	r1, [sp, #4]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800d8a6:	9202      	str	r2, [sp, #8]
 800d8a8:	6b19      	ldr	r1, [r3, #48]	; 0x30
 800d8aa:	f041 0104 	orr.w	r1, r1, #4
 800d8ae:	6319      	str	r1, [r3, #48]	; 0x30
 800d8b0:	6b19      	ldr	r1, [r3, #48]	; 0x30
 800d8b2:	f001 0104 	and.w	r1, r1, #4
 800d8b6:	9102      	str	r1, [sp, #8]
 800d8b8:	9902      	ldr	r1, [sp, #8]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 800d8ba:	9203      	str	r2, [sp, #12]
 800d8bc:	6b19      	ldr	r1, [r3, #48]	; 0x30
 800d8be:	f041 0108 	orr.w	r1, r1, #8
 800d8c2:	6319      	str	r1, [r3, #48]	; 0x30
 800d8c4:	6b19      	ldr	r1, [r3, #48]	; 0x30
 800d8c6:	f001 0108 	and.w	r1, r1, #8
 800d8ca:	9103      	str	r1, [sp, #12]
 800d8cc:	9903      	ldr	r1, [sp, #12]
  __HAL_RCC_GPIOE_CLK_ENABLE();
 800d8ce:	9204      	str	r2, [sp, #16]
 800d8d0:	6b19      	ldr	r1, [r3, #48]	; 0x30
 800d8d2:	f041 0110 	orr.w	r1, r1, #16
 800d8d6:	6319      	str	r1, [r3, #48]	; 0x30
 800d8d8:	6b19      	ldr	r1, [r3, #48]	; 0x30
 800d8da:	f001 0110 	and.w	r1, r1, #16
 800d8de:	9104      	str	r1, [sp, #16]
 800d8e0:	9904      	ldr	r1, [sp, #16]
#ifdef GPIOF
  __HAL_RCC_GPIOF_CLK_ENABLE();
 800d8e2:	9205      	str	r2, [sp, #20]
 800d8e4:	6b19      	ldr	r1, [r3, #48]	; 0x30
 800d8e6:	f041 0120 	orr.w	r1, r1, #32
 800d8ea:	6319      	str	r1, [r3, #48]	; 0x30
 800d8ec:	6b19      	ldr	r1, [r3, #48]	; 0x30
 800d8ee:	f001 0120 	and.w	r1, r1, #32
 800d8f2:	9105      	str	r1, [sp, #20]
 800d8f4:	9905      	ldr	r1, [sp, #20]
#endif
#ifdef GPIOG
  __HAL_RCC_GPIOG_CLK_ENABLE();
 800d8f6:	9206      	str	r2, [sp, #24]
 800d8f8:	6b19      	ldr	r1, [r3, #48]	; 0x30
 800d8fa:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 800d8fe:	6319      	str	r1, [r3, #48]	; 0x30
 800d900:	6b19      	ldr	r1, [r3, #48]	; 0x30
 800d902:	f001 0140 	and.w	r1, r1, #64	; 0x40
 800d906:	9106      	str	r1, [sp, #24]
 800d908:	9906      	ldr	r1, [sp, #24]
#endif
#ifdef GPIOH
  __HAL_RCC_GPIOH_CLK_ENABLE();
 800d90a:	9207      	str	r2, [sp, #28]
 800d90c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800d90e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800d912:	631a      	str	r2, [r3, #48]	; 0x30
 800d914:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d916:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800d91a:	9307      	str	r3, [sp, #28]
 800d91c:	9b07      	ldr	r3, [sp, #28]
#endif
}
 800d91e:	b008      	add	sp, #32
 800d920:	4770      	bx	lr
 800d922:	bf00      	nop
 800d924:	40023800 	.word	0x40023800

0800d928 <SystemClock_Config>:
{
 800d928:	b510      	push	{r4, lr}
 800d92a:	b094      	sub	sp, #80	; 0x50
  __HAL_RCC_PWR_CLK_ENABLE();
 800d92c:	2100      	movs	r1, #0
 800d92e:	9101      	str	r1, [sp, #4]
 800d930:	4b1e      	ldr	r3, [pc, #120]	; (800d9ac <SystemClock_Config+0x84>)
 800d932:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800d934:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800d938:	641a      	str	r2, [r3, #64]	; 0x40
 800d93a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d93c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800d940:	9301      	str	r3, [sp, #4]
 800d942:	9b01      	ldr	r3, [sp, #4]
   __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 800d944:	9102      	str	r1, [sp, #8]
 800d946:	4b1a      	ldr	r3, [pc, #104]	; (800d9b0 <SystemClock_Config+0x88>)
 800d948:	681a      	ldr	r2, [r3, #0]
 800d94a:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800d94e:	601a      	str	r2, [r3, #0]
 800d950:	681b      	ldr	r3, [r3, #0]
 800d952:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800d956:	9302      	str	r3, [sp, #8]
 800d958:	9b02      	ldr	r3, [sp, #8]
    RCC_OscInitTypeDef RCC_OscInitStruct = {
 800d95a:	2230      	movs	r2, #48	; 0x30
 800d95c:	a808      	add	r0, sp, #32
 800d95e:	f015 f90a 	bl	8022b76 <memset>
 800d962:	2301      	movs	r3, #1
 800d964:	9308      	str	r3, [sp, #32]
 800d966:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800d96a:	9309      	str	r3, [sp, #36]	; 0x24
 800d96c:	2302      	movs	r3, #2
 800d96e:	930e      	str	r3, [sp, #56]	; 0x38
 800d970:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 800d974:	920f      	str	r2, [sp, #60]	; 0x3c
 800d976:	2208      	movs	r2, #8
 800d978:	9210      	str	r2, [sp, #64]	; 0x40
 800d97a:	f44f 72a8 	mov.w	r2, #336	; 0x150
 800d97e:	9211      	str	r2, [sp, #68]	; 0x44
 800d980:	9312      	str	r3, [sp, #72]	; 0x48
 800d982:	2307      	movs	r3, #7
 800d984:	9313      	str	r3, [sp, #76]	; 0x4c
    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
 800d986:	a808      	add	r0, sp, #32
 800d988:	f7fc fb26 	bl	8009fd8 <HAL_RCC_OscConfig>
    RCC_ClkInitTypeDef RCC_ClkInitStruct = {
 800d98c:	f10d 0c0c 	add.w	ip, sp, #12
 800d990:	4c08      	ldr	r4, [pc, #32]	; (800d9b4 <SystemClock_Config+0x8c>)
 800d992:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800d994:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 800d998:	6823      	ldr	r3, [r4, #0]
 800d99a:	f8cc 3000 	str.w	r3, [ip]
    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY) != HAL_OK) {
 800d99e:	2105      	movs	r1, #5
 800d9a0:	a803      	add	r0, sp, #12
 800d9a2:	f7fc fd7d 	bl	800a4a0 <HAL_RCC_ClockConfig>
}
 800d9a6:	b014      	add	sp, #80	; 0x50
 800d9a8:	bd10      	pop	{r4, pc}
 800d9aa:	bf00      	nop
 800d9ac:	40023800 	.word	0x40023800
 800d9b0:	40007000 	.word	0x40007000
 800d9b4:	08025370 	.word	0x08025370

0800d9b8 <main>:
{
 800d9b8:	b508      	push	{r3, lr}
    HAL_Init();
 800d9ba:	f7fb f9f3 	bl	8008da4 <HAL_Init>
    SystemClock_Config();
 800d9be:	f7ff ffb3 	bl	800d928 <SystemClock_Config>
    MX_GPIO_Init();
 800d9c2:	f7ff ff59 	bl	800d878 <MX_GPIO_Init>
    grbl_enter();
 800d9c6:	f005 f9d3 	bl	8012d70 <grbl_enter>
    while(1);
 800d9ca:	e7fe      	b.n	800d9ca <main+0x12>

0800d9cc <Error_Handler>:
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}
 800d9cc:	4770      	bx	lr
	...

0800d9d0 <serialRxFree>:
//
// Returns number of free characters in serial input buffer
//
static uint16_t serialRxFree (void)
{
    uint16_t tail = rxbuf.tail, head = rxbuf.head;
 800d9d0:	4b08      	ldr	r3, [pc, #32]	; (800d9f4 <serialRxFree+0x24>)
 800d9d2:	6858      	ldr	r0, [r3, #4]
 800d9d4:	b280      	uxth	r0, r0
 800d9d6:	681b      	ldr	r3, [r3, #0]
 800d9d8:	b29b      	uxth	r3, r3

    return (RX_BUFFER_SIZE - 1) - BUFCOUNT(head, tail, RX_BUFFER_SIZE);
 800d9da:	4298      	cmp	r0, r3
 800d9dc:	d804      	bhi.n	800d9e8 <serialRxFree+0x18>
 800d9de:	1ac0      	subs	r0, r0, r3
 800d9e0:	f200 30ff 	addw	r0, r0, #1023	; 0x3ff
 800d9e4:	b280      	uxth	r0, r0
 800d9e6:	4770      	bx	lr
 800d9e8:	1ac0      	subs	r0, r0, r3
 800d9ea:	b280      	uxth	r0, r0
 800d9ec:	3801      	subs	r0, #1
 800d9ee:	b280      	uxth	r0, r0
}
 800d9f0:	4770      	bx	lr
 800d9f2:	bf00      	nop
 800d9f4:	2000076c 	.word	0x2000076c

0800d9f8 <serialRxCount>:
//
// Returns number of characters in serial input buffer
//
static uint16_t serialRxCount (void)
{
    uint32_t tail = rxbuf.tail, head = rxbuf.head;
 800d9f8:	4a07      	ldr	r2, [pc, #28]	; (800da18 <serialRxCount+0x20>)
 800d9fa:	6853      	ldr	r3, [r2, #4]
 800d9fc:	6810      	ldr	r0, [r2, #0]

    return BUFCOUNT(head, tail, RX_BUFFER_SIZE);
 800d9fe:	4283      	cmp	r3, r0
 800da00:	d804      	bhi.n	800da0c <serialRxCount+0x14>
 800da02:	b280      	uxth	r0, r0
 800da04:	b29b      	uxth	r3, r3
 800da06:	1ac0      	subs	r0, r0, r3
 800da08:	b280      	uxth	r0, r0
 800da0a:	4770      	bx	lr
 800da0c:	1ac0      	subs	r0, r0, r3
 800da0e:	b280      	uxth	r0, r0
 800da10:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 800da14:	b280      	uxth	r0, r0
}
 800da16:	4770      	bx	lr
 800da18:	2000076c 	.word	0x2000076c

0800da1c <serialRxFlush>:
//
// Flushes the serial input buffer
//
static void serialRxFlush (void)
{
    rxbuf.tail = rxbuf.head;
 800da1c:	4b01      	ldr	r3, [pc, #4]	; (800da24 <serialRxFlush+0x8>)
 800da1e:	681a      	ldr	r2, [r3, #0]
 800da20:	605a      	str	r2, [r3, #4]
}
 800da22:	4770      	bx	lr
 800da24:	2000076c 	.word	0x2000076c

0800da28 <serialRxCancel>:
//
// Flushes and adds a CAN character to the serial input buffer
//
static void serialRxCancel (void)
{
    rxbuf.data[rxbuf.head] = ASCII_CAN;
 800da28:	4b06      	ldr	r3, [pc, #24]	; (800da44 <serialRxCancel+0x1c>)
 800da2a:	681a      	ldr	r2, [r3, #0]
 800da2c:	441a      	add	r2, r3
 800da2e:	2118      	movs	r1, #24
 800da30:	72d1      	strb	r1, [r2, #11]
    rxbuf.tail = rxbuf.head;
 800da32:	681a      	ldr	r2, [r3, #0]
 800da34:	605a      	str	r2, [r3, #4]
    rxbuf.head = BUFNEXT(rxbuf.head, rxbuf);
 800da36:	681a      	ldr	r2, [r3, #0]
 800da38:	3201      	adds	r2, #1
 800da3a:	f3c2 0209 	ubfx	r2, r2, #0, #10
 800da3e:	601a      	str	r2, [r3, #0]
}
 800da40:	4770      	bx	lr
 800da42:	bf00      	nop
 800da44:	2000076c 	.word	0x2000076c

0800da48 <serialPutC>:

//
// Writes a character to the serial output stream
//
static bool serialPutC (const char c)
{
 800da48:	b538      	push	{r3, r4, r5, lr}
 800da4a:	4605      	mov	r5, r0
    uint16_t next_head = BUFNEXT(txbuf.head, txbuf);    // Get pointer to next free slot in buffer
 800da4c:	4b0e      	ldr	r3, [pc, #56]	; (800da88 <serialPutC+0x40>)
 800da4e:	681c      	ldr	r4, [r3, #0]
 800da50:	3401      	adds	r4, #1
 800da52:	f3c4 0408 	ubfx	r4, r4, #0, #9

    while(txbuf.tail == next_head) {                    // While TX buffer full
 800da56:	4b0c      	ldr	r3, [pc, #48]	; (800da88 <serialPutC+0x40>)
 800da58:	685b      	ldr	r3, [r3, #4]
 800da5a:	42a3      	cmp	r3, r4
 800da5c:	d107      	bne.n	800da6e <serialPutC+0x26>
        if(!hal.stream_blocking_callback())             // check if blocking for space,
 800da5e:	4b0b      	ldr	r3, [pc, #44]	; (800da8c <serialPutC+0x44>)
 800da60:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800da64:	4798      	blx	r3
 800da66:	4603      	mov	r3, r0
 800da68:	2800      	cmp	r0, #0
 800da6a:	d1f4      	bne.n	800da56 <serialPutC+0xe>
 800da6c:	e00a      	b.n	800da84 <serialPutC+0x3c>
            return false;                               // exit if not (leaves TX buffer in an inconsistent state)
    }
    txbuf.data[txbuf.head] = c;                         // Add data to buffer,
 800da6e:	4b06      	ldr	r3, [pc, #24]	; (800da88 <serialPutC+0x40>)
 800da70:	681a      	ldr	r2, [r3, #0]
 800da72:	441a      	add	r2, r3
 800da74:	7215      	strb	r5, [r2, #8]
    txbuf.head = next_head;                             // update head pointer and
 800da76:	601c      	str	r4, [r3, #0]
    USART->CR1 |= USART_CR1_TXEIE;                      // enable TX interrupts
 800da78:	4a05      	ldr	r2, [pc, #20]	; (800da90 <serialPutC+0x48>)
 800da7a:	68d3      	ldr	r3, [r2, #12]
 800da7c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800da80:	60d3      	str	r3, [r2, #12]

    return true;
 800da82:	2301      	movs	r3, #1
}
 800da84:	4618      	mov	r0, r3
 800da86:	bd38      	pop	{r3, r4, r5, pc}
 800da88:	20000f84 	.word	0x20000f84
 800da8c:	2000350c 	.word	0x2000350c
 800da90:	40011000 	.word	0x40011000

0800da94 <serialWriteS>:

//
// Writes a null terminated string to the serial output stream, blocks if buffer full
//
static void serialWriteS (const char *s)
{
 800da94:	b510      	push	{r4, lr}
 800da96:	4604      	mov	r4, r0
    char c, *ptr = (char *)s;

    while((c = *ptr++) != '\0')
 800da98:	e001      	b.n	800da9e <serialWriteS+0xa>
        serialPutC(c);
 800da9a:	f7ff ffd5 	bl	800da48 <serialPutC>
    while((c = *ptr++) != '\0')
 800da9e:	f814 0b01 	ldrb.w	r0, [r4], #1
 800daa2:	2800      	cmp	r0, #0
 800daa4:	d1f9      	bne.n	800da9a <serialWriteS+0x6>
}
 800daa6:	bd10      	pop	{r4, pc}

0800daa8 <serialWrite>:

//
// Writes a number of characters from string to the serial output stream followed by EOL, blocks if buffer full
//
static void serialWrite (const char *s, uint16_t length)
{
 800daa8:	b538      	push	{r3, r4, r5, lr}
 800daaa:	4604      	mov	r4, r0
    char *ptr = (char *)s;

    while(length--)
 800daac:	e004      	b.n	800dab8 <serialWrite+0x10>
        serialPutC(*ptr++);
 800daae:	f814 0b01 	ldrb.w	r0, [r4], #1
 800dab2:	f7ff ffc9 	bl	800da48 <serialPutC>
    while(length--)
 800dab6:	4629      	mov	r1, r5
 800dab8:	1e4b      	subs	r3, r1, #1
 800daba:	b29d      	uxth	r5, r3
 800dabc:	2900      	cmp	r1, #0
 800dabe:	d1f6      	bne.n	800daae <serialWrite+0x6>
}
 800dac0:	bd38      	pop	{r3, r4, r5, pc}
	...

0800dac4 <serialTxFlush>:
//
// Flushes the serial output buffer
//
static void serialTxFlush (void)
{
    USART->CR1 &= ~USART_CR1_TXEIE;     // Disable TX interrupts
 800dac4:	4a04      	ldr	r2, [pc, #16]	; (800dad8 <serialTxFlush+0x14>)
 800dac6:	68d3      	ldr	r3, [r2, #12]
 800dac8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800dacc:	60d3      	str	r3, [r2, #12]
    txbuf.tail = txbuf.head;
 800dace:	4b03      	ldr	r3, [pc, #12]	; (800dadc <serialTxFlush+0x18>)
 800dad0:	681a      	ldr	r2, [r3, #0]
 800dad2:	605a      	str	r2, [r3, #4]
}
 800dad4:	4770      	bx	lr
 800dad6:	bf00      	nop
 800dad8:	40011000 	.word	0x40011000
 800dadc:	20000f84 	.word	0x20000f84

0800dae0 <serialTxCount>:
//
// Returns number of characters pending transmission
//
static uint16_t serialTxCount (void)
{
    uint32_t tail = txbuf.tail, head = txbuf.head;
 800dae0:	4b0c      	ldr	r3, [pc, #48]	; (800db14 <serialTxCount+0x34>)
 800dae2:	685a      	ldr	r2, [r3, #4]
 800dae4:	681b      	ldr	r3, [r3, #0]

    return BUFCOUNT(head, tail, TX_BUFFER_SIZE) + (USART->SR & USART_SR_TC ? 0 : 1);
 800dae6:	429a      	cmp	r2, r3
 800dae8:	d80d      	bhi.n	800db06 <serialTxCount+0x26>
 800daea:	b29b      	uxth	r3, r3
 800daec:	b292      	uxth	r2, r2
 800daee:	1a9b      	subs	r3, r3, r2
 800daf0:	b29b      	uxth	r3, r3
 800daf2:	4a09      	ldr	r2, [pc, #36]	; (800db18 <serialTxCount+0x38>)
 800daf4:	6812      	ldr	r2, [r2, #0]
 800daf6:	f012 0f40 	tst.w	r2, #64	; 0x40
 800dafa:	bf0c      	ite	eq
 800dafc:	2001      	moveq	r0, #1
 800dafe:	2000      	movne	r0, #0
 800db00:	4418      	add	r0, r3
}
 800db02:	b280      	uxth	r0, r0
 800db04:	4770      	bx	lr
    return BUFCOUNT(head, tail, TX_BUFFER_SIZE) + (USART->SR & USART_SR_TC ? 0 : 1);
 800db06:	1a9b      	subs	r3, r3, r2
 800db08:	b29b      	uxth	r3, r3
 800db0a:	f503 7300 	add.w	r3, r3, #512	; 0x200
 800db0e:	b29b      	uxth	r3, r3
 800db10:	e7ef      	b.n	800daf2 <serialTxCount+0x12>
 800db12:	bf00      	nop
 800db14:	20000f84 	.word	0x20000f84
 800db18:	40011000 	.word	0x40011000

0800db1c <serialGetC>:
//
// serialGetC - returns -1 if no data available
//
static int16_t serialGetC (void)
{
    uint_fast16_t tail = rxbuf.tail;    // Get buffer pointer
 800db1c:	4a07      	ldr	r2, [pc, #28]	; (800db3c <serialGetC+0x20>)
 800db1e:	6853      	ldr	r3, [r2, #4]

    if(tail == rxbuf.head)
 800db20:	6812      	ldr	r2, [r2, #0]
 800db22:	429a      	cmp	r2, r3
 800db24:	d007      	beq.n	800db36 <serialGetC+0x1a>
        return -1; // no data available

    char data = rxbuf.data[tail];       // Get next character
 800db26:	4a05      	ldr	r2, [pc, #20]	; (800db3c <serialGetC+0x20>)
 800db28:	18d1      	adds	r1, r2, r3
    rxbuf.tail = BUFNEXT(tail, rxbuf);  // and update pointer
 800db2a:	3301      	adds	r3, #1
 800db2c:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800db30:	6053      	str	r3, [r2, #4]

    return (int16_t)data;
 800db32:	7ac8      	ldrb	r0, [r1, #11]
 800db34:	4770      	bx	lr
        return -1; // no data available
 800db36:	f04f 30ff 	mov.w	r0, #4294967295
}
 800db3a:	4770      	bx	lr
 800db3c:	2000076c 	.word	0x2000076c

0800db40 <serialDisable>:
    return true;
}

static bool serialDisable (bool disable)
{
    if(disable)
 800db40:	b130      	cbz	r0, 800db50 <serialDisable+0x10>
        USART->CR1 &= ~USART_CR1_RXNEIE;
 800db42:	4a06      	ldr	r2, [pc, #24]	; (800db5c <serialDisable+0x1c>)
 800db44:	68d3      	ldr	r3, [r2, #12]
 800db46:	f023 0320 	bic.w	r3, r3, #32
 800db4a:	60d3      	str	r3, [r2, #12]
    else
        USART->CR1 |= USART_CR1_RXNEIE;

    return true;
}
 800db4c:	2001      	movs	r0, #1
 800db4e:	4770      	bx	lr
        USART->CR1 |= USART_CR1_RXNEIE;
 800db50:	4a02      	ldr	r2, [pc, #8]	; (800db5c <serialDisable+0x1c>)
 800db52:	68d3      	ldr	r3, [r2, #12]
 800db54:	f043 0320 	orr.w	r3, r3, #32
 800db58:	60d3      	str	r3, [r2, #12]
 800db5a:	e7f7      	b.n	800db4c <serialDisable+0xc>
 800db5c:	40011000 	.word	0x40011000

0800db60 <serialEnqueueRtCommand>:

static bool serialEnqueueRtCommand (char c)
{
 800db60:	b508      	push	{r3, lr}
    return enqueue_realtime_command(c);
 800db62:	4b02      	ldr	r3, [pc, #8]	; (800db6c <serialEnqueueRtCommand+0xc>)
 800db64:	681b      	ldr	r3, [r3, #0]
 800db66:	4798      	blx	r3
}
 800db68:	bd08      	pop	{r3, pc}
 800db6a:	bf00      	nop
 800db6c:	20000340 	.word	0x20000340

0800db70 <serialSetRtHandler>:

static enqueue_realtime_command_ptr serialSetRtHandler (enqueue_realtime_command_ptr handler)
{
 800db70:	4603      	mov	r3, r0
    enqueue_realtime_command_ptr prev = enqueue_realtime_command;
 800db72:	4a03      	ldr	r2, [pc, #12]	; (800db80 <serialSetRtHandler+0x10>)
 800db74:	6810      	ldr	r0, [r2, #0]

    if(handler)
 800db76:	461a      	mov	r2, r3
 800db78:	b10b      	cbz	r3, 800db7e <serialSetRtHandler+0xe>
        enqueue_realtime_command = handler;
 800db7a:	4b01      	ldr	r3, [pc, #4]	; (800db80 <serialSetRtHandler+0x10>)
 800db7c:	601a      	str	r2, [r3, #0]

    return prev;
}
 800db7e:	4770      	bx	lr
 800db80:	20000340 	.word	0x20000340

0800db84 <serial2RxFree>:
//
// Returns number of free characters in serial input buffer
//
static uint16_t serial2RxFree (void)
{
    uint32_t tail = rxbuf2.tail, head = rxbuf2.head;
 800db84:	4a07      	ldr	r2, [pc, #28]	; (800dba4 <serial2RxFree+0x20>)
 800db86:	6853      	ldr	r3, [r2, #4]
 800db88:	6810      	ldr	r0, [r2, #0]

    return (RX_BUFFER_SIZE - 1) - BUFCOUNT(head, tail, RX_BUFFER_SIZE);
 800db8a:	4283      	cmp	r3, r0
 800db8c:	d805      	bhi.n	800db9a <serial2RxFree+0x16>
 800db8e:	1a18      	subs	r0, r3, r0
 800db90:	b280      	uxth	r0, r0
 800db92:	f200 30ff 	addw	r0, r0, #1023	; 0x3ff
 800db96:	b280      	uxth	r0, r0
 800db98:	4770      	bx	lr
 800db9a:	1a18      	subs	r0, r3, r0
 800db9c:	b280      	uxth	r0, r0
 800db9e:	3801      	subs	r0, #1
 800dba0:	b280      	uxth	r0, r0
}
 800dba2:	4770      	bx	lr
 800dba4:	20000b78 	.word	0x20000b78

0800dba8 <serial2RxCount>:
//
// Returns number of characters in serial input buffer
//
static uint16_t serial2RxCount (void)
{
    uint32_t tail = rxbuf2.tail, head = rxbuf2.head;
 800dba8:	4a07      	ldr	r2, [pc, #28]	; (800dbc8 <serial2RxCount+0x20>)
 800dbaa:	6853      	ldr	r3, [r2, #4]
 800dbac:	6810      	ldr	r0, [r2, #0]

    return BUFCOUNT(head, tail, RX_BUFFER_SIZE);
 800dbae:	4283      	cmp	r3, r0
 800dbb0:	d804      	bhi.n	800dbbc <serial2RxCount+0x14>
 800dbb2:	b280      	uxth	r0, r0
 800dbb4:	b29b      	uxth	r3, r3
 800dbb6:	1ac0      	subs	r0, r0, r3
 800dbb8:	b280      	uxth	r0, r0
 800dbba:	4770      	bx	lr
 800dbbc:	1ac0      	subs	r0, r0, r3
 800dbbe:	b280      	uxth	r0, r0
 800dbc0:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 800dbc4:	b280      	uxth	r0, r0
}
 800dbc6:	4770      	bx	lr
 800dbc8:	20000b78 	.word	0x20000b78

0800dbcc <serial2RxFlush>:
//
// Flushes the serial input buffer
//
static void serial2RxFlush (void)
{
    rxbuf2.tail = rxbuf2.head;
 800dbcc:	4b01      	ldr	r3, [pc, #4]	; (800dbd4 <serial2RxFlush+0x8>)
 800dbce:	681a      	ldr	r2, [r3, #0]
 800dbd0:	605a      	str	r2, [r3, #4]
}
 800dbd2:	4770      	bx	lr
 800dbd4:	20000b78 	.word	0x20000b78

0800dbd8 <serial2RxCancel>:
//
// Flushes and adds a CAN character to the serial input buffer
//
static void serial2RxCancel (void)
{
    rxbuf2.data[rxbuf2.head] = ASCII_CAN;
 800dbd8:	4b06      	ldr	r3, [pc, #24]	; (800dbf4 <serial2RxCancel+0x1c>)
 800dbda:	681a      	ldr	r2, [r3, #0]
 800dbdc:	441a      	add	r2, r3
 800dbde:	2118      	movs	r1, #24
 800dbe0:	72d1      	strb	r1, [r2, #11]
    rxbuf2.tail = rxbuf2.head;
 800dbe2:	681a      	ldr	r2, [r3, #0]
 800dbe4:	605a      	str	r2, [r3, #4]
    rxbuf2.head = BUFNEXT(rxbuf2.head, rxbuf2);
 800dbe6:	681a      	ldr	r2, [r3, #0]
 800dbe8:	3201      	adds	r2, #1
 800dbea:	f3c2 0209 	ubfx	r2, r2, #0, #10
 800dbee:	601a      	str	r2, [r3, #0]
}
 800dbf0:	4770      	bx	lr
 800dbf2:	bf00      	nop
 800dbf4:	20000b78 	.word	0x20000b78

0800dbf8 <serial2PutC>:

//
// Writes a character to the serial output stream
//
static bool serial2PutC (const char c)
{
 800dbf8:	b538      	push	{r3, r4, r5, lr}
 800dbfa:	4605      	mov	r5, r0
    uint32_t next_head = BUFNEXT(txbuf2.head, txbuf2);   // Set and update head pointer
 800dbfc:	4b11      	ldr	r3, [pc, #68]	; (800dc44 <serial2PutC+0x4c>)
 800dbfe:	681c      	ldr	r4, [r3, #0]
 800dc00:	3401      	adds	r4, #1
 800dc02:	f3c4 0408 	ubfx	r4, r4, #0, #9

    while(txbuf2.tail == next_head) {           // While TX buffer full
 800dc06:	e004      	b.n	800dc12 <serial2PutC+0x1a>
        if(!hal.stream_blocking_callback())     // check if blocking for space,
            return false;                       // exit if not (leaves TX buffer in an inconsistent state)
        UART2->CR1 |= USART_CR1_TXEIE;          // Enable TX interrupts???
 800dc08:	4a0f      	ldr	r2, [pc, #60]	; (800dc48 <serial2PutC+0x50>)
 800dc0a:	68d3      	ldr	r3, [r2, #12]
 800dc0c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800dc10:	60d3      	str	r3, [r2, #12]
    while(txbuf2.tail == next_head) {           // While TX buffer full
 800dc12:	4b0c      	ldr	r3, [pc, #48]	; (800dc44 <serial2PutC+0x4c>)
 800dc14:	685b      	ldr	r3, [r3, #4]
 800dc16:	42a3      	cmp	r3, r4
 800dc18:	d107      	bne.n	800dc2a <serial2PutC+0x32>
        if(!hal.stream_blocking_callback())     // check if blocking for space,
 800dc1a:	4b0c      	ldr	r3, [pc, #48]	; (800dc4c <serial2PutC+0x54>)
 800dc1c:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800dc20:	4798      	blx	r3
 800dc22:	4603      	mov	r3, r0
 800dc24:	2800      	cmp	r0, #0
 800dc26:	d1ef      	bne.n	800dc08 <serial2PutC+0x10>
 800dc28:	e00a      	b.n	800dc40 <serial2PutC+0x48>
    }

    txbuf2.data[txbuf2.head] = c;               // Add data to buffer
 800dc2a:	4b06      	ldr	r3, [pc, #24]	; (800dc44 <serial2PutC+0x4c>)
 800dc2c:	681a      	ldr	r2, [r3, #0]
 800dc2e:	441a      	add	r2, r3
 800dc30:	7215      	strb	r5, [r2, #8]
    txbuf2.head = next_head;                    // and update head pointer
 800dc32:	601c      	str	r4, [r3, #0]

    UART2->CR1 |= USART_CR1_TXEIE;              // Enable TX interrupts
 800dc34:	4a04      	ldr	r2, [pc, #16]	; (800dc48 <serial2PutC+0x50>)
 800dc36:	68d3      	ldr	r3, [r2, #12]
 800dc38:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800dc3c:	60d3      	str	r3, [r2, #12]

    return true;
 800dc3e:	2301      	movs	r3, #1
}
 800dc40:	4618      	mov	r0, r3
 800dc42:	bd38      	pop	{r3, r4, r5, pc}
 800dc44:	2000118c 	.word	0x2000118c
 800dc48:	40004400 	.word	0x40004400
 800dc4c:	2000350c 	.word	0x2000350c

0800dc50 <serial2WriteS>:

//
// Writes a null terminated string to the serial output stream, blocks if buffer full
//
static void serial2WriteS (const char *s)
{
 800dc50:	b510      	push	{r4, lr}
 800dc52:	4604      	mov	r4, r0
    char c, *ptr = (char *)s;

    while((c = *ptr++) != '\0')
 800dc54:	e001      	b.n	800dc5a <serial2WriteS+0xa>
        serial2PutC(c);
 800dc56:	f7ff ffcf 	bl	800dbf8 <serial2PutC>
    while((c = *ptr++) != '\0')
 800dc5a:	f814 0b01 	ldrb.w	r0, [r4], #1
 800dc5e:	2800      	cmp	r0, #0
 800dc60:	d1f9      	bne.n	800dc56 <serial2WriteS+0x6>
}
 800dc62:	bd10      	pop	{r4, pc}

0800dc64 <serial2Write>:

// Writes a number of characters from a buffer to the serial output stream, blocks if buffer full
//
static void serial2Write (const char *s, uint16_t length)
{
 800dc64:	b538      	push	{r3, r4, r5, lr}
 800dc66:	4604      	mov	r4, r0
    char *ptr = (char *)s;

    while(length--)
 800dc68:	e004      	b.n	800dc74 <serial2Write+0x10>
        serial2PutC(*ptr++);
 800dc6a:	f814 0b01 	ldrb.w	r0, [r4], #1
 800dc6e:	f7ff ffc3 	bl	800dbf8 <serial2PutC>
    while(length--)
 800dc72:	4629      	mov	r1, r5
 800dc74:	1e4b      	subs	r3, r1, #1
 800dc76:	b29d      	uxth	r5, r3
 800dc78:	2900      	cmp	r1, #0
 800dc7a:	d1f6      	bne.n	800dc6a <serial2Write+0x6>
}
 800dc7c:	bd38      	pop	{r3, r4, r5, pc}
	...

0800dc80 <serial2TxFlush>:
//
// Flushes the serial output buffer
//
static void serial2TxFlush (void)
{
    UART2->CR1 &= ~USART_CR1_TXEIE;     // Disable TX interrupts
 800dc80:	4a04      	ldr	r2, [pc, #16]	; (800dc94 <serial2TxFlush+0x14>)
 800dc82:	68d3      	ldr	r3, [r2, #12]
 800dc84:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800dc88:	60d3      	str	r3, [r2, #12]
    txbuf2.tail = txbuf2.head;
 800dc8a:	4b03      	ldr	r3, [pc, #12]	; (800dc98 <serial2TxFlush+0x18>)
 800dc8c:	681a      	ldr	r2, [r3, #0]
 800dc8e:	605a      	str	r2, [r3, #4]
}
 800dc90:	4770      	bx	lr
 800dc92:	bf00      	nop
 800dc94:	40004400 	.word	0x40004400
 800dc98:	2000118c 	.word	0x2000118c

0800dc9c <serial2TxCount>:
//
// Returns number of characters pending transmission
//
static uint16_t serial2TxCount (void)
{
    uint32_t tail = txbuf2.tail, head = txbuf2.head;
 800dc9c:	4b0c      	ldr	r3, [pc, #48]	; (800dcd0 <serial2TxCount+0x34>)
 800dc9e:	685a      	ldr	r2, [r3, #4]
 800dca0:	681b      	ldr	r3, [r3, #0]

    return BUFCOUNT(head, tail, TX_BUFFER_SIZE) + (UART2->SR & USART_SR_TC ? 0 : 1);
 800dca2:	429a      	cmp	r2, r3
 800dca4:	d80d      	bhi.n	800dcc2 <serial2TxCount+0x26>
 800dca6:	b29b      	uxth	r3, r3
 800dca8:	b292      	uxth	r2, r2
 800dcaa:	1a9b      	subs	r3, r3, r2
 800dcac:	b29b      	uxth	r3, r3
 800dcae:	4a09      	ldr	r2, [pc, #36]	; (800dcd4 <serial2TxCount+0x38>)
 800dcb0:	6812      	ldr	r2, [r2, #0]
 800dcb2:	f012 0f40 	tst.w	r2, #64	; 0x40
 800dcb6:	bf0c      	ite	eq
 800dcb8:	2001      	moveq	r0, #1
 800dcba:	2000      	movne	r0, #0
 800dcbc:	4418      	add	r0, r3
}
 800dcbe:	b280      	uxth	r0, r0
 800dcc0:	4770      	bx	lr
    return BUFCOUNT(head, tail, TX_BUFFER_SIZE) + (UART2->SR & USART_SR_TC ? 0 : 1);
 800dcc2:	1a9b      	subs	r3, r3, r2
 800dcc4:	b29b      	uxth	r3, r3
 800dcc6:	f503 7300 	add.w	r3, r3, #512	; 0x200
 800dcca:	b29b      	uxth	r3, r3
 800dccc:	e7ef      	b.n	800dcae <serial2TxCount+0x12>
 800dcce:	bf00      	nop
 800dcd0:	2000118c 	.word	0x2000118c
 800dcd4:	40004400 	.word	0x40004400

0800dcd8 <serial2GetC>:
//
// serialGetC - returns -1 if no data available
//
static int16_t serial2GetC (void)
{
    uint_fast16_t tail = rxbuf2.tail;       // Get buffer pointer
 800dcd8:	4a07      	ldr	r2, [pc, #28]	; (800dcf8 <serial2GetC+0x20>)
 800dcda:	6853      	ldr	r3, [r2, #4]

    if(tail == rxbuf2.head)
 800dcdc:	6812      	ldr	r2, [r2, #0]
 800dcde:	429a      	cmp	r2, r3
 800dce0:	d007      	beq.n	800dcf2 <serial2GetC+0x1a>
        return -1; // no data available

    char data = rxbuf2.data[tail];          // Get next character
 800dce2:	4a05      	ldr	r2, [pc, #20]	; (800dcf8 <serial2GetC+0x20>)
 800dce4:	18d1      	adds	r1, r2, r3
    rxbuf2.tail = BUFNEXT(tail, rxbuf2);    // and update pointer
 800dce6:	3301      	adds	r3, #1
 800dce8:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800dcec:	6053      	str	r3, [r2, #4]

    return (int16_t)data;
 800dcee:	7ac8      	ldrb	r0, [r1, #11]
 800dcf0:	4770      	bx	lr
        return -1; // no data available
 800dcf2:	f04f 30ff 	mov.w	r0, #4294967295
}
 800dcf6:	4770      	bx	lr
 800dcf8:	20000b78 	.word	0x20000b78

0800dcfc <serial2Disable>:
    return true;
}

static bool serial2Disable (bool disable)
{
    if(disable)
 800dcfc:	b130      	cbz	r0, 800dd0c <serial2Disable+0x10>
        UART2->CR1 &= ~USART_CR1_RXNEIE;
 800dcfe:	4a06      	ldr	r2, [pc, #24]	; (800dd18 <serial2Disable+0x1c>)
 800dd00:	68d3      	ldr	r3, [r2, #12]
 800dd02:	f023 0320 	bic.w	r3, r3, #32
 800dd06:	60d3      	str	r3, [r2, #12]
    else
        UART2->CR1 |= USART_CR1_RXNEIE;

    return true;
}
 800dd08:	2001      	movs	r0, #1
 800dd0a:	4770      	bx	lr
        UART2->CR1 |= USART_CR1_RXNEIE;
 800dd0c:	4a02      	ldr	r2, [pc, #8]	; (800dd18 <serial2Disable+0x1c>)
 800dd0e:	68d3      	ldr	r3, [r2, #12]
 800dd10:	f043 0320 	orr.w	r3, r3, #32
 800dd14:	60d3      	str	r3, [r2, #12]
 800dd16:	e7f7      	b.n	800dd08 <serial2Disable+0xc>
 800dd18:	40004400 	.word	0x40004400

0800dd1c <serial2EnqueueRtCommand>:

static bool serial2EnqueueRtCommand (char c)
{
 800dd1c:	b508      	push	{r3, lr}
    return enqueue_realtime_command2(c);
 800dd1e:	4b02      	ldr	r3, [pc, #8]	; (800dd28 <serial2EnqueueRtCommand+0xc>)
 800dd20:	681b      	ldr	r3, [r3, #0]
 800dd22:	4798      	blx	r3
}
 800dd24:	bd08      	pop	{r3, pc}
 800dd26:	bf00      	nop
 800dd28:	20000344 	.word	0x20000344

0800dd2c <serial2SetRtHandler>:

static enqueue_realtime_command_ptr serial2SetRtHandler (enqueue_realtime_command_ptr handler)
{
 800dd2c:	4603      	mov	r3, r0
    enqueue_realtime_command_ptr prev = enqueue_realtime_command2;
 800dd2e:	4a03      	ldr	r2, [pc, #12]	; (800dd3c <serial2SetRtHandler+0x10>)
 800dd30:	6810      	ldr	r0, [r2, #0]

    if(handler)
 800dd32:	461a      	mov	r2, r3
 800dd34:	b10b      	cbz	r3, 800dd3a <serial2SetRtHandler+0xe>
        enqueue_realtime_command2 = handler;
 800dd36:	4b01      	ldr	r3, [pc, #4]	; (800dd3c <serial2SetRtHandler+0x10>)
 800dd38:	601a      	str	r2, [r3, #0]

    return prev;
}
 800dd3a:	4770      	bx	lr
 800dd3c:	20000344 	.word	0x20000344

0800dd40 <serialSetBaudRate>:
{
 800dd40:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800dd44:	4607      	mov	r7, r0
    USART->CR1 = USART_CR1_RE|USART_CR1_TE;
 800dd46:	f8df a130 	ldr.w	sl, [pc, #304]	; 800de78 <serialSetBaudRate+0x138>
 800dd4a:	230c      	movs	r3, #12
 800dd4c:	f8ca 300c 	str.w	r3, [sl, #12]
    USART->BRR = UART_BRR_SAMPLING16(USART_CLK, baud_rate);
 800dd50:	f7fc fc6c 	bl	800a62c <HAL_RCC_GetPCLK2Freq>
 800dd54:	2400      	movs	r4, #0
 800dd56:	1803      	adds	r3, r0, r0
 800dd58:	eb44 0104 	adc.w	r1, r4, r4
 800dd5c:	181b      	adds	r3, r3, r0
 800dd5e:	f141 0100 	adc.w	r1, r1, #0
 800dd62:	00c9      	lsls	r1, r1, #3
 800dd64:	ea41 7153 	orr.w	r1, r1, r3, lsr #29
 800dd68:	00db      	lsls	r3, r3, #3
 800dd6a:	1818      	adds	r0, r3, r0
 800dd6c:	ea4f 7997 	mov.w	r9, r7, lsr #30
 800dd70:	ea4f 0787 	mov.w	r7, r7, lsl #2
 800dd74:	463a      	mov	r2, r7
 800dd76:	464b      	mov	r3, r9
 800dd78:	f141 0100 	adc.w	r1, r1, #0
 800dd7c:	f7fa fe6e 	bl	8008a5c <__aeabi_uldivmod>
 800dd80:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 800de7c <serialSetBaudRate+0x13c>
 800dd84:	fba8 3500 	umull	r3, r5, r8, r0
 800dd88:	096d      	lsrs	r5, r5, #5
 800dd8a:	012d      	lsls	r5, r5, #4
 800dd8c:	f7fc fc4e 	bl	800a62c <HAL_RCC_GetPCLK2Freq>
 800dd90:	1803      	adds	r3, r0, r0
 800dd92:	eb44 0104 	adc.w	r1, r4, r4
 800dd96:	181b      	adds	r3, r3, r0
 800dd98:	f141 0100 	adc.w	r1, r1, #0
 800dd9c:	00c9      	lsls	r1, r1, #3
 800dd9e:	ea41 7153 	orr.w	r1, r1, r3, lsr #29
 800dda2:	00db      	lsls	r3, r3, #3
 800dda4:	1818      	adds	r0, r3, r0
 800dda6:	463a      	mov	r2, r7
 800dda8:	464b      	mov	r3, r9
 800ddaa:	f141 0100 	adc.w	r1, r1, #0
 800ddae:	f7fa fe55 	bl	8008a5c <__aeabi_uldivmod>
 800ddb2:	4606      	mov	r6, r0
 800ddb4:	f7fc fc3a 	bl	800a62c <HAL_RCC_GetPCLK2Freq>
 800ddb8:	1803      	adds	r3, r0, r0
 800ddba:	eb44 0104 	adc.w	r1, r4, r4
 800ddbe:	181b      	adds	r3, r3, r0
 800ddc0:	f141 0100 	adc.w	r1, r1, #0
 800ddc4:	00c9      	lsls	r1, r1, #3
 800ddc6:	ea41 7153 	orr.w	r1, r1, r3, lsr #29
 800ddca:	00db      	lsls	r3, r3, #3
 800ddcc:	1818      	adds	r0, r3, r0
 800ddce:	463a      	mov	r2, r7
 800ddd0:	464b      	mov	r3, r9
 800ddd2:	f141 0100 	adc.w	r1, r1, #0
 800ddd6:	f7fa fe41 	bl	8008a5c <__aeabi_uldivmod>
 800ddda:	fba8 3000 	umull	r3, r0, r8, r0
 800ddde:	0940      	lsrs	r0, r0, #5
 800dde0:	f04f 0b64 	mov.w	fp, #100	; 0x64
 800dde4:	fb0b 6310 	mls	r3, fp, r0, r6
 800dde8:	011b      	lsls	r3, r3, #4
 800ddea:	3332      	adds	r3, #50	; 0x32
 800ddec:	fba8 2303 	umull	r2, r3, r8, r3
 800ddf0:	095b      	lsrs	r3, r3, #5
 800ddf2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800ddf6:	441d      	add	r5, r3
 800ddf8:	f7fc fc18 	bl	800a62c <HAL_RCC_GetPCLK2Freq>
 800ddfc:	1803      	adds	r3, r0, r0
 800ddfe:	eb44 0104 	adc.w	r1, r4, r4
 800de02:	181b      	adds	r3, r3, r0
 800de04:	f141 0100 	adc.w	r1, r1, #0
 800de08:	00c9      	lsls	r1, r1, #3
 800de0a:	ea41 7153 	orr.w	r1, r1, r3, lsr #29
 800de0e:	00db      	lsls	r3, r3, #3
 800de10:	1818      	adds	r0, r3, r0
 800de12:	463a      	mov	r2, r7
 800de14:	464b      	mov	r3, r9
 800de16:	f141 0100 	adc.w	r1, r1, #0
 800de1a:	f7fa fe1f 	bl	8008a5c <__aeabi_uldivmod>
 800de1e:	4606      	mov	r6, r0
 800de20:	f7fc fc04 	bl	800a62c <HAL_RCC_GetPCLK2Freq>
 800de24:	1803      	adds	r3, r0, r0
 800de26:	4164      	adcs	r4, r4
 800de28:	181b      	adds	r3, r3, r0
 800de2a:	f144 0100 	adc.w	r1, r4, #0
 800de2e:	00c9      	lsls	r1, r1, #3
 800de30:	ea41 7153 	orr.w	r1, r1, r3, lsr #29
 800de34:	00db      	lsls	r3, r3, #3
 800de36:	1818      	adds	r0, r3, r0
 800de38:	463a      	mov	r2, r7
 800de3a:	464b      	mov	r3, r9
 800de3c:	f141 0100 	adc.w	r1, r1, #0
 800de40:	f7fa fe0c 	bl	8008a5c <__aeabi_uldivmod>
 800de44:	fba8 3000 	umull	r3, r0, r8, r0
 800de48:	0940      	lsrs	r0, r0, #5
 800de4a:	fb0b 6310 	mls	r3, fp, r0, r6
 800de4e:	011b      	lsls	r3, r3, #4
 800de50:	3332      	adds	r3, #50	; 0x32
 800de52:	fba8 8303 	umull	r8, r3, r8, r3
 800de56:	f3c3 1343 	ubfx	r3, r3, #5, #4
 800de5a:	441d      	add	r5, r3
 800de5c:	f8ca 5008 	str.w	r5, [sl, #8]
    USART->CR1 |= (USART_CR1_UE|USART_CR1_RXNEIE);
 800de60:	f8da 300c 	ldr.w	r3, [sl, #12]
 800de64:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800de68:	f043 0320 	orr.w	r3, r3, #32
 800de6c:	f8ca 300c 	str.w	r3, [sl, #12]
}
 800de70:	2001      	movs	r0, #1
 800de72:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800de76:	bf00      	nop
 800de78:	40011000 	.word	0x40011000
 800de7c:	51eb851f 	.word	0x51eb851f

0800de80 <serialInit>:
    if(serial[0].flags.claimed)
 800de80:	4b23      	ldr	r3, [pc, #140]	; (800df10 <serialInit+0x90>)
 800de82:	789b      	ldrb	r3, [r3, #2]
 800de84:	f013 0f04 	tst.w	r3, #4
 800de88:	d140      	bne.n	800df0c <serialInit+0x8c>
{
 800de8a:	b570      	push	{r4, r5, r6, lr}
 800de8c:	b088      	sub	sp, #32
 800de8e:	4605      	mov	r5, r0
    serial[0].flags.claimed = On;
 800de90:	4a1f      	ldr	r2, [pc, #124]	; (800df10 <serialInit+0x90>)
 800de92:	f043 0304 	orr.w	r3, r3, #4
 800de96:	7093      	strb	r3, [r2, #2]
    __HAL_RCC_USART1_CLK_ENABLE();
 800de98:	2600      	movs	r6, #0
 800de9a:	9601      	str	r6, [sp, #4]
 800de9c:	4b1d      	ldr	r3, [pc, #116]	; (800df14 <serialInit+0x94>)
 800de9e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800dea0:	f042 0210 	orr.w	r2, r2, #16
 800dea4:	645a      	str	r2, [r3, #68]	; 0x44
 800dea6:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800dea8:	f002 0210 	and.w	r2, r2, #16
 800deac:	9201      	str	r2, [sp, #4]
 800deae:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800deb0:	9602      	str	r6, [sp, #8]
 800deb2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800deb4:	f042 0201 	orr.w	r2, r2, #1
 800deb8:	631a      	str	r2, [r3, #48]	; 0x30
 800deba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800debc:	f003 0301 	and.w	r3, r3, #1
 800dec0:	9302      	str	r3, [sp, #8]
 800dec2:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitTypeDef GPIO_InitStructure = {
 800dec4:	f10d 0c0c 	add.w	ip, sp, #12
 800dec8:	4c13      	ldr	r4, [pc, #76]	; (800df18 <serialInit+0x98>)
 800deca:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800decc:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 800ded0:	6823      	ldr	r3, [r4, #0]
 800ded2:	f8cc 3000 	str.w	r3, [ip]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
 800ded6:	a903      	add	r1, sp, #12
 800ded8:	4810      	ldr	r0, [pc, #64]	; (800df1c <serialInit+0x9c>)
 800deda:	f7fb f9f5 	bl	80092c8 <HAL_GPIO_Init>
    serialSetBaudRate(baud_rate);
 800dede:	4628      	mov	r0, r5
 800dee0:	f7ff ff2e 	bl	800dd40 <serialSetBaudRate>
    HAL_NVIC_SetPriority(USART_IRQ, 0, 0);
 800dee4:	4632      	mov	r2, r6
 800dee6:	4631      	mov	r1, r6
 800dee8:	2025      	movs	r0, #37	; 0x25
 800deea:	f7fa ffad 	bl	8008e48 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART_IRQ);
 800deee:	2025      	movs	r0, #37	; 0x25
 800def0:	f7fa ffe2 	bl	8008eb8 <HAL_NVIC_EnableIRQ>
    hal.periph_port.register_pin(&rx);
 800def4:	4c0a      	ldr	r4, [pc, #40]	; (800df20 <serialInit+0xa0>)
 800def6:	f8d4 3138 	ldr.w	r3, [r4, #312]	; 0x138
 800defa:	480a      	ldr	r0, [pc, #40]	; (800df24 <serialInit+0xa4>)
 800defc:	4798      	blx	r3
    hal.periph_port.register_pin(&tx);
 800defe:	f8d4 3138 	ldr.w	r3, [r4, #312]	; 0x138
 800df02:	4809      	ldr	r0, [pc, #36]	; (800df28 <serialInit+0xa8>)
 800df04:	4798      	blx	r3
    return &stream;
 800df06:	4809      	ldr	r0, [pc, #36]	; (800df2c <serialInit+0xac>)
}
 800df08:	b008      	add	sp, #32
 800df0a:	bd70      	pop	{r4, r5, r6, pc}
        return NULL;
 800df0c:	2000      	movs	r0, #0
}
 800df0e:	4770      	bx	lr
 800df10:	20000348 	.word	0x20000348
 800df14:	40023800 	.word	0x40023800
 800df18:	08025384 	.word	0x08025384
 800df1c:	40020000 	.word	0x40020000
 800df20:	2000350c 	.word	0x2000350c
 800df24:	080254a4 	.word	0x080254a4
 800df28:	0802556c 	.word	0x0802556c
 800df2c:	08025508 	.word	0x08025508

0800df30 <serialSuspendInput>:
{
 800df30:	b508      	push	{r3, lr}
 800df32:	4601      	mov	r1, r0
    return stream_rx_suspend(&rxbuf, suspend);
 800df34:	4801      	ldr	r0, [pc, #4]	; (800df3c <serialSuspendInput+0xc>)
 800df36:	f012 f8ad 	bl	8020094 <stream_rx_suspend>
}
 800df3a:	bd08      	pop	{r3, pc}
 800df3c:	2000076c 	.word	0x2000076c

0800df40 <serial2SuspendInput>:
{
 800df40:	b508      	push	{r3, lr}
 800df42:	4601      	mov	r1, r0
    return stream_rx_suspend(&rxbuf2, suspend);
 800df44:	4801      	ldr	r0, [pc, #4]	; (800df4c <serial2SuspendInput+0xc>)
 800df46:	f012 f8a5 	bl	8020094 <stream_rx_suspend>
}
 800df4a:	bd08      	pop	{r3, pc}
 800df4c:	20000b78 	.word	0x20000b78

0800df50 <serial2SetBaudRate>:
{
 800df50:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800df54:	4607      	mov	r7, r0
    UART2->CR1 = USART_CR1_RE|USART_CR1_TE;
 800df56:	f8df a130 	ldr.w	sl, [pc, #304]	; 800e088 <serial2SetBaudRate+0x138>
 800df5a:	230c      	movs	r3, #12
 800df5c:	f8ca 300c 	str.w	r3, [sl, #12]
    UART2->BRR = UART_BRR_SAMPLING16(UART2_CLK, baud_rate);
 800df60:	f7fc fb54 	bl	800a60c <HAL_RCC_GetPCLK1Freq>
 800df64:	2400      	movs	r4, #0
 800df66:	1803      	adds	r3, r0, r0
 800df68:	eb44 0104 	adc.w	r1, r4, r4
 800df6c:	181b      	adds	r3, r3, r0
 800df6e:	f141 0100 	adc.w	r1, r1, #0
 800df72:	00c9      	lsls	r1, r1, #3
 800df74:	ea41 7153 	orr.w	r1, r1, r3, lsr #29
 800df78:	00db      	lsls	r3, r3, #3
 800df7a:	1818      	adds	r0, r3, r0
 800df7c:	ea4f 7997 	mov.w	r9, r7, lsr #30
 800df80:	ea4f 0787 	mov.w	r7, r7, lsl #2
 800df84:	463a      	mov	r2, r7
 800df86:	464b      	mov	r3, r9
 800df88:	f141 0100 	adc.w	r1, r1, #0
 800df8c:	f7fa fd66 	bl	8008a5c <__aeabi_uldivmod>
 800df90:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 800e08c <serial2SetBaudRate+0x13c>
 800df94:	fba8 3500 	umull	r3, r5, r8, r0
 800df98:	096d      	lsrs	r5, r5, #5
 800df9a:	012d      	lsls	r5, r5, #4
 800df9c:	f7fc fb36 	bl	800a60c <HAL_RCC_GetPCLK1Freq>
 800dfa0:	1803      	adds	r3, r0, r0
 800dfa2:	eb44 0104 	adc.w	r1, r4, r4
 800dfa6:	181b      	adds	r3, r3, r0
 800dfa8:	f141 0100 	adc.w	r1, r1, #0
 800dfac:	00c9      	lsls	r1, r1, #3
 800dfae:	ea41 7153 	orr.w	r1, r1, r3, lsr #29
 800dfb2:	00db      	lsls	r3, r3, #3
 800dfb4:	1818      	adds	r0, r3, r0
 800dfb6:	463a      	mov	r2, r7
 800dfb8:	464b      	mov	r3, r9
 800dfba:	f141 0100 	adc.w	r1, r1, #0
 800dfbe:	f7fa fd4d 	bl	8008a5c <__aeabi_uldivmod>
 800dfc2:	4606      	mov	r6, r0
 800dfc4:	f7fc fb22 	bl	800a60c <HAL_RCC_GetPCLK1Freq>
 800dfc8:	1803      	adds	r3, r0, r0
 800dfca:	eb44 0104 	adc.w	r1, r4, r4
 800dfce:	181b      	adds	r3, r3, r0
 800dfd0:	f141 0100 	adc.w	r1, r1, #0
 800dfd4:	00c9      	lsls	r1, r1, #3
 800dfd6:	ea41 7153 	orr.w	r1, r1, r3, lsr #29
 800dfda:	00db      	lsls	r3, r3, #3
 800dfdc:	1818      	adds	r0, r3, r0
 800dfde:	463a      	mov	r2, r7
 800dfe0:	464b      	mov	r3, r9
 800dfe2:	f141 0100 	adc.w	r1, r1, #0
 800dfe6:	f7fa fd39 	bl	8008a5c <__aeabi_uldivmod>
 800dfea:	fba8 3000 	umull	r3, r0, r8, r0
 800dfee:	0940      	lsrs	r0, r0, #5
 800dff0:	f04f 0b64 	mov.w	fp, #100	; 0x64
 800dff4:	fb0b 6310 	mls	r3, fp, r0, r6
 800dff8:	011b      	lsls	r3, r3, #4
 800dffa:	3332      	adds	r3, #50	; 0x32
 800dffc:	fba8 2303 	umull	r2, r3, r8, r3
 800e000:	095b      	lsrs	r3, r3, #5
 800e002:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800e006:	441d      	add	r5, r3
 800e008:	f7fc fb00 	bl	800a60c <HAL_RCC_GetPCLK1Freq>
 800e00c:	1803      	adds	r3, r0, r0
 800e00e:	eb44 0104 	adc.w	r1, r4, r4
 800e012:	181b      	adds	r3, r3, r0
 800e014:	f141 0100 	adc.w	r1, r1, #0
 800e018:	00c9      	lsls	r1, r1, #3
 800e01a:	ea41 7153 	orr.w	r1, r1, r3, lsr #29
 800e01e:	00db      	lsls	r3, r3, #3
 800e020:	1818      	adds	r0, r3, r0
 800e022:	463a      	mov	r2, r7
 800e024:	464b      	mov	r3, r9
 800e026:	f141 0100 	adc.w	r1, r1, #0
 800e02a:	f7fa fd17 	bl	8008a5c <__aeabi_uldivmod>
 800e02e:	4606      	mov	r6, r0
 800e030:	f7fc faec 	bl	800a60c <HAL_RCC_GetPCLK1Freq>
 800e034:	1803      	adds	r3, r0, r0
 800e036:	4164      	adcs	r4, r4
 800e038:	181b      	adds	r3, r3, r0
 800e03a:	f144 0100 	adc.w	r1, r4, #0
 800e03e:	00c9      	lsls	r1, r1, #3
 800e040:	ea41 7153 	orr.w	r1, r1, r3, lsr #29
 800e044:	00db      	lsls	r3, r3, #3
 800e046:	1818      	adds	r0, r3, r0
 800e048:	463a      	mov	r2, r7
 800e04a:	464b      	mov	r3, r9
 800e04c:	f141 0100 	adc.w	r1, r1, #0
 800e050:	f7fa fd04 	bl	8008a5c <__aeabi_uldivmod>
 800e054:	fba8 3000 	umull	r3, r0, r8, r0
 800e058:	0940      	lsrs	r0, r0, #5
 800e05a:	fb0b 6310 	mls	r3, fp, r0, r6
 800e05e:	011b      	lsls	r3, r3, #4
 800e060:	3332      	adds	r3, #50	; 0x32
 800e062:	fba8 8303 	umull	r8, r3, r8, r3
 800e066:	f3c3 1343 	ubfx	r3, r3, #5, #4
 800e06a:	441d      	add	r5, r3
 800e06c:	f8ca 5008 	str.w	r5, [sl, #8]
    UART2->CR1 |= (USART_CR1_UE|USART_CR1_RXNEIE);
 800e070:	f8da 300c 	ldr.w	r3, [sl, #12]
 800e074:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800e078:	f043 0320 	orr.w	r3, r3, #32
 800e07c:	f8ca 300c 	str.w	r3, [sl, #12]
}
 800e080:	2001      	movs	r0, #1
 800e082:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800e086:	bf00      	nop
 800e088:	40004400 	.word	0x40004400
 800e08c:	51eb851f 	.word	0x51eb851f

0800e090 <serial2Init>:
        .disable_rx = serial2Disable,
        .set_baud_rate = serial2SetBaudRate,
        .set_enqueue_rt_handler = serial2SetRtHandler
    };

    if(serial[1].flags.claimed)
 800e090:	4b23      	ldr	r3, [pc, #140]	; (800e120 <serial2Init+0x90>)
 800e092:	7a9b      	ldrb	r3, [r3, #10]
 800e094:	f013 0f04 	tst.w	r3, #4
 800e098:	d140      	bne.n	800e11c <serial2Init+0x8c>
{
 800e09a:	b570      	push	{r4, r5, r6, lr}
 800e09c:	b088      	sub	sp, #32
 800e09e:	4605      	mov	r5, r0
        return NULL;

    serial[1].flags.claimed = On;
 800e0a0:	4a1f      	ldr	r2, [pc, #124]	; (800e120 <serial2Init+0x90>)
 800e0a2:	f043 0304 	orr.w	r3, r3, #4
 800e0a6:	7293      	strb	r3, [r2, #10]
        .description = "UART2"
    };

#elif SERIAL2_MOD == 2

    __HAL_RCC_USART2_CLK_ENABLE();
 800e0a8:	2600      	movs	r6, #0
 800e0aa:	9601      	str	r6, [sp, #4]
 800e0ac:	4b1d      	ldr	r3, [pc, #116]	; (800e124 <serial2Init+0x94>)
 800e0ae:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800e0b0:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800e0b4:	641a      	str	r2, [r3, #64]	; 0x40
 800e0b6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800e0b8:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 800e0bc:	9201      	str	r2, [sp, #4]
 800e0be:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800e0c0:	9602      	str	r6, [sp, #8]
 800e0c2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800e0c4:	f042 0201 	orr.w	r2, r2, #1
 800e0c8:	631a      	str	r2, [r3, #48]	; 0x30
 800e0ca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e0cc:	f003 0301 	and.w	r3, r3, #1
 800e0d0:	9302      	str	r3, [sp, #8]
 800e0d2:	9b02      	ldr	r3, [sp, #8]

    GPIO_InitTypeDef GPIO_InitStructure = {
 800e0d4:	f10d 0c0c 	add.w	ip, sp, #12
 800e0d8:	4c13      	ldr	r4, [pc, #76]	; (800e128 <serial2Init+0x98>)
 800e0da:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800e0dc:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 800e0e0:	6823      	ldr	r3, [r4, #0]
 800e0e2:	f8cc 3000 	str.w	r3, [ip]
        .Pull      = GPIO_NOPULL,
        .Speed     = GPIO_SPEED_FREQ_VERY_HIGH,
        .Pin       = GPIO_PIN_2|GPIO_PIN_3,
        .Alternate = GPIO_AF7_USART1	//GPIO_AF7_USART2 - this is what i wrote, but now i've changed it to it's original
    };
    HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
 800e0e6:	a903      	add	r1, sp, #12
 800e0e8:	4810      	ldr	r0, [pc, #64]	; (800e12c <serial2Init+0x9c>)
 800e0ea:	f7fb f8ed 	bl	80092c8 <HAL_GPIO_Init>

#else
#error Code has to be added to support serial module 2
#endif

    serial2SetBaudRate(baud_rate);
 800e0ee:	4628      	mov	r0, r5
 800e0f0:	f7ff ff2e 	bl	800df50 <serial2SetBaudRate>

    HAL_NVIC_SetPriority(UART2_IRQ, 0, 0);
 800e0f4:	4632      	mov	r2, r6
 800e0f6:	4631      	mov	r1, r6
 800e0f8:	2026      	movs	r0, #38	; 0x26
 800e0fa:	f7fa fea5 	bl	8008e48 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(UART2_IRQ);
 800e0fe:	2026      	movs	r0, #38	; 0x26
 800e100:	f7fa feda 	bl	8008eb8 <HAL_NVIC_EnableIRQ>

    hal.periph_port.register_pin(&rx);
 800e104:	4c0a      	ldr	r4, [pc, #40]	; (800e130 <serial2Init+0xa0>)
 800e106:	f8d4 3138 	ldr.w	r3, [r4, #312]	; 0x138
 800e10a:	480a      	ldr	r0, [pc, #40]	; (800e134 <serial2Init+0xa4>)
 800e10c:	4798      	blx	r3
    hal.periph_port.register_pin(&tx);
 800e10e:	f8d4 3138 	ldr.w	r3, [r4, #312]	; 0x138
 800e112:	4809      	ldr	r0, [pc, #36]	; (800e138 <serial2Init+0xa8>)
 800e114:	4798      	blx	r3

    return &stream;
 800e116:	4809      	ldr	r0, [pc, #36]	; (800e13c <serial2Init+0xac>)
}
 800e118:	b008      	add	sp, #32
 800e11a:	bd70      	pop	{r4, r5, r6, pc}
        return NULL;
 800e11c:	2000      	movs	r0, #0
}
 800e11e:	4770      	bx	lr
 800e120:	20000348 	.word	0x20000348
 800e124:	40023800 	.word	0x40023800
 800e128:	08025398 	.word	0x08025398
 800e12c:	40020000 	.word	0x40020000
 800e130:	2000350c 	.word	0x2000350c
 800e134:	0802548c 	.word	0x0802548c
 800e138:	08025554 	.word	0x08025554
 800e13c:	080254bc 	.word	0x080254bc

0800e140 <serialRegisterStreams>:
{
 800e140:	b508      	push	{r3, lr}
    stream_register_streams(&streams);
 800e142:	4802      	ldr	r0, [pc, #8]	; (800e14c <serialRegisterStreams+0xc>)
 800e144:	f011 ff6e 	bl	8020024 <stream_register_streams>
}
 800e148:	bd08      	pop	{r3, pc}
 800e14a:	bf00      	nop
 800e14c:	20000358 	.word	0x20000358

0800e150 <USART1_IRQHandler>:
{
 800e150:	b510      	push	{r4, lr}
    if(USART->SR & USART_SR_RXNE) {
 800e152:	4b1d      	ldr	r3, [pc, #116]	; (800e1c8 <USART1_IRQHandler+0x78>)
 800e154:	681b      	ldr	r3, [r3, #0]
 800e156:	f013 0f20 	tst.w	r3, #32
 800e15a:	d014      	beq.n	800e186 <USART1_IRQHandler+0x36>
        uint32_t data = USART->DR;
 800e15c:	4b1a      	ldr	r3, [pc, #104]	; (800e1c8 <USART1_IRQHandler+0x78>)
 800e15e:	685c      	ldr	r4, [r3, #4]
        if(!enqueue_realtime_command((char)data)) {             // Check and strip realtime commands...
 800e160:	b2e4      	uxtb	r4, r4
 800e162:	4b1a      	ldr	r3, [pc, #104]	; (800e1cc <USART1_IRQHandler+0x7c>)
 800e164:	681b      	ldr	r3, [r3, #0]
 800e166:	4620      	mov	r0, r4
 800e168:	4798      	blx	r3
 800e16a:	b960      	cbnz	r0, 800e186 <USART1_IRQHandler+0x36>
            uint16_t next_head = BUFNEXT(rxbuf.head, rxbuf);    // Get and increment buffer pointer
 800e16c:	4a18      	ldr	r2, [pc, #96]	; (800e1d0 <USART1_IRQHandler+0x80>)
 800e16e:	6813      	ldr	r3, [r2, #0]
 800e170:	3301      	adds	r3, #1
 800e172:	f3c3 0309 	ubfx	r3, r3, #0, #10
            if(next_head == rxbuf.tail)                         // If buffer full
 800e176:	6852      	ldr	r2, [r2, #4]
 800e178:	4293      	cmp	r3, r2
 800e17a:	d01c      	beq.n	800e1b6 <USART1_IRQHandler+0x66>
                rxbuf.data[rxbuf.head] = (char)data;            // if not add data to buffer
 800e17c:	4a14      	ldr	r2, [pc, #80]	; (800e1d0 <USART1_IRQHandler+0x80>)
 800e17e:	6811      	ldr	r1, [r2, #0]
 800e180:	4411      	add	r1, r2
 800e182:	72cc      	strb	r4, [r1, #11]
                rxbuf.head = next_head;                         // and update pointer
 800e184:	6013      	str	r3, [r2, #0]
    if((USART->SR & USART_SR_TXE) && (USART->CR1 & USART_CR1_TXEIE)) {
 800e186:	4b10      	ldr	r3, [pc, #64]	; (800e1c8 <USART1_IRQHandler+0x78>)
 800e188:	681b      	ldr	r3, [r3, #0]
 800e18a:	f013 0f80 	tst.w	r3, #128	; 0x80
 800e18e:	d011      	beq.n	800e1b4 <USART1_IRQHandler+0x64>
 800e190:	4b0d      	ldr	r3, [pc, #52]	; (800e1c8 <USART1_IRQHandler+0x78>)
 800e192:	68db      	ldr	r3, [r3, #12]
 800e194:	f013 0f80 	tst.w	r3, #128	; 0x80
 800e198:	d00c      	beq.n	800e1b4 <USART1_IRQHandler+0x64>
        uint_fast16_t tail = txbuf.tail;            // Get buffer pointer
 800e19a:	4a0e      	ldr	r2, [pc, #56]	; (800e1d4 <USART1_IRQHandler+0x84>)
 800e19c:	6853      	ldr	r3, [r2, #4]
        USART->DR = txbuf.data[tail];               // Send next character
 800e19e:	18d1      	adds	r1, r2, r3
 800e1a0:	7a08      	ldrb	r0, [r1, #8]
 800e1a2:	4909      	ldr	r1, [pc, #36]	; (800e1c8 <USART1_IRQHandler+0x78>)
 800e1a4:	6048      	str	r0, [r1, #4]
        txbuf.tail = tail = BUFNEXT(tail, txbuf);   // and increment pointer
 800e1a6:	3301      	adds	r3, #1
 800e1a8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800e1ac:	6053      	str	r3, [r2, #4]
        if(tail == txbuf.head)                      // If buffer empty then
 800e1ae:	6812      	ldr	r2, [r2, #0]
 800e1b0:	429a      	cmp	r2, r3
 800e1b2:	d004      	beq.n	800e1be <USART1_IRQHandler+0x6e>
}
 800e1b4:	bd10      	pop	{r4, pc}
                rxbuf.overflow = 1;                             // flag overflow
 800e1b6:	4b06      	ldr	r3, [pc, #24]	; (800e1d0 <USART1_IRQHandler+0x80>)
 800e1b8:	2201      	movs	r2, #1
 800e1ba:	725a      	strb	r2, [r3, #9]
 800e1bc:	e7e3      	b.n	800e186 <USART1_IRQHandler+0x36>
            USART->CR1 &= ~USART_CR1_TXEIE;         // disable UART TX interrupt
 800e1be:	68cb      	ldr	r3, [r1, #12]
 800e1c0:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800e1c4:	60cb      	str	r3, [r1, #12]
}
 800e1c6:	e7f5      	b.n	800e1b4 <USART1_IRQHandler+0x64>
 800e1c8:	40011000 	.word	0x40011000
 800e1cc:	20000340 	.word	0x20000340
 800e1d0:	2000076c 	.word	0x2000076c
 800e1d4:	20000f84 	.word	0x20000f84

0800e1d8 <USART2_IRQHandler>:

void UART2_IRQHandler (void)
{
 800e1d8:	b510      	push	{r4, lr}
    if(UART2->SR & USART_SR_RXNE) {
 800e1da:	4b1d      	ldr	r3, [pc, #116]	; (800e250 <USART2_IRQHandler+0x78>)
 800e1dc:	681b      	ldr	r3, [r3, #0]
 800e1de:	f013 0f20 	tst.w	r3, #32
 800e1e2:	d014      	beq.n	800e20e <USART2_IRQHandler+0x36>
        uint32_t data = UART2->DR;
 800e1e4:	4b1a      	ldr	r3, [pc, #104]	; (800e250 <USART2_IRQHandler+0x78>)
 800e1e6:	685c      	ldr	r4, [r3, #4]
        if(!enqueue_realtime_command2((char)data)) {            // Check and strip realtime commands...
 800e1e8:	b2e4      	uxtb	r4, r4
 800e1ea:	4b1a      	ldr	r3, [pc, #104]	; (800e254 <USART2_IRQHandler+0x7c>)
 800e1ec:	681b      	ldr	r3, [r3, #0]
 800e1ee:	4620      	mov	r0, r4
 800e1f0:	4798      	blx	r3
 800e1f2:	b960      	cbnz	r0, 800e20e <USART2_IRQHandler+0x36>
            uint16_t next_head = BUFNEXT(rxbuf2.head, rxbuf2);  // Get and increment buffer pointer
 800e1f4:	4a18      	ldr	r2, [pc, #96]	; (800e258 <USART2_IRQHandler+0x80>)
 800e1f6:	6813      	ldr	r3, [r2, #0]
 800e1f8:	3301      	adds	r3, #1
 800e1fa:	f3c3 0309 	ubfx	r3, r3, #0, #10
            if(next_head == rxbuf2.tail)                        // If buffer full
 800e1fe:	6852      	ldr	r2, [r2, #4]
 800e200:	4293      	cmp	r3, r2
 800e202:	d01c      	beq.n	800e23e <USART2_IRQHandler+0x66>
                rxbuf2.overflow = 1;                            // flag overflow
            else {
                rxbuf2.data[rxbuf2.head] = (char)data;          // if not add data to buffer
 800e204:	4a14      	ldr	r2, [pc, #80]	; (800e258 <USART2_IRQHandler+0x80>)
 800e206:	6811      	ldr	r1, [r2, #0]
 800e208:	4411      	add	r1, r2
 800e20a:	72cc      	strb	r4, [r1, #11]
                rxbuf2.head = next_head;                        // and update pointer
 800e20c:	6013      	str	r3, [r2, #0]
            }
        }
    }

    if((UART2->SR & USART_SR_TXE) && (UART2->CR1 & USART_CR1_TXEIE)) {
 800e20e:	4b10      	ldr	r3, [pc, #64]	; (800e250 <USART2_IRQHandler+0x78>)
 800e210:	681b      	ldr	r3, [r3, #0]
 800e212:	f013 0f80 	tst.w	r3, #128	; 0x80
 800e216:	d011      	beq.n	800e23c <USART2_IRQHandler+0x64>
 800e218:	4b0d      	ldr	r3, [pc, #52]	; (800e250 <USART2_IRQHandler+0x78>)
 800e21a:	68db      	ldr	r3, [r3, #12]
 800e21c:	f013 0f80 	tst.w	r3, #128	; 0x80
 800e220:	d00c      	beq.n	800e23c <USART2_IRQHandler+0x64>
        uint_fast16_t tail = txbuf2.tail;           // Get buffer pointer
 800e222:	4a0e      	ldr	r2, [pc, #56]	; (800e25c <USART2_IRQHandler+0x84>)
 800e224:	6853      	ldr	r3, [r2, #4]
        UART2->DR = txbuf2.data[tail];              // Send next character
 800e226:	18d1      	adds	r1, r2, r3
 800e228:	7a08      	ldrb	r0, [r1, #8]
 800e22a:	4909      	ldr	r1, [pc, #36]	; (800e250 <USART2_IRQHandler+0x78>)
 800e22c:	6048      	str	r0, [r1, #4]
        txbuf2.tail = tail = BUFNEXT(tail, txbuf2); // and increment pointer
 800e22e:	3301      	adds	r3, #1
 800e230:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800e234:	6053      	str	r3, [r2, #4]
        if(tail == txbuf2.head)                     // If buffer empty then
 800e236:	6812      	ldr	r2, [r2, #0]
 800e238:	429a      	cmp	r2, r3
 800e23a:	d004      	beq.n	800e246 <USART2_IRQHandler+0x6e>
            UART2->CR1 &= ~USART_CR1_TXEIE;         // disable UART TX interrupt
   }
}
 800e23c:	bd10      	pop	{r4, pc}
                rxbuf2.overflow = 1;                            // flag overflow
 800e23e:	4b06      	ldr	r3, [pc, #24]	; (800e258 <USART2_IRQHandler+0x80>)
 800e240:	2201      	movs	r2, #1
 800e242:	725a      	strb	r2, [r3, #9]
 800e244:	e7e3      	b.n	800e20e <USART2_IRQHandler+0x36>
            UART2->CR1 &= ~USART_CR1_TXEIE;         // disable UART TX interrupt
 800e246:	68cb      	ldr	r3, [r1, #12]
 800e248:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800e24c:	60cb      	str	r3, [r1, #12]
}
 800e24e:	e7f5      	b.n	800e23c <USART2_IRQHandler+0x64>
 800e250:	40004400 	.word	0x40004400
 800e254:	20000344 	.word	0x20000344
 800e258:	20000b78 	.word	0x20000b78
 800e25c:	2000118c 	.word	0x2000118c

0800e260 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 800e260:	b500      	push	{lr}
 800e262:	b083      	sub	sp, #12
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 800e264:	2100      	movs	r1, #0
 800e266:	9100      	str	r1, [sp, #0]
 800e268:	4b0c      	ldr	r3, [pc, #48]	; (800e29c <HAL_MspInit+0x3c>)
 800e26a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800e26c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800e270:	645a      	str	r2, [r3, #68]	; 0x44
 800e272:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800e274:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 800e278:	9200      	str	r2, [sp, #0]
 800e27a:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 800e27c:	9101      	str	r1, [sp, #4]
 800e27e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800e280:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800e284:	641a      	str	r2, [r3, #64]	; 0x40
 800e286:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800e288:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800e28c:	9301      	str	r3, [sp, #4]
 800e28e:	9b01      	ldr	r3, [sp, #4]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2);
 800e290:	2005      	movs	r0, #5
 800e292:	f7fa fdc7 	bl	8008e24 <HAL_NVIC_SetPriorityGrouping>
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800e296:	b003      	add	sp, #12
 800e298:	f85d fb04 	ldr.w	pc, [sp], #4
 800e29c:	40023800 	.word	0x40023800

0800e2a0 <NMI_Handler>:

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 800e2a0:	4770      	bx	lr

0800e2a2 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 800e2a2:	e7fe      	b.n	800e2a2 <HardFault_Handler>

0800e2a4 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 800e2a4:	e7fe      	b.n	800e2a4 <MemManage_Handler>

0800e2a6 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 800e2a6:	e7fe      	b.n	800e2a6 <BusFault_Handler>

0800e2a8 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 800e2a8:	e7fe      	b.n	800e2a8 <UsageFault_Handler>

0800e2aa <SVC_Handler>:

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 800e2aa:	4770      	bx	lr

0800e2ac <DebugMon_Handler>:

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 800e2ac:	4770      	bx	lr

0800e2ae <PendSV_Handler>:

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 800e2ae:	4770      	bx	lr

0800e2b0 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 800e2b0:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 800e2b2:	f7fa fd91 	bl	8008dd8 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */
  Driver_IncTick();
 800e2b6:	f7ff fa71 	bl	800d79c <Driver_IncTick>
  /* USER CODE END SysTick_IRQn 1 */
}
 800e2ba:	bd08      	pop	{r3, pc}

0800e2bc <OTG_FS_IRQHandler>:
/**
  * @brief This function handles USB On The Go FS global interrupt.
  */
#if USB_SERIAL_CDC
void OTG_FS_IRQHandler(void)
{
 800e2bc:	b508      	push	{r3, lr}
  /* USER CODE BEGIN OTG_FS_IRQn 0 */

  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 800e2be:	4802      	ldr	r0, [pc, #8]	; (800e2c8 <OTG_FS_IRQHandler+0xc>)
 800e2c0:	f7fb faac 	bl	800981c <HAL_PCD_IRQHandler>
  /* USER CODE BEGIN OTG_FS_IRQn 1 */

  /* USER CODE END OTG_FS_IRQn 1 */
}
 800e2c4:	bd08      	pop	{r3, pc}
 800e2c6:	bf00      	nop
 800e2c8:	20002e90 	.word	0x20002e90

0800e2cc <_getpid>:
}

int _getpid(void)
{
	return 1;
}
 800e2cc:	2001      	movs	r0, #1
 800e2ce:	4770      	bx	lr

0800e2d0 <_kill>:

int _kill(int pid, int sig)
{
 800e2d0:	b508      	push	{r3, lr}
	errno = EINVAL;
 800e2d2:	f014 fd79 	bl	8022dc8 <__errno>
 800e2d6:	2316      	movs	r3, #22
 800e2d8:	6003      	str	r3, [r0, #0]
	return -1;
}
 800e2da:	f04f 30ff 	mov.w	r0, #4294967295
 800e2de:	bd08      	pop	{r3, pc}

0800e2e0 <_exit>:

void _exit (int status)
{
 800e2e0:	b508      	push	{r3, lr}
	_kill(status, -1);
 800e2e2:	f04f 31ff 	mov.w	r1, #4294967295
 800e2e6:	f7ff fff3 	bl	800e2d0 <_kill>
	while (1) {}		/* Make sure we hang here */
 800e2ea:	e7fe      	b.n	800e2ea <_exit+0xa>

0800e2ec <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 800e2ec:	b570      	push	{r4, r5, r6, lr}
 800e2ee:	460c      	mov	r4, r1
 800e2f0:	4616      	mov	r6, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800e2f2:	2500      	movs	r5, #0
 800e2f4:	e006      	b.n	800e304 <_read+0x18>
	{
		*ptr++ = __io_getchar();
 800e2f6:	f3af 8000 	nop.w
 800e2fa:	4621      	mov	r1, r4
 800e2fc:	f801 0b01 	strb.w	r0, [r1], #1
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800e300:	3501      	adds	r5, #1
		*ptr++ = __io_getchar();
 800e302:	460c      	mov	r4, r1
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800e304:	42b5      	cmp	r5, r6
 800e306:	dbf6      	blt.n	800e2f6 <_read+0xa>
	}

return len;
}
 800e308:	4630      	mov	r0, r6
 800e30a:	bd70      	pop	{r4, r5, r6, pc}

0800e30c <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 800e30c:	b570      	push	{r4, r5, r6, lr}
 800e30e:	460c      	mov	r4, r1
 800e310:	4616      	mov	r6, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800e312:	2500      	movs	r5, #0
 800e314:	e004      	b.n	800e320 <_write+0x14>
	{
		__io_putchar(*ptr++);
 800e316:	f814 0b01 	ldrb.w	r0, [r4], #1
 800e31a:	f3af 8000 	nop.w
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800e31e:	3501      	adds	r5, #1
 800e320:	42b5      	cmp	r5, r6
 800e322:	dbf8      	blt.n	800e316 <_write+0xa>
	}
	return len;
}
 800e324:	4630      	mov	r0, r6
 800e326:	bd70      	pop	{r4, r5, r6, pc}

0800e328 <_close>:

int _close(int file)
{
	return -1;
}
 800e328:	f04f 30ff 	mov.w	r0, #4294967295
 800e32c:	4770      	bx	lr

0800e32e <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 800e32e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800e332:	604b      	str	r3, [r1, #4]
	return 0;
}
 800e334:	2000      	movs	r0, #0
 800e336:	4770      	bx	lr

0800e338 <_isatty>:

int _isatty(int file)
{
	return 1;
}
 800e338:	2001      	movs	r0, #1
 800e33a:	4770      	bx	lr

0800e33c <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 800e33c:	2000      	movs	r0, #0
 800e33e:	4770      	bx	lr

0800e340 <_sbrk>:
/**
 _sbrk
 Increase program data space. Malloc and related functions depend on this
**/
caddr_t _sbrk(int incr)
{
 800e340:	b508      	push	{r3, lr}
 800e342:	4603      	mov	r3, r0
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 800e344:	4a0b      	ldr	r2, [pc, #44]	; (800e374 <_sbrk+0x34>)
 800e346:	6812      	ldr	r2, [r2, #0]
 800e348:	b142      	cbz	r2, 800e35c <_sbrk+0x1c>
		heap_end = &end;

	prev_heap_end = heap_end;
 800e34a:	4a0a      	ldr	r2, [pc, #40]	; (800e374 <_sbrk+0x34>)
 800e34c:	6810      	ldr	r0, [r2, #0]
	if (heap_end + incr > stack_ptr)
 800e34e:	4403      	add	r3, r0
 800e350:	466a      	mov	r2, sp
 800e352:	4293      	cmp	r3, r2
 800e354:	d806      	bhi.n	800e364 <_sbrk+0x24>
	{
		errno = ENOMEM;
		return (caddr_t) -1;
	}

	heap_end += incr;
 800e356:	4a07      	ldr	r2, [pc, #28]	; (800e374 <_sbrk+0x34>)
 800e358:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap_end;
}
 800e35a:	bd08      	pop	{r3, pc}
		heap_end = &end;
 800e35c:	4a05      	ldr	r2, [pc, #20]	; (800e374 <_sbrk+0x34>)
 800e35e:	4906      	ldr	r1, [pc, #24]	; (800e378 <_sbrk+0x38>)
 800e360:	6011      	str	r1, [r2, #0]
 800e362:	e7f2      	b.n	800e34a <_sbrk+0xa>
		errno = ENOMEM;
 800e364:	f014 fd30 	bl	8022dc8 <__errno>
 800e368:	230c      	movs	r3, #12
 800e36a:	6003      	str	r3, [r0, #0]
		return (caddr_t) -1;
 800e36c:	f04f 30ff 	mov.w	r0, #4294967295
 800e370:	e7f3      	b.n	800e35a <_sbrk+0x1a>
 800e372:	bf00      	nop
 800e374:	20001394 	.word	0x20001394
 800e378:	200049b0 	.word	0x200049b0

0800e37c <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800e37c:	4b05      	ldr	r3, [pc, #20]	; (800e394 <SystemInit+0x18>)
 800e37e:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800e382:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 800e386:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800e38a:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 800e38e:	609a      	str	r2, [r3, #8]
#endif
}
 800e390:	4770      	bx	lr
 800e392:	bf00      	nop
 800e394:	e000ed00 	.word	0xe000ed00

0800e398 <is_connected>:
static enqueue_realtime_command_ptr enqueue_realtime_command = protocol_enqueue_realtime_command;

volatile usb_linestate_t usb_linestate = {0};

static bool is_connected (void)
{
 800e398:	b508      	push	{r3, lr}
    return usb_linestate.pin.dtr && hal.get_elapsed_ticks() - usb_linestate.timestamp >= 15;
 800e39a:	4b0a      	ldr	r3, [pc, #40]	; (800e3c4 <is_connected+0x2c>)
 800e39c:	781b      	ldrb	r3, [r3, #0]
 800e39e:	f013 0f01 	tst.w	r3, #1
 800e3a2:	d00a      	beq.n	800e3ba <is_connected+0x22>
 800e3a4:	4b08      	ldr	r3, [pc, #32]	; (800e3c8 <is_connected+0x30>)
 800e3a6:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 800e3aa:	4798      	blx	r3
 800e3ac:	4b05      	ldr	r3, [pc, #20]	; (800e3c4 <is_connected+0x2c>)
 800e3ae:	685b      	ldr	r3, [r3, #4]
 800e3b0:	1ac0      	subs	r0, r0, r3
 800e3b2:	280e      	cmp	r0, #14
 800e3b4:	d903      	bls.n	800e3be <is_connected+0x26>
 800e3b6:	2001      	movs	r0, #1
 800e3b8:	e000      	b.n	800e3bc <is_connected+0x24>
 800e3ba:	2000      	movs	r0, #0
}
 800e3bc:	bd08      	pop	{r3, pc}
    return usb_linestate.pin.dtr && hal.get_elapsed_ticks() - usb_linestate.timestamp >= 15;
 800e3be:	2000      	movs	r0, #0
 800e3c0:	e7fc      	b.n	800e3bc <is_connected+0x24>
 800e3c2:	bf00      	nop
 800e3c4:	200019b8 	.word	0x200019b8
 800e3c8:	2000350c 	.word	0x2000350c

0800e3cc <usbRxFree>:
//
// Returns number of free characters in the input buffer
//
static uint16_t usbRxFree (void)
{
    uint16_t tail = rxbuf.tail, head = rxbuf.head;
 800e3cc:	4b07      	ldr	r3, [pc, #28]	; (800e3ec <usbRxFree+0x20>)
 800e3ce:	6858      	ldr	r0, [r3, #4]
 800e3d0:	b280      	uxth	r0, r0
 800e3d2:	681b      	ldr	r3, [r3, #0]
 800e3d4:	b29b      	uxth	r3, r3

    return RX_BUFFER_SIZE - BUFCOUNT(head, tail, RX_BUFFER_SIZE);
 800e3d6:	4298      	cmp	r0, r3
 800e3d8:	d804      	bhi.n	800e3e4 <usbRxFree+0x18>
 800e3da:	1ac0      	subs	r0, r0, r3
 800e3dc:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 800e3e0:	b280      	uxth	r0, r0
 800e3e2:	4770      	bx	lr
 800e3e4:	1ac0      	subs	r0, r0, r3
 800e3e6:	b280      	uxth	r0, r0
}
 800e3e8:	4770      	bx	lr
 800e3ea:	bf00      	nop
 800e3ec:	2000139c 	.word	0x2000139c

0800e3f0 <usbRxFlush>:
//
// Flushes the input buffer
//
static void usbRxFlush (void)
{
    rxbuf.tail = rxbuf.head;
 800e3f0:	4b01      	ldr	r3, [pc, #4]	; (800e3f8 <usbRxFlush+0x8>)
 800e3f2:	681a      	ldr	r2, [r3, #0]
 800e3f4:	605a      	str	r2, [r3, #4]
}
 800e3f6:	4770      	bx	lr
 800e3f8:	2000139c 	.word	0x2000139c

0800e3fc <usbRxCancel>:
//
// Flushes and adds a CAN character to the input buffer
//
static void usbRxCancel (void)
{
    rxbuf.data[rxbuf.head] = ASCII_CAN;
 800e3fc:	4b06      	ldr	r3, [pc, #24]	; (800e418 <usbRxCancel+0x1c>)
 800e3fe:	681a      	ldr	r2, [r3, #0]
 800e400:	441a      	add	r2, r3
 800e402:	2118      	movs	r1, #24
 800e404:	72d1      	strb	r1, [r2, #11]
    rxbuf.tail = rxbuf.head;
 800e406:	681a      	ldr	r2, [r3, #0]
 800e408:	605a      	str	r2, [r3, #4]
    rxbuf.head = BUFNEXT(rxbuf.head, rxbuf);
 800e40a:	681a      	ldr	r2, [r3, #0]
 800e40c:	3201      	adds	r2, #1
 800e40e:	f3c2 0209 	ubfx	r2, r2, #0, #10
 800e412:	601a      	str	r2, [r3, #0]
}
 800e414:	4770      	bx	lr
 800e416:	bf00      	nop
 800e418:	2000139c 	.word	0x2000139c

0800e41c <usbGetC>:
//
// usbGetC - returns -1 if no data available
//
static int16_t usbGetC (void)
{
    uint_fast16_t tail = rxbuf.tail;    // Get buffer pointer
 800e41c:	4a07      	ldr	r2, [pc, #28]	; (800e43c <usbGetC+0x20>)
 800e41e:	6853      	ldr	r3, [r2, #4]

    if(tail == rxbuf.head)
 800e420:	6812      	ldr	r2, [r2, #0]
 800e422:	429a      	cmp	r2, r3
 800e424:	d007      	beq.n	800e436 <usbGetC+0x1a>
        return -1; // no data available

    char data = rxbuf.data[tail];       // Get next character
 800e426:	4a05      	ldr	r2, [pc, #20]	; (800e43c <usbGetC+0x20>)
 800e428:	18d1      	adds	r1, r2, r3
    rxbuf.tail = BUFNEXT(tail, rxbuf);  // and update pointer
 800e42a:	3301      	adds	r3, #1
 800e42c:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800e430:	6053      	str	r3, [r2, #4]

    return (int16_t)data;
 800e432:	7ac8      	ldrb	r0, [r1, #11]
 800e434:	4770      	bx	lr
        return -1; // no data available
 800e436:	f04f 30ff 	mov.w	r0, #4294967295
}
 800e43a:	4770      	bx	lr
 800e43c:	2000139c 	.word	0x2000139c

0800e440 <usbEnqueueRtCommand>:
{
    return stream_rx_suspend(&rxbuf, suspend);
}

static bool usbEnqueueRtCommand (char c)
{
 800e440:	b508      	push	{r3, lr}
    return enqueue_realtime_command(c);
 800e442:	4b02      	ldr	r3, [pc, #8]	; (800e44c <usbEnqueueRtCommand+0xc>)
 800e444:	681b      	ldr	r3, [r3, #0]
 800e446:	4798      	blx	r3
}
 800e448:	bd08      	pop	{r3, pc}
 800e44a:	bf00      	nop
 800e44c:	20000368 	.word	0x20000368

0800e450 <usbSetRtHandler>:

static enqueue_realtime_command_ptr usbSetRtHandler (enqueue_realtime_command_ptr handler)
{
 800e450:	4603      	mov	r3, r0
    enqueue_realtime_command_ptr prev = enqueue_realtime_command;
 800e452:	4a03      	ldr	r2, [pc, #12]	; (800e460 <usbSetRtHandler+0x10>)
 800e454:	6810      	ldr	r0, [r2, #0]

    if(handler)
 800e456:	461a      	mov	r2, r3
 800e458:	b10b      	cbz	r3, 800e45e <usbSetRtHandler+0xe>
        enqueue_realtime_command = handler;
 800e45a:	4b01      	ldr	r3, [pc, #4]	; (800e460 <usbSetRtHandler+0x10>)
 800e45c:	601a      	str	r2, [r3, #0]

    return prev;
}
 800e45e:	4770      	bx	lr
 800e460:	20000368 	.word	0x20000368

0800e464 <usbPutC>:
{
 800e464:	b508      	push	{r3, lr}
    *buf = c;
 800e466:	4b09      	ldr	r3, [pc, #36]	; (800e48c <usbPutC+0x28>)
 800e468:	7018      	strb	r0, [r3, #0]
    while(CDC_Transmit_FS(buf, 1) == USBD_BUSY) {
 800e46a:	2101      	movs	r1, #1
 800e46c:	4807      	ldr	r0, [pc, #28]	; (800e48c <usbPutC+0x28>)
 800e46e:	f000 fab3 	bl	800e9d8 <CDC_Transmit_FS>
 800e472:	2801      	cmp	r0, #1
 800e474:	d107      	bne.n	800e486 <usbPutC+0x22>
        if(!hal.stream_blocking_callback())
 800e476:	4b06      	ldr	r3, [pc, #24]	; (800e490 <usbPutC+0x2c>)
 800e478:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800e47c:	4798      	blx	r3
 800e47e:	4603      	mov	r3, r0
 800e480:	2800      	cmp	r0, #0
 800e482:	d1f2      	bne.n	800e46a <usbPutC+0x6>
 800e484:	e000      	b.n	800e488 <usbPutC+0x24>
    return true;
 800e486:	2301      	movs	r3, #1
}
 800e488:	4618      	mov	r0, r3
 800e48a:	bd08      	pop	{r3, pc}
 800e48c:	20001398 	.word	0x20001398
 800e490:	2000350c 	.word	0x2000350c

0800e494 <usbSuspendInput>:
{
 800e494:	b508      	push	{r3, lr}
 800e496:	4601      	mov	r1, r0
    return stream_rx_suspend(&rxbuf, suspend);
 800e498:	4801      	ldr	r0, [pc, #4]	; (800e4a0 <usbSuspendInput+0xc>)
 800e49a:	f011 fdfb 	bl	8020094 <stream_rx_suspend>
}
 800e49e:	bd08      	pop	{r3, pc}
 800e4a0:	2000139c 	.word	0x2000139c

0800e4a4 <usbWriteS>:
{
 800e4a4:	b570      	push	{r4, r5, r6, lr}
 800e4a6:	4604      	mov	r4, r0
    size_t length = strlen(s);
 800e4a8:	f7f9 fdd4 	bl	8008054 <strlen>
    if(length == 0)
 800e4ac:	2800      	cmp	r0, #0
 800e4ae:	f000 8092 	beq.w	800e5d6 <usbWriteS+0x132>
 800e4b2:	4605      	mov	r5, r0
    if(txbuf.length && (txbuf.length + length) > txbuf.max_length) {
 800e4b4:	4b6c      	ldr	r3, [pc, #432]	; (800e668 <usbWriteS+0x1c4>)
 800e4b6:	681b      	ldr	r3, [r3, #0]
 800e4b8:	2b00      	cmp	r3, #0
 800e4ba:	d05b      	beq.n	800e574 <usbWriteS+0xd0>
 800e4bc:	4403      	add	r3, r0
 800e4be:	4a6a      	ldr	r2, [pc, #424]	; (800e668 <usbWriteS+0x1c4>)
 800e4c0:	6852      	ldr	r2, [r2, #4]
 800e4c2:	4293      	cmp	r3, r2
 800e4c4:	d956      	bls.n	800e574 <usbWriteS+0xd0>
    txbuf.s = txbuf.use_tx2data ? txbuf.data2 : txbuf.data;
 800e4c6:	4b68      	ldr	r3, [pc, #416]	; (800e668 <usbWriteS+0x1c4>)
 800e4c8:	7b1b      	ldrb	r3, [r3, #12]
 800e4ca:	b19b      	cbz	r3, 800e4f4 <usbWriteS+0x50>
 800e4cc:	4a67      	ldr	r2, [pc, #412]	; (800e66c <usbWriteS+0x1c8>)
 800e4ce:	4b66      	ldr	r3, [pc, #408]	; (800e668 <usbWriteS+0x1c4>)
 800e4d0:	609a      	str	r2, [r3, #8]
    while(CDC_Transmit_FS((uint8_t *)txbuf.s, txbuf.length) == USBD_BUSY) {
 800e4d2:	4b65      	ldr	r3, [pc, #404]	; (800e668 <usbWriteS+0x1c4>)
 800e4d4:	8819      	ldrh	r1, [r3, #0]
 800e4d6:	6898      	ldr	r0, [r3, #8]
 800e4d8:	f000 fa7e 	bl	800e9d8 <CDC_Transmit_FS>
 800e4dc:	2801      	cmp	r0, #1
 800e4de:	d10b      	bne.n	800e4f8 <usbWriteS+0x54>
        if(!hal.stream_blocking_callback())
 800e4e0:	4b63      	ldr	r3, [pc, #396]	; (800e670 <usbWriteS+0x1cc>)
 800e4e2:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800e4e6:	4798      	blx	r3
 800e4e8:	4603      	mov	r3, r0
 800e4ea:	2800      	cmp	r0, #0
 800e4ec:	d1f1      	bne.n	800e4d2 <usbWriteS+0x2e>
        if(!usb_write())
 800e4ee:	2b00      	cmp	r3, #0
 800e4f0:	d140      	bne.n	800e574 <usbWriteS+0xd0>
 800e4f2:	e070      	b.n	800e5d6 <usbWriteS+0x132>
    txbuf.s = txbuf.use_tx2data ? txbuf.data2 : txbuf.data;
 800e4f4:	4a5f      	ldr	r2, [pc, #380]	; (800e674 <usbWriteS+0x1d0>)
 800e4f6:	e7ea      	b.n	800e4ce <usbWriteS+0x2a>
    if(txbuf.length % 64 == 0) {
 800e4f8:	4b5b      	ldr	r3, [pc, #364]	; (800e668 <usbWriteS+0x1c4>)
 800e4fa:	681b      	ldr	r3, [r3, #0]
 800e4fc:	f013 0f3f 	tst.w	r3, #63	; 0x3f
 800e500:	d00d      	beq.n	800e51e <usbWriteS+0x7a>
    txbuf.use_tx2data = !txbuf.use_tx2data;
 800e502:	4a59      	ldr	r2, [pc, #356]	; (800e668 <usbWriteS+0x1c4>)
 800e504:	7b13      	ldrb	r3, [r2, #12]
 800e506:	f083 0301 	eor.w	r3, r3, #1
 800e50a:	7313      	strb	r3, [r2, #12]
    txbuf.s = txbuf.use_tx2data ? txbuf.data2 : txbuf.data;
 800e50c:	b1ab      	cbz	r3, 800e53a <usbWriteS+0x96>
 800e50e:	f202 120d 	addw	r2, r2, #269	; 0x10d
 800e512:	4b55      	ldr	r3, [pc, #340]	; (800e668 <usbWriteS+0x1c4>)
 800e514:	609a      	str	r2, [r3, #8]
    txbuf.length = 0;
 800e516:	2200      	movs	r2, #0
 800e518:	601a      	str	r2, [r3, #0]
    return true;
 800e51a:	2301      	movs	r3, #1
 800e51c:	e7e7      	b.n	800e4ee <usbWriteS+0x4a>
        while(CDC_Transmit_FS(&dummy, 0) == USBD_BUSY) {
 800e51e:	2100      	movs	r1, #0
 800e520:	4855      	ldr	r0, [pc, #340]	; (800e678 <usbWriteS+0x1d4>)
 800e522:	f000 fa59 	bl	800e9d8 <CDC_Transmit_FS>
 800e526:	2801      	cmp	r0, #1
 800e528:	d1eb      	bne.n	800e502 <usbWriteS+0x5e>
            if(!hal.stream_blocking_callback())
 800e52a:	4b51      	ldr	r3, [pc, #324]	; (800e670 <usbWriteS+0x1cc>)
 800e52c:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800e530:	4798      	blx	r3
 800e532:	4603      	mov	r3, r0
 800e534:	2800      	cmp	r0, #0
 800e536:	d1f2      	bne.n	800e51e <usbWriteS+0x7a>
 800e538:	e7d9      	b.n	800e4ee <usbWriteS+0x4a>
    txbuf.s = txbuf.use_tx2data ? txbuf.data2 : txbuf.data;
 800e53a:	4a4e      	ldr	r2, [pc, #312]	; (800e674 <usbWriteS+0x1d0>)
 800e53c:	e7e9      	b.n	800e512 <usbWriteS+0x6e>
    txbuf.s = txbuf.use_tx2data ? txbuf.data2 : txbuf.data;
 800e53e:	4a4d      	ldr	r2, [pc, #308]	; (800e674 <usbWriteS+0x1d0>)
 800e540:	e027      	b.n	800e592 <usbWriteS+0xee>
    if(txbuf.length % 64 == 0) {
 800e542:	4b49      	ldr	r3, [pc, #292]	; (800e668 <usbWriteS+0x1c4>)
 800e544:	681b      	ldr	r3, [r3, #0]
 800e546:	f013 0f3f 	tst.w	r3, #63	; 0x3f
 800e54a:	d033      	beq.n	800e5b4 <usbWriteS+0x110>
    txbuf.use_tx2data = !txbuf.use_tx2data;
 800e54c:	4a46      	ldr	r2, [pc, #280]	; (800e668 <usbWriteS+0x1c4>)
 800e54e:	7b13      	ldrb	r3, [r2, #12]
 800e550:	f083 0301 	eor.w	r3, r3, #1
 800e554:	7313      	strb	r3, [r2, #12]
    txbuf.s = txbuf.use_tx2data ? txbuf.data2 : txbuf.data;
 800e556:	2b00      	cmp	r3, #0
 800e558:	d03a      	beq.n	800e5d0 <usbWriteS+0x12c>
 800e55a:	f202 120d 	addw	r2, r2, #269	; 0x10d
 800e55e:	4b42      	ldr	r3, [pc, #264]	; (800e668 <usbWriteS+0x1c4>)
 800e560:	609a      	str	r2, [r3, #8]
    txbuf.length = 0;
 800e562:	2200      	movs	r2, #0
 800e564:	601a      	str	r2, [r3, #0]
    return true;
 800e566:	2301      	movs	r3, #1
        if(!usb_write())
 800e568:	2b00      	cmp	r3, #0
 800e56a:	d034      	beq.n	800e5d6 <usbWriteS+0x132>
        length -= txbuf.max_length;
 800e56c:	4b3e      	ldr	r3, [pc, #248]	; (800e668 <usbWriteS+0x1c4>)
 800e56e:	685b      	ldr	r3, [r3, #4]
 800e570:	1aed      	subs	r5, r5, r3
        s += txbuf.max_length;
 800e572:	441c      	add	r4, r3
    while(length > txbuf.max_length) {
 800e574:	4b3c      	ldr	r3, [pc, #240]	; (800e668 <usbWriteS+0x1c4>)
 800e576:	685a      	ldr	r2, [r3, #4]
 800e578:	42aa      	cmp	r2, r5
 800e57a:	d22b      	bcs.n	800e5d4 <usbWriteS+0x130>
        txbuf.length = txbuf.max_length;
 800e57c:	4e3a      	ldr	r6, [pc, #232]	; (800e668 <usbWriteS+0x1c4>)
 800e57e:	6032      	str	r2, [r6, #0]
        memcpy(txbuf.s, s, txbuf.length);
 800e580:	4621      	mov	r1, r4
 800e582:	68b0      	ldr	r0, [r6, #8]
 800e584:	f014 fc54 	bl	8022e30 <memcpy>
    txbuf.s = txbuf.use_tx2data ? txbuf.data2 : txbuf.data;
 800e588:	7b33      	ldrb	r3, [r6, #12]
 800e58a:	2b00      	cmp	r3, #0
 800e58c:	d0d7      	beq.n	800e53e <usbWriteS+0x9a>
 800e58e:	f206 120d 	addw	r2, r6, #269	; 0x10d
 800e592:	4b35      	ldr	r3, [pc, #212]	; (800e668 <usbWriteS+0x1c4>)
 800e594:	609a      	str	r2, [r3, #8]
    while(CDC_Transmit_FS((uint8_t *)txbuf.s, txbuf.length) == USBD_BUSY) {
 800e596:	4b34      	ldr	r3, [pc, #208]	; (800e668 <usbWriteS+0x1c4>)
 800e598:	8819      	ldrh	r1, [r3, #0]
 800e59a:	6898      	ldr	r0, [r3, #8]
 800e59c:	f000 fa1c 	bl	800e9d8 <CDC_Transmit_FS>
 800e5a0:	2801      	cmp	r0, #1
 800e5a2:	d1ce      	bne.n	800e542 <usbWriteS+0x9e>
        if(!hal.stream_blocking_callback())
 800e5a4:	4b32      	ldr	r3, [pc, #200]	; (800e670 <usbWriteS+0x1cc>)
 800e5a6:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800e5aa:	4798      	blx	r3
 800e5ac:	4603      	mov	r3, r0
 800e5ae:	2800      	cmp	r0, #0
 800e5b0:	d1f1      	bne.n	800e596 <usbWriteS+0xf2>
 800e5b2:	e7d9      	b.n	800e568 <usbWriteS+0xc4>
        while(CDC_Transmit_FS(&dummy, 0) == USBD_BUSY) {
 800e5b4:	2100      	movs	r1, #0
 800e5b6:	4830      	ldr	r0, [pc, #192]	; (800e678 <usbWriteS+0x1d4>)
 800e5b8:	f000 fa0e 	bl	800e9d8 <CDC_Transmit_FS>
 800e5bc:	2801      	cmp	r0, #1
 800e5be:	d1c5      	bne.n	800e54c <usbWriteS+0xa8>
            if(!hal.stream_blocking_callback())
 800e5c0:	4b2b      	ldr	r3, [pc, #172]	; (800e670 <usbWriteS+0x1cc>)
 800e5c2:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800e5c6:	4798      	blx	r3
 800e5c8:	4603      	mov	r3, r0
 800e5ca:	2800      	cmp	r0, #0
 800e5cc:	d1f2      	bne.n	800e5b4 <usbWriteS+0x110>
 800e5ce:	e7cb      	b.n	800e568 <usbWriteS+0xc4>
    txbuf.s = txbuf.use_tx2data ? txbuf.data2 : txbuf.data;
 800e5d0:	4a28      	ldr	r2, [pc, #160]	; (800e674 <usbWriteS+0x1d0>)
 800e5d2:	e7c4      	b.n	800e55e <usbWriteS+0xba>
    if(length) {
 800e5d4:	b905      	cbnz	r5, 800e5d8 <usbWriteS+0x134>
}
 800e5d6:	bd70      	pop	{r4, r5, r6, pc}
        memcpy(txbuf.s, s, length);
 800e5d8:	461e      	mov	r6, r3
 800e5da:	462a      	mov	r2, r5
 800e5dc:	4621      	mov	r1, r4
 800e5de:	6898      	ldr	r0, [r3, #8]
 800e5e0:	f014 fc26 	bl	8022e30 <memcpy>
        txbuf.length += length;
 800e5e4:	6833      	ldr	r3, [r6, #0]
 800e5e6:	442b      	add	r3, r5
 800e5e8:	6033      	str	r3, [r6, #0]
        txbuf.s += length;
 800e5ea:	68b3      	ldr	r3, [r6, #8]
 800e5ec:	442b      	add	r3, r5
 800e5ee:	60b3      	str	r3, [r6, #8]
        if(s[length - 1] == ASCII_LF)
 800e5f0:	442c      	add	r4, r5
 800e5f2:	f814 3c01 	ldrb.w	r3, [r4, #-1]
 800e5f6:	2b0a      	cmp	r3, #10
 800e5f8:	d1ed      	bne.n	800e5d6 <usbWriteS+0x132>
    txbuf.s = txbuf.use_tx2data ? txbuf.data2 : txbuf.data;
 800e5fa:	7b33      	ldrb	r3, [r6, #12]
 800e5fc:	b18b      	cbz	r3, 800e622 <usbWriteS+0x17e>
 800e5fe:	f206 130d 	addw	r3, r6, #269	; 0x10d
 800e602:	4a19      	ldr	r2, [pc, #100]	; (800e668 <usbWriteS+0x1c4>)
 800e604:	6093      	str	r3, [r2, #8]
    while(CDC_Transmit_FS((uint8_t *)txbuf.s, txbuf.length) == USBD_BUSY) {
 800e606:	4b18      	ldr	r3, [pc, #96]	; (800e668 <usbWriteS+0x1c4>)
 800e608:	8819      	ldrh	r1, [r3, #0]
 800e60a:	6898      	ldr	r0, [r3, #8]
 800e60c:	f000 f9e4 	bl	800e9d8 <CDC_Transmit_FS>
 800e610:	2801      	cmp	r0, #1
 800e612:	d108      	bne.n	800e626 <usbWriteS+0x182>
        if(!hal.stream_blocking_callback())
 800e614:	4b16      	ldr	r3, [pc, #88]	; (800e670 <usbWriteS+0x1cc>)
 800e616:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800e61a:	4798      	blx	r3
 800e61c:	2800      	cmp	r0, #0
 800e61e:	d1f2      	bne.n	800e606 <usbWriteS+0x162>
 800e620:	e7d9      	b.n	800e5d6 <usbWriteS+0x132>
    txbuf.s = txbuf.use_tx2data ? txbuf.data2 : txbuf.data;
 800e622:	4b14      	ldr	r3, [pc, #80]	; (800e674 <usbWriteS+0x1d0>)
 800e624:	e7ed      	b.n	800e602 <usbWriteS+0x15e>
    if(txbuf.length % 64 == 0) {
 800e626:	4b10      	ldr	r3, [pc, #64]	; (800e668 <usbWriteS+0x1c4>)
 800e628:	681b      	ldr	r3, [r3, #0]
 800e62a:	f013 0f3f 	tst.w	r3, #63	; 0x3f
 800e62e:	d00c      	beq.n	800e64a <usbWriteS+0x1a6>
    txbuf.use_tx2data = !txbuf.use_tx2data;
 800e630:	4a0d      	ldr	r2, [pc, #52]	; (800e668 <usbWriteS+0x1c4>)
 800e632:	7b13      	ldrb	r3, [r2, #12]
 800e634:	f083 0301 	eor.w	r3, r3, #1
 800e638:	7313      	strb	r3, [r2, #12]
    txbuf.s = txbuf.use_tx2data ? txbuf.data2 : txbuf.data;
 800e63a:	b19b      	cbz	r3, 800e664 <usbWriteS+0x1c0>
 800e63c:	f202 120d 	addw	r2, r2, #269	; 0x10d
 800e640:	4b09      	ldr	r3, [pc, #36]	; (800e668 <usbWriteS+0x1c4>)
 800e642:	609a      	str	r2, [r3, #8]
    txbuf.length = 0;
 800e644:	2200      	movs	r2, #0
 800e646:	601a      	str	r2, [r3, #0]
    return true;
 800e648:	e7c5      	b.n	800e5d6 <usbWriteS+0x132>
        while(CDC_Transmit_FS(&dummy, 0) == USBD_BUSY) {
 800e64a:	2100      	movs	r1, #0
 800e64c:	480a      	ldr	r0, [pc, #40]	; (800e678 <usbWriteS+0x1d4>)
 800e64e:	f000 f9c3 	bl	800e9d8 <CDC_Transmit_FS>
 800e652:	2801      	cmp	r0, #1
 800e654:	d1ec      	bne.n	800e630 <usbWriteS+0x18c>
            if(!hal.stream_blocking_callback())
 800e656:	4b06      	ldr	r3, [pc, #24]	; (800e670 <usbWriteS+0x1cc>)
 800e658:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800e65c:	4798      	blx	r3
 800e65e:	2800      	cmp	r0, #0
 800e660:	d1f3      	bne.n	800e64a <usbWriteS+0x1a6>
 800e662:	e7b8      	b.n	800e5d6 <usbWriteS+0x132>
    txbuf.s = txbuf.use_tx2data ? txbuf.data2 : txbuf.data;
 800e664:	4a03      	ldr	r2, [pc, #12]	; (800e674 <usbWriteS+0x1d0>)
 800e666:	e7eb      	b.n	800e640 <usbWriteS+0x19c>
 800e668:	200017a8 	.word	0x200017a8
 800e66c:	200018b5 	.word	0x200018b5
 800e670:	2000350c 	.word	0x2000350c
 800e674:	200017b5 	.word	0x200017b5
 800e678:	20001399 	.word	0x20001399

0800e67c <usbWrite>:
    if(length == 0)
 800e67c:	2900      	cmp	r1, #0
 800e67e:	f000 80da 	beq.w	800e836 <usbWrite+0x1ba>
{
 800e682:	b570      	push	{r4, r5, r6, lr}
 800e684:	4605      	mov	r5, r0
 800e686:	460c      	mov	r4, r1
    if(txbuf.length && (txbuf.length + length) > txbuf.max_length) {
 800e688:	4b6b      	ldr	r3, [pc, #428]	; (800e838 <usbWrite+0x1bc>)
 800e68a:	681b      	ldr	r3, [r3, #0]
 800e68c:	2b00      	cmp	r3, #0
 800e68e:	d05c      	beq.n	800e74a <usbWrite+0xce>
 800e690:	440b      	add	r3, r1
 800e692:	4a69      	ldr	r2, [pc, #420]	; (800e838 <usbWrite+0x1bc>)
 800e694:	6852      	ldr	r2, [r2, #4]
 800e696:	4293      	cmp	r3, r2
 800e698:	d957      	bls.n	800e74a <usbWrite+0xce>
    txbuf.s = txbuf.use_tx2data ? txbuf.data2 : txbuf.data;
 800e69a:	4b67      	ldr	r3, [pc, #412]	; (800e838 <usbWrite+0x1bc>)
 800e69c:	7b1b      	ldrb	r3, [r3, #12]
 800e69e:	b19b      	cbz	r3, 800e6c8 <usbWrite+0x4c>
 800e6a0:	4a66      	ldr	r2, [pc, #408]	; (800e83c <usbWrite+0x1c0>)
 800e6a2:	4b65      	ldr	r3, [pc, #404]	; (800e838 <usbWrite+0x1bc>)
 800e6a4:	609a      	str	r2, [r3, #8]
    while(CDC_Transmit_FS((uint8_t *)txbuf.s, txbuf.length) == USBD_BUSY) {
 800e6a6:	4b64      	ldr	r3, [pc, #400]	; (800e838 <usbWrite+0x1bc>)
 800e6a8:	8819      	ldrh	r1, [r3, #0]
 800e6aa:	6898      	ldr	r0, [r3, #8]
 800e6ac:	f000 f994 	bl	800e9d8 <CDC_Transmit_FS>
 800e6b0:	2801      	cmp	r0, #1
 800e6b2:	d10b      	bne.n	800e6cc <usbWrite+0x50>
        if(!hal.stream_blocking_callback())
 800e6b4:	4b62      	ldr	r3, [pc, #392]	; (800e840 <usbWrite+0x1c4>)
 800e6b6:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800e6ba:	4798      	blx	r3
 800e6bc:	4603      	mov	r3, r0
 800e6be:	2800      	cmp	r0, #0
 800e6c0:	d1f1      	bne.n	800e6a6 <usbWrite+0x2a>
        if(!usb_write())
 800e6c2:	2b00      	cmp	r3, #0
 800e6c4:	d141      	bne.n	800e74a <usbWrite+0xce>
 800e6c6:	e072      	b.n	800e7ae <usbWrite+0x132>
    txbuf.s = txbuf.use_tx2data ? txbuf.data2 : txbuf.data;
 800e6c8:	4a5e      	ldr	r2, [pc, #376]	; (800e844 <usbWrite+0x1c8>)
 800e6ca:	e7ea      	b.n	800e6a2 <usbWrite+0x26>
    if(txbuf.length % 64 == 0) {
 800e6cc:	4b5a      	ldr	r3, [pc, #360]	; (800e838 <usbWrite+0x1bc>)
 800e6ce:	681b      	ldr	r3, [r3, #0]
 800e6d0:	f013 0f3f 	tst.w	r3, #63	; 0x3f
 800e6d4:	d00d      	beq.n	800e6f2 <usbWrite+0x76>
    txbuf.use_tx2data = !txbuf.use_tx2data;
 800e6d6:	4a58      	ldr	r2, [pc, #352]	; (800e838 <usbWrite+0x1bc>)
 800e6d8:	7b13      	ldrb	r3, [r2, #12]
 800e6da:	f083 0301 	eor.w	r3, r3, #1
 800e6de:	7313      	strb	r3, [r2, #12]
    txbuf.s = txbuf.use_tx2data ? txbuf.data2 : txbuf.data;
 800e6e0:	b1ab      	cbz	r3, 800e70e <usbWrite+0x92>
 800e6e2:	f202 120d 	addw	r2, r2, #269	; 0x10d
 800e6e6:	4b54      	ldr	r3, [pc, #336]	; (800e838 <usbWrite+0x1bc>)
 800e6e8:	609a      	str	r2, [r3, #8]
    txbuf.length = 0;
 800e6ea:	2200      	movs	r2, #0
 800e6ec:	601a      	str	r2, [r3, #0]
    return true;
 800e6ee:	2301      	movs	r3, #1
 800e6f0:	e7e7      	b.n	800e6c2 <usbWrite+0x46>
        while(CDC_Transmit_FS(&dummy, 0) == USBD_BUSY) {
 800e6f2:	2100      	movs	r1, #0
 800e6f4:	4854      	ldr	r0, [pc, #336]	; (800e848 <usbWrite+0x1cc>)
 800e6f6:	f000 f96f 	bl	800e9d8 <CDC_Transmit_FS>
 800e6fa:	2801      	cmp	r0, #1
 800e6fc:	d1eb      	bne.n	800e6d6 <usbWrite+0x5a>
            if(!hal.stream_blocking_callback())
 800e6fe:	4b50      	ldr	r3, [pc, #320]	; (800e840 <usbWrite+0x1c4>)
 800e700:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800e704:	4798      	blx	r3
 800e706:	4603      	mov	r3, r0
 800e708:	2800      	cmp	r0, #0
 800e70a:	d1f2      	bne.n	800e6f2 <usbWrite+0x76>
 800e70c:	e7d9      	b.n	800e6c2 <usbWrite+0x46>
    txbuf.s = txbuf.use_tx2data ? txbuf.data2 : txbuf.data;
 800e70e:	4a4d      	ldr	r2, [pc, #308]	; (800e844 <usbWrite+0x1c8>)
 800e710:	e7e9      	b.n	800e6e6 <usbWrite+0x6a>
    txbuf.s = txbuf.use_tx2data ? txbuf.data2 : txbuf.data;
 800e712:	4a4c      	ldr	r2, [pc, #304]	; (800e844 <usbWrite+0x1c8>)
 800e714:	e029      	b.n	800e76a <usbWrite+0xee>
    if(txbuf.length % 64 == 0) {
 800e716:	4b48      	ldr	r3, [pc, #288]	; (800e838 <usbWrite+0x1bc>)
 800e718:	681b      	ldr	r3, [r3, #0]
 800e71a:	f013 0f3f 	tst.w	r3, #63	; 0x3f
 800e71e:	d035      	beq.n	800e78c <usbWrite+0x110>
    txbuf.use_tx2data = !txbuf.use_tx2data;
 800e720:	4a45      	ldr	r2, [pc, #276]	; (800e838 <usbWrite+0x1bc>)
 800e722:	7b13      	ldrb	r3, [r2, #12]
 800e724:	f083 0301 	eor.w	r3, r3, #1
 800e728:	7313      	strb	r3, [r2, #12]
    txbuf.s = txbuf.use_tx2data ? txbuf.data2 : txbuf.data;
 800e72a:	2b00      	cmp	r3, #0
 800e72c:	d03c      	beq.n	800e7a8 <usbWrite+0x12c>
 800e72e:	f202 120d 	addw	r2, r2, #269	; 0x10d
 800e732:	4b41      	ldr	r3, [pc, #260]	; (800e838 <usbWrite+0x1bc>)
 800e734:	609a      	str	r2, [r3, #8]
    txbuf.length = 0;
 800e736:	2200      	movs	r2, #0
 800e738:	601a      	str	r2, [r3, #0]
    return true;
 800e73a:	2301      	movs	r3, #1
        if(!usb_write())
 800e73c:	2b00      	cmp	r3, #0
 800e73e:	d036      	beq.n	800e7ae <usbWrite+0x132>
        length -= txbuf.max_length;
 800e740:	4b3d      	ldr	r3, [pc, #244]	; (800e838 <usbWrite+0x1bc>)
 800e742:	685b      	ldr	r3, [r3, #4]
 800e744:	1ae4      	subs	r4, r4, r3
 800e746:	b2a4      	uxth	r4, r4
        s += txbuf.max_length;
 800e748:	441d      	add	r5, r3
    while(length > txbuf.max_length) {
 800e74a:	4626      	mov	r6, r4
 800e74c:	4b3a      	ldr	r3, [pc, #232]	; (800e838 <usbWrite+0x1bc>)
 800e74e:	685a      	ldr	r2, [r3, #4]
 800e750:	4294      	cmp	r4, r2
 800e752:	d92b      	bls.n	800e7ac <usbWrite+0x130>
        txbuf.length = txbuf.max_length;
 800e754:	4e38      	ldr	r6, [pc, #224]	; (800e838 <usbWrite+0x1bc>)
 800e756:	6032      	str	r2, [r6, #0]
        memcpy(txbuf.s, s, txbuf.length);
 800e758:	4629      	mov	r1, r5
 800e75a:	68b0      	ldr	r0, [r6, #8]
 800e75c:	f014 fb68 	bl	8022e30 <memcpy>
    txbuf.s = txbuf.use_tx2data ? txbuf.data2 : txbuf.data;
 800e760:	7b33      	ldrb	r3, [r6, #12]
 800e762:	2b00      	cmp	r3, #0
 800e764:	d0d5      	beq.n	800e712 <usbWrite+0x96>
 800e766:	f206 120d 	addw	r2, r6, #269	; 0x10d
 800e76a:	4b33      	ldr	r3, [pc, #204]	; (800e838 <usbWrite+0x1bc>)
 800e76c:	609a      	str	r2, [r3, #8]
    while(CDC_Transmit_FS((uint8_t *)txbuf.s, txbuf.length) == USBD_BUSY) {
 800e76e:	4b32      	ldr	r3, [pc, #200]	; (800e838 <usbWrite+0x1bc>)
 800e770:	8819      	ldrh	r1, [r3, #0]
 800e772:	6898      	ldr	r0, [r3, #8]
 800e774:	f000 f930 	bl	800e9d8 <CDC_Transmit_FS>
 800e778:	2801      	cmp	r0, #1
 800e77a:	d1cc      	bne.n	800e716 <usbWrite+0x9a>
        if(!hal.stream_blocking_callback())
 800e77c:	4b30      	ldr	r3, [pc, #192]	; (800e840 <usbWrite+0x1c4>)
 800e77e:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800e782:	4798      	blx	r3
 800e784:	4603      	mov	r3, r0
 800e786:	2800      	cmp	r0, #0
 800e788:	d1f1      	bne.n	800e76e <usbWrite+0xf2>
 800e78a:	e7d7      	b.n	800e73c <usbWrite+0xc0>
        while(CDC_Transmit_FS(&dummy, 0) == USBD_BUSY) {
 800e78c:	2100      	movs	r1, #0
 800e78e:	482e      	ldr	r0, [pc, #184]	; (800e848 <usbWrite+0x1cc>)
 800e790:	f000 f922 	bl	800e9d8 <CDC_Transmit_FS>
 800e794:	2801      	cmp	r0, #1
 800e796:	d1c3      	bne.n	800e720 <usbWrite+0xa4>
            if(!hal.stream_blocking_callback())
 800e798:	4b29      	ldr	r3, [pc, #164]	; (800e840 <usbWrite+0x1c4>)
 800e79a:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800e79e:	4798      	blx	r3
 800e7a0:	4603      	mov	r3, r0
 800e7a2:	2800      	cmp	r0, #0
 800e7a4:	d1f2      	bne.n	800e78c <usbWrite+0x110>
 800e7a6:	e7c9      	b.n	800e73c <usbWrite+0xc0>
    txbuf.s = txbuf.use_tx2data ? txbuf.data2 : txbuf.data;
 800e7a8:	4a26      	ldr	r2, [pc, #152]	; (800e844 <usbWrite+0x1c8>)
 800e7aa:	e7c2      	b.n	800e732 <usbWrite+0xb6>
    if(length) {
 800e7ac:	b904      	cbnz	r4, 800e7b0 <usbWrite+0x134>
}
 800e7ae:	bd70      	pop	{r4, r5, r6, pc}
        memcpy(txbuf.s, s, length);
 800e7b0:	461c      	mov	r4, r3
 800e7b2:	4632      	mov	r2, r6
 800e7b4:	4629      	mov	r1, r5
 800e7b6:	6898      	ldr	r0, [r3, #8]
 800e7b8:	f014 fb3a 	bl	8022e30 <memcpy>
        txbuf.length += length;
 800e7bc:	6823      	ldr	r3, [r4, #0]
 800e7be:	4433      	add	r3, r6
 800e7c0:	6023      	str	r3, [r4, #0]
        txbuf.s += length;
 800e7c2:	68a3      	ldr	r3, [r4, #8]
 800e7c4:	4433      	add	r3, r6
 800e7c6:	60a3      	str	r3, [r4, #8]
    txbuf.s = txbuf.use_tx2data ? txbuf.data2 : txbuf.data;
 800e7c8:	7b23      	ldrb	r3, [r4, #12]
 800e7ca:	b18b      	cbz	r3, 800e7f0 <usbWrite+0x174>
 800e7cc:	f204 120d 	addw	r2, r4, #269	; 0x10d
 800e7d0:	4b19      	ldr	r3, [pc, #100]	; (800e838 <usbWrite+0x1bc>)
 800e7d2:	609a      	str	r2, [r3, #8]
    while(CDC_Transmit_FS((uint8_t *)txbuf.s, txbuf.length) == USBD_BUSY) {
 800e7d4:	4b18      	ldr	r3, [pc, #96]	; (800e838 <usbWrite+0x1bc>)
 800e7d6:	8819      	ldrh	r1, [r3, #0]
 800e7d8:	6898      	ldr	r0, [r3, #8]
 800e7da:	f000 f8fd 	bl	800e9d8 <CDC_Transmit_FS>
 800e7de:	2801      	cmp	r0, #1
 800e7e0:	d108      	bne.n	800e7f4 <usbWrite+0x178>
        if(!hal.stream_blocking_callback())
 800e7e2:	4b17      	ldr	r3, [pc, #92]	; (800e840 <usbWrite+0x1c4>)
 800e7e4:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800e7e8:	4798      	blx	r3
 800e7ea:	2800      	cmp	r0, #0
 800e7ec:	d1f2      	bne.n	800e7d4 <usbWrite+0x158>
 800e7ee:	e7de      	b.n	800e7ae <usbWrite+0x132>
    txbuf.s = txbuf.use_tx2data ? txbuf.data2 : txbuf.data;
 800e7f0:	4a14      	ldr	r2, [pc, #80]	; (800e844 <usbWrite+0x1c8>)
 800e7f2:	e7ed      	b.n	800e7d0 <usbWrite+0x154>
    if(txbuf.length % 64 == 0) {
 800e7f4:	4b10      	ldr	r3, [pc, #64]	; (800e838 <usbWrite+0x1bc>)
 800e7f6:	681b      	ldr	r3, [r3, #0]
 800e7f8:	f013 0f3f 	tst.w	r3, #63	; 0x3f
 800e7fc:	d00c      	beq.n	800e818 <usbWrite+0x19c>
    txbuf.use_tx2data = !txbuf.use_tx2data;
 800e7fe:	4a0e      	ldr	r2, [pc, #56]	; (800e838 <usbWrite+0x1bc>)
 800e800:	7b13      	ldrb	r3, [r2, #12]
 800e802:	f083 0301 	eor.w	r3, r3, #1
 800e806:	7313      	strb	r3, [r2, #12]
    txbuf.s = txbuf.use_tx2data ? txbuf.data2 : txbuf.data;
 800e808:	b19b      	cbz	r3, 800e832 <usbWrite+0x1b6>
 800e80a:	f202 120d 	addw	r2, r2, #269	; 0x10d
 800e80e:	4b0a      	ldr	r3, [pc, #40]	; (800e838 <usbWrite+0x1bc>)
 800e810:	609a      	str	r2, [r3, #8]
    txbuf.length = 0;
 800e812:	2200      	movs	r2, #0
 800e814:	601a      	str	r2, [r3, #0]
    return true;
 800e816:	e7ca      	b.n	800e7ae <usbWrite+0x132>
        while(CDC_Transmit_FS(&dummy, 0) == USBD_BUSY) {
 800e818:	2100      	movs	r1, #0
 800e81a:	480b      	ldr	r0, [pc, #44]	; (800e848 <usbWrite+0x1cc>)
 800e81c:	f000 f8dc 	bl	800e9d8 <CDC_Transmit_FS>
 800e820:	2801      	cmp	r0, #1
 800e822:	d1ec      	bne.n	800e7fe <usbWrite+0x182>
            if(!hal.stream_blocking_callback())
 800e824:	4b06      	ldr	r3, [pc, #24]	; (800e840 <usbWrite+0x1c4>)
 800e826:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800e82a:	4798      	blx	r3
 800e82c:	2800      	cmp	r0, #0
 800e82e:	d1f3      	bne.n	800e818 <usbWrite+0x19c>
 800e830:	e7bd      	b.n	800e7ae <usbWrite+0x132>
    txbuf.s = txbuf.use_tx2data ? txbuf.data2 : txbuf.data;
 800e832:	4a04      	ldr	r2, [pc, #16]	; (800e844 <usbWrite+0x1c8>)
 800e834:	e7eb      	b.n	800e80e <usbWrite+0x192>
 800e836:	4770      	bx	lr
 800e838:	200017a8 	.word	0x200017a8
 800e83c:	200018b5 	.word	0x200018b5
 800e840:	2000350c 	.word	0x2000350c
 800e844:	200017b5 	.word	0x200017b5
 800e848:	20001399 	.word	0x20001399

0800e84c <usbInit>:

// NOTE: USB interrupt priority should be set lower than stepper/step timer to avoid jitter
// It is set in HAL_PCD_MspInit() in usbd_conf.c
const io_stream_t *usbInit (void)
{
 800e84c:	b508      	push	{r3, lr}
        .cancel_read_buffer = usbRxCancel,
        .suspend_read = usbSuspendInput,
        .set_enqueue_rt_handler = usbSetRtHandler
    };

    MX_USB_DEVICE_Init();
 800e84e:	f000 f85b 	bl	800e908 <MX_USB_DEVICE_Init>

    txbuf.s = txbuf.data;
 800e852:	4b04      	ldr	r3, [pc, #16]	; (800e864 <usbInit+0x18>)
 800e854:	f103 020d 	add.w	r2, r3, #13
 800e858:	609a      	str	r2, [r3, #8]
    txbuf.max_length = BLOCK_TX_BUFFER_SIZE;
 800e85a:	f44f 7280 	mov.w	r2, #256	; 0x100
 800e85e:	605a      	str	r2, [r3, #4]

    return &stream;
}
 800e860:	4801      	ldr	r0, [pc, #4]	; (800e868 <usbInit+0x1c>)
 800e862:	bd08      	pop	{r3, pc}
 800e864:	200017a8 	.word	0x200017a8
 800e868:	0802559c 	.word	0x0802559c

0800e86c <usbBufferInput>:

// NOTE: add a call to this function as the first line CDC_Receive_FS() in usbd_cdc_if.c
void usbBufferInput (uint8_t *data, uint32_t length)
{
 800e86c:	b538      	push	{r3, r4, r5, lr}
 800e86e:	4604      	mov	r4, r0
    while(length--) {
 800e870:	e004      	b.n	800e87c <usbBufferInput+0x10>
        if(!enqueue_realtime_command(*data)) {                  // Check and strip realtime commands,
            uint16_t next_head = BUFNEXT(rxbuf.head, rxbuf);    // Get and increment buffer pointer
            if(next_head == rxbuf.tail)                         // If buffer full
                rxbuf.overflow = 1;                             // flag overflow
 800e872:	4b0e      	ldr	r3, [pc, #56]	; (800e8ac <usbBufferInput+0x40>)
 800e874:	2201      	movs	r2, #1
 800e876:	725a      	strb	r2, [r3, #9]
            else {
                rxbuf.data[rxbuf.head] = *data;                 // if not add data to buffer
                rxbuf.head = next_head;                         // and update pointer
            }
        }
        data++;                                                 // next...
 800e878:	3401      	adds	r4, #1
    while(length--) {
 800e87a:	4629      	mov	r1, r5
 800e87c:	1e4d      	subs	r5, r1, #1
 800e87e:	b1a1      	cbz	r1, 800e8aa <usbBufferInput+0x3e>
        if(!enqueue_realtime_command(*data)) {                  // Check and strip realtime commands,
 800e880:	4b0b      	ldr	r3, [pc, #44]	; (800e8b0 <usbBufferInput+0x44>)
 800e882:	681b      	ldr	r3, [r3, #0]
 800e884:	7820      	ldrb	r0, [r4, #0]
 800e886:	4798      	blx	r3
 800e888:	2800      	cmp	r0, #0
 800e88a:	d1f5      	bne.n	800e878 <usbBufferInput+0xc>
            uint16_t next_head = BUFNEXT(rxbuf.head, rxbuf);    // Get and increment buffer pointer
 800e88c:	4a07      	ldr	r2, [pc, #28]	; (800e8ac <usbBufferInput+0x40>)
 800e88e:	6813      	ldr	r3, [r2, #0]
 800e890:	3301      	adds	r3, #1
 800e892:	f3c3 0309 	ubfx	r3, r3, #0, #10
            if(next_head == rxbuf.tail)                         // If buffer full
 800e896:	6852      	ldr	r2, [r2, #4]
 800e898:	4293      	cmp	r3, r2
 800e89a:	d0ea      	beq.n	800e872 <usbBufferInput+0x6>
                rxbuf.data[rxbuf.head] = *data;                 // if not add data to buffer
 800e89c:	4a03      	ldr	r2, [pc, #12]	; (800e8ac <usbBufferInput+0x40>)
 800e89e:	6811      	ldr	r1, [r2, #0]
 800e8a0:	7820      	ldrb	r0, [r4, #0]
 800e8a2:	4411      	add	r1, r2
 800e8a4:	72c8      	strb	r0, [r1, #11]
                rxbuf.head = next_head;                         // and update pointer
 800e8a6:	6013      	str	r3, [r2, #0]
 800e8a8:	e7e6      	b.n	800e878 <usbBufferInput+0xc>
    }
}
 800e8aa:	bd38      	pop	{r3, r4, r5, pc}
 800e8ac:	2000139c 	.word	0x2000139c
 800e8b0:	20000368 	.word	0x20000368

0800e8b4 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 800e8b4:	f8df d034 	ldr.w	sp, [pc, #52]	; 800e8ec <LoopFillZerobss+0x12>

/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
 800e8b8:	480d      	ldr	r0, [pc, #52]	; (800e8f0 <LoopFillZerobss+0x16>)
  ldr r1, =_edata
 800e8ba:	490e      	ldr	r1, [pc, #56]	; (800e8f4 <LoopFillZerobss+0x1a>)
  ldr r2, =_sidata
 800e8bc:	4a0e      	ldr	r2, [pc, #56]	; (800e8f8 <LoopFillZerobss+0x1e>)
  movs r3, #0
 800e8be:	2300      	movs	r3, #0
  b LoopCopyDataInit
 800e8c0:	e002      	b.n	800e8c8 <LoopCopyDataInit>

0800e8c2 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 800e8c2:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 800e8c4:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 800e8c6:	3304      	adds	r3, #4

0800e8c8 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 800e8c8:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800e8ca:	428c      	cmp	r4, r1
  bcc CopyDataInit
 800e8cc:	d3f9      	bcc.n	800e8c2 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800e8ce:	4a0b      	ldr	r2, [pc, #44]	; (800e8fc <LoopFillZerobss+0x22>)
  ldr r4, =_ebss
 800e8d0:	4c0b      	ldr	r4, [pc, #44]	; (800e900 <LoopFillZerobss+0x26>)
  movs r3, #0
 800e8d2:	2300      	movs	r3, #0
  b LoopFillZerobss
 800e8d4:	e001      	b.n	800e8da <LoopFillZerobss>

0800e8d6 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 800e8d6:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800e8d8:	3204      	adds	r2, #4

0800e8da <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800e8da:	42a2      	cmp	r2, r4
  bcc FillZerobss
 800e8dc:	d3fb      	bcc.n	800e8d6 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 800e8de:	f7ff fd4d 	bl	800e37c <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800e8e2:	f014 fa77 	bl	8022dd4 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800e8e6:	f7ff f867 	bl	800d9b8 <main>
  bx  lr    
 800e8ea:	4770      	bx	lr
  ldr   sp, =_estack     /* set stack pointer */
 800e8ec:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 800e8f0:	20000000 	.word	0x20000000
  ldr r1, =_edata
 800e8f4:	20000630 	.word	0x20000630
  ldr r2, =_sidata
 800e8f8:	0802d668 	.word	0x0802d668
  ldr r2, =_sbss
 800e8fc:	20000630 	.word	0x20000630
  ldr r4, =_ebss
 800e900:	200049b0 	.word	0x200049b0

0800e904 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 800e904:	e7fe      	b.n	800e904 <ADC_IRQHandler>
	...

0800e908 <MX_USB_DEVICE_Init>:
/**
  * Init USB device Library, add supported class and start the library
  * @retval None
  */
void MX_USB_DEVICE_Init(void)
{
 800e908:	b508      	push	{r3, lr}
  /* USER CODE BEGIN USB_DEVICE_Init_PreTreatment */

  /* USER CODE END USB_DEVICE_Init_PreTreatment */

  /* Init Device Library, add supported class and start the library. */
  if (USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS) != USBD_OK)
 800e90a:	2200      	movs	r2, #0
 800e90c:	490f      	ldr	r1, [pc, #60]	; (800e94c <MX_USB_DEVICE_Init+0x44>)
 800e90e:	4810      	ldr	r0, [pc, #64]	; (800e950 <MX_USB_DEVICE_Init+0x48>)
 800e910:	f7fc fe60 	bl	800b5d4 <USBD_Init>
 800e914:	b970      	cbnz	r0, 800e934 <MX_USB_DEVICE_Init+0x2c>
  {
    Error_Handler();
  }
  if (USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC) != USBD_OK)
 800e916:	490f      	ldr	r1, [pc, #60]	; (800e954 <MX_USB_DEVICE_Init+0x4c>)
 800e918:	480d      	ldr	r0, [pc, #52]	; (800e950 <MX_USB_DEVICE_Init+0x48>)
 800e91a:	f7fc fe77 	bl	800b60c <USBD_RegisterClass>
 800e91e:	b960      	cbnz	r0, 800e93a <MX_USB_DEVICE_Init+0x32>
  {
    Error_Handler();
  }
  if (USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS) != USBD_OK)
 800e920:	490d      	ldr	r1, [pc, #52]	; (800e958 <MX_USB_DEVICE_Init+0x50>)
 800e922:	480b      	ldr	r0, [pc, #44]	; (800e950 <MX_USB_DEVICE_Init+0x48>)
 800e924:	f7fc fe0e 	bl	800b544 <USBD_CDC_RegisterInterface>
 800e928:	b950      	cbnz	r0, 800e940 <MX_USB_DEVICE_Init+0x38>
  {
    Error_Handler();
  }
  if (USBD_Start(&hUsbDeviceFS) != USBD_OK)
 800e92a:	4809      	ldr	r0, [pc, #36]	; (800e950 <MX_USB_DEVICE_Init+0x48>)
 800e92c:	f7fc fe82 	bl	800b634 <USBD_Start>
 800e930:	b948      	cbnz	r0, 800e946 <MX_USB_DEVICE_Init+0x3e>
  }

  /* USER CODE BEGIN USB_DEVICE_Init_PostTreatment */

  /* USER CODE END USB_DEVICE_Init_PostTreatment */
}
 800e932:	bd08      	pop	{r3, pc}
    Error_Handler();
 800e934:	f7ff f84a 	bl	800d9cc <Error_Handler>
 800e938:	e7ed      	b.n	800e916 <MX_USB_DEVICE_Init+0xe>
    Error_Handler();
 800e93a:	f7ff f847 	bl	800d9cc <Error_Handler>
 800e93e:	e7ef      	b.n	800e920 <MX_USB_DEVICE_Init+0x18>
    Error_Handler();
 800e940:	f7ff f844 	bl	800d9cc <Error_Handler>
 800e944:	e7f1      	b.n	800e92a <MX_USB_DEVICE_Init+0x22>
    Error_Handler();
 800e946:	f7ff f841 	bl	800d9cc <Error_Handler>
}
 800e94a:	e7f2      	b.n	800e932 <MX_USB_DEVICE_Init+0x2a>
 800e94c:	20000380 	.word	0x20000380
 800e950:	200019c0 	.word	0x200019c0
 800e954:	20000008 	.word	0x20000008
 800e958:	2000036c 	.word	0x2000036c

0800e95c <CDC_DeInit_FS>:
static int8_t CDC_DeInit_FS(void)
{
  /* USER CODE BEGIN 4 */
  return (USBD_OK);
  /* USER CODE END 4 */
}
 800e95c:	2000      	movs	r0, #0
 800e95e:	4770      	bx	lr

0800e960 <CDC_Control_FS>:
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Control_FS(uint8_t cmd, uint8_t* pbuf, uint16_t length)
{
  /* USER CODE BEGIN 5 */
  switch(cmd)
 800e960:	2822      	cmp	r0, #34	; 0x22
 800e962:	d001      	beq.n	800e968 <CDC_Control_FS+0x8>
    break;
  }

  return (USBD_OK);
  /* USER CODE END 5 */
}
 800e964:	2000      	movs	r0, #0
 800e966:	4770      	bx	lr
{
 800e968:	b510      	push	{r4, lr}
        usb_linestate.pin.value = pbuf[2];
 800e96a:	788b      	ldrb	r3, [r1, #2]
 800e96c:	4c04      	ldr	r4, [pc, #16]	; (800e980 <CDC_Control_FS+0x20>)
 800e96e:	7023      	strb	r3, [r4, #0]
        usb_linestate.timestamp = hal.get_elapsed_ticks();
 800e970:	4b04      	ldr	r3, [pc, #16]	; (800e984 <CDC_Control_FS+0x24>)
 800e972:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 800e976:	4798      	blx	r3
 800e978:	6060      	str	r0, [r4, #4]
}
 800e97a:	2000      	movs	r0, #0
 800e97c:	bd10      	pop	{r4, pc}
 800e97e:	bf00      	nop
 800e980:	200019b8 	.word	0x200019b8
 800e984:	2000350c 	.word	0x2000350c

0800e988 <CDC_TransmitCplt_FS>:
  UNUSED(Buf);
  UNUSED(Len);
  UNUSED(epnum);
  /* USER CODE END 13 */
  return result;
}
 800e988:	2000      	movs	r0, #0
 800e98a:	4770      	bx	lr

0800e98c <CDC_Receive_FS>:
{
 800e98c:	b538      	push	{r3, r4, r5, lr}
 800e98e:	4604      	mov	r4, r0
  usbBufferInput(Buf, *Len);
 800e990:	6809      	ldr	r1, [r1, #0]
 800e992:	f7ff ff6b 	bl	800e86c <usbBufferInput>
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);
 800e996:	4d05      	ldr	r5, [pc, #20]	; (800e9ac <CDC_Receive_FS+0x20>)
 800e998:	4621      	mov	r1, r4
 800e99a:	4628      	mov	r0, r5
 800e99c:	f7fc fde1 	bl	800b562 <USBD_CDC_SetRxBuffer>
  USBD_CDC_ReceivePacket(&hUsbDeviceFS);
 800e9a0:	4628      	mov	r0, r5
 800e9a2:	f7fc fdfe 	bl	800b5a2 <USBD_CDC_ReceivePacket>
}
 800e9a6:	2000      	movs	r0, #0
 800e9a8:	bd38      	pop	{r3, r4, r5, pc}
 800e9aa:	bf00      	nop
 800e9ac:	200019c0 	.word	0x200019c0

0800e9b0 <CDC_Init_FS>:
{
 800e9b0:	b510      	push	{r4, lr}
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, UserTxBufferFS, 0);
 800e9b2:	4c06      	ldr	r4, [pc, #24]	; (800e9cc <CDC_Init_FS+0x1c>)
 800e9b4:	2200      	movs	r2, #0
 800e9b6:	4906      	ldr	r1, [pc, #24]	; (800e9d0 <CDC_Init_FS+0x20>)
 800e9b8:	4620      	mov	r0, r4
 800e9ba:	f7fc fdca 	bl	800b552 <USBD_CDC_SetTxBuffer>
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, UserRxBufferFS);
 800e9be:	4905      	ldr	r1, [pc, #20]	; (800e9d4 <CDC_Init_FS+0x24>)
 800e9c0:	4620      	mov	r0, r4
 800e9c2:	f7fc fdce 	bl	800b562 <USBD_CDC_SetRxBuffer>
}
 800e9c6:	2000      	movs	r0, #0
 800e9c8:	bd10      	pop	{r4, pc}
 800e9ca:	bf00      	nop
 800e9cc:	200019c0 	.word	0x200019c0
 800e9d0:	20002490 	.word	0x20002490
 800e9d4:	20001c90 	.word	0x20001c90

0800e9d8 <CDC_Transmit_FS>:
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;
 800e9d8:	4b09      	ldr	r3, [pc, #36]	; (800ea00 <CDC_Transmit_FS+0x28>)
 800e9da:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
  if (hcdc->TxState != 0){
 800e9de:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 800e9e2:	b10b      	cbz	r3, 800e9e8 <CDC_Transmit_FS+0x10>
    return USBD_BUSY;
 800e9e4:	2001      	movs	r0, #1
}
 800e9e6:	4770      	bx	lr
{
 800e9e8:	b510      	push	{r4, lr}
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, Buf, Len);
 800e9ea:	4c05      	ldr	r4, [pc, #20]	; (800ea00 <CDC_Transmit_FS+0x28>)
 800e9ec:	460a      	mov	r2, r1
 800e9ee:	4601      	mov	r1, r0
 800e9f0:	4620      	mov	r0, r4
 800e9f2:	f7fc fdae 	bl	800b552 <USBD_CDC_SetTxBuffer>
  result = USBD_CDC_TransmitPacket(&hUsbDeviceFS);
 800e9f6:	4620      	mov	r0, r4
 800e9f8:	f7fc fdb9 	bl	800b56e <USBD_CDC_TransmitPacket>
}
 800e9fc:	bd10      	pop	{r4, pc}
 800e9fe:	bf00      	nop
 800ea00:	200019c0 	.word	0x200019c0

0800ea04 <USBD_FS_DeviceDescriptor>:
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  UNUSED(speed);
  *length = sizeof(USBD_FS_DeviceDesc);
 800ea04:	2312      	movs	r3, #18
 800ea06:	800b      	strh	r3, [r1, #0]
  return USBD_FS_DeviceDesc;
}
 800ea08:	4800      	ldr	r0, [pc, #0]	; (800ea0c <USBD_FS_DeviceDescriptor+0x8>)
 800ea0a:	4770      	bx	lr
 800ea0c:	2000039c 	.word	0x2000039c

0800ea10 <USBD_FS_LangIDStrDescriptor>:
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  UNUSED(speed);
  *length = sizeof(USBD_LangIDDesc);
 800ea10:	2304      	movs	r3, #4
 800ea12:	800b      	strh	r3, [r1, #0]
  return USBD_LangIDDesc;
}
 800ea14:	4800      	ldr	r0, [pc, #0]	; (800ea18 <USBD_FS_LangIDStrDescriptor+0x8>)
 800ea16:	4770      	bx	lr
 800ea18:	200003b0 	.word	0x200003b0

0800ea1c <IntToUnicode>:
  */
static void IntToUnicode(uint32_t value, uint8_t * pbuf, uint8_t len)
{
  uint8_t idx = 0;

  for (idx = 0; idx < len; idx++)
 800ea1c:	2300      	movs	r3, #0
 800ea1e:	4293      	cmp	r3, r2
 800ea20:	d21e      	bcs.n	800ea60 <IntToUnicode+0x44>
{
 800ea22:	b500      	push	{lr}
 800ea24:	e010      	b.n	800ea48 <IntToUnicode+0x2c>
    {
      pbuf[2 * idx] = (value >> 28) + '0';
    }
    else
    {
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 800ea26:	f10c 0c37 	add.w	ip, ip, #55	; 0x37
 800ea2a:	f801 c013 	strb.w	ip, [r1, r3, lsl #1]
    }

    value = value << 4;
 800ea2e:	0100      	lsls	r0, r0, #4

    pbuf[2 * idx + 1] = 0;
 800ea30:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800ea34:	f10c 0c01 	add.w	ip, ip, #1
 800ea38:	f04f 0e00 	mov.w	lr, #0
 800ea3c:	f801 e00c 	strb.w	lr, [r1, ip]
  for (idx = 0; idx < len; idx++)
 800ea40:	3301      	adds	r3, #1
 800ea42:	b2db      	uxtb	r3, r3
 800ea44:	4293      	cmp	r3, r2
 800ea46:	d209      	bcs.n	800ea5c <IntToUnicode+0x40>
    if (((value >> 28)) < 0xA)
 800ea48:	ea4f 7c10 	mov.w	ip, r0, lsr #28
 800ea4c:	f1b0 4f20 	cmp.w	r0, #2684354560	; 0xa0000000
 800ea50:	d2e9      	bcs.n	800ea26 <IntToUnicode+0xa>
      pbuf[2 * idx] = (value >> 28) + '0';
 800ea52:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 800ea56:	f801 c013 	strb.w	ip, [r1, r3, lsl #1]
 800ea5a:	e7e8      	b.n	800ea2e <IntToUnicode+0x12>
  }
}
 800ea5c:	f85d fb04 	ldr.w	pc, [sp], #4
 800ea60:	4770      	bx	lr
	...

0800ea64 <Get_SerialNum>:
{
 800ea64:	b538      	push	{r3, r4, r5, lr}
  deviceserial0 = *(uint32_t *) DEVICE_ID1;
 800ea66:	4b0b      	ldr	r3, [pc, #44]	; (800ea94 <Get_SerialNum+0x30>)
 800ea68:	f8d3 0a10 	ldr.w	r0, [r3, #2576]	; 0xa10
  deviceserial1 = *(uint32_t *) DEVICE_ID2;
 800ea6c:	f8d3 4a14 	ldr.w	r4, [r3, #2580]	; 0xa14
  deviceserial2 = *(uint32_t *) DEVICE_ID3;
 800ea70:	f8d3 3a18 	ldr.w	r3, [r3, #2584]	; 0xa18
  if (deviceserial0 != 0)
 800ea74:	18c0      	adds	r0, r0, r3
 800ea76:	d100      	bne.n	800ea7a <Get_SerialNum+0x16>
}
 800ea78:	bd38      	pop	{r3, r4, r5, pc}
    IntToUnicode(deviceserial0, &USBD_StringSerial[2], 8);
 800ea7a:	4d07      	ldr	r5, [pc, #28]	; (800ea98 <Get_SerialNum+0x34>)
 800ea7c:	2208      	movs	r2, #8
 800ea7e:	1ca9      	adds	r1, r5, #2
 800ea80:	f7ff ffcc 	bl	800ea1c <IntToUnicode>
    IntToUnicode(deviceserial1, &USBD_StringSerial[18], 4);
 800ea84:	2204      	movs	r2, #4
 800ea86:	f105 0112 	add.w	r1, r5, #18
 800ea8a:	4620      	mov	r0, r4
 800ea8c:	f7ff ffc6 	bl	800ea1c <IntToUnicode>
}
 800ea90:	e7f2      	b.n	800ea78 <Get_SerialNum+0x14>
 800ea92:	bf00      	nop
 800ea94:	1fff7000 	.word	0x1fff7000
 800ea98:	200003b4 	.word	0x200003b4

0800ea9c <USBD_FS_SerialStrDescriptor>:
{
 800ea9c:	b508      	push	{r3, lr}
  *length = USB_SIZ_STRING_SERIAL;
 800ea9e:	231a      	movs	r3, #26
 800eaa0:	800b      	strh	r3, [r1, #0]
  Get_SerialNum();
 800eaa2:	f7ff ffdf 	bl	800ea64 <Get_SerialNum>
}
 800eaa6:	4801      	ldr	r0, [pc, #4]	; (800eaac <USBD_FS_SerialStrDescriptor+0x10>)
 800eaa8:	bd08      	pop	{r3, pc}
 800eaaa:	bf00      	nop
 800eaac:	200003b4 	.word	0x200003b4

0800eab0 <USBD_FS_ProductStrDescriptor>:
{
 800eab0:	b508      	push	{r3, lr}
 800eab2:	460a      	mov	r2, r1
  if(speed == 0)
 800eab4:	b928      	cbnz	r0, 800eac2 <USBD_FS_ProductStrDescriptor+0x12>
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 800eab6:	4905      	ldr	r1, [pc, #20]	; (800eacc <USBD_FS_ProductStrDescriptor+0x1c>)
 800eab8:	4805      	ldr	r0, [pc, #20]	; (800ead0 <USBD_FS_ProductStrDescriptor+0x20>)
 800eaba:	f7fd fa1d 	bl	800bef8 <USBD_GetString>
}
 800eabe:	4803      	ldr	r0, [pc, #12]	; (800eacc <USBD_FS_ProductStrDescriptor+0x1c>)
 800eac0:	bd08      	pop	{r3, pc}
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 800eac2:	4902      	ldr	r1, [pc, #8]	; (800eacc <USBD_FS_ProductStrDescriptor+0x1c>)
 800eac4:	4802      	ldr	r0, [pc, #8]	; (800ead0 <USBD_FS_ProductStrDescriptor+0x20>)
 800eac6:	f7fd fa17 	bl	800bef8 <USBD_GetString>
 800eaca:	e7f8      	b.n	800eabe <USBD_FS_ProductStrDescriptor+0xe>
 800eacc:	20002c90 	.word	0x20002c90
 800ead0:	080255e8 	.word	0x080255e8

0800ead4 <USBD_FS_ManufacturerStrDescriptor>:
{
 800ead4:	b510      	push	{r4, lr}
 800ead6:	460a      	mov	r2, r1
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 800ead8:	4c03      	ldr	r4, [pc, #12]	; (800eae8 <USBD_FS_ManufacturerStrDescriptor+0x14>)
 800eada:	4621      	mov	r1, r4
 800eadc:	4803      	ldr	r0, [pc, #12]	; (800eaec <USBD_FS_ManufacturerStrDescriptor+0x18>)
 800eade:	f7fd fa0b 	bl	800bef8 <USBD_GetString>
}
 800eae2:	4620      	mov	r0, r4
 800eae4:	bd10      	pop	{r4, pc}
 800eae6:	bf00      	nop
 800eae8:	20002c90 	.word	0x20002c90
 800eaec:	08025600 	.word	0x08025600

0800eaf0 <USBD_FS_ConfigStrDescriptor>:
{
 800eaf0:	b508      	push	{r3, lr}
 800eaf2:	460a      	mov	r2, r1
  if(speed == USBD_SPEED_HIGH)
 800eaf4:	b928      	cbnz	r0, 800eb02 <USBD_FS_ConfigStrDescriptor+0x12>
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 800eaf6:	4905      	ldr	r1, [pc, #20]	; (800eb0c <USBD_FS_ConfigStrDescriptor+0x1c>)
 800eaf8:	4805      	ldr	r0, [pc, #20]	; (800eb10 <USBD_FS_ConfigStrDescriptor+0x20>)
 800eafa:	f7fd f9fd 	bl	800bef8 <USBD_GetString>
}
 800eafe:	4803      	ldr	r0, [pc, #12]	; (800eb0c <USBD_FS_ConfigStrDescriptor+0x1c>)
 800eb00:	bd08      	pop	{r3, pc}
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 800eb02:	4902      	ldr	r1, [pc, #8]	; (800eb0c <USBD_FS_ConfigStrDescriptor+0x1c>)
 800eb04:	4802      	ldr	r0, [pc, #8]	; (800eb10 <USBD_FS_ConfigStrDescriptor+0x20>)
 800eb06:	f7fd f9f7 	bl	800bef8 <USBD_GetString>
 800eb0a:	e7f8      	b.n	800eafe <USBD_FS_ConfigStrDescriptor+0xe>
 800eb0c:	20002c90 	.word	0x20002c90
 800eb10:	08025614 	.word	0x08025614

0800eb14 <USBD_FS_InterfaceStrDescriptor>:
{
 800eb14:	b508      	push	{r3, lr}
 800eb16:	460a      	mov	r2, r1
  if(speed == 0)
 800eb18:	b928      	cbnz	r0, 800eb26 <USBD_FS_InterfaceStrDescriptor+0x12>
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 800eb1a:	4905      	ldr	r1, [pc, #20]	; (800eb30 <USBD_FS_InterfaceStrDescriptor+0x1c>)
 800eb1c:	4805      	ldr	r0, [pc, #20]	; (800eb34 <USBD_FS_InterfaceStrDescriptor+0x20>)
 800eb1e:	f7fd f9eb 	bl	800bef8 <USBD_GetString>
}
 800eb22:	4803      	ldr	r0, [pc, #12]	; (800eb30 <USBD_FS_InterfaceStrDescriptor+0x1c>)
 800eb24:	bd08      	pop	{r3, pc}
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 800eb26:	4902      	ldr	r1, [pc, #8]	; (800eb30 <USBD_FS_InterfaceStrDescriptor+0x1c>)
 800eb28:	4802      	ldr	r0, [pc, #8]	; (800eb34 <USBD_FS_InterfaceStrDescriptor+0x20>)
 800eb2a:	f7fd f9e5 	bl	800bef8 <USBD_GetString>
 800eb2e:	e7f8      	b.n	800eb22 <USBD_FS_InterfaceStrDescriptor+0xe>
 800eb30:	20002c90 	.word	0x20002c90
 800eb34:	08025620 	.word	0x08025620

0800eb38 <HAL_PCD_MspInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 800eb38:	b530      	push	{r4, r5, lr}
 800eb3a:	b089      	sub	sp, #36	; 0x24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800eb3c:	2300      	movs	r3, #0
 800eb3e:	9303      	str	r3, [sp, #12]
 800eb40:	9304      	str	r3, [sp, #16]
 800eb42:	9305      	str	r3, [sp, #20]
 800eb44:	9306      	str	r3, [sp, #24]
 800eb46:	9307      	str	r3, [sp, #28]
  if(pcdHandle->Instance==USB_OTG_FS)
 800eb48:	6803      	ldr	r3, [r0, #0]
 800eb4a:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 800eb4e:	d001      	beq.n	800eb54 <HAL_PCD_MspInit+0x1c>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 800eb50:	b009      	add	sp, #36	; 0x24
 800eb52:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800eb54:	2500      	movs	r5, #0
 800eb56:	9501      	str	r5, [sp, #4]
 800eb58:	4c16      	ldr	r4, [pc, #88]	; (800ebb4 <HAL_PCD_MspInit+0x7c>)
 800eb5a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800eb5c:	f043 0301 	orr.w	r3, r3, #1
 800eb60:	6323      	str	r3, [r4, #48]	; 0x30
 800eb62:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800eb64:	f003 0301 	and.w	r3, r3, #1
 800eb68:	9301      	str	r3, [sp, #4]
 800eb6a:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 800eb6c:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 800eb70:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800eb72:	2302      	movs	r3, #2
 800eb74:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800eb76:	2303      	movs	r3, #3
 800eb78:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 800eb7a:	230a      	movs	r3, #10
 800eb7c:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800eb7e:	a903      	add	r1, sp, #12
 800eb80:	480d      	ldr	r0, [pc, #52]	; (800ebb8 <HAL_PCD_MspInit+0x80>)
 800eb82:	f7fa fba1 	bl	80092c8 <HAL_GPIO_Init>
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 800eb86:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800eb88:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800eb8c:	6363      	str	r3, [r4, #52]	; 0x34
 800eb8e:	9502      	str	r5, [sp, #8]
 800eb90:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800eb92:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800eb96:	6463      	str	r3, [r4, #68]	; 0x44
 800eb98:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800eb9a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800eb9e:	9302      	str	r3, [sp, #8]
 800eba0:	9b02      	ldr	r3, [sp, #8]
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 0);
 800eba2:	462a      	mov	r2, r5
 800eba4:	4629      	mov	r1, r5
 800eba6:	2043      	movs	r0, #67	; 0x43
 800eba8:	f7fa f94e 	bl	8008e48 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 800ebac:	2043      	movs	r0, #67	; 0x43
 800ebae:	f7fa f983 	bl	8008eb8 <HAL_NVIC_EnableIRQ>
}
 800ebb2:	e7cd      	b.n	800eb50 <HAL_PCD_MspInit+0x18>
 800ebb4:	40023800 	.word	0x40023800
 800ebb8:	40020000 	.word	0x40020000

0800ebbc <HAL_PCD_SetupStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 800ebbc:	b508      	push	{r3, lr}
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 800ebbe:	f500 7171 	add.w	r1, r0, #964	; 0x3c4
 800ebc2:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 800ebc6:	f7fc fd4a 	bl	800b65e <USBD_LL_SetupStage>
}
 800ebca:	bd08      	pop	{r3, pc}

0800ebcc <HAL_PCD_DataOutStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 800ebcc:	b508      	push	{r3, lr}
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 800ebce:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 800ebd2:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800ebd6:	f8d3 2208 	ldr.w	r2, [r3, #520]	; 0x208
 800ebda:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 800ebde:	f7fc fd6a 	bl	800b6b6 <USBD_LL_DataOutStage>
}
 800ebe2:	bd08      	pop	{r3, pc}

0800ebe4 <HAL_PCD_DataInStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 800ebe4:	b508      	push	{r3, lr}
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 800ebe6:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 800ebea:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800ebee:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800ebf0:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 800ebf4:	f7fc fd98 	bl	800b728 <USBD_LL_DataInStage>
}
 800ebf8:	bd08      	pop	{r3, pc}

0800ebfa <HAL_PCD_SOFCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 800ebfa:	b508      	push	{r3, lr}
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 800ebfc:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 800ec00:	f7fc fe2e 	bl	800b860 <USBD_LL_SOF>
}
 800ec04:	bd08      	pop	{r3, pc}

0800ec06 <HAL_PCD_ResetCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 800ec06:	b510      	push	{r4, lr}
 800ec08:	4604      	mov	r4, r0
   USBD_SpeedTypeDef speed = USBD_SPEED_FULL;

  if ( hpcd->Init.speed != PCD_SPEED_FULL)
 800ec0a:	68c3      	ldr	r3, [r0, #12]
 800ec0c:	2b02      	cmp	r3, #2
 800ec0e:	d109      	bne.n	800ec24 <HAL_PCD_ResetCallback+0x1e>
  {
    Error_Handler();
  }
    /* Set Speed. */
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 800ec10:	2101      	movs	r1, #1
 800ec12:	f8d4 0404 	ldr.w	r0, [r4, #1028]	; 0x404
 800ec16:	f7fc fe0c 	bl	800b832 <USBD_LL_SetSpeed>

  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 800ec1a:	f8d4 0404 	ldr.w	r0, [r4, #1028]	; 0x404
 800ec1e:	f7fc fddf 	bl	800b7e0 <USBD_LL_Reset>
}
 800ec22:	bd10      	pop	{r4, pc}
    Error_Handler();
 800ec24:	f7fe fed2 	bl	800d9cc <Error_Handler>
 800ec28:	e7f2      	b.n	800ec10 <HAL_PCD_ResetCallback+0xa>
	...

0800ec2c <HAL_PCD_SuspendCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 800ec2c:	b510      	push	{r4, lr}
 800ec2e:	4604      	mov	r4, r0
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 800ec30:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 800ec34:	f7fc fe00 	bl	800b838 <USBD_LL_Suspend>
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 800ec38:	6822      	ldr	r2, [r4, #0]
 800ec3a:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
 800ec3e:	f043 0301 	orr.w	r3, r3, #1
 800ec42:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 800ec46:	6a23      	ldr	r3, [r4, #32]
 800ec48:	b123      	cbz	r3, 800ec54 <HAL_PCD_SuspendCallback+0x28>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 800ec4a:	4a03      	ldr	r2, [pc, #12]	; (800ec58 <HAL_PCD_SuspendCallback+0x2c>)
 800ec4c:	6913      	ldr	r3, [r2, #16]
 800ec4e:	f043 0306 	orr.w	r3, r3, #6
 800ec52:	6113      	str	r3, [r2, #16]
  }
  /* USER CODE END 2 */
}
 800ec54:	bd10      	pop	{r4, pc}
 800ec56:	bf00      	nop
 800ec58:	e000ed00 	.word	0xe000ed00

0800ec5c <HAL_PCD_ResumeCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 800ec5c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN 3 */

  /* USER CODE END 3 */
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 800ec5e:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 800ec62:	f7fc fdf2 	bl	800b84a <USBD_LL_Resume>
}
 800ec66:	bd08      	pop	{r3, pc}

0800ec68 <HAL_PCD_ISOOUTIncompleteCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 800ec68:	b508      	push	{r3, lr}
  USBD_LL_IsoOUTIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 800ec6a:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 800ec6e:	f7fc fe07 	bl	800b880 <USBD_LL_IsoOUTIncomplete>
}
 800ec72:	bd08      	pop	{r3, pc}

0800ec74 <HAL_PCD_ISOINIncompleteCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 800ec74:	b508      	push	{r3, lr}
  USBD_LL_IsoINIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 800ec76:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 800ec7a:	f7fc fdff 	bl	800b87c <USBD_LL_IsoINIncomplete>
}
 800ec7e:	bd08      	pop	{r3, pc}

0800ec80 <HAL_PCD_ConnectCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 800ec80:	b508      	push	{r3, lr}
  USBD_LL_DevConnected((USBD_HandleTypeDef*)hpcd->pData);
 800ec82:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 800ec86:	f7fc fdfd 	bl	800b884 <USBD_LL_DevConnected>
}
 800ec8a:	bd08      	pop	{r3, pc}

0800ec8c <HAL_PCD_DisconnectCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 800ec8c:	b508      	push	{r3, lr}
  USBD_LL_DevDisconnected((USBD_HandleTypeDef*)hpcd->pData);
 800ec8e:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 800ec92:	f7fc fdf9 	bl	800b888 <USBD_LL_DevDisconnected>
}
 800ec96:	bd08      	pop	{r3, pc}

0800ec98 <USBD_LL_Init>:
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Init(USBD_HandleTypeDef *pdev)
{
  /* Init USB Ip. */
  if (pdev->id == DEVICE_FS) {
 800ec98:	7802      	ldrb	r2, [r0, #0]
 800ec9a:	b10a      	cbz	r2, 800eca0 <USBD_LL_Init+0x8>
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
  }
  return USBD_OK;
}
 800ec9c:	2000      	movs	r0, #0
 800ec9e:	4770      	bx	lr
{
 800eca0:	b510      	push	{r4, lr}
 800eca2:	4603      	mov	r3, r0
  hpcd_USB_OTG_FS.pData = pdev;
 800eca4:	4815      	ldr	r0, [pc, #84]	; (800ecfc <USBD_LL_Init+0x64>)
 800eca6:	f8c0 3404 	str.w	r3, [r0, #1028]	; 0x404
  pdev->pData = &hpcd_USB_OTG_FS;
 800ecaa:	f8c3 02c4 	str.w	r0, [r3, #708]	; 0x2c4
  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
 800ecae:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 800ecb2:	6003      	str	r3, [r0, #0]
  hpcd_USB_OTG_FS.Init.dev_endpoints = 4;
 800ecb4:	2304      	movs	r3, #4
 800ecb6:	6043      	str	r3, [r0, #4]
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
 800ecb8:	2202      	movs	r2, #2
 800ecba:	60c2      	str	r2, [r0, #12]
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
 800ecbc:	2300      	movs	r3, #0
 800ecbe:	6103      	str	r3, [r0, #16]
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 800ecc0:	6182      	str	r2, [r0, #24]
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
 800ecc2:	61c3      	str	r3, [r0, #28]
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
 800ecc4:	6203      	str	r3, [r0, #32]
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
 800ecc6:	6243      	str	r3, [r0, #36]	; 0x24
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = DISABLE;
 800ecc8:	62c3      	str	r3, [r0, #44]	; 0x2c
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
 800ecca:	6303      	str	r3, [r0, #48]	; 0x30
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 800eccc:	f7fa fc4c 	bl	8009568 <HAL_PCD_Init>
 800ecd0:	b980      	cbnz	r0, 800ecf4 <USBD_LL_Init+0x5c>
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
 800ecd2:	4c0a      	ldr	r4, [pc, #40]	; (800ecfc <USBD_LL_Init+0x64>)
 800ecd4:	2180      	movs	r1, #128	; 0x80
 800ecd6:	4620      	mov	r0, r4
 800ecd8:	f7fb f979 	bl	8009fce <HAL_PCDEx_SetRxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
 800ecdc:	2240      	movs	r2, #64	; 0x40
 800ecde:	2100      	movs	r1, #0
 800ece0:	4620      	mov	r0, r4
 800ece2:	f7fb f94e 	bl	8009f82 <HAL_PCDEx_SetTxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
 800ece6:	2280      	movs	r2, #128	; 0x80
 800ece8:	2101      	movs	r1, #1
 800ecea:	4620      	mov	r0, r4
 800ecec:	f7fb f949 	bl	8009f82 <HAL_PCDEx_SetTxFiFo>
}
 800ecf0:	2000      	movs	r0, #0
 800ecf2:	bd10      	pop	{r4, pc}
    Error_Handler( );
 800ecf4:	f7fe fe6a 	bl	800d9cc <Error_Handler>
 800ecf8:	e7eb      	b.n	800ecd2 <USBD_LL_Init+0x3a>
 800ecfa:	bf00      	nop
 800ecfc:	20002e90 	.word	0x20002e90

0800ed00 <USBD_LL_IsStallEP>:
  * @param  ep_addr: Endpoint number
  * @retval Stall (1: Yes, 0: No)
  */
uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 800ed00:	f8d0 32c4 	ldr.w	r3, [r0, #708]	; 0x2c4

  if((ep_addr & 0x80) == 0x80)
 800ed04:	f011 0f80 	tst.w	r1, #128	; 0x80
 800ed08:	d108      	bne.n	800ed1c <USBD_LL_IsStallEP+0x1c>
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
 800ed0a:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 800ed0e:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 800ed12:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 800ed16:	f893 01fe 	ldrb.w	r0, [r3, #510]	; 0x1fe
  }
}
 800ed1a:	4770      	bx	lr
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
 800ed1c:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 800ed20:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 800ed24:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 800ed28:	f893 003e 	ldrb.w	r0, [r3, #62]	; 0x3e
 800ed2c:	4770      	bx	lr

0800ed2e <USBD_LL_GetRxDataSize>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Recived Data Size
  */
uint32_t USBD_LL_GetRxDataSize(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 800ed2e:	b508      	push	{r3, lr}
  return HAL_PCD_EP_GetRxCount((PCD_HandleTypeDef*) pdev->pData, ep_addr);
 800ed30:	f8d0 02c4 	ldr.w	r0, [r0, #708]	; 0x2c4
 800ed34:	f7fb f86e 	bl	8009e14 <HAL_PCD_EP_GetRxCount>
}
 800ed38:	bd08      	pop	{r3, pc}

0800ed3a <USBD_Get_USB_Status>:
  */
USBD_StatusTypeDef USBD_Get_USB_Status(HAL_StatusTypeDef hal_status)
{
  USBD_StatusTypeDef usb_status = USBD_OK;

  switch (hal_status)
 800ed3a:	2803      	cmp	r0, #3
 800ed3c:	d805      	bhi.n	800ed4a <USBD_Get_USB_Status+0x10>
 800ed3e:	e8df f000 	tbb	[pc, r0]
 800ed42:	0405      	.short	0x0405
 800ed44:	0502      	.short	0x0502
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
    break;
    case HAL_BUSY :
      usb_status = USBD_BUSY;
 800ed46:	2001      	movs	r0, #1
    break;
 800ed48:	4770      	bx	lr
      usb_status = USBD_FAIL;
 800ed4a:	2003      	movs	r0, #3
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;
}
 800ed4c:	4770      	bx	lr

0800ed4e <USBD_LL_Start>:
{
 800ed4e:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_Start(pdev->pData);
 800ed50:	f8d0 02c4 	ldr.w	r0, [r0, #708]	; 0x2c4
 800ed54:	f7fa fc9f 	bl	8009696 <HAL_PCD_Start>
  usb_status =  USBD_Get_USB_Status(hal_status);
 800ed58:	f7ff ffef 	bl	800ed3a <USBD_Get_USB_Status>
}
 800ed5c:	bd08      	pop	{r3, pc}

0800ed5e <USBD_LL_OpenEP>:
{
 800ed5e:	b508      	push	{r3, lr}
 800ed60:	4694      	mov	ip, r2
 800ed62:	461a      	mov	r2, r3
  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 800ed64:	4663      	mov	r3, ip
 800ed66:	f8d0 02c4 	ldr.w	r0, [r0, #708]	; 0x2c4
 800ed6a:	f7fa ffa6 	bl	8009cba <HAL_PCD_EP_Open>
  usb_status =  USBD_Get_USB_Status(hal_status);
 800ed6e:	f7ff ffe4 	bl	800ed3a <USBD_Get_USB_Status>
}
 800ed72:	bd08      	pop	{r3, pc}

0800ed74 <USBD_LL_CloseEP>:
{
 800ed74:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 800ed76:	f8d0 02c4 	ldr.w	r0, [r0, #708]	; 0x2c4
 800ed7a:	f7fa ffe3 	bl	8009d44 <HAL_PCD_EP_Close>
  usb_status =  USBD_Get_USB_Status(hal_status);
 800ed7e:	f7ff ffdc 	bl	800ed3a <USBD_Get_USB_Status>
}
 800ed82:	bd08      	pop	{r3, pc}

0800ed84 <USBD_LL_StallEP>:
{
 800ed84:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 800ed86:	f8d0 02c4 	ldr.w	r0, [r0, #708]	; 0x2c4
 800ed8a:	f7fb f87b 	bl	8009e84 <HAL_PCD_EP_SetStall>
  usb_status =  USBD_Get_USB_Status(hal_status);
 800ed8e:	f7ff ffd4 	bl	800ed3a <USBD_Get_USB_Status>
}
 800ed92:	bd08      	pop	{r3, pc}

0800ed94 <USBD_LL_ClearStallEP>:
{
 800ed94:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 800ed96:	f8d0 02c4 	ldr.w	r0, [r0, #708]	; 0x2c4
 800ed9a:	f7fb f8b7 	bl	8009f0c <HAL_PCD_EP_ClrStall>
  usb_status =  USBD_Get_USB_Status(hal_status);
 800ed9e:	f7ff ffcc 	bl	800ed3a <USBD_Get_USB_Status>
}
 800eda2:	bd08      	pop	{r3, pc}

0800eda4 <USBD_LL_SetUSBAddress>:
{
 800eda4:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 800eda6:	f8d0 02c4 	ldr.w	r0, [r0, #708]	; 0x2c4
 800edaa:	f7fa ff72 	bl	8009c92 <HAL_PCD_SetAddress>
  usb_status =  USBD_Get_USB_Status(hal_status);
 800edae:	f7ff ffc4 	bl	800ed3a <USBD_Get_USB_Status>
}
 800edb2:	bd08      	pop	{r3, pc}

0800edb4 <USBD_LL_Transmit>:
{
 800edb4:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 800edb6:	f8d0 02c4 	ldr.w	r0, [r0, #708]	; 0x2c4
 800edba:	f7fb f834 	bl	8009e26 <HAL_PCD_EP_Transmit>
  usb_status =  USBD_Get_USB_Status(hal_status);
 800edbe:	f7ff ffbc 	bl	800ed3a <USBD_Get_USB_Status>
}
 800edc2:	bd08      	pop	{r3, pc}

0800edc4 <USBD_LL_PrepareReceive>:
{
 800edc4:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 800edc6:	f8d0 02c4 	ldr.w	r0, [r0, #708]	; 0x2c4
 800edca:	f7fa fff4 	bl	8009db6 <HAL_PCD_EP_Receive>
  usb_status =  USBD_Get_USB_Status(hal_status);
 800edce:	f7ff ffb4 	bl	800ed3a <USBD_Get_USB_Status>
}
 800edd2:	bd08      	pop	{r3, pc}

0800edd4 <alarms_get_details>:
}

alarm_details_t *alarms_get_details (void)
{
    return &details;
}
 800edd4:	4800      	ldr	r0, [pc, #0]	; (800edd8 <alarms_get_details+0x4>)
 800edd6:	4770      	bx	lr
 800edd8:	200003d0 	.word	0x200003d0

0800eddc <coolant_set_state>:
// Main program only. Immediately sets flood coolant running state and also mist coolant,
// if enabled. Also sets a flag to report an update to a coolant state.
// Called by coolant toggle override, parking restore, parking retract, sleep mode, g-code
// parser program end, and g-code parser coolant_sync().
void coolant_set_state (coolant_state_t mode)
{
 800eddc:	b508      	push	{r3, lr}
    if (!ABORTED) { // Block during abort.
 800edde:	4b06      	ldr	r3, [pc, #24]	; (800edf8 <coolant_set_state+0x1c>)
 800ede0:	781b      	ldrb	r3, [r3, #0]
 800ede2:	b943      	cbnz	r3, 800edf6 <coolant_set_state+0x1a>
 800ede4:	4b04      	ldr	r3, [pc, #16]	; (800edf8 <coolant_set_state+0x1c>)
 800ede6:	785b      	ldrb	r3, [r3, #1]
 800ede8:	b92b      	cbnz	r3, 800edf6 <coolant_set_state+0x1a>
        hal.coolant.set_state(mode);
 800edea:	4b04      	ldr	r3, [pc, #16]	; (800edfc <coolant_set_state+0x20>)
 800edec:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800edee:	4798      	blx	r3
        system_add_rt_report(Report_Coolant); // Set to report change immediately
 800edf0:	2020      	movs	r0, #32
 800edf2:	f012 fa25 	bl	8021240 <system_add_rt_report>
    }
}
 800edf6:	bd08      	pop	{r3, pc}
 800edf8:	200036c4 	.word	0x200036c4
 800edfc:	2000350c 	.word	0x2000350c

0800ee00 <coolant_sync>:

// G-code parser entry-point for setting coolant state. Forces a planner buffer sync and bails
// if an abort or check-mode is active.
bool coolant_sync (coolant_state_t mode)
{
 800ee00:	b538      	push	{r3, r4, r5, lr}
 800ee02:	4604      	mov	r4, r0
    bool ok = true;
    if (state_get() != STATE_CHECK_MODE) {
 800ee04:	f00f fbee 	bl	801e5e4 <state_get>
 800ee08:	2802      	cmp	r0, #2
 800ee0a:	d102      	bne.n	800ee12 <coolant_sync+0x12>
    bool ok = true;
 800ee0c:	2501      	movs	r5, #1
        if((ok = protocol_buffer_synchronize())) // Ensure coolant changes state when specified in program.
            coolant_set_state(mode);
    }

    return ok;
}
 800ee0e:	4628      	mov	r0, r5
 800ee10:	bd38      	pop	{r3, r4, r5, pc}
        if((ok = protocol_buffer_synchronize())) // Ensure coolant changes state when specified in program.
 800ee12:	f008 fee1 	bl	8017bd8 <protocol_buffer_synchronize>
 800ee16:	4605      	mov	r5, r0
 800ee18:	2800      	cmp	r0, #0
 800ee1a:	d0f8      	beq.n	800ee0e <coolant_sync+0xe>
            coolant_set_state(mode);
 800ee1c:	4620      	mov	r0, r4
 800ee1e:	f7ff ffdd 	bl	800eddc <coolant_set_state>
 800ee22:	e7f4      	b.n	800ee0e <coolant_sync+0xe>

0800ee24 <errors_get_details>:
}

error_details_t *errors_get_details (void)
{
    return &details;
}
 800ee24:	4800      	ldr	r0, [pc, #0]	; (800ee28 <errors_get_details+0x4>)
 800ee26:	4770      	bx	lr
 800ee28:	200003dc 	.word	0x200003dc

0800ee2c <init_sync_motion>:

    return add_cmd != NULL;
}

static status_code_t init_sync_motion (plan_line_data_t *pl_data, float pitch)
{
 800ee2c:	b508      	push	{r3, lr}
 800ee2e:	ed2d 8b02 	vpush	{d8}
    pl_data->condition.inverse_time = Off;
 800ee32:	7d03      	ldrb	r3, [r0, #20]
 800ee34:	f36f 1345 	bfc	r3, #5, #1
 800ee38:	7503      	strb	r3, [r0, #20]
    pl_data->feed_rate = gc_state.distance_per_rev = pitch;
 800ee3a:	4b25      	ldr	r3, [pc, #148]	; (800eed0 <init_sync_motion+0xa4>)
 800ee3c:	ed83 0a17 	vstr	s0, [r3, #92]	; 0x5c
 800ee40:	ed80 0a00 	vstr	s0, [r0]
    pl_data->spindle.css = NULL;                    // Switch off CSS.
 800ee44:	2300      	movs	r3, #0
 800ee46:	60c3      	str	r3, [r0, #12]
    pl_data->overrides = sys.override.control;      // Use current override flags and
 800ee48:	4b22      	ldr	r3, [pc, #136]	; (800eed4 <init_sync_motion+0xa8>)
 800ee4a:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
 800ee4e:	7602      	strb	r2, [r0, #24]
    pl_data->overrides.sync = On;                   // set to sync overrides on execution of motion.
 800ee50:	b2d2      	uxtb	r2, r2
 800ee52:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800ee56:	7602      	strb	r2, [r0, #24]

    // Disable feed rate and spindle overrides for the duration of the cycle.
    pl_data->overrides.spindle_rpm_disable = sys.override.control.spindle_rpm_disable = On;
 800ee58:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
 800ee5c:	f042 0204 	orr.w	r2, r2, #4
 800ee60:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
 800ee64:	7e02      	ldrb	r2, [r0, #24]
 800ee66:	f042 0204 	orr.w	r2, r2, #4
 800ee6a:	7602      	strb	r2, [r0, #24]
    pl_data->overrides.feed_rate_disable = sys.override.control.feed_rate_disable = On;
 800ee6c:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
 800ee70:	f042 0201 	orr.w	r2, r2, #1
 800ee74:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
 800ee78:	7e03      	ldrb	r3, [r0, #24]
 800ee7a:	f043 0301 	orr.w	r3, r3, #1
 800ee7e:	7603      	strb	r3, [r0, #24]
    pl_data->spindle.hal->param->override_pct = DEFAULT_SPINDLE_RPM_OVERRIDE;
 800ee80:	6903      	ldr	r3, [r0, #16]
 800ee82:	685b      	ldr	r3, [r3, #4]
 800ee84:	2264      	movs	r2, #100	; 0x64
 800ee86:	60da      	str	r2, [r3, #12]
    // TODO: need for gc_state.distance_per_rev to be reset on modal change?
    float feed_rate = pl_data->feed_rate * pl_data->spindle.hal->get_data(SpindleData_RPM)->rpm;
 800ee88:	ed90 8a00 	vldr	s16, [r0]
 800ee8c:	6903      	ldr	r3, [r0, #16]
 800ee8e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800ee90:	2001      	movs	r0, #1
 800ee92:	4798      	blx	r3
 800ee94:	edd0 7a00 	vldr	s15, [r0]
 800ee98:	ee68 7a27 	vmul.f32	s15, s16, s15

    if(feed_rate == 0.0f)
 800ee9c:	eef5 7a40 	vcmp.f32	s15, #0.0
 800eea0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800eea4:	d00f      	beq.n	800eec6 <init_sync_motion+0x9a>
        FAIL(Status_GcodeSpindleNotRunning); // [Spindle not running]

    if(feed_rate > settings.axis[Z_AXIS].max_rate * 0.9f)
 800eea6:	4b0c      	ldr	r3, [pc, #48]	; (800eed8 <init_sync_motion+0xac>)
 800eea8:	ed93 7a17 	vldr	s14, [r3, #92]	; 0x5c
 800eeac:	eddf 6a0b 	vldr	s13, [pc, #44]	; 800eedc <init_sync_motion+0xb0>
 800eeb0:	ee27 7a26 	vmul.f32	s14, s14, s13
 800eeb4:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800eeb8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800eebc:	d405      	bmi.n	800eeca <init_sync_motion+0x9e>
        FAIL(Status_GcodeMaxFeedRateExceeded); // [Feed rate too high]

    return Status_OK;
 800eebe:	2000      	movs	r0, #0
}
 800eec0:	ecbd 8b02 	vpop	{d8}
 800eec4:	bd08      	pop	{r3, pc}
        FAIL(Status_GcodeSpindleNotRunning); // [Spindle not running]
 800eec6:	2029      	movs	r0, #41	; 0x29
 800eec8:	e7fa      	b.n	800eec0 <init_sync_motion+0x94>
        FAIL(Status_GcodeMaxFeedRateExceeded); // [Feed rate too high]
 800eeca:	202b      	movs	r0, #43	; 0x2b
 800eecc:	e7f8      	b.n	800eec0 <init_sync_motion+0x94>
 800eece:	bf00      	nop
 800eed0:	20003344 	.word	0x20003344
 800eed4:	200036c4 	.word	0x200036c4
 800eed8:	20003b14 	.word	0x20003b14
 800eedc:	3f666666 	.word	0x3f666666

0800eee0 <add_output_command>:
{
 800eee0:	b510      	push	{r4, lr}
 800eee2:	4604      	mov	r4, r0
    if((add_cmd = malloc(sizeof(output_command_t)))) {
 800eee4:	200c      	movs	r0, #12
 800eee6:	f013 fae3 	bl	80224b0 <malloc>
 800eeea:	4601      	mov	r1, r0
 800eeec:	b168      	cbz	r0, 800ef0a <add_output_command+0x2a>
        memcpy(add_cmd, command, sizeof(output_command_t));
 800eeee:	6820      	ldr	r0, [r4, #0]
 800eef0:	6862      	ldr	r2, [r4, #4]
 800eef2:	68a3      	ldr	r3, [r4, #8]
 800eef4:	6008      	str	r0, [r1, #0]
 800eef6:	604a      	str	r2, [r1, #4]
 800eef8:	608b      	str	r3, [r1, #8]
        if(output_commands == NULL)
 800eefa:	4b07      	ldr	r3, [pc, #28]	; (800ef18 <add_output_command+0x38>)
 800eefc:	681b      	ldr	r3, [r3, #0]
 800eefe:	b143      	cbz	r3, 800ef12 <add_output_command+0x32>
            while(cmd->next)
 800ef00:	461a      	mov	r2, r3
 800ef02:	689b      	ldr	r3, [r3, #8]
 800ef04:	2b00      	cmp	r3, #0
 800ef06:	d1fb      	bne.n	800ef00 <add_output_command+0x20>
            cmd->next = add_cmd;
 800ef08:	6091      	str	r1, [r2, #8]
}
 800ef0a:	1e08      	subs	r0, r1, #0
 800ef0c:	bf18      	it	ne
 800ef0e:	2001      	movne	r0, #1
 800ef10:	bd10      	pop	{r4, pc}
            output_commands = add_cmd;
 800ef12:	4b01      	ldr	r3, [pc, #4]	; (800ef18 <add_output_command+0x38>)
 800ef14:	6019      	str	r1, [r3, #0]
 800ef16:	e7f8      	b.n	800ef0a <add_output_command+0x2a>
 800ef18:	200033dc 	.word	0x200033dc

0800ef1c <tool_get_pending>:
{
 800ef1c:	b470      	push	{r4, r5, r6}
 800ef1e:	4606      	mov	r6, r0
    memcpy(&tool_data, gc_state.tool, sizeof(tool_data_t));
 800ef20:	4b08      	ldr	r3, [pc, #32]	; (800ef44 <tool_get_pending+0x28>)
 800ef22:	f8d3 4094 	ldr.w	r4, [r3, #148]	; 0x94
 800ef26:	4d08      	ldr	r5, [pc, #32]	; (800ef48 <tool_get_pending+0x2c>)
 800ef28:	46ac      	mov	ip, r5
 800ef2a:	6820      	ldr	r0, [r4, #0]
 800ef2c:	6861      	ldr	r1, [r4, #4]
 800ef2e:	68a2      	ldr	r2, [r4, #8]
 800ef30:	68e3      	ldr	r3, [r4, #12]
 800ef32:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 800ef36:	6920      	ldr	r0, [r4, #16]
 800ef38:	f8cc 0000 	str.w	r0, [ip]
    tool_data.tool_id = tool_id;
 800ef3c:	612e      	str	r6, [r5, #16]
}
 800ef3e:	4628      	mov	r0, r5
 800ef40:	bc70      	pop	{r4, r5, r6}
 800ef42:	4770      	bx	lr
 800ef44:	20003344 	.word	0x20003344
 800ef48:	20003410 	.word	0x20003410

0800ef4c <output_message>:

// Output and free previously allocated message
static void output_message (char *message)
{
 800ef4c:	b510      	push	{r4, lr}
 800ef4e:	4604      	mov	r4, r0
    if(grbl.on_gcode_message)
 800ef50:	4b07      	ldr	r3, [pc, #28]	; (800ef70 <output_message+0x24>)
 800ef52:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800ef56:	b103      	cbz	r3, 800ef5a <output_message+0xe>
        grbl.on_gcode_message(message);
 800ef58:	4798      	blx	r3

    if(*message)
 800ef5a:	7823      	ldrb	r3, [r4, #0]
 800ef5c:	b91b      	cbnz	r3, 800ef66 <output_message+0x1a>
        report_message(message, Message_Plain);

    free(message);
 800ef5e:	4620      	mov	r0, r4
 800ef60:	f013 faae 	bl	80224c0 <free>
}
 800ef64:	bd10      	pop	{r4, pc}
        report_message(message, Message_Plain);
 800ef66:	2100      	movs	r1, #0
 800ef68:	4620      	mov	r0, r4
 800ef6a:	f00a f95d 	bl	8019228 <report_message>
 800ef6e:	e7f6      	b.n	800ef5e <output_message+0x12>
 800ef70:	2000343c 	.word	0x2000343c

0800ef74 <gc_get_scaling>:
}
 800ef74:	4800      	ldr	r0, [pc, #0]	; (800ef78 <gc_get_scaling+0x4>)
 800ef76:	4770      	bx	lr
 800ef78:	200003f4 	.word	0x200003f4

0800ef7c <gc_get_g51_state>:
    axes_signals_t scaled = {0};
 800ef7c:	f04f 0000 	mov.w	r0, #0
    uint_fast8_t idx = N_AXIS;
 800ef80:	2303      	movs	r3, #3
 800ef82:	e002      	b.n	800ef8a <gc_get_g51_state+0xe>
            scaled.value |= 0x01;
 800ef84:	f041 0001 	orr.w	r0, r1, #1
    } while(idx);
 800ef88:	b193      	cbz	r3, 800efb0 <gc_get_g51_state+0x34>
        scaled.value <<= 1;
 800ef8a:	0040      	lsls	r0, r0, #1
 800ef8c:	b2c1      	uxtb	r1, r0
 800ef8e:	4608      	mov	r0, r1
        if(scale_factor.ijk[--idx] != 1.0f)
 800ef90:	3b01      	subs	r3, #1
 800ef92:	f103 0c02 	add.w	ip, r3, #2
 800ef96:	4a07      	ldr	r2, [pc, #28]	; (800efb4 <gc_get_g51_state+0x38>)
 800ef98:	eb02 028c 	add.w	r2, r2, ip, lsl #2
 800ef9c:	ed92 7a01 	vldr	s14, [r2, #4]
 800efa0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800efa4:	eeb4 7a67 	vcmp.f32	s14, s15
 800efa8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800efac:	d0ec      	beq.n	800ef88 <gc_get_g51_state+0xc>
 800efae:	e7e9      	b.n	800ef84 <gc_get_g51_state+0x8>
}
 800efb0:	4770      	bx	lr
 800efb2:	bf00      	nop
 800efb4:	200003e8 	.word	0x200003e8

0800efb8 <set_scaling>:
{
 800efb8:	b510      	push	{r4, lr}
 800efba:	ed2d 8b02 	vpush	{d8}
 800efbe:	eeb0 8a40 	vmov.f32	s16, s0
    axes_signals_t state = gc_get_g51_state();
 800efc2:	f7ff ffdb 	bl	800ef7c <gc_get_g51_state>
    uint_fast8_t idx = N_AXIS;
 800efc6:	2303      	movs	r3, #3
        scale_factor.ijk[--idx] = factor;
 800efc8:	3b01      	subs	r3, #1
 800efca:	4a12      	ldr	r2, [pc, #72]	; (800f014 <set_scaling+0x5c>)
 800efcc:	1c99      	adds	r1, r3, #2
 800efce:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 800efd2:	ed81 8a01 	vstr	s16, [r1, #4]
        scale_factor.xyz[idx] = 0.0f;
 800efd6:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 800efda:	2100      	movs	r1, #0
 800efdc:	6011      	str	r1, [r2, #0]
    } while(idx);
 800efde:	2b00      	cmp	r3, #0
 800efe0:	d1f2      	bne.n	800efc8 <set_scaling+0x10>
    gc_state.modal.scaling_active = factor != 1.0f;
 800efe2:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800efe6:	eeb4 8a67 	vcmp.f32	s16, s15
 800efea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800efee:	bf14      	ite	ne
 800eff0:	2201      	movne	r2, #1
 800eff2:	2200      	moveq	r2, #0
 800eff4:	4b08      	ldr	r3, [pc, #32]	; (800f018 <set_scaling+0x60>)
 800eff6:	779a      	strb	r2, [r3, #30]
    if(state.value != gc_get_g51_state().value)
 800eff8:	b2c4      	uxtb	r4, r0
 800effa:	f7ff ffbf 	bl	800ef7c <gc_get_g51_state>
 800effe:	b2c0      	uxtb	r0, r0
 800f000:	4284      	cmp	r4, r0
 800f002:	d102      	bne.n	800f00a <set_scaling+0x52>
}
 800f004:	ecbd 8b02 	vpop	{d8}
 800f008:	bd10      	pop	{r4, pc}
        system_add_rt_report(Report_Scaling);
 800f00a:	2002      	movs	r0, #2
 800f00c:	f012 f918 	bl	8021240 <system_add_rt_report>
}
 800f010:	e7f8      	b.n	800f004 <set_scaling+0x4c>
 800f012:	bf00      	nop
 800f014:	200003e8 	.word	0x200003e8
 800f018:	20003344 	.word	0x20003344

0800f01c <gc_get_offset>:
    return gc_state.modal.coord_system.xyz[idx] + gc_state.g92_coord_offset[idx] + gc_state.tool_length_offset[idx];
 800f01c:	4b0a      	ldr	r3, [pc, #40]	; (800f048 <gc_get_offset+0x2c>)
 800f01e:	1c82      	adds	r2, r0, #2
 800f020:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 800f024:	edd2 7a00 	vldr	s15, [r2]
 800f028:	f100 021e 	add.w	r2, r0, #30
 800f02c:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 800f030:	ed92 7a01 	vldr	s14, [r2, #4]
 800f034:	ee77 7a87 	vadd.f32	s15, s15, s14
 800f038:	3022      	adds	r0, #34	; 0x22
 800f03a:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800f03e:	ed93 0a00 	vldr	s0, [r3]
}
 800f042:	ee37 0a80 	vadd.f32	s0, s15, s0
 800f046:	4770      	bx	lr
 800f048:	20003344 	.word	0x20003344

0800f04c <gc_set_tool_offset>:
{
 800f04c:	b510      	push	{r4, lr}
 800f04e:	b082      	sub	sp, #8
 800f050:	9201      	str	r2, [sp, #4]
    switch(mode) {
 800f052:	4684      	mov	ip, r0
 800f054:	b120      	cbz	r0, 800f060 <gc_set_tool_offset+0x14>
 800f056:	2802      	cmp	r0, #2
 800f058:	d01d      	beq.n	800f096 <gc_set_tool_offset+0x4a>
    gc_state.modal.tool_offset_mode = mode;
 800f05a:	4b27      	ldr	r3, [pc, #156]	; (800f0f8 <gc_set_tool_offset+0xac>)
 800f05c:	71d8      	strb	r0, [r3, #7]
    if(tlo_changed) {
 800f05e:	e041      	b.n	800f0e4 <gc_set_tool_offset+0x98>
    switch(mode) {
 800f060:	2000      	movs	r0, #0
 800f062:	2303      	movs	r3, #3
                idx--;
 800f064:	3b01      	subs	r3, #1
                tlo_changed |= gc_state.tool_length_offset[idx] != 0.0f;
 800f066:	4c24      	ldr	r4, [pc, #144]	; (800f0f8 <gc_set_tool_offset+0xac>)
 800f068:	f103 0222 	add.w	r2, r3, #34	; 0x22
 800f06c:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 800f070:	edd2 7a00 	vldr	s15, [r2]
 800f074:	eef5 7a40 	vcmp.f32	s15, #0.0
 800f078:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800f07c:	bf18      	it	ne
 800f07e:	f040 0001 	orrne.w	r0, r0, #1
                gc_state.tool_length_offset[idx] = 0.0f;
 800f082:	2100      	movs	r1, #0
 800f084:	6011      	str	r1, [r2, #0]
                gc_state.tool->offset[idx] = 0.0f;
 800f086:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
 800f08a:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 800f08e:	6011      	str	r1, [r2, #0]
            } while(idx);
 800f090:	2b00      	cmp	r3, #0
 800f092:	d1e7      	bne.n	800f064 <gc_set_tool_offset+0x18>
 800f094:	e022      	b.n	800f0dc <gc_set_tool_offset+0x90>
                float new_offset = offset / settings.axis[idx].steps_per_mm;
 800f096:	eddd 7a01 	vldr	s15, [sp, #4]
 800f09a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800f09e:	eb01 0281 	add.w	r2, r1, r1, lsl #2
 800f0a2:	4b16      	ldr	r3, [pc, #88]	; (800f0fc <gc_set_tool_offset+0xb0>)
 800f0a4:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800f0a8:	edd3 6a0c 	vldr	s13, [r3, #48]	; 0x30
 800f0ac:	ee87 7aa6 	vdiv.f32	s14, s15, s13
                tlo_changed |= gc_state.tool_length_offset[idx] != new_offset;
 800f0b0:	4a11      	ldr	r2, [pc, #68]	; (800f0f8 <gc_set_tool_offset+0xac>)
 800f0b2:	f101 0322 	add.w	r3, r1, #34	; 0x22
 800f0b6:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 800f0ba:	edd3 7a00 	vldr	s15, [r3]
 800f0be:	eef4 7a47 	vcmp.f32	s15, s14
 800f0c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800f0c6:	bf14      	ite	ne
 800f0c8:	2001      	movne	r0, #1
 800f0ca:	2000      	moveq	r0, #0
                gc_state.tool_length_offset[idx] = new_offset;
 800f0cc:	ed83 7a00 	vstr	s14, [r3]
                gc_state.tool->offset[idx] = new_offset;
 800f0d0:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 800f0d4:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 800f0d8:	ed83 7a00 	vstr	s14, [r3]
    gc_state.modal.tool_offset_mode = mode;
 800f0dc:	4b06      	ldr	r3, [pc, #24]	; (800f0f8 <gc_set_tool_offset+0xac>)
 800f0de:	f883 c007 	strb.w	ip, [r3, #7]
    if(tlo_changed) {
 800f0e2:	b908      	cbnz	r0, 800f0e8 <gc_set_tool_offset+0x9c>
}
 800f0e4:	b002      	add	sp, #8
 800f0e6:	bd10      	pop	{r4, pc}
        system_add_rt_report(Report_ToolOffset);
 800f0e8:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800f0ec:	f012 f8a8 	bl	8021240 <system_add_rt_report>
        system_flag_wco_change();
 800f0f0:	f012 f904 	bl	80212fc <system_flag_wco_change>
}
 800f0f4:	e7f6      	b.n	800f0e4 <gc_set_tool_offset+0x98>
 800f0f6:	bf00      	nop
 800f0f8:	20003344 	.word	0x20003344
 800f0fc:	20003b14 	.word	0x20003b14

0800f100 <gc_get_plane_data>:
    switch (select) {
 800f100:	b141      	cbz	r1, 800f114 <gc_get_plane_data+0x14>
 800f102:	2901      	cmp	r1, #1
 800f104:	d00d      	beq.n	800f122 <gc_get_plane_data+0x22>
            plane->axis_0 = Y_AXIS;
 800f106:	2301      	movs	r3, #1
 800f108:	7003      	strb	r3, [r0, #0]
            plane->axis_1 = Z_AXIS;
 800f10a:	2302      	movs	r3, #2
 800f10c:	7043      	strb	r3, [r0, #1]
            plane->axis_linear = X_AXIS;
 800f10e:	2300      	movs	r3, #0
 800f110:	7083      	strb	r3, [r0, #2]
}
 800f112:	4770      	bx	lr
            plane->axis_0 = X_AXIS;
 800f114:	2300      	movs	r3, #0
 800f116:	7003      	strb	r3, [r0, #0]
            plane->axis_1 = Y_AXIS;
 800f118:	2301      	movs	r3, #1
 800f11a:	7043      	strb	r3, [r0, #1]
            plane->axis_linear = Z_AXIS;
 800f11c:	2302      	movs	r3, #2
 800f11e:	7083      	strb	r3, [r0, #2]
            break;
 800f120:	4770      	bx	lr
            plane->axis_0 = Z_AXIS;
 800f122:	2302      	movs	r3, #2
 800f124:	7003      	strb	r3, [r0, #0]
            plane->axis_1 = X_AXIS;
 800f126:	2300      	movs	r3, #0
 800f128:	7043      	strb	r3, [r0, #1]
            plane->axis_linear = Y_AXIS;
 800f12a:	2301      	movs	r3, #1
 800f12c:	7083      	strb	r3, [r0, #2]
            break;
 800f12e:	4770      	bx	lr

0800f130 <gc_init>:
{
 800f130:	b510      	push	{r4, lr}
 800f132:	b086      	sub	sp, #24
    if(sys.cold_start) {
 800f134:	4b3e      	ldr	r3, [pc, #248]	; (800f230 <gc_init+0x100>)
 800f136:	f893 307d 	ldrb.w	r3, [r3, #125]	; 0x7d
 800f13a:	b17b      	cbz	r3, 800f15c <gc_init+0x2c>
        memset(&gc_state, 0, sizeof(parser_state_t));
 800f13c:	4c3d      	ldr	r4, [pc, #244]	; (800f234 <gc_init+0x104>)
 800f13e:	2298      	movs	r2, #152	; 0x98
 800f140:	2100      	movs	r1, #0
 800f142:	4620      	mov	r0, r4
 800f144:	f013 fd17 	bl	8022b76 <memset>
        memset(&tool_table, 0, sizeof(tool_table));
 800f148:	4b3b      	ldr	r3, [pc, #236]	; (800f238 <gc_init+0x108>)
 800f14a:	2200      	movs	r2, #0
 800f14c:	601a      	str	r2, [r3, #0]
 800f14e:	605a      	str	r2, [r3, #4]
 800f150:	609a      	str	r2, [r3, #8]
 800f152:	60da      	str	r2, [r3, #12]
 800f154:	611a      	str	r2, [r3, #16]
        gc_state.tool = &tool_table;
 800f156:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
 800f15a:	e015      	b.n	800f188 <gc_init+0x58>
        memset(&gc_state, 0, offsetof(parser_state_t, g92_coord_offset));
 800f15c:	4c35      	ldr	r4, [pc, #212]	; (800f234 <gc_init+0x104>)
 800f15e:	227c      	movs	r2, #124	; 0x7c
 800f160:	2100      	movs	r1, #0
 800f162:	4620      	mov	r0, r4
 800f164:	f013 fd07 	bl	8022b76 <memset>
        gc_state.tool_pending = gc_state.tool->tool_id;
 800f168:	f8d4 0094 	ldr.w	r0, [r4, #148]	; 0x94
 800f16c:	6903      	ldr	r3, [r0, #16]
 800f16e:	6723      	str	r3, [r4, #112]	; 0x70
        if(hal.tool.select)
 800f170:	4b32      	ldr	r3, [pc, #200]	; (800f23c <gc_init+0x10c>)
 800f172:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 800f176:	b13b      	cbz	r3, 800f188 <gc_init+0x58>
            hal.tool.select(gc_state.tool, false);
 800f178:	2100      	movs	r1, #0
 800f17a:	4798      	blx	r3
 800f17c:	e004      	b.n	800f188 <gc_init+0x58>
        output_command_t *next = output_commands->next;
 800f17e:	6884      	ldr	r4, [r0, #8]
        free(output_commands);
 800f180:	f013 f99e 	bl	80224c0 <free>
        output_commands = next;
 800f184:	4b2e      	ldr	r3, [pc, #184]	; (800f240 <gc_init+0x110>)
 800f186:	601c      	str	r4, [r3, #0]
    while(output_commands) {
 800f188:	4b2d      	ldr	r3, [pc, #180]	; (800f240 <gc_init+0x110>)
 800f18a:	6818      	ldr	r0, [r3, #0]
 800f18c:	2800      	cmp	r0, #0
 800f18e:	d1f6      	bne.n	800f17e <gc_init+0x4e>
    gc_state.modal.override_ctrl = sys.override.control;
 800f190:	4c28      	ldr	r4, [pc, #160]	; (800f234 <gc_init+0x104>)
 800f192:	4b27      	ldr	r3, [pc, #156]	; (800f230 <gc_init+0x100>)
 800f194:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 800f198:	7723      	strb	r3, [r4, #28]
    gc_state.spindle.hal = spindle_get(0);
 800f19a:	f00e fbdb 	bl	801d954 <spindle_get>
 800f19e:	6560      	str	r0, [r4, #84]	; 0x54
    set_scaling(1.0f);
 800f1a0:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 800f1a4:	f7ff ff08 	bl	800efb8 <set_scaling>
    if (!settings_read_coord_data(gc_state.modal.coord_system.id, &gc_state.modal.coord_system.xyz))
 800f1a8:	f104 0108 	add.w	r1, r4, #8
 800f1ac:	7d20      	ldrb	r0, [r4, #20]
 800f1ae:	f00d fc21 	bl	801c9f4 <settings_read_coord_data>
 800f1b2:	b918      	cbnz	r0, 800f1bc <gc_init+0x8c>
        grbl.report.status_message(Status_SettingReadFail);
 800f1b4:	4b23      	ldr	r3, [pc, #140]	; (800f244 <gc_init+0x114>)
 800f1b6:	689b      	ldr	r3, [r3, #8]
 800f1b8:	2007      	movs	r0, #7
 800f1ba:	4798      	blx	r3
    if (sys.cold_start && !settings.flags.g92_is_volatile && !settings_read_coord_data(CoordinateSystem_G92, &gc_state.g92_coord_offset))
 800f1bc:	4b1c      	ldr	r3, [pc, #112]	; (800f230 <gc_init+0x100>)
 800f1be:	f893 307d 	ldrb.w	r3, [r3, #125]	; 0x7d
 800f1c2:	b12b      	cbz	r3, 800f1d0 <gc_init+0xa0>
 800f1c4:	4b20      	ldr	r3, [pc, #128]	; (800f248 <gc_init+0x118>)
 800f1c6:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
 800f1ca:	f013 0f02 	tst.w	r3, #2
 800f1ce:	d023      	beq.n	800f218 <gc_init+0xe8>
    if(grbl.on_wco_changed && (!sys.cold_start ||
 800f1d0:	4b1c      	ldr	r3, [pc, #112]	; (800f244 <gc_init+0x114>)
 800f1d2:	6adc      	ldr	r4, [r3, #44]	; 0x2c
 800f1d4:	b1cc      	cbz	r4, 800f20a <gc_init+0xda>
 800f1d6:	4b16      	ldr	r3, [pc, #88]	; (800f230 <gc_init+0x100>)
 800f1d8:	f893 307d 	ldrb.w	r3, [r3, #125]	; 0x7d
 800f1dc:	b1a3      	cbz	r3, 800f208 <gc_init+0xd8>
                                !is0_position_vector(gc_state.modal.coord_system.xyz) ||
 800f1de:	2300      	movs	r3, #0
 800f1e0:	9300      	str	r3, [sp, #0]
 800f1e2:	9301      	str	r3, [sp, #4]
 800f1e4:	9302      	str	r3, [sp, #8]
 800f1e6:	220c      	movs	r2, #12
 800f1e8:	4669      	mov	r1, sp
 800f1ea:	4818      	ldr	r0, [pc, #96]	; (800f24c <gc_init+0x11c>)
 800f1ec:	f013 fcb3 	bl	8022b56 <memcmp>
    if(grbl.on_wco_changed && (!sys.cold_start ||
 800f1f0:	b950      	cbnz	r0, 800f208 <gc_init+0xd8>
                                 !is0_position_vector(gc_state.g92_coord_offset)))
 800f1f2:	2300      	movs	r3, #0
 800f1f4:	9303      	str	r3, [sp, #12]
 800f1f6:	9304      	str	r3, [sp, #16]
 800f1f8:	9305      	str	r3, [sp, #20]
 800f1fa:	220c      	movs	r2, #12
 800f1fc:	eb0d 0102 	add.w	r1, sp, r2
 800f200:	4813      	ldr	r0, [pc, #76]	; (800f250 <gc_init+0x120>)
 800f202:	f013 fca8 	bl	8022b56 <memcmp>
                                !is0_position_vector(gc_state.modal.coord_system.xyz) ||
 800f206:	b100      	cbz	r0, 800f20a <gc_init+0xda>
        grbl.on_wco_changed();
 800f208:	47a0      	blx	r4
    if(grbl.on_parser_init)
 800f20a:	4b0e      	ldr	r3, [pc, #56]	; (800f244 <gc_init+0x114>)
 800f20c:	699b      	ldr	r3, [r3, #24]
 800f20e:	b10b      	cbz	r3, 800f214 <gc_init+0xe4>
        grbl.on_parser_init(&gc_state);
 800f210:	4808      	ldr	r0, [pc, #32]	; (800f234 <gc_init+0x104>)
 800f212:	4798      	blx	r3
}
 800f214:	b006      	add	sp, #24
 800f216:	bd10      	pop	{r4, pc}
    if (sys.cold_start && !settings.flags.g92_is_volatile && !settings_read_coord_data(CoordinateSystem_G92, &gc_state.g92_coord_offset))
 800f218:	490d      	ldr	r1, [pc, #52]	; (800f250 <gc_init+0x120>)
 800f21a:	200b      	movs	r0, #11
 800f21c:	f00d fbea 	bl	801c9f4 <settings_read_coord_data>
 800f220:	2800      	cmp	r0, #0
 800f222:	d1d5      	bne.n	800f1d0 <gc_init+0xa0>
        grbl.report.status_message(Status_SettingReadFail);
 800f224:	4b07      	ldr	r3, [pc, #28]	; (800f244 <gc_init+0x114>)
 800f226:	689b      	ldr	r3, [r3, #8]
 800f228:	2007      	movs	r0, #7
 800f22a:	4798      	blx	r3
 800f22c:	e7d0      	b.n	800f1d0 <gc_init+0xa0>
 800f22e:	bf00      	nop
 800f230:	200036c4 	.word	0x200036c4
 800f234:	20003344 	.word	0x20003344
 800f238:	20003424 	.word	0x20003424
 800f23c:	2000350c 	.word	0x2000350c
 800f240:	200033dc 	.word	0x200033dc
 800f244:	2000343c 	.word	0x2000343c
 800f248:	20003b14 	.word	0x20003b14
 800f24c:	2000334c 	.word	0x2000334c
 800f250:	200033c0 	.word	0x200033c0

0800f254 <gc_spindle_off>:
{
 800f254:	b508      	push	{r3, lr}
    gc_state.spindle.rpm = 0.0f;
 800f256:	4b05      	ldr	r3, [pc, #20]	; (800f26c <gc_spindle_off+0x18>)
 800f258:	2200      	movs	r2, #0
 800f25a:	649a      	str	r2, [r3, #72]	; 0x48
    gc_state.modal.spindle.state.value = 0;
 800f25c:	2200      	movs	r2, #0
 800f25e:	769a      	strb	r2, [r3, #26]
    spindle_all_off();
 800f260:	f00e fd66 	bl	801dd30 <spindle_all_off>
    system_add_rt_report(Report_Spindle);
 800f264:	2010      	movs	r0, #16
 800f266:	f011 ffeb 	bl	8021240 <system_add_rt_report>
}
 800f26a:	bd08      	pop	{r3, pc}
 800f26c:	20003344 	.word	0x20003344

0800f270 <gc_coolant_off>:
{
 800f270:	b508      	push	{r3, lr}
    gc_state.modal.coolant.value = 0;
 800f272:	2000      	movs	r0, #0
 800f274:	4b04      	ldr	r3, [pc, #16]	; (800f288 <gc_coolant_off+0x18>)
 800f276:	7658      	strb	r0, [r3, #25]
    hal.coolant.set_state(gc_state.modal.coolant);
 800f278:	4b04      	ldr	r3, [pc, #16]	; (800f28c <gc_coolant_off+0x1c>)
 800f27a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800f27c:	4798      	blx	r3
    system_add_rt_report(Report_Coolant);
 800f27e:	2020      	movs	r0, #32
 800f280:	f011 ffde 	bl	8021240 <system_add_rt_report>
}
 800f284:	bd08      	pop	{r3, pc}
 800f286:	bf00      	nop
 800f288:	20003344 	.word	0x20003344
 800f28c:	2000350c 	.word	0x2000350c

0800f290 <gc_spindle_get>:
}
 800f290:	4b01      	ldr	r3, [pc, #4]	; (800f298 <gc_spindle_get+0x8>)
 800f292:	6d58      	ldr	r0, [r3, #84]	; 0x54
 800f294:	4770      	bx	lr
 800f296:	bf00      	nop
 800f298:	20003344 	.word	0x20003344

0800f29c <gc_normalize_block>:
// else the block delete character. Remaining characters are converted to upper case.
// If the driver handles message comments then the first is extracted and returned in a dynamically
// allocated memory block, the caller must free this after the message has been processed.

char *gc_normalize_block (char *block, char **message)
{
 800f29c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800f2a0:	4604      	mov	r4, r0
 800f2a2:	460f      	mov	r7, r1
    char c, *s1, *s2, *comment = NULL;

    // Remove leading whitespace & control characters
    while(*block && *block <= ' ')
 800f2a4:	e000      	b.n	800f2a8 <gc_normalize_block+0xc>
        block++;
 800f2a6:	3401      	adds	r4, #1
    while(*block && *block <= ' ')
 800f2a8:	7822      	ldrb	r2, [r4, #0]
 800f2aa:	1e53      	subs	r3, r2, #1
 800f2ac:	b2db      	uxtb	r3, r3
 800f2ae:	2b1f      	cmp	r3, #31
 800f2b0:	d9f9      	bls.n	800f2a6 <gc_normalize_block+0xa>

    if(*block == ';' || (*block == '/' && sys.flags.block_delete_enabled)) {
 800f2b2:	2a3b      	cmp	r2, #59	; 0x3b
 800f2b4:	d00c      	beq.n	800f2d0 <gc_normalize_block+0x34>
 800f2b6:	2a2f      	cmp	r2, #47	; 0x2f
 800f2b8:	d005      	beq.n	800f2c6 <gc_normalize_block+0x2a>
        *block = '\0';
        return block;
    }

    if(*block == '/')
 800f2ba:	2a2f      	cmp	r2, #47	; 0x2f
 800f2bc:	d00c      	beq.n	800f2d8 <gc_normalize_block+0x3c>
        block++;

    s1 = s2 = block;
 800f2be:	46a0      	mov	r8, r4
 800f2c0:	4625      	mov	r5, r4
    char c, *s1, *s2, *comment = NULL;
 800f2c2:	2600      	movs	r6, #0

    while((c = *s1) != '\0') {
 800f2c4:	e060      	b.n	800f388 <gc_normalize_block+0xec>
    if(*block == ';' || (*block == '/' && sys.flags.block_delete_enabled)) {
 800f2c6:	4b41      	ldr	r3, [pc, #260]	; (800f3cc <gc_normalize_block+0x130>)
 800f2c8:	7d9b      	ldrb	r3, [r3, #22]
 800f2ca:	f013 0f10 	tst.w	r3, #16
 800f2ce:	d0f4      	beq.n	800f2ba <gc_normalize_block+0x1e>
        *block = '\0';
 800f2d0:	2300      	movs	r3, #0
 800f2d2:	7023      	strb	r3, [r4, #0]
        return block;
 800f2d4:	4620      	mov	r0, r4
 800f2d6:	e076      	b.n	800f3c6 <gc_normalize_block+0x12a>
        block++;
 800f2d8:	3401      	adds	r4, #1
 800f2da:	e7f0      	b.n	800f2be <gc_normalize_block+0x22>

        if(c > ' ') switch(c) {

            case ';':
                if(!comment) {
 800f2dc:	2e00      	cmp	r6, #0
 800f2de:	d146      	bne.n	800f36e <gc_normalize_block+0xd2>
                    *s1 = '\0';
 800f2e0:	2300      	movs	r3, #0
 800f2e2:	702b      	strb	r3, [r5, #0]
                    continue;
 800f2e4:	e050      	b.n	800f388 <gc_normalize_block+0xec>
                // TODO: generate error if a left parenthesis is found inside a comment...
                comment = s1;
                break;

            case ')':
                if(comment && !gc_state.skip_blocks) {
 800f2e6:	2e00      	cmp	r6, #0
 800f2e8:	d04d      	beq.n	800f386 <gc_normalize_block+0xea>
 800f2ea:	4b39      	ldr	r3, [pc, #228]	; (800f3d0 <gc_normalize_block+0x134>)
 800f2ec:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
 800f2f0:	2b00      	cmp	r3, #0
 800f2f2:	d15f      	bne.n	800f3b4 <gc_normalize_block+0x118>
                    *s1 = '\0';
 800f2f4:	702b      	strb	r3, [r5, #0]
                    if(!hal.driver_cap.no_gcode_message_handling) {
 800f2f6:	4b37      	ldr	r3, [pc, #220]	; (800f3d4 <gc_normalize_block+0x138>)
 800f2f8:	f893 31a6 	ldrb.w	r3, [r3, #422]	; 0x1a6
 800f2fc:	f013 0f02 	tst.w	r3, #2
 800f300:	d106      	bne.n	800f310 <gc_normalize_block+0x74>

                        size_t len = s1 - comment - 4;
 800f302:	eba5 0906 	sub.w	r9, r5, r6
 800f306:	f1a9 0904 	sub.w	r9, r9, #4

                        if(message && *message == NULL && !strncmp(comment, "(MSG,", 5) && (*message = malloc(len))) {
 800f30a:	b10f      	cbz	r7, 800f310 <gc_normalize_block+0x74>
 800f30c:	683b      	ldr	r3, [r7, #0]
 800f30e:	b14b      	cbz	r3, 800f324 <gc_normalize_block+0x88>
                            *comment = '\0'; // Do not generate grbl.on_gcode_comment event!
                        }
#endif // NGC_EXPRESSIONS_ENABLE
                    }

                    if(*comment && *message == NULL && grbl.on_gcode_comment)
 800f310:	7833      	ldrb	r3, [r6, #0]
 800f312:	2b00      	cmp	r3, #0
 800f314:	d050      	beq.n	800f3b8 <gc_normalize_block+0x11c>
 800f316:	f8d7 9000 	ldr.w	r9, [r7]
 800f31a:	f1b9 0f00 	cmp.w	r9, #0
 800f31e:	d01b      	beq.n	800f358 <gc_normalize_block+0xbc>
                        grbl.on_gcode_comment(comment);
                }
                comment = NULL;
 800f320:	2600      	movs	r6, #0
 800f322:	e030      	b.n	800f386 <gc_normalize_block+0xea>
                        if(message && *message == NULL && !strncmp(comment, "(MSG,", 5) && (*message = malloc(len))) {
 800f324:	2205      	movs	r2, #5
 800f326:	492c      	ldr	r1, [pc, #176]	; (800f3d8 <gc_normalize_block+0x13c>)
 800f328:	4630      	mov	r0, r6
 800f32a:	f013 fc48 	bl	8022bbe <strncmp>
 800f32e:	2800      	cmp	r0, #0
 800f330:	d1ee      	bne.n	800f310 <gc_normalize_block+0x74>
 800f332:	4648      	mov	r0, r9
 800f334:	f013 f8bc 	bl	80224b0 <malloc>
 800f338:	6038      	str	r0, [r7, #0]
 800f33a:	2800      	cmp	r0, #0
 800f33c:	d0e8      	beq.n	800f310 <gc_normalize_block+0x74>
                            comment += 5;
 800f33e:	3605      	adds	r6, #5
                            while(*comment == ' ') {
 800f340:	e002      	b.n	800f348 <gc_normalize_block+0xac>
                                comment++;
 800f342:	3601      	adds	r6, #1
                                len--;
 800f344:	f109 39ff 	add.w	r9, r9, #4294967295
                            while(*comment == ' ') {
 800f348:	7833      	ldrb	r3, [r6, #0]
 800f34a:	2b20      	cmp	r3, #32
 800f34c:	d0f9      	beq.n	800f342 <gc_normalize_block+0xa6>
                            memcpy(*message, comment, len);
 800f34e:	464a      	mov	r2, r9
 800f350:	4631      	mov	r1, r6
 800f352:	f013 fd6d 	bl	8022e30 <memcpy>
 800f356:	e7db      	b.n	800f310 <gc_normalize_block+0x74>
                    if(*comment && *message == NULL && grbl.on_gcode_comment)
 800f358:	4b20      	ldr	r3, [pc, #128]	; (800f3dc <gc_normalize_block+0x140>)
 800f35a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800f35e:	b36b      	cbz	r3, 800f3bc <gc_normalize_block+0x120>
                        grbl.on_gcode_comment(comment);
 800f360:	4630      	mov	r0, r6
 800f362:	4798      	blx	r3
                comment = NULL;
 800f364:	464e      	mov	r6, r9
 800f366:	e00e      	b.n	800f386 <gc_normalize_block+0xea>
                break;

            default:
                if(comment == NULL)
                    *s2++ = CAPS(c);
 800f368:	461a      	mov	r2, r3
 800f36a:	e020      	b.n	800f3ae <gc_normalize_block+0x112>
        if(c > ' ') switch(c) {
 800f36c:	462e      	mov	r6, r5

#if NGC_EXPRESSIONS_ENABLE
        if(comment && s1 - comment < (strncmp(comment, "(DEBU,", 5) ? 5 : 7))
            *s1 = CAPS(c);
#else
        if(comment && s1 - comment < 5)
 800f36e:	b156      	cbz	r6, 800f386 <gc_normalize_block+0xea>
 800f370:	1baa      	subs	r2, r5, r6
 800f372:	2a04      	cmp	r2, #4
 800f374:	dc07      	bgt.n	800f386 <gc_normalize_block+0xea>
            *s1 = CAPS(c);
 800f376:	f1a3 0261 	sub.w	r2, r3, #97	; 0x61
 800f37a:	b2d2      	uxtb	r2, r2
 800f37c:	2a19      	cmp	r2, #25
 800f37e:	d801      	bhi.n	800f384 <gc_normalize_block+0xe8>
 800f380:	f003 035f 	and.w	r3, r3, #95	; 0x5f
 800f384:	702b      	strb	r3, [r5, #0]
#endif
        s1++;
 800f386:	3501      	adds	r5, #1
    while((c = *s1) != '\0') {
 800f388:	782b      	ldrb	r3, [r5, #0]
 800f38a:	b1cb      	cbz	r3, 800f3c0 <gc_normalize_block+0x124>
        if(c > ' ') switch(c) {
 800f38c:	2b20      	cmp	r3, #32
 800f38e:	d9ee      	bls.n	800f36e <gc_normalize_block+0xd2>
 800f390:	2b29      	cmp	r3, #41	; 0x29
 800f392:	d0a8      	beq.n	800f2e6 <gc_normalize_block+0x4a>
 800f394:	2b3b      	cmp	r3, #59	; 0x3b
 800f396:	d0a1      	beq.n	800f2dc <gc_normalize_block+0x40>
 800f398:	2b28      	cmp	r3, #40	; 0x28
 800f39a:	d0e7      	beq.n	800f36c <gc_normalize_block+0xd0>
                if(comment == NULL)
 800f39c:	2e00      	cmp	r6, #0
 800f39e:	d1e6      	bne.n	800f36e <gc_normalize_block+0xd2>
                    *s2++ = CAPS(c);
 800f3a0:	f1a3 0261 	sub.w	r2, r3, #97	; 0x61
 800f3a4:	b2d2      	uxtb	r2, r2
 800f3a6:	2a19      	cmp	r2, #25
 800f3a8:	d8de      	bhi.n	800f368 <gc_normalize_block+0xcc>
 800f3aa:	f003 025f 	and.w	r2, r3, #95	; 0x5f
 800f3ae:	f808 2b01 	strb.w	r2, [r8], #1
 800f3b2:	e7dc      	b.n	800f36e <gc_normalize_block+0xd2>
                comment = NULL;
 800f3b4:	2600      	movs	r6, #0
 800f3b6:	e7e6      	b.n	800f386 <gc_normalize_block+0xea>
 800f3b8:	2600      	movs	r6, #0
 800f3ba:	e7e4      	b.n	800f386 <gc_normalize_block+0xea>
 800f3bc:	464e      	mov	r6, r9
 800f3be:	e7e2      	b.n	800f386 <gc_normalize_block+0xea>
    }

    *s2 = '\0';
 800f3c0:	f888 3000 	strb.w	r3, [r8]

    return block;
 800f3c4:	4620      	mov	r0, r4
}
 800f3c6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800f3ca:	bf00      	nop
 800f3cc:	200036c4 	.word	0x200036c4
 800f3d0:	20003344 	.word	0x20003344
 800f3d4:	2000350c 	.word	0x2000350c
 800f3d8:	080269ec 	.word	0x080269ec
 800f3dc:	2000343c 	.word	0x2000343c

0800f3e0 <gc_execute_block>:
// Parses and executes one block (line) of 0-terminated G-Code.
// In this function, all units and positions are converted and exported to internal functions
// in terms of (mm, mm/min) and absolute machine coordinates, respectively.

status_code_t gc_execute_block (char *block)
{
 800f3e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f3e4:	ed2d 8b06 	vpush	{d8-d10}
 800f3e8:	b0a3      	sub	sp, #140	; 0x8c
       { &gc_block.values.xyz[Z_AXIS], ValueType_Float }
    };

#endif

    char *message = NULL;
 800f3ea:	2300      	movs	r3, #0
 800f3ec:	9321      	str	r3, [sp, #132]	; 0x84

    block = gc_normalize_block(block, &message);
 800f3ee:	a921      	add	r1, sp, #132	; 0x84
 800f3f0:	f7ff ff54 	bl	800f29c <gc_normalize_block>

    if(block[0] == '\0') {
 800f3f4:	7804      	ldrb	r4, [r0, #0]
 800f3f6:	b364      	cbz	r4, 800f452 <gc_execute_block+0x72>
 800f3f8:	4606      	mov	r6, r0
    // Old comment from protocol.c:
    // NOTE: This maybe installed to tell Grbl when a program is running vs manual input,
    // where, during a program, the system auto-cycle start will continue to execute
    // everything until the next '%' sign. This will help fix resuming issues with certain
    // functions that empty the planner buffer to execute its task on-time.
    if (block[0] == CMD_PROGRAM_DEMARCATION && block[1] == '\0') {
 800f3fa:	2c25      	cmp	r4, #37	; 0x25
 800f3fc:	d101      	bne.n	800f402 <gc_execute_block+0x22>
 800f3fe:	7844      	ldrb	r4, [r0, #1]
 800f400:	b374      	cbz	r4, 800f460 <gc_execute_block+0x80>
     updates these modes and commands as the block line is parsed and will only be used and
     executed after successful error-checking. The parser block struct also contains a block
     values struct, word tracking variables, and a non-modal commands tracker for the new
     block. This struct contains all of the necessary information to execute the block. */

    memset(&gc_block, 0, sizeof(gc_block));                           // Initialize the parser block struct.
 800f402:	4c9a      	ldr	r4, [pc, #616]	; (800f66c <gc_execute_block+0x28c>)
 800f404:	22ac      	movs	r2, #172	; 0xac
 800f406:	2100      	movs	r1, #0
 800f408:	4620      	mov	r0, r4
 800f40a:	f013 fbb4 	bl	8022b76 <memset>
    memcpy(&gc_block.modal, &gc_state.modal, sizeof(gc_state.modal)); // Copy current modes
 800f40e:	3408      	adds	r4, #8
 800f410:	4d97      	ldr	r5, [pc, #604]	; (800f670 <gc_execute_block+0x290>)
 800f412:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800f414:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800f416:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800f418:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800f41a:	e895 0003 	ldmia.w	r5, {r0, r1}
 800f41e:	e884 0003 	stmia.w	r4, {r0, r1}
    axis_command_t axis_command = AxisCommand_None;
    io_mcode_t port_command = (io_mcode_t)0;
    plane_t plane;

    // Initialize bitflag tracking variables for axis indices compatible operations.
    axes_signals_t axis_words = {0}; // XYZ tracking
 800f422:	f04f 0800 	mov.w	r8, #0
 800f426:	46c3      	mov	fp, r8
    ijk_words_t ijk_words = {0}; // IJK tracking
 800f428:	f8cd 8010 	str.w	r8, [sp, #16]

    // Initialize command and value words and parser flags variables.
    modal_groups_t command_words = {0};         // Bitfield for tracking G and M command words. Also used for modal group violations.
 800f42c:	4647      	mov	r7, r8
    gc_parser_flags_t gc_parser_flags = {0};    // Parser flags for handling special cases.
    static parameter_words_t user_words = {0};  // User M-code words "taken"

    // Determine if the line is a jogging motion or a normal g-code block.
    if (block[0] == '$') { // NOTE: `$J=` already parsed when passed to this function.
 800f42e:	7833      	ldrb	r3, [r6, #0]
 800f430:	2b24      	cmp	r3, #36	; 0x24
 800f432:	d023      	beq.n	800f47c <gc_execute_block+0x9c>
     STEP 2: Import all g-code words in the block. A g-code word is a letter followed by
     a number, which can either be a 'G'/'M' command or sets/assigns a command value. Also,
     perform initial error-checks for command word modal group violations, for any repeated
     words, and for negative values set for the value words F, N, P, T, and S. */

    uint_fast8_t char_counter = gc_parser_flags.jog_motion ? 3 /* Start parsing after `$J=` */ : 0;
 800f434:	f018 0f01 	tst.w	r8, #1
 800f438:	d02b      	beq.n	800f492 <gc_execute_block+0xb2>
 800f43a:	2303      	movs	r3, #3
 800f43c:	931f      	str	r3, [sp, #124]	; 0x7c
    char letter;
    float value;
    uint32_t int_value = 0;
    uint_fast16_t mantissa = 0;
    bool is_user_mcode = false;
    word_bit_t word_bit = { .parameter = {0}, .modal_group = {0} }; // Bit-value for assigning tracking variables
 800f43e:	2300      	movs	r3, #0
 800f440:	931c      	str	r3, [sp, #112]	; 0x70
 800f442:	931d      	str	r3, [sp, #116]	; 0x74
    bool is_user_mcode = false;
 800f444:	4699      	mov	r9, r3
    uint32_t int_value = 0;
 800f446:	461c      	mov	r4, r3
    io_mcode_t port_command = (io_mcode_t)0;
 800f448:	9305      	str	r3, [sp, #20]
    axis_command_t axis_command = AxisCommand_None;
 800f44a:	469a      	mov	sl, r3
    bool set_tool = false, spindle_programmed = false;
 800f44c:	9306      	str	r3, [sp, #24]

    while ((letter = block[char_counter++]) != '\0') { // Loop until no more g-code words in block.
 800f44e:	f000 bc6f 	b.w	800fd30 <gc_execute_block+0x950>
        if(message)
 800f452:	9821      	ldr	r0, [sp, #132]	; 0x84
 800f454:	2800      	cmp	r0, #0
 800f456:	f000 8099 	beq.w	800f58c <gc_execute_block+0x1ac>
            output_message(message);
 800f45a:	f7ff fd77 	bl	800ef4c <output_message>
        return Status_OK;
 800f45e:	e095      	b.n	800f58c <gc_execute_block+0x1ac>
        gc_state.file_run = !gc_state.file_run;
 800f460:	4a83      	ldr	r2, [pc, #524]	; (800f670 <gc_execute_block+0x290>)
 800f462:	f892 3074 	ldrb.w	r3, [r2, #116]	; 0x74
 800f466:	f083 0301 	eor.w	r3, r3, #1
 800f46a:	f882 3074 	strb.w	r3, [r2, #116]	; 0x74
        if(message)
 800f46e:	9821      	ldr	r0, [sp, #132]	; 0x84
 800f470:	2800      	cmp	r0, #0
 800f472:	f000 808b 	beq.w	800f58c <gc_execute_block+0x1ac>
            output_message(message);
 800f476:	f7ff fd69 	bl	800ef4c <output_message>
        return Status_OK;
 800f47a:	e087      	b.n	800f58c <gc_execute_block+0x1ac>
        gc_parser_flags.jog_motion = On;
 800f47c:	f04f 0801 	mov.w	r8, #1
        gc_block.modal.motion = MotionMode_Linear;
 800f480:	f1a4 0328 	sub.w	r3, r4, #40	; 0x28
 800f484:	2201      	movs	r2, #1
 800f486:	811a      	strh	r2, [r3, #8]
        gc_block.modal.feed_mode = FeedMode_UnitsPerMin;
 800f488:	f883 b00a 	strb.w	fp, [r3, #10]
        gc_block.modal.spindle.rpm_mode = SpindleSpeedMode_RPM;
 800f48c:	f883 b023 	strb.w	fp, [r3, #35]	; 0x23
        gc_block.values.n = JOG_LINE_NUMBER; // Initialize default line number reported during jog.
 800f490:	e7d0      	b.n	800f434 <gc_execute_block+0x54>
    uint_fast8_t char_counter = gc_parser_flags.jog_motion ? 3 /* Start parsing after `$J=` */ : 0;
 800f492:	2300      	movs	r3, #0
 800f494:	e7d2      	b.n	800f43c <gc_execute_block+0x5c>
        // accurate enough for value words that require integers to within 0.0001. This should be
        // a good enough compromise and catch most all non-integer errors. To make it compliant,
        // we would simply need to change the mantissa to int16, but this add compiled flash space.
        // Maybe update this later.
        if(isnan(value))
            mantissa = 0;
 800f496:	2100      	movs	r1, #0
 800f498:	f000 bc7f 	b.w	800fd9a <gc_execute_block+0x9ba>
             NOTE: Modal group numbers are defined in Table 4 of NIST RS274-NGC v3, pg.20 */

            case 'G': // Determine 'G' command and its modal group

                is_user_mcode = false;
                word_bit.modal_group.mask = 0;
 800f49c:	2300      	movs	r3, #0
 800f49e:	931d      	str	r3, [sp, #116]	; 0x74

                switch(int_value) {
 800f4a0:	2c41      	cmp	r4, #65	; 0x41
 800f4a2:	d858      	bhi.n	800f556 <gc_execute_block+0x176>
 800f4a4:	2c41      	cmp	r4, #65	; 0x41
 800f4a6:	f203 8273 	bhi.w	8012990 <gc_execute_block+0x35b0>
 800f4aa:	e8df f014 	tbh	[pc, r4, lsl #1]
 800f4ae:	00f3      	.short	0x00f3
 800f4b0:	00f300f3 	.word	0x00f300f3
 800f4b4:	009000f3 	.word	0x009000f3
 800f4b8:	1a7100f3 	.word	0x1a7100f3
 800f4bc:	00770077 	.word	0x00770077
 800f4c0:	00891a71 	.word	0x00891a71
 800f4c4:	1a711a71 	.word	0x1a711a71
 800f4c8:	1a711a71 	.word	0x1a711a71
 800f4cc:	1a711a71 	.word	0x1a711a71
 800f4d0:	01360136 	.word	0x01360136
 800f4d4:	01730136 	.word	0x01730136
 800f4d8:	1a710173 	.word	0x1a710173
 800f4dc:	1a711a71 	.word	0x1a711a71
 800f4e0:	1a711a71 	.word	0x1a711a71
 800f4e4:	00891a71 	.word	0x00891a71
 800f4e8:	00891a71 	.word	0x00891a71
 800f4ec:	1a711a71 	.word	0x1a711a71
 800f4f0:	1a7100b7 	.word	0x1a7100b7
 800f4f4:	1a711a71 	.word	0x1a711a71
 800f4f8:	00cc1a71 	.word	0x00cc1a71
 800f4fc:	01801a71 	.word	0x01801a71
 800f500:	1a711a71 	.word	0x1a711a71
 800f504:	1a710187 	.word	0x1a710187
 800f508:	1a711a71 	.word	0x1a711a71
 800f50c:	1a711a71 	.word	0x1a711a71
 800f510:	023c0187 	.word	0x023c0187
 800f514:	1a71023c 	.word	0x1a71023c
 800f518:	01a20090 	.word	0x01a20090
 800f51c:	01a201a2 	.word	0x01a201a2
 800f520:	01a201a2 	.word	0x01a201a2
 800f524:	1a7101a2 	.word	0x1a7101a2
 800f528:	1a7101fe 	.word	0x1a7101fe
 800f52c:	1a711a71 	.word	0x1a711a71
 800f530:	0209      	.short	0x0209
 800f532:	f1a4 0249 	sub.w	r2, r4, #73	; 0x49
 800f536:	2301      	movs	r3, #1
 800f538:	4093      	lsls	r3, r2
 800f53a:	4a4e      	ldr	r2, [pc, #312]	; (800f674 <gc_execute_block+0x294>)
 800f53c:	401a      	ands	r2, r3
 800f53e:	2a00      	cmp	r2, #0
 800f540:	f040 80d1 	bne.w	800f6e6 <gc_execute_block+0x306>
 800f544:	f013 0f80 	tst.w	r3, #128	; 0x80
 800f548:	f040 80aa 	bne.w	800f6a0 <gc_execute_block+0x2c0>
 800f54c:	f013 0f08 	tst.w	r3, #8
 800f550:	d164      	bne.n	800f61c <gc_execute_block+0x23c>
 800f552:	2414      	movs	r4, #20
 800f554:	e01a      	b.n	800f58c <gc_execute_block+0x1ac>
 800f556:	2c59      	cmp	r4, #89	; 0x59
 800f558:	d915      	bls.n	800f586 <gc_execute_block+0x1a6>
 800f55a:	2c63      	cmp	r4, #99	; 0x63
 800f55c:	f203 821b 	bhi.w	8012996 <gc_execute_block+0x35b6>
 800f560:	2c5a      	cmp	r4, #90	; 0x5a
 800f562:	d319      	bcc.n	800f598 <gc_execute_block+0x1b8>
 800f564:	f1a4 035a 	sub.w	r3, r4, #90	; 0x5a
 800f568:	2b09      	cmp	r3, #9
 800f56a:	f203 820e 	bhi.w	801298a <gc_execute_block+0x35aa>
 800f56e:	e8df f013 	tbh	[pc, r3, lsl #1]
 800f572:	00df      	.short	0x00df
 800f574:	002700df 	.word	0x002700df
 800f578:	00fb00fb 	.word	0x00fb00fb
 800f57c:	01ba0107 	.word	0x01ba0107
 800f580:	01ce01ba 	.word	0x01ce01ba
 800f584:	01ce      	.short	0x01ce
 800f586:	2c49      	cmp	r4, #73	; 0x49
 800f588:	d2d3      	bcs.n	800f532 <gc_execute_block+0x152>
 800f58a:	2414      	movs	r4, #20
#endif

    // TODO: % to denote start of program.

    return Status_OK;
}
 800f58c:	4620      	mov	r0, r4
 800f58e:	b023      	add	sp, #140	; 0x8c
 800f590:	ecbd 8b06 	vpop	{d8-d10}
 800f594:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800f598:	2414      	movs	r4, #20
 800f59a:	e7f7      	b.n	800f58c <gc_execute_block+0x1ac>
                        if(settings.mode == Mode_Lathe) {
 800f59c:	4b36      	ldr	r3, [pc, #216]	; (800f678 <gc_execute_block+0x298>)
 800f59e:	7e1b      	ldrb	r3, [r3, #24]
 800f5a0:	2b02      	cmp	r3, #2
 800f5a2:	f043 81fb 	bne.w	801299c <gc_execute_block+0x35bc>
                            word_bit.modal_group.G15 = On;
 800f5a6:	f89d 3075 	ldrb.w	r3, [sp, #117]	; 0x75
 800f5aa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800f5ae:	f88d 3075 	strb.w	r3, [sp, #117]	; 0x75
                            gc_block.modal.diameter_mode = int_value == 7; // TODO: find specs for implementation, only affects X calculation? reporting? current position?
 800f5b2:	2c07      	cmp	r4, #7
 800f5b4:	bf14      	ite	ne
 800f5b6:	2200      	movne	r2, #0
 800f5b8:	2201      	moveq	r2, #1
 800f5ba:	4b2c      	ldr	r3, [pc, #176]	; (800f66c <gc_execute_block+0x28c>)
 800f5bc:	735a      	strb	r2, [r3, #13]
                        break;
 800f5be:	e07d      	b.n	800f6bc <gc_execute_block+0x2dc>
                        if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
 800f5c0:	b929      	cbnz	r1, 800f5ce <gc_execute_block+0x1ee>
                            if (axis_command)
 800f5c2:	f1ba 0f00 	cmp.w	sl, #0
 800f5c6:	f043 81ec 	bne.w	80129a2 <gc_execute_block+0x35c2>
                            axis_command = AxisCommand_NonModal;
 800f5ca:	f04f 0a01 	mov.w	sl, #1
                        word_bit.modal_group.G0 = On;
 800f5ce:	f89d 3074 	ldrb.w	r3, [sp, #116]	; 0x74
 800f5d2:	f043 0301 	orr.w	r3, r3, #1
 800f5d6:	f88d 3074 	strb.w	r3, [sp, #116]	; 0x74
                        gc_block.non_modal_command = (non_modal_t)int_value;
 800f5da:	b2e3      	uxtb	r3, r4
 800f5dc:	4a23      	ldr	r2, [pc, #140]	; (800f66c <gc_execute_block+0x28c>)
 800f5de:	7013      	strb	r3, [r2, #0]
                        if ((int_value == 28) || (int_value == 30)) {
 800f5e0:	2c1c      	cmp	r4, #28
 800f5e2:	d00d      	beq.n	800f600 <gc_execute_block+0x220>
 800f5e4:	2c1e      	cmp	r4, #30
 800f5e6:	d00b      	beq.n	800f600 <gc_execute_block+0x220>
                        } else if (int_value == 92) {
 800f5e8:	2c5c      	cmp	r4, #92	; 0x5c
 800f5ea:	d167      	bne.n	800f6bc <gc_execute_block+0x2dc>
                            if (!((mantissa == 0) || (mantissa == 10) || (mantissa == 20) || (mantissa == 30)))
 800f5ec:	291e      	cmp	r1, #30
 800f5ee:	f203 81de 	bhi.w	80129ae <gc_execute_block+0x35ce>
 800f5f2:	4a22      	ldr	r2, [pc, #136]	; (800f67c <gc_execute_block+0x29c>)
 800f5f4:	40ca      	lsrs	r2, r1
 800f5f6:	f012 0f01 	tst.w	r2, #1
 800f5fa:	d10a      	bne.n	800f612 <gc_execute_block+0x232>
                        } else if (int_value == 92) {
 800f5fc:	2414      	movs	r4, #20
 800f5fe:	e7c5      	b.n	800f58c <gc_execute_block+0x1ac>
                            if (!((mantissa == 0) || (mantissa == 10)))
 800f600:	b111      	cbz	r1, 800f608 <gc_execute_block+0x228>
 800f602:	290a      	cmp	r1, #10
 800f604:	f043 81d0 	bne.w	80129a8 <gc_execute_block+0x35c8>
                            gc_block.non_modal_command += mantissa;
 800f608:	440b      	add	r3, r1
 800f60a:	4a18      	ldr	r2, [pc, #96]	; (800f66c <gc_execute_block+0x28c>)
 800f60c:	7013      	strb	r3, [r2, #0]
                            mantissa = 0; // Set to zero to indicate valid non-integer G command.
 800f60e:	2100      	movs	r1, #0
 800f610:	e054      	b.n	800f6bc <gc_execute_block+0x2dc>
                            gc_block.non_modal_command += mantissa;
 800f612:	440b      	add	r3, r1
 800f614:	4a15      	ldr	r2, [pc, #84]	; (800f66c <gc_execute_block+0x28c>)
 800f616:	7013      	strb	r3, [r2, #0]
                            mantissa = 0; // Set to zero to indicate valid non-integer G command.
 800f618:	2100      	movs	r1, #0
 800f61a:	e04f      	b.n	800f6bc <gc_execute_block+0x2dc>
                        if(mantissa != 0)
 800f61c:	2900      	cmp	r1, #0
 800f61e:	f043 81c9 	bne.w	80129b4 <gc_execute_block+0x35d4>
                        if (axis_command)
 800f622:	f1ba 0f00 	cmp.w	sl, #0
 800f626:	f043 81c8 	bne.w	80129ba <gc_execute_block+0x35da>
                        word_bit.modal_group.G1 = On;
 800f62a:	f89d 3074 	ldrb.w	r3, [sp, #116]	; 0x74
 800f62e:	f043 0302 	orr.w	r3, r3, #2
 800f632:	f88d 3074 	strb.w	r3, [sp, #116]	; 0x74
                        gc_block.modal.motion = (motion_mode_t)int_value;
 800f636:	4b0d      	ldr	r3, [pc, #52]	; (800f66c <gc_execute_block+0x28c>)
 800f638:	811c      	strh	r4, [r3, #8]
                        gc_block.modal.canned_cycle_active = false;
 800f63a:	2200      	movs	r2, #0
 800f63c:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
                        axis_command = AxisCommand_MotionMode;
 800f640:	f04f 0a02 	mov.w	sl, #2
                        break;
 800f644:	e03a      	b.n	800f6bc <gc_execute_block+0x2dc>
                        if(!(hal.probe.get_state && ((mantissa == 20) || (mantissa == 30) || (mantissa == 40) || (mantissa == 50))))
 800f646:	4b0e      	ldr	r3, [pc, #56]	; (800f680 <gc_execute_block+0x2a0>)
 800f648:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 800f64c:	2b00      	cmp	r3, #0
 800f64e:	f003 81b7 	beq.w	80129c0 <gc_execute_block+0x35e0>
 800f652:	f1a1 0214 	sub.w	r2, r1, #20
 800f656:	2a1e      	cmp	r2, #30
 800f658:	f203 81b5 	bhi.w	80129c6 <gc_execute_block+0x35e6>
 800f65c:	4b07      	ldr	r3, [pc, #28]	; (800f67c <gc_execute_block+0x29c>)
 800f65e:	40d3      	lsrs	r3, r2
 800f660:	f013 0f01 	tst.w	r3, #1
 800f664:	d10e      	bne.n	800f684 <gc_execute_block+0x2a4>
 800f666:	2414      	movs	r4, #20
 800f668:	e790      	b.n	800f58c <gc_execute_block+0x1ac>
 800f66a:	bf00      	nop
 800f66c:	20003298 	.word	0x20003298
 800f670:	20003344 	.word	0x20003344
 800f674:	00013701 	.word	0x00013701
 800f678:	20003b14 	.word	0x20003b14
 800f67c:	40100401 	.word	0x40100401
 800f680:	2000350c 	.word	0x2000350c
                        int_value += (mantissa / 10) + 100;
 800f684:	4bb0      	ldr	r3, [pc, #704]	; (800f948 <gc_execute_block+0x568>)
 800f686:	fba3 2301 	umull	r2, r3, r3, r1
 800f68a:	eb04 03d3 	add.w	r3, r4, r3, lsr #3
 800f68e:	f103 0464 	add.w	r4, r3, #100	; 0x64
                        mantissa = 0; // Set to zero to indicate valid non-integer G command.
 800f692:	2100      	movs	r1, #0
                        if (axis_command)
 800f694:	f1ba 0f00 	cmp.w	sl, #0
 800f698:	f043 8198 	bne.w	80129cc <gc_execute_block+0x35ec>
                        axis_command = AxisCommand_MotionMode;
 800f69c:	f04f 0a02 	mov.w	sl, #2
                        word_bit.modal_group.G1 = On;
 800f6a0:	f89d 3074 	ldrb.w	r3, [sp, #116]	; 0x74
 800f6a4:	f043 0302 	orr.w	r3, r3, #2
 800f6a8:	f88d 3074 	strb.w	r3, [sp, #116]	; 0x74
                        if(int_value == 5 && mantissa != 0) {
 800f6ac:	2c05      	cmp	r4, #5
 800f6ae:	d010      	beq.n	800f6d2 <gc_execute_block+0x2f2>
                            gc_block.modal.motion = (motion_mode_t)int_value;
 800f6b0:	4ba6      	ldr	r3, [pc, #664]	; (800f94c <gc_execute_block+0x56c>)
 800f6b2:	811c      	strh	r4, [r3, #8]
                        gc_block.modal.canned_cycle_active = false;
 800f6b4:	4ba5      	ldr	r3, [pc, #660]	; (800f94c <gc_execute_block+0x56c>)
 800f6b6:	2200      	movs	r2, #0
 800f6b8:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
                if (mantissa > 0)
 800f6bc:	2900      	cmp	r1, #0
 800f6be:	f043 81a3 	bne.w	8012a08 <gc_execute_block+0x3628>
                if (command_words.mask & word_bit.modal_group.mask)
 800f6c2:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 800f6c4:	421f      	tst	r7, r3
 800f6c6:	f043 81a2 	bne.w	8012a0e <gc_execute_block+0x362e>
                command_words.mask |= word_bit.modal_group.mask;
 800f6ca:	431f      	orrs	r7, r3
                is_user_mcode = false;
 800f6cc:	f04f 0900 	mov.w	r9, #0
                break;
 800f6d0:	e32e      	b.n	800fd30 <gc_execute_block+0x950>
                        if(int_value == 5 && mantissa != 0) {
 800f6d2:	2900      	cmp	r1, #0
 800f6d4:	d0ec      	beq.n	800f6b0 <gc_execute_block+0x2d0>
                            if(mantissa == 10) {
 800f6d6:	290a      	cmp	r1, #10
 800f6d8:	f043 817b 	bne.w	80129d2 <gc_execute_block+0x35f2>
                                gc_block.modal.motion = MotionMode_QuadraticSpline;
 800f6dc:	4b9b      	ldr	r3, [pc, #620]	; (800f94c <gc_execute_block+0x56c>)
 800f6de:	2233      	movs	r2, #51	; 0x33
 800f6e0:	811a      	strh	r2, [r3, #8]
                                mantissa = 0; // Set to zero to indicate valid non-integer G command.
 800f6e2:	2100      	movs	r1, #0
                            if(mantissa == 10) {
 800f6e4:	e7e6      	b.n	800f6b4 <gc_execute_block+0x2d4>
                        if (axis_command)
 800f6e6:	f1ba 0f00 	cmp.w	sl, #0
 800f6ea:	f043 8175 	bne.w	80129d8 <gc_execute_block+0x35f8>
                        word_bit.modal_group.G1 = On;
 800f6ee:	f89d 3074 	ldrb.w	r3, [sp, #116]	; 0x74
 800f6f2:	f043 0302 	orr.w	r3, r3, #2
 800f6f6:	f88d 3074 	strb.w	r3, [sp, #116]	; 0x74
                        gc_block.modal.canned_cycle_active = true;
 800f6fa:	4a94      	ldr	r2, [pc, #592]	; (800f94c <gc_execute_block+0x56c>)
 800f6fc:	2301      	movs	r3, #1
 800f6fe:	f882 3027 	strb.w	r3, [r2, #39]	; 0x27
                        gc_block.modal.motion = (motion_mode_t)int_value;
 800f702:	b2a3      	uxth	r3, r4
 800f704:	8113      	strh	r3, [r2, #8]
                        gc_parser_flags.canned_cycle_change = gc_block.modal.motion != gc_state.modal.motion;
 800f706:	4a92      	ldr	r2, [pc, #584]	; (800f950 <gc_execute_block+0x570>)
 800f708:	8812      	ldrh	r2, [r2, #0]
 800f70a:	1a9b      	subs	r3, r3, r2
 800f70c:	bf18      	it	ne
 800f70e:	2301      	movne	r3, #1
 800f710:	f363 0841 	bfi	r8, r3, #1, #1
                        axis_command = AxisCommand_MotionMode;
 800f714:	f04f 0a02 	mov.w	sl, #2
                        break;
 800f718:	e7d0      	b.n	800f6bc <gc_execute_block+0x2dc>
                        word_bit.modal_group.G2 = On;
 800f71a:	f89d 3074 	ldrb.w	r3, [sp, #116]	; 0x74
 800f71e:	f043 0304 	orr.w	r3, r3, #4
 800f722:	f88d 3074 	strb.w	r3, [sp, #116]	; 0x74
                        gc_block.modal.plane_select = (plane_select_t)(int_value - 17);
 800f726:	b2e3      	uxtb	r3, r4
 800f728:	3b11      	subs	r3, #17
 800f72a:	4a88      	ldr	r2, [pc, #544]	; (800f94c <gc_execute_block+0x56c>)
 800f72c:	7393      	strb	r3, [r2, #14]
                        break;
 800f72e:	e7c5      	b.n	800f6bc <gc_execute_block+0x2dc>
                        if (mantissa == 0) {
 800f730:	b961      	cbnz	r1, 800f74c <gc_execute_block+0x36c>
                            word_bit.modal_group.G3 = On;
 800f732:	f89d 3074 	ldrb.w	r3, [sp, #116]	; 0x74
 800f736:	f043 0308 	orr.w	r3, r3, #8
 800f73a:	f88d 3074 	strb.w	r3, [sp, #116]	; 0x74
                            gc_block.modal.distance_incremental = int_value == 91;
 800f73e:	2c5b      	cmp	r4, #91	; 0x5b
 800f740:	bf14      	ite	ne
 800f742:	2200      	movne	r2, #0
 800f744:	2201      	moveq	r2, #1
 800f746:	4b81      	ldr	r3, [pc, #516]	; (800f94c <gc_execute_block+0x56c>)
 800f748:	731a      	strb	r2, [r3, #12]
 800f74a:	e7b7      	b.n	800f6bc <gc_execute_block+0x2dc>
                            word_bit.modal_group.G4 = On;
 800f74c:	f89d 3074 	ldrb.w	r3, [sp, #116]	; 0x74
 800f750:	f043 0310 	orr.w	r3, r3, #16
 800f754:	f88d 3074 	strb.w	r3, [sp, #116]	; 0x74
                            if ((mantissa != 10) || (int_value == 90))
 800f758:	290a      	cmp	r1, #10
 800f75a:	f043 8140 	bne.w	80129de <gc_execute_block+0x35fe>
 800f75e:	2c5a      	cmp	r4, #90	; 0x5a
 800f760:	f003 8140 	beq.w	80129e4 <gc_execute_block+0x3604>
                            mantissa = 0; // Set to zero to indicate valid non-integer G command.
 800f764:	2100      	movs	r1, #0
 800f766:	e7a9      	b.n	800f6bc <gc_execute_block+0x2dc>
                        word_bit.modal_group.G5 = On;
 800f768:	f89d 3074 	ldrb.w	r3, [sp, #116]	; 0x74
 800f76c:	f043 0320 	orr.w	r3, r3, #32
 800f770:	f88d 3074 	strb.w	r3, [sp, #116]	; 0x74
                        gc_block.modal.feed_mode = (feed_mode_t)(94 - int_value);
 800f774:	b2e3      	uxtb	r3, r4
 800f776:	f1c3 035e 	rsb	r3, r3, #94	; 0x5e
 800f77a:	4a74      	ldr	r2, [pc, #464]	; (800f94c <gc_execute_block+0x56c>)
 800f77c:	7293      	strb	r3, [r2, #10]
                        break;
 800f77e:	e79d      	b.n	800f6bc <gc_execute_block+0x2dc>
                        word_bit.modal_group.G5 = On;
 800f780:	f89d 3074 	ldrb.w	r3, [sp, #116]	; 0x74
 800f784:	f043 0320 	orr.w	r3, r3, #32
 800f788:	f88d 3074 	strb.w	r3, [sp, #116]	; 0x74
                        gc_block.modal.feed_mode = FeedMode_UnitsPerRev;
 800f78c:	4b6f      	ldr	r3, [pc, #444]	; (800f94c <gc_execute_block+0x56c>)
 800f78e:	2202      	movs	r2, #2
 800f790:	729a      	strb	r2, [r3, #10]
                        break;
 800f792:	e793      	b.n	800f6bc <gc_execute_block+0x2dc>
                        word_bit.modal_group.G6 = On;
 800f794:	f89d 3074 	ldrb.w	r3, [sp, #116]	; 0x74
 800f798:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800f79c:	f88d 3074 	strb.w	r3, [sp, #116]	; 0x74
                        gc_block.modal.units_imperial = int_value == 20;
 800f7a0:	2c14      	cmp	r4, #20
 800f7a2:	bf14      	ite	ne
 800f7a4:	2200      	movne	r2, #0
 800f7a6:	2201      	moveq	r2, #1
 800f7a8:	4b68      	ldr	r3, [pc, #416]	; (800f94c <gc_execute_block+0x56c>)
 800f7aa:	72da      	strb	r2, [r3, #11]
                        break;
 800f7ac:	e786      	b.n	800f6bc <gc_execute_block+0x2dc>
                        word_bit.modal_group.G7 = On;
 800f7ae:	f89d 3074 	ldrb.w	r3, [sp, #116]	; 0x74
 800f7b2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800f7b6:	f88d 3074 	strb.w	r3, [sp, #116]	; 0x74
                        break;
 800f7ba:	e77f      	b.n	800f6bc <gc_execute_block+0x2dc>
                        word_bit.modal_group.G8 = On;
 800f7bc:	f89d 3075 	ldrb.w	r3, [sp, #117]	; 0x75
 800f7c0:	f043 0301 	orr.w	r3, r3, #1
 800f7c4:	f88d 3075 	strb.w	r3, [sp, #117]	; 0x75
                        if (int_value == 49) // G49
 800f7c8:	2c31      	cmp	r4, #49	; 0x31
 800f7ca:	d00d      	beq.n	800f7e8 <gc_execute_block+0x408>
                        else if (mantissa == 10) { // G43.1
 800f7cc:	290a      	cmp	r1, #10
 800f7ce:	f043 810c 	bne.w	80129ea <gc_execute_block+0x360a>
                            if (axis_command)
 800f7d2:	f1ba 0f00 	cmp.w	sl, #0
 800f7d6:	f043 810b 	bne.w	80129f0 <gc_execute_block+0x3610>
                            gc_block.modal.tool_offset_mode = ToolLengthOffset_EnableDynamic;
 800f7da:	4b5c      	ldr	r3, [pc, #368]	; (800f94c <gc_execute_block+0x56c>)
 800f7dc:	2202      	movs	r2, #2
 800f7de:	73da      	strb	r2, [r3, #15]
                        mantissa = 0; // Set to zero to indicate valid non-integer G command.
 800f7e0:	2100      	movs	r1, #0
                            axis_command = AxisCommand_ToolLengthOffset;
 800f7e2:	f04f 0a03 	mov.w	sl, #3
 800f7e6:	e769      	b.n	800f6bc <gc_execute_block+0x2dc>
                            gc_block.modal.tool_offset_mode = ToolLengthOffset_Cancel;
 800f7e8:	2300      	movs	r3, #0
 800f7ea:	4a58      	ldr	r2, [pc, #352]	; (800f94c <gc_execute_block+0x56c>)
 800f7ec:	73d3      	strb	r3, [r2, #15]
                        mantissa = 0; // Set to zero to indicate valid non-integer G command.
 800f7ee:	4619      	mov	r1, r3
 800f7f0:	e764      	b.n	800f6bc <gc_execute_block+0x2dc>
                        word_bit.modal_group.G12 = On;
 800f7f2:	f89d 3075 	ldrb.w	r3, [sp, #117]	; 0x75
 800f7f6:	f043 0308 	orr.w	r3, r3, #8
 800f7fa:	f88d 3075 	strb.w	r3, [sp, #117]	; 0x75
                        gc_block.modal.coord_system.id = (coord_system_id_t)(int_value - 54); // Shift to array indexing.
 800f7fe:	b2e2      	uxtb	r2, r4
 800f800:	3a36      	subs	r2, #54	; 0x36
 800f802:	b2d2      	uxtb	r2, r2
 800f804:	4b51      	ldr	r3, [pc, #324]	; (800f94c <gc_execute_block+0x56c>)
 800f806:	771a      	strb	r2, [r3, #28]
                        if(int_value == 59 && mantissa > 0) {
 800f808:	2c3b      	cmp	r4, #59	; 0x3b
 800f80a:	f47f af57 	bne.w	800f6bc <gc_execute_block+0x2dc>
 800f80e:	291e      	cmp	r1, #30
 800f810:	f203 80f1 	bhi.w	80129f6 <gc_execute_block+0x3616>
 800f814:	a301      	add	r3, pc, #4	; (adr r3, 800f81c <gc_execute_block+0x43c>)
 800f816:	f853 f021 	ldr.w	pc, [r3, r1, lsl #2]
 800f81a:	bf00      	nop
 800f81c:	0800f6bd 	.word	0x0800f6bd
 800f820:	080129f7 	.word	0x080129f7
 800f824:	080129f7 	.word	0x080129f7
 800f828:	080129f7 	.word	0x080129f7
 800f82c:	080129f7 	.word	0x080129f7
 800f830:	080129f7 	.word	0x080129f7
 800f834:	080129f7 	.word	0x080129f7
 800f838:	080129f7 	.word	0x080129f7
 800f83c:	080129f7 	.word	0x080129f7
 800f840:	080129f7 	.word	0x080129f7
 800f844:	0800f899 	.word	0x0800f899
 800f848:	080129f7 	.word	0x080129f7
 800f84c:	080129f7 	.word	0x080129f7
 800f850:	080129f7 	.word	0x080129f7
 800f854:	080129f7 	.word	0x080129f7
 800f858:	080129f7 	.word	0x080129f7
 800f85c:	080129f7 	.word	0x080129f7
 800f860:	080129f7 	.word	0x080129f7
 800f864:	080129f7 	.word	0x080129f7
 800f868:	080129f7 	.word	0x080129f7
 800f86c:	0800f899 	.word	0x0800f899
 800f870:	080129f7 	.word	0x080129f7
 800f874:	080129f7 	.word	0x080129f7
 800f878:	080129f7 	.word	0x080129f7
 800f87c:	080129f7 	.word	0x080129f7
 800f880:	080129f7 	.word	0x080129f7
 800f884:	080129f7 	.word	0x080129f7
 800f888:	080129f7 	.word	0x080129f7
 800f88c:	080129f7 	.word	0x080129f7
 800f890:	080129f7 	.word	0x080129f7
 800f894:	0800f899 	.word	0x0800f899
                                gc_block.modal.coord_system.id += mantissa / 10;
 800f898:	4b2b      	ldr	r3, [pc, #172]	; (800f948 <gc_execute_block+0x568>)
 800f89a:	fba3 1301 	umull	r1, r3, r3, r1
 800f89e:	eb02 02d3 	add.w	r2, r2, r3, lsr #3
 800f8a2:	4b2a      	ldr	r3, [pc, #168]	; (800f94c <gc_execute_block+0x56c>)
 800f8a4:	771a      	strb	r2, [r3, #28]
                                mantissa = 0;
 800f8a6:	2100      	movs	r1, #0
 800f8a8:	e708      	b.n	800f6bc <gc_execute_block+0x2dc>
                        word_bit.modal_group.G13 = On;
 800f8aa:	f89d 3075 	ldrb.w	r3, [sp, #117]	; 0x75
 800f8ae:	f043 0310 	orr.w	r3, r3, #16
 800f8b2:	f88d 3075 	strb.w	r3, [sp, #117]	; 0x75
                        if (mantissa != 0) // [G61.1 not supported]
 800f8b6:	2900      	cmp	r1, #0
 800f8b8:	f43f af00 	beq.w	800f6bc <gc_execute_block+0x2dc>
                            FAIL(Status_GcodeUnsupportedCommand);
 800f8bc:	2414      	movs	r4, #20
 800f8be:	e665      	b.n	800f58c <gc_execute_block+0x1ac>
                        word_bit.modal_group.G0 = On;
 800f8c0:	f89d 3074 	ldrb.w	r3, [sp, #116]	; 0x74
 800f8c4:	f043 0301 	orr.w	r3, r3, #1
 800f8c8:	f88d 3074 	strb.w	r3, [sp, #116]	; 0x74
                        gc_block.non_modal_command = (non_modal_t)int_value;
 800f8cc:	4b1f      	ldr	r3, [pc, #124]	; (800f94c <gc_execute_block+0x56c>)
 800f8ce:	701c      	strb	r4, [r3, #0]
                        if(mantissa != 0 || grbl.on_macro_execute == NULL)
 800f8d0:	2900      	cmp	r1, #0
 800f8d2:	f043 8093 	bne.w	80129fc <gc_execute_block+0x361c>
 800f8d6:	4b1f      	ldr	r3, [pc, #124]	; (800f954 <gc_execute_block+0x574>)
 800f8d8:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 800f8dc:	2b00      	cmp	r3, #0
 800f8de:	f47f aeed 	bne.w	800f6bc <gc_execute_block+0x2dc>
                            FAIL(Status_GcodeUnsupportedCommand);
 800f8e2:	2414      	movs	r4, #20
 800f8e4:	e652      	b.n	800f58c <gc_execute_block+0x1ac>
                        if(settings.mode == Mode_Lathe) {
 800f8e6:	4b1c      	ldr	r3, [pc, #112]	; (800f958 <gc_execute_block+0x578>)
 800f8e8:	7e1b      	ldrb	r3, [r3, #24]
 800f8ea:	2b02      	cmp	r3, #2
 800f8ec:	f043 8089 	bne.w	8012a02 <gc_execute_block+0x3622>
                            word_bit.modal_group.G14 = On;
 800f8f0:	f89d 3075 	ldrb.w	r3, [sp, #117]	; 0x75
 800f8f4:	f043 0320 	orr.w	r3, r3, #32
 800f8f8:	f88d 3075 	strb.w	r3, [sp, #117]	; 0x75
                            gc_block.modal.spindle.rpm_mode = (spindle_rpm_mode_t)((int_value - 96) ^ 1);
 800f8fc:	f1a4 0360 	sub.w	r3, r4, #96	; 0x60
 800f900:	b2db      	uxtb	r3, r3
 800f902:	f083 0301 	eor.w	r3, r3, #1
 800f906:	4a11      	ldr	r2, [pc, #68]	; (800f94c <gc_execute_block+0x56c>)
 800f908:	f882 3023 	strb.w	r3, [r2, #35]	; 0x23
                        break;
 800f90c:	e6d6      	b.n	800f6bc <gc_execute_block+0x2dc>
                        word_bit.modal_group.G10 = On;
 800f90e:	f89d 3075 	ldrb.w	r3, [sp, #117]	; 0x75
 800f912:	f043 0302 	orr.w	r3, r3, #2
 800f916:	f88d 3075 	strb.w	r3, [sp, #117]	; 0x75
                        gc_block.modal.retract_mode = (cc_retract_mode_t)(int_value - 98);
 800f91a:	b2e3      	uxtb	r3, r4
 800f91c:	3b62      	subs	r3, #98	; 0x62
 800f91e:	4a0b      	ldr	r2, [pc, #44]	; (800f94c <gc_execute_block+0x56c>)
 800f920:	f882 3025 	strb.w	r3, [r2, #37]	; 0x25
                        break;
 800f924:	e6ca      	b.n	800f6bc <gc_execute_block+0x2dc>
                        word_bit.modal_group.G11 = On;
 800f926:	f89d 3075 	ldrb.w	r3, [sp, #117]	; 0x75
 800f92a:	f043 0304 	orr.w	r3, r3, #4
 800f92e:	f88d 3075 	strb.w	r3, [sp, #117]	; 0x75
                        gc_block.modal.scaling_active = int_value == 51;
 800f932:	2c33      	cmp	r4, #51	; 0x33
 800f934:	bf14      	ite	ne
 800f936:	2200      	movne	r2, #0
 800f938:	2201      	moveq	r2, #1
 800f93a:	4b04      	ldr	r3, [pc, #16]	; (800f94c <gc_execute_block+0x56c>)
 800f93c:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
                        axis_command = AxisCommand_Scaling;
 800f940:	f04f 0a04 	mov.w	sl, #4
                        break;
 800f944:	e6ba      	b.n	800f6bc <gc_execute_block+0x2dc>
 800f946:	bf00      	nop
 800f948:	cccccccd 	.word	0xcccccccd
 800f94c:	20003298 	.word	0x20003298
 800f950:	20003344 	.word	0x20003344
 800f954:	2000343c 	.word	0x2000343c
 800f958:	20003b14 	.word	0x20003b14
                if(gc_block.non_modal_command == NonModal_MacroCall) {
 800f95c:	4ba4      	ldr	r3, [pc, #656]	; (800fbf0 <gc_execute_block+0x810>)
 800f95e:	781b      	ldrb	r3, [r3, #0]
 800f960:	2b41      	cmp	r3, #65	; 0x41
 800f962:	d06d      	beq.n	800fa40 <gc_execute_block+0x660>
                if(mantissa > 0)
 800f964:	2900      	cmp	r1, #0
 800f966:	f043 8058 	bne.w	8012a1a <gc_execute_block+0x363a>
                word_bit.modal_group.mask = 0;
 800f96a:	2300      	movs	r3, #0
 800f96c:	931d      	str	r3, [sp, #116]	; 0x74
                switch(int_value) {
 800f96e:	2c63      	cmp	r4, #99	; 0x63
 800f970:	f200 81aa 	bhi.w	800fcc8 <gc_execute_block+0x8e8>
 800f974:	e8df f014 	tbh	[pc, r4, lsl #1]
 800f978:	00750075 	.word	0x00750075
 800f97c:	00af0075 	.word	0x00af0075
 800f980:	00af00af 	.word	0x00af00af
 800f984:	00ec00d2 	.word	0x00ec00d2
 800f988:	00ec00ec 	.word	0x00ec00ec
 800f98c:	01a801a8 	.word	0x01a801a8
 800f990:	01a801a8 	.word	0x01a801a8
 800f994:	01a801a8 	.word	0x01a801a8
 800f998:	01a801a8 	.word	0x01a801a8
 800f99c:	01a801a8 	.word	0x01a801a8
 800f9a0:	01a801a8 	.word	0x01a801a8
 800f9a4:	01a801a8 	.word	0x01a801a8
 800f9a8:	01a801a8 	.word	0x01a801a8
 800f9ac:	01a801a8 	.word	0x01a801a8
 800f9b0:	01a801a8 	.word	0x01a801a8
 800f9b4:	01a80075 	.word	0x01a80075
 800f9b8:	01a801a8 	.word	0x01a801a8
 800f9bc:	01a801a8 	.word	0x01a801a8
 800f9c0:	01a801a8 	.word	0x01a801a8
 800f9c4:	01a801a8 	.word	0x01a801a8
 800f9c8:	01a801a8 	.word	0x01a801a8
 800f9cc:	01a801a8 	.word	0x01a801a8
 800f9d0:	01a801a8 	.word	0x01a801a8
 800f9d4:	01a801a8 	.word	0x01a801a8
 800f9d8:	012c012c 	.word	0x012c012c
 800f9dc:	012c012c 	.word	0x012c012c
 800f9e0:	012c01a8 	.word	0x012c01a8
 800f9e4:	01a801a8 	.word	0x01a801a8
 800f9e8:	01a80125 	.word	0x01a80125
 800f9ec:	01a801a8 	.word	0x01a801a8
 800f9f0:	01440075 	.word	0x01440075
 800f9f4:	014f014f 	.word	0x014f014f
 800f9f8:	014f014f 	.word	0x014f014f
 800f9fc:	017e0166 	.word	0x017e0166
 800fa00:	01a8017e 	.word	0x01a8017e
 800fa04:	01a801a8 	.word	0x01a801a8
 800fa08:	01a801a8 	.word	0x01a801a8
 800fa0c:	01a801a8 	.word	0x01a801a8
 800fa10:	01a801a8 	.word	0x01a801a8
 800fa14:	01a801a8 	.word	0x01a801a8
 800fa18:	01a801a8 	.word	0x01a801a8
 800fa1c:	01a801a8 	.word	0x01a801a8
 800fa20:	01a801a8 	.word	0x01a801a8
 800fa24:	01a801a8 	.word	0x01a801a8
 800fa28:	01a801a8 	.word	0x01a801a8
 800fa2c:	01a801a8 	.word	0x01a801a8
 800fa30:	01a801a8 	.word	0x01a801a8
 800fa34:	01a801a8 	.word	0x01a801a8
 800fa38:	01a801a8 	.word	0x01a801a8
 800fa3c:	019501a8 	.word	0x019501a8
                    if(gc_block.words.m)
 800fa40:	4b6b      	ldr	r3, [pc, #428]	; (800fbf0 <gc_execute_block+0x810>)
 800fa42:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 800fa46:	f013 0f20 	tst.w	r3, #32
 800fa4a:	f042 87e3 	bne.w	8012a14 <gc_execute_block+0x3634>
                    gc_block.values.m = value;
 800fa4e:	4b68      	ldr	r3, [pc, #416]	; (800fbf0 <gc_execute_block+0x810>)
 800fa50:	ed83 8a13 	vstr	s16, [r3, #76]	; 0x4c
                    gc_block.words.m = On; // Flag to indicate parameter assigned.
 800fa54:	f893 2095 	ldrb.w	r2, [r3, #149]	; 0x95
 800fa58:	f042 0220 	orr.w	r2, r2, #32
 800fa5c:	f883 2095 	strb.w	r2, [r3, #149]	; 0x95
                    continue;
 800fa60:	e166      	b.n	800fd30 <gc_execute_block+0x950>
                        word_bit.modal_group.M4 = On;
 800fa62:	f89d 3075 	ldrb.w	r3, [sp, #117]	; 0x75
 800fa66:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800fa6a:	f88d 3075 	strb.w	r3, [sp, #117]	; 0x75
                        switch(int_value) {
 800fa6e:	b13c      	cbz	r4, 800fa80 <gc_execute_block+0x6a0>
 800fa70:	2c01      	cmp	r4, #1
 800fa72:	d00c      	beq.n	800fa8e <gc_execute_block+0x6ae>
                                gc_block.modal.program_flow = (program_flow_t)int_value;
 800fa74:	4b5e      	ldr	r3, [pc, #376]	; (800fbf0 <gc_execute_block+0x810>)
 800fa76:	f883 4020 	strb.w	r4, [r3, #32]
                is_user_mcode = false;
 800fa7a:	f04f 0900 	mov.w	r9, #0
 800fa7e:	e0b1      	b.n	800fbe4 <gc_execute_block+0x804>
                                gc_block.modal.program_flow = ProgramFlow_Paused;
 800fa80:	4b5b      	ldr	r3, [pc, #364]	; (800fbf0 <gc_execute_block+0x810>)
 800fa82:	2203      	movs	r2, #3
 800fa84:	f883 2020 	strb.w	r2, [r3, #32]
                is_user_mcode = false;
 800fa88:	f04f 0900 	mov.w	r9, #0
                                break;
 800fa8c:	e0aa      	b.n	800fbe4 <gc_execute_block+0x804>
                                if(hal.signals_cap.stop_disable ? !hal.control.get_state().stop_disable : !sys.flags.optional_stop_disable)
 800fa8e:	4b59      	ldr	r3, [pc, #356]	; (800fbf4 <gc_execute_block+0x814>)
 800fa90:	f893 31a8 	ldrb.w	r3, [r3, #424]	; 0x1a8
 800fa94:	f013 0f20 	tst.w	r3, #32
 800fa98:	d013      	beq.n	800fac2 <gc_execute_block+0x6e2>
 800fa9a:	4b56      	ldr	r3, [pc, #344]	; (800fbf4 <gc_execute_block+0x814>)
 800fa9c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800fa9e:	4798      	blx	r3
 800faa0:	f3c0 1942 	ubfx	r9, r0, #5, #3
 800faa4:	f089 0901 	eor.w	r9, r9, #1
 800faa8:	f009 0901 	and.w	r9, r9, #1
 800faac:	f1b9 0f00 	cmp.w	r9, #0
 800fab0:	f000 8098 	beq.w	800fbe4 <gc_execute_block+0x804>
                                    gc_block.modal.program_flow = ProgramFlow_OptionalStop;
 800fab4:	4b4e      	ldr	r3, [pc, #312]	; (800fbf0 <gc_execute_block+0x810>)
 800fab6:	2201      	movs	r2, #1
 800fab8:	f883 2020 	strb.w	r2, [r3, #32]
                is_user_mcode = false;
 800fabc:	f04f 0900 	mov.w	r9, #0
 800fac0:	e090      	b.n	800fbe4 <gc_execute_block+0x804>
                                if(hal.signals_cap.stop_disable ? !hal.control.get_state().stop_disable : !sys.flags.optional_stop_disable)
 800fac2:	4b4d      	ldr	r3, [pc, #308]	; (800fbf8 <gc_execute_block+0x818>)
 800fac4:	f893 9016 	ldrb.w	r9, [r3, #22]
 800fac8:	ea4f 1999 	mov.w	r9, r9, lsr #6
 800facc:	f089 0901 	eor.w	r9, r9, #1
 800fad0:	f009 0901 	and.w	r9, r9, #1
 800fad4:	e7ea      	b.n	800faac <gc_execute_block+0x6cc>
                        word_bit.modal_group.M7 = On;
 800fad6:	f89d 3076 	ldrb.w	r3, [sp, #118]	; 0x76
 800fada:	f043 0302 	orr.w	r3, r3, #2
 800fade:	f88d 3076 	strb.w	r3, [sp, #118]	; 0x76
                        gc_block.modal.spindle.state.on = !(int_value == 5);
 800fae2:	1f61      	subs	r1, r4, #5
 800fae4:	bf18      	it	ne
 800fae6:	2101      	movne	r1, #1
 800fae8:	4b41      	ldr	r3, [pc, #260]	; (800fbf0 <gc_execute_block+0x810>)
 800faea:	f893 2022 	ldrb.w	r2, [r3, #34]	; 0x22
 800faee:	f361 0200 	bfi	r2, r1, #0, #1
 800faf2:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
                        gc_block.modal.spindle.state.ccw = int_value == 4;
 800faf6:	2c04      	cmp	r4, #4
 800faf8:	bf14      	ite	ne
 800fafa:	2100      	movne	r1, #0
 800fafc:	2101      	moveq	r1, #1
 800fafe:	b2d2      	uxtb	r2, r2
 800fb00:	f361 0241 	bfi	r2, r1, #1, #1
 800fb04:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
                        sys.override_delay.spindle = On;
 800fb08:	4a3b      	ldr	r2, [pc, #236]	; (800fbf8 <gc_execute_block+0x818>)
 800fb0a:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c
 800fb0e:	f043 0304 	orr.w	r3, r3, #4
 800fb12:	f882 302c 	strb.w	r3, [r2, #44]	; 0x2c
                is_user_mcode = false;
 800fb16:	f04f 0900 	mov.w	r9, #0
                        break;
 800fb1a:	e063      	b.n	800fbe4 <gc_execute_block+0x804>
                        if(settings.tool_change.mode != ToolChange_Ignore) {
 800fb1c:	4b37      	ldr	r3, [pc, #220]	; (800fbfc <gc_execute_block+0x81c>)
 800fb1e:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800fb22:	2b04      	cmp	r3, #4
 800fb24:	f000 80e4 	beq.w	800fcf0 <gc_execute_block+0x910>
                            if(hal.stream.suspend_read || hal.tool.change)
 800fb28:	4b32      	ldr	r3, [pc, #200]	; (800fbf4 <gc_execute_block+0x814>)
 800fb2a:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 800fb2e:	b143      	cbz	r3, 800fb42 <gc_execute_block+0x762>
                                word_bit.modal_group.M6 = On;
 800fb30:	f89d 3076 	ldrb.w	r3, [sp, #118]	; 0x76
 800fb34:	f043 0301 	orr.w	r3, r3, #1
 800fb38:	f88d 3076 	strb.w	r3, [sp, #118]	; 0x76
                is_user_mcode = false;
 800fb3c:	f04f 0900 	mov.w	r9, #0
                                word_bit.modal_group.M6 = On;
 800fb40:	e050      	b.n	800fbe4 <gc_execute_block+0x804>
                            if(hal.stream.suspend_read || hal.tool.change)
 800fb42:	4b2c      	ldr	r3, [pc, #176]	; (800fbf4 <gc_execute_block+0x814>)
 800fb44:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 800fb48:	2b00      	cmp	r3, #0
 800fb4a:	d1f1      	bne.n	800fb30 <gc_execute_block+0x750>
                                FAIL(Status_GcodeUnsupportedCommand); // [Unsupported M command]
 800fb4c:	2414      	movs	r4, #20
 800fb4e:	e51d      	b.n	800f58c <gc_execute_block+0x1ac>
                        word_bit.modal_group.M8 = On;
 800fb50:	f89d 3076 	ldrb.w	r3, [sp, #118]	; 0x76
 800fb54:	f043 0304 	orr.w	r3, r3, #4
 800fb58:	f88d 3076 	strb.w	r3, [sp, #118]	; 0x76
                        sys.override_delay.coolant = On;
 800fb5c:	4a26      	ldr	r2, [pc, #152]	; (800fbf8 <gc_execute_block+0x818>)
 800fb5e:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c
 800fb62:	f043 0302 	orr.w	r3, r3, #2
 800fb66:	f882 302c 	strb.w	r3, [r2, #44]	; 0x2c
                        gc_parser_flags.set_coolant = On;
 800fb6a:	f448 7880 	orr.w	r8, r8, #256	; 0x100
                        switch(int_value) {
 800fb6e:	2c08      	cmp	r4, #8
 800fb70:	d017      	beq.n	800fba2 <gc_execute_block+0x7c2>
 800fb72:	2c09      	cmp	r4, #9
 800fb74:	d01f      	beq.n	800fbb6 <gc_execute_block+0x7d6>
 800fb76:	2c07      	cmp	r4, #7
 800fb78:	d002      	beq.n	800fb80 <gc_execute_block+0x7a0>
 800fb7a:	f04f 0900 	mov.w	r9, #0
 800fb7e:	e031      	b.n	800fbe4 <gc_execute_block+0x804>
                                if(!hal.driver_cap.mist_control)
 800fb80:	4b1c      	ldr	r3, [pc, #112]	; (800fbf4 <gc_execute_block+0x814>)
 800fb82:	f893 31a4 	ldrb.w	r3, [r3, #420]	; 0x1a4
 800fb86:	f013 0f01 	tst.w	r3, #1
 800fb8a:	f002 8749 	beq.w	8012a20 <gc_execute_block+0x3640>
                                gc_block.modal.coolant.mist = On;
 800fb8e:	4a18      	ldr	r2, [pc, #96]	; (800fbf0 <gc_execute_block+0x810>)
 800fb90:	f892 3021 	ldrb.w	r3, [r2, #33]	; 0x21
 800fb94:	f043 0302 	orr.w	r3, r3, #2
 800fb98:	f882 3021 	strb.w	r3, [r2, #33]	; 0x21
                is_user_mcode = false;
 800fb9c:	f04f 0900 	mov.w	r9, #0
                                break;
 800fba0:	e020      	b.n	800fbe4 <gc_execute_block+0x804>
                                gc_block.modal.coolant.flood = On;
 800fba2:	4a13      	ldr	r2, [pc, #76]	; (800fbf0 <gc_execute_block+0x810>)
 800fba4:	f892 3021 	ldrb.w	r3, [r2, #33]	; 0x21
 800fba8:	f043 0301 	orr.w	r3, r3, #1
 800fbac:	f882 3021 	strb.w	r3, [r2, #33]	; 0x21
                is_user_mcode = false;
 800fbb0:	f04f 0900 	mov.w	r9, #0
                                break;
 800fbb4:	e016      	b.n	800fbe4 <gc_execute_block+0x804>
                                gc_block.modal.coolant.value = 0;
 800fbb6:	f04f 0900 	mov.w	r9, #0
 800fbba:	4b0d      	ldr	r3, [pc, #52]	; (800fbf0 <gc_execute_block+0x810>)
 800fbbc:	f883 9021 	strb.w	r9, [r3, #33]	; 0x21
                                break;
 800fbc0:	e010      	b.n	800fbe4 <gc_execute_block+0x804>
                        if(!settings.parking.flags.enable_override_control) // TODO: check if enabled?
 800fbc2:	4b0e      	ldr	r3, [pc, #56]	; (800fbfc <gc_execute_block+0x81c>)
 800fbc4:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 800fbc8:	f013 0f04 	tst.w	r3, #4
 800fbcc:	f002 872b 	beq.w	8012a26 <gc_execute_block+0x3646>
                        word_bit.modal_group.M9 = On;
 800fbd0:	f89d 3076 	ldrb.w	r3, [sp, #118]	; 0x76
 800fbd4:	f043 0308 	orr.w	r3, r3, #8
 800fbd8:	f88d 3076 	strb.w	r3, [sp, #118]	; 0x76
                        gc_block.override_command = (override_mode_t)int_value;
 800fbdc:	4b04      	ldr	r3, [pc, #16]	; (800fbf0 <gc_execute_block+0x810>)
 800fbde:	705c      	strb	r4, [r3, #1]
                is_user_mcode = false;
 800fbe0:	f04f 0900 	mov.w	r9, #0
                if (command_words.mask & word_bit.modal_group.mask)
 800fbe4:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 800fbe6:	421f      	tst	r7, r3
 800fbe8:	f042 8735 	bne.w	8012a56 <gc_execute_block+0x3676>
                command_words.mask |= word_bit.modal_group.mask;
 800fbec:	431f      	orrs	r7, r3
                break;
 800fbee:	e09f      	b.n	800fd30 <gc_execute_block+0x950>
 800fbf0:	20003298 	.word	0x20003298
 800fbf4:	2000350c 	.word	0x2000350c
 800fbf8:	200036c4 	.word	0x200036c4
 800fbfc:	20003b14 	.word	0x20003b14
                        word_bit.modal_group.M6 = On; //??
 800fc00:	f89d 3076 	ldrb.w	r3, [sp, #118]	; 0x76
 800fc04:	f043 0301 	orr.w	r3, r3, #1
 800fc08:	f88d 3076 	strb.w	r3, [sp, #118]	; 0x76
                is_user_mcode = false;
 800fc0c:	f04f 0900 	mov.w	r9, #0
                        set_tool = true;
 800fc10:	2301      	movs	r3, #1
 800fc12:	9306      	str	r3, [sp, #24]
                        break;
 800fc14:	e7e6      	b.n	800fbe4 <gc_execute_block+0x804>
                        if(hal.port.digital_out == NULL || hal.port.num_digital_out == 0)
 800fc16:	4bc9      	ldr	r3, [pc, #804]	; (800ff3c <gc_execute_block+0xb5c>)
 800fc18:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 800fc1c:	2b00      	cmp	r3, #0
 800fc1e:	f002 8705 	beq.w	8012a2c <gc_execute_block+0x364c>
 800fc22:	4bc6      	ldr	r3, [pc, #792]	; (800ff3c <gc_execute_block+0xb5c>)
 800fc24:	f893 3115 	ldrb.w	r3, [r3, #277]	; 0x115
 800fc28:	2b00      	cmp	r3, #0
 800fc2a:	f002 8702 	beq.w	8012a32 <gc_execute_block+0x3652>
                        word_bit.modal_group.M10 = On;
 800fc2e:	f89d 3076 	ldrb.w	r3, [sp, #118]	; 0x76
 800fc32:	f043 0310 	orr.w	r3, r3, #16
 800fc36:	f88d 3076 	strb.w	r3, [sp, #118]	; 0x76
                        port_command = (io_mcode_t)int_value;
 800fc3a:	b2e3      	uxtb	r3, r4
 800fc3c:	9305      	str	r3, [sp, #20]
                is_user_mcode = false;
 800fc3e:	f04f 0900 	mov.w	r9, #0
                        break;
 800fc42:	e7cf      	b.n	800fbe4 <gc_execute_block+0x804>
                        if(hal.port.wait_on_input == NULL || (hal.port.num_digital_in == 0 && hal.port.num_analog_in == 0))
 800fc44:	4bbd      	ldr	r3, [pc, #756]	; (800ff3c <gc_execute_block+0xb5c>)
 800fc46:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
 800fc4a:	2b00      	cmp	r3, #0
 800fc4c:	f002 86f4 	beq.w	8012a38 <gc_execute_block+0x3658>
 800fc50:	4bba      	ldr	r3, [pc, #744]	; (800ff3c <gc_execute_block+0xb5c>)
 800fc52:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 800fc56:	f013 1fff 	tst.w	r3, #16711935	; 0xff00ff
 800fc5a:	f002 86f0 	beq.w	8012a3e <gc_execute_block+0x365e>
                        word_bit.modal_group.M10 = On;
 800fc5e:	f89d 3076 	ldrb.w	r3, [sp, #118]	; 0x76
 800fc62:	f043 0310 	orr.w	r3, r3, #16
 800fc66:	f88d 3076 	strb.w	r3, [sp, #118]	; 0x76
                        port_command = (io_mcode_t)int_value;
 800fc6a:	b2e3      	uxtb	r3, r4
 800fc6c:	9305      	str	r3, [sp, #20]
                is_user_mcode = false;
 800fc6e:	f04f 0900 	mov.w	r9, #0
                        break;
 800fc72:	e7b7      	b.n	800fbe4 <gc_execute_block+0x804>
                        if(hal.port.analog_out == NULL || hal.port.num_analog_out == 0)
 800fc74:	4bb1      	ldr	r3, [pc, #708]	; (800ff3c <gc_execute_block+0xb5c>)
 800fc76:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
 800fc7a:	2b00      	cmp	r3, #0
 800fc7c:	f002 86e2 	beq.w	8012a44 <gc_execute_block+0x3664>
 800fc80:	4bae      	ldr	r3, [pc, #696]	; (800ff3c <gc_execute_block+0xb5c>)
 800fc82:	f893 3117 	ldrb.w	r3, [r3, #279]	; 0x117
 800fc86:	2b00      	cmp	r3, #0
 800fc88:	f002 86df 	beq.w	8012a4a <gc_execute_block+0x366a>
                        word_bit.modal_group.M10 = On;
 800fc8c:	f89d 3076 	ldrb.w	r3, [sp, #118]	; 0x76
 800fc90:	f043 0310 	orr.w	r3, r3, #16
 800fc94:	f88d 3076 	strb.w	r3, [sp, #118]	; 0x76
                        port_command = (io_mcode_t)int_value;
 800fc98:	b2e3      	uxtb	r3, r4
 800fc9a:	9305      	str	r3, [sp, #20]
                is_user_mcode = false;
 800fc9c:	f04f 0900 	mov.w	r9, #0
                        break;
 800fca0:	e7a0      	b.n	800fbe4 <gc_execute_block+0x804>
                        word_bit.modal_group.M4 = On;
 800fca2:	f89d 3075 	ldrb.w	r3, [sp, #117]	; 0x75
 800fca6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800fcaa:	f88d 3075 	strb.w	r3, [sp, #117]	; 0x75
                        gc_block.modal.program_flow = ProgramFlow_Return;
 800fcae:	4ba4      	ldr	r3, [pc, #656]	; (800ff40 <gc_execute_block+0xb60>)
 800fcb0:	2263      	movs	r2, #99	; 0x63
 800fcb2:	f883 2020 	strb.w	r2, [r3, #32]
                        if(grbl.on_macro_return == NULL)
 800fcb6:	4ba3      	ldr	r3, [pc, #652]	; (800ff44 <gc_execute_block+0xb64>)
 800fcb8:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 800fcbc:	2b00      	cmp	r3, #0
 800fcbe:	f002 86c7 	beq.w	8012a50 <gc_execute_block+0x3670>
                is_user_mcode = false;
 800fcc2:	f04f 0900 	mov.w	r9, #0
 800fcc6:	e78d      	b.n	800fbe4 <gc_execute_block+0x804>
                        if(hal.user_mcode.check && (gc_block.user_mcode = hal.user_mcode.check((user_mcode_t)int_value))) {
 800fcc8:	4b9c      	ldr	r3, [pc, #624]	; (800ff3c <gc_execute_block+0xb5c>)
 800fcca:	f8d3 3184 	ldr.w	r3, [r3, #388]	; 0x184
 800fcce:	b16b      	cbz	r3, 800fcec <gc_execute_block+0x90c>
 800fcd0:	b2a0      	uxth	r0, r4
 800fcd2:	4798      	blx	r3
 800fcd4:	4b9a      	ldr	r3, [pc, #616]	; (800ff40 <gc_execute_block+0xb60>)
 800fcd6:	8058      	strh	r0, [r3, #2]
 800fcd8:	b140      	cbz	r0, 800fcec <gc_execute_block+0x90c>
                            word_bit.modal_group.M10 = On;
 800fcda:	f89d 3076 	ldrb.w	r3, [sp, #118]	; 0x76
 800fcde:	f043 0310 	orr.w	r3, r3, #16
 800fce2:	f88d 3076 	strb.w	r3, [sp, #118]	; 0x76
                            is_user_mcode = true;
 800fce6:	f04f 0901 	mov.w	r9, #1
                            word_bit.modal_group.M10 = On;
 800fcea:	e77b      	b.n	800fbe4 <gc_execute_block+0x804>
                            FAIL(Status_GcodeUnsupportedCommand); // [Unsupported M command]
 800fcec:	2414      	movs	r4, #20
 800fcee:	e44d      	b.n	800f58c <gc_execute_block+0x1ac>
                is_user_mcode = false;
 800fcf0:	f04f 0900 	mov.w	r9, #0
 800fcf4:	e776      	b.n	800fbe4 <gc_execute_block+0x804>
                        word_bit.parameter.d = On;
 800fcf6:	f89d 3070 	ldrb.w	r3, [sp, #112]	; 0x70
 800fcfa:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800fcfe:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
                        gc_block.values.d = value;
 800fd02:	4b8f      	ldr	r3, [pc, #572]	; (800ff40 <gc_execute_block+0xb60>)
 800fd04:	ed83 8a0c 	vstr	s16, [r3, #48]	; 0x30
                if (gc_block.words.mask & word_bit.parameter.mask)
 800fd08:	4b8d      	ldr	r3, [pc, #564]	; (800ff40 <gc_execute_block+0xb60>)
 800fd0a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800fd0e:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 800fd10:	4213      	tst	r3, r2
 800fd12:	f042 86b8 	bne.w	8012a86 <gc_execute_block+0x36a6>
                if ((word_bit.parameter.mask & positive_only_words.mask) && value < 0.0f)
 800fd16:	498c      	ldr	r1, [pc, #560]	; (800ff48 <gc_execute_block+0xb68>)
 800fd18:	420a      	tst	r2, r1
 800fd1a:	d005      	beq.n	800fd28 <gc_execute_block+0x948>
 800fd1c:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 800fd20:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800fd24:	f102 86b2 	bmi.w	8012a8c <gc_execute_block+0x36ac>
                gc_block.words.mask |= word_bit.parameter.mask; // Flag to indicate parameter assigned.
 800fd28:	4313      	orrs	r3, r2
 800fd2a:	4a85      	ldr	r2, [pc, #532]	; (800ff40 <gc_execute_block+0xb60>)
 800fd2c:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
    while ((letter = block[char_counter++]) != '\0') { // Loop until no more g-code words in block.
 800fd30:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800fd32:	1c5a      	adds	r2, r3, #1
 800fd34:	921f      	str	r2, [sp, #124]	; 0x7c
 800fd36:	5cf5      	ldrb	r5, [r6, r3]
 800fd38:	2d00      	cmp	r5, #0
 800fd3a:	f000 81b7 	beq.w	80100ac <gc_execute_block+0xccc>
        if((letter < 'A' && letter != '$') || letter > 'Z')
 800fd3e:	2d40      	cmp	r5, #64	; 0x40
 800fd40:	d802      	bhi.n	800fd48 <gc_execute_block+0x968>
 800fd42:	2d24      	cmp	r5, #36	; 0x24
 800fd44:	f042 8618 	bne.w	8012978 <gc_execute_block+0x3598>
 800fd48:	2d5a      	cmp	r5, #90	; 0x5a
 800fd4a:	f202 8618 	bhi.w	801297e <gc_execute_block+0x359e>
        if (!read_float(block, &char_counter, &value)) {
 800fd4e:	aa1e      	add	r2, sp, #120	; 0x78
 800fd50:	a91f      	add	r1, sp, #124	; 0x7c
 800fd52:	4630      	mov	r0, r6
 800fd54:	f005 fdf6 	bl	8015944 <read_float>
 800fd58:	b928      	cbnz	r0, 800fd66 <gc_execute_block+0x986>
            if(is_user_mcode)                   // Valueless parameters allowed for user defined M-codes.
 800fd5a:	f1b9 0f00 	cmp.w	r9, #0
 800fd5e:	f002 8611 	beq.w	8012984 <gc_execute_block+0x35a4>
                value = NAN;                    // Parameter validation deferred to implementation.
 800fd62:	4b7a      	ldr	r3, [pc, #488]	; (800ff4c <gc_execute_block+0xb6c>)
 800fd64:	931e      	str	r3, [sp, #120]	; 0x78
        if(isnan(value))
 800fd66:	ed9d 8a1e 	vldr	s16, [sp, #120]	; 0x78
 800fd6a:	eeb4 8a48 	vcmp.f32	s16, s16
 800fd6e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800fd72:	f5bf ab90 	bvs.w	800f496 <gc_execute_block+0xb6>
            int_value = (uint32_t)truncf(value);
 800fd76:	eefc 7ac8 	vcvt.u32.f32	s15, s16
 800fd7a:	ee17 4a90 	vmov	r4, s15
            mantissa = (uint_fast16_t)roundf(100.0f * (value - int_value));
 800fd7e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800fd82:	ee78 7a67 	vsub.f32	s15, s16, s15
 800fd86:	ed9f 0a72 	vldr	s0, [pc, #456]	; 800ff50 <gc_execute_block+0xb70>
 800fd8a:	ee27 0a80 	vmul.f32	s0, s15, s0
 800fd8e:	f013 ffb5 	bl	8023cfc <roundf>
 800fd92:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 800fd96:	ee17 1a90 	vmov	r1, s15
        switch(letter) {
 800fd9a:	2d47      	cmp	r5, #71	; 0x47
 800fd9c:	f43f ab7e 	beq.w	800f49c <gc_execute_block+0xbc>
 800fda0:	2d4d      	cmp	r5, #77	; 0x4d
 800fda2:	f43f addb 	beq.w	800f95c <gc_execute_block+0x57c>
                word_bit.parameter.mask = 0;
 800fda6:	2300      	movs	r3, #0
 800fda8:	931c      	str	r3, [sp, #112]	; 0x70
                switch(letter) {
 800fdaa:	3d24      	subs	r5, #36	; 0x24
 800fdac:	2d36      	cmp	r5, #54	; 0x36
 800fdae:	f202 8655 	bhi.w	8012a5c <gc_execute_block+0x367c>
 800fdb2:	a301      	add	r3, pc, #4	; (adr r3, 800fdb8 <gc_execute_block+0x9d8>)
 800fdb4:	f853 f025 	ldr.w	pc, [r3, r5, lsl #2]
 800fdb8:	0801008f 	.word	0x0801008f
 800fdbc:	08012a5d 	.word	0x08012a5d
 800fdc0:	08012a5d 	.word	0x08012a5d
 800fdc4:	08012a5d 	.word	0x08012a5d
 800fdc8:	08012a5d 	.word	0x08012a5d
 800fdcc:	08012a5d 	.word	0x08012a5d
 800fdd0:	08012a5d 	.word	0x08012a5d
 800fdd4:	08012a5d 	.word	0x08012a5d
 800fdd8:	08012a5d 	.word	0x08012a5d
 800fddc:	08012a5d 	.word	0x08012a5d
 800fde0:	08012a5d 	.word	0x08012a5d
 800fde4:	08012a5d 	.word	0x08012a5d
 800fde8:	08012a5d 	.word	0x08012a5d
 800fdec:	08012a5d 	.word	0x08012a5d
 800fdf0:	08012a5d 	.word	0x08012a5d
 800fdf4:	08012a5d 	.word	0x08012a5d
 800fdf8:	08012a5d 	.word	0x08012a5d
 800fdfc:	08012a5d 	.word	0x08012a5d
 800fe00:	08012a5d 	.word	0x08012a5d
 800fe04:	08012a5d 	.word	0x08012a5d
 800fe08:	08012a5d 	.word	0x08012a5d
 800fe0c:	08012a5d 	.word	0x08012a5d
 800fe10:	08012a5d 	.word	0x08012a5d
 800fe14:	08012a5d 	.word	0x08012a5d
 800fe18:	08012a5d 	.word	0x08012a5d
 800fe1c:	08012a5d 	.word	0x08012a5d
 800fe20:	08012a5d 	.word	0x08012a5d
 800fe24:	08012a5d 	.word	0x08012a5d
 800fe28:	08012a5d 	.word	0x08012a5d
 800fe2c:	08012a5d 	.word	0x08012a5d
 800fe30:	08012a5d 	.word	0x08012a5d
 800fe34:	08012a5d 	.word	0x08012a5d
 800fe38:	0800fcf7 	.word	0x0800fcf7
 800fe3c:	0800fe95 	.word	0x0800fe95
 800fe40:	0800fea9 	.word	0x0800fea9
 800fe44:	08012a5d 	.word	0x08012a5d
 800fe48:	0800febd 	.word	0x0800febd
 800fe4c:	0800fee9 	.word	0x0800fee9
 800fe50:	0800ff05 	.word	0x0800ff05
 800fe54:	0800ff21 	.word	0x0800ff21
 800fe58:	0800ff55 	.word	0x0800ff55
 800fe5c:	08012a5d 	.word	0x08012a5d
 800fe60:	0800ff7f 	.word	0x0800ff7f
 800fe64:	0800ff97 	.word	0x0800ff97
 800fe68:	0800ffc3 	.word	0x0800ffc3
 800fe6c:	0800ffd7 	.word	0x0800ffd7
 800fe70:	0800ffeb 	.word	0x0800ffeb
 800fe74:	0800ffff 	.word	0x0800ffff
 800fe78:	08010013 	.word	0x08010013
 800fe7c:	08012a5d 	.word	0x08012a5d
 800fe80:	08012a5d 	.word	0x08012a5d
 800fe84:	08012a5d 	.word	0x08012a5d
 800fe88:	08010047 	.word	0x08010047
 800fe8c:	0801005f 	.word	0x0801005f
 800fe90:	08010077 	.word	0x08010077
                        word_bit.parameter.e = On;
 800fe94:	f89d 3071 	ldrb.w	r3, [sp, #113]	; 0x71
 800fe98:	f043 0301 	orr.w	r3, r3, #1
 800fe9c:	f88d 3071 	strb.w	r3, [sp, #113]	; 0x71
                        gc_block.values.e = value;
 800fea0:	4b27      	ldr	r3, [pc, #156]	; (800ff40 <gc_execute_block+0xb60>)
 800fea2:	ed83 8a0d 	vstr	s16, [r3, #52]	; 0x34
                        break;
 800fea6:	e72f      	b.n	800fd08 <gc_execute_block+0x928>
                        word_bit.parameter.f = On;
 800fea8:	f89d 3071 	ldrb.w	r3, [sp, #113]	; 0x71
 800feac:	f043 0302 	orr.w	r3, r3, #2
 800feb0:	f88d 3071 	strb.w	r3, [sp, #113]	; 0x71
                        gc_block.values.f = value;
 800feb4:	4b22      	ldr	r3, [pc, #136]	; (800ff40 <gc_execute_block+0xb60>)
 800feb6:	ed83 8a0e 	vstr	s16, [r3, #56]	; 0x38
                        break;
 800feba:	e725      	b.n	800fd08 <gc_execute_block+0x928>
                        if (mantissa > 0)
 800febc:	2900      	cmp	r1, #0
 800febe:	f042 85d0 	bne.w	8012a62 <gc_execute_block+0x3682>
                        word_bit.parameter.h = On;
 800fec2:	f89d 3071 	ldrb.w	r3, [sp, #113]	; 0x71
 800fec6:	f043 0308 	orr.w	r3, r3, #8
 800feca:	f88d 3071 	strb.w	r3, [sp, #113]	; 0x71
                        gc_block.values.h = isnan(value) ? 0xFFFFFFFF : int_value;
 800fece:	eeb4 8a48 	vcmp.f32	s16, s16
 800fed2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800fed6:	d604      	bvs.n	800fee2 <gc_execute_block+0xb02>
 800fed8:	4622      	mov	r2, r4
 800feda:	4b19      	ldr	r3, [pc, #100]	; (800ff40 <gc_execute_block+0xb60>)
 800fedc:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
                        break;
 800fee0:	e712      	b.n	800fd08 <gc_execute_block+0x928>
                        gc_block.values.h = isnan(value) ? 0xFFFFFFFF : int_value;
 800fee2:	f04f 32ff 	mov.w	r2, #4294967295
 800fee6:	e7f8      	b.n	800feda <gc_execute_block+0xafa>
                        ijk_words.i = On;
 800fee8:	9b04      	ldr	r3, [sp, #16]
 800feea:	f043 0301 	orr.w	r3, r3, #1
 800feee:	9304      	str	r3, [sp, #16]
                        word_bit.parameter.i = On;
 800fef0:	f89d 3070 	ldrb.w	r3, [sp, #112]	; 0x70
 800fef4:	f043 0310 	orr.w	r3, r3, #16
 800fef8:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
                        gc_block.values.ijk[I_VALUE] = value;
 800fefc:	4b10      	ldr	r3, [pc, #64]	; (800ff40 <gc_execute_block+0xb60>)
 800fefe:	ed83 8a0f 	vstr	s16, [r3, #60]	; 0x3c
                        break;
 800ff02:	e701      	b.n	800fd08 <gc_execute_block+0x928>
                        ijk_words.j = On;
 800ff04:	9b04      	ldr	r3, [sp, #16]
 800ff06:	f043 0302 	orr.w	r3, r3, #2
 800ff0a:	9304      	str	r3, [sp, #16]
                        word_bit.parameter.j = On;
 800ff0c:	f89d 3070 	ldrb.w	r3, [sp, #112]	; 0x70
 800ff10:	f043 0320 	orr.w	r3, r3, #32
 800ff14:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
                        gc_block.values.ijk[J_VALUE] = value;
 800ff18:	4b09      	ldr	r3, [pc, #36]	; (800ff40 <gc_execute_block+0xb60>)
 800ff1a:	ed83 8a10 	vstr	s16, [r3, #64]	; 0x40
                        break;
 800ff1e:	e6f3      	b.n	800fd08 <gc_execute_block+0x928>
                        ijk_words.k = On;
 800ff20:	9b04      	ldr	r3, [sp, #16]
 800ff22:	f043 0304 	orr.w	r3, r3, #4
 800ff26:	9304      	str	r3, [sp, #16]
                        word_bit.parameter.k = On;
 800ff28:	f89d 3070 	ldrb.w	r3, [sp, #112]	; 0x70
 800ff2c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800ff30:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
                        gc_block.values.ijk[K_VALUE] = value;
 800ff34:	4b02      	ldr	r3, [pc, #8]	; (800ff40 <gc_execute_block+0xb60>)
 800ff36:	ed83 8a11 	vstr	s16, [r3, #68]	; 0x44
                        break;
 800ff3a:	e6e5      	b.n	800fd08 <gc_execute_block+0x928>
 800ff3c:	2000350c 	.word	0x2000350c
 800ff40:	20003298 	.word	0x20003298
 800ff44:	2000343c 	.word	0x2000343c
 800ff48:	0018ca80 	.word	0x0018ca80
 800ff4c:	7fc00000 	.word	0x7fc00000
 800ff50:	42c80000 	.word	0x42c80000
                        if (mantissa > 0)
 800ff54:	2900      	cmp	r1, #0
 800ff56:	f042 8587 	bne.w	8012a68 <gc_execute_block+0x3688>
                        word_bit.parameter.l = On;
 800ff5a:	f89d 3071 	ldrb.w	r3, [sp, #113]	; 0x71
 800ff5e:	f043 0310 	orr.w	r3, r3, #16
 800ff62:	f88d 3071 	strb.w	r3, [sp, #113]	; 0x71
                        gc_block.values.l = isnan(value) ? 0xFF : (uint8_t)int_value;
 800ff66:	eeb4 8a48 	vcmp.f32	s16, s16
 800ff6a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ff6e:	d604      	bvs.n	800ff7a <gc_execute_block+0xb9a>
 800ff70:	b2e2      	uxtb	r2, r4
 800ff72:	4bae      	ldr	r3, [pc, #696]	; (801022c <gc_execute_block+0xe4c>)
 800ff74:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90
                        break;
 800ff78:	e6c6      	b.n	800fd08 <gc_execute_block+0x928>
                        gc_block.values.l = isnan(value) ? 0xFF : (uint8_t)int_value;
 800ff7a:	22ff      	movs	r2, #255	; 0xff
 800ff7c:	e7f9      	b.n	800ff72 <gc_execute_block+0xb92>
                        word_bit.parameter.n = On;
 800ff7e:	f89d 3071 	ldrb.w	r3, [sp, #113]	; 0x71
 800ff82:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800ff86:	f88d 3071 	strb.w	r3, [sp, #113]	; 0x71
                        gc_block.values.n = (int32_t)truncf(value);
 800ff8a:	4aa8      	ldr	r2, [pc, #672]	; (801022c <gc_execute_block+0xe4c>)
 800ff8c:	eefd 7ac8 	vcvt.s32.f32	s15, s16
 800ff90:	edc2 7a20 	vstr	s15, [r2, #128]	; 0x80
                        break;
 800ff94:	e6b8      	b.n	800fd08 <gc_execute_block+0x928>
                        if (mantissa > 0)
 800ff96:	2900      	cmp	r1, #0
 800ff98:	f042 8569 	bne.w	8012a6e <gc_execute_block+0x368e>
                        word_bit.parameter.o = On;
 800ff9c:	f89d 3071 	ldrb.w	r3, [sp, #113]	; 0x71
 800ffa0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800ffa4:	f88d 3071 	strb.w	r3, [sp, #113]	; 0x71
                        gc_block.values.o = isnan(value) ? 0xFFFFFFFF : int_value;
 800ffa8:	eeb4 8a48 	vcmp.f32	s16, s16
 800ffac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ffb0:	d604      	bvs.n	800ffbc <gc_execute_block+0xbdc>
 800ffb2:	4622      	mov	r2, r4
 800ffb4:	4b9d      	ldr	r3, [pc, #628]	; (801022c <gc_execute_block+0xe4c>)
 800ffb6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                        break;
 800ffba:	e6a5      	b.n	800fd08 <gc_execute_block+0x928>
                        gc_block.values.o = isnan(value) ? 0xFFFFFFFF : int_value;
 800ffbc:	f04f 32ff 	mov.w	r2, #4294967295
 800ffc0:	e7f8      	b.n	800ffb4 <gc_execute_block+0xbd4>
                        word_bit.parameter.p = On;
 800ffc2:	f89d 3072 	ldrb.w	r3, [sp, #114]	; 0x72
 800ffc6:	f043 0301 	orr.w	r3, r3, #1
 800ffca:	f88d 3072 	strb.w	r3, [sp, #114]	; 0x72
                        gc_block.values.p = value;
 800ffce:	4b97      	ldr	r3, [pc, #604]	; (801022c <gc_execute_block+0xe4c>)
 800ffd0:	ed83 8a14 	vstr	s16, [r3, #80]	; 0x50
                        break;
 800ffd4:	e698      	b.n	800fd08 <gc_execute_block+0x928>
                        word_bit.parameter.q = On;
 800ffd6:	f89d 3072 	ldrb.w	r3, [sp, #114]	; 0x72
 800ffda:	f043 0302 	orr.w	r3, r3, #2
 800ffde:	f88d 3072 	strb.w	r3, [sp, #114]	; 0x72
                        gc_block.values.q = value;
 800ffe2:	4b92      	ldr	r3, [pc, #584]	; (801022c <gc_execute_block+0xe4c>)
 800ffe4:	ed83 8a15 	vstr	s16, [r3, #84]	; 0x54
                        break;
 800ffe8:	e68e      	b.n	800fd08 <gc_execute_block+0x928>
                        word_bit.parameter.r = On;
 800ffea:	f89d 3072 	ldrb.w	r3, [sp, #114]	; 0x72
 800ffee:	f043 0304 	orr.w	r3, r3, #4
 800fff2:	f88d 3072 	strb.w	r3, [sp, #114]	; 0x72
                        gc_block.values.r = value;
 800fff6:	4b8d      	ldr	r3, [pc, #564]	; (801022c <gc_execute_block+0xe4c>)
 800fff8:	ed83 8a16 	vstr	s16, [r3, #88]	; 0x58
                        break;
 800fffc:	e684      	b.n	800fd08 <gc_execute_block+0x928>
                        word_bit.parameter.s = On;
 800fffe:	f89d 3072 	ldrb.w	r3, [sp, #114]	; 0x72
 8010002:	f043 0308 	orr.w	r3, r3, #8
 8010006:	f88d 3072 	strb.w	r3, [sp, #114]	; 0x72
                        gc_block.values.s = value;
 801000a:	4b88      	ldr	r3, [pc, #544]	; (801022c <gc_execute_block+0xe4c>)
 801000c:	ed83 8a17 	vstr	s16, [r3, #92]	; 0x5c
                        break;
 8010010:	e67a      	b.n	800fd08 <gc_execute_block+0x928>
                        if (mantissa > 0)
 8010012:	2900      	cmp	r1, #0
 8010014:	f042 852e 	bne.w	8012a74 <gc_execute_block+0x3694>
                        if (int_value > MAX_TOOL_NUMBER)
 8010018:	f1b4 3fff 	cmp.w	r4, #4294967295
 801001c:	f002 852d 	beq.w	8012a7a <gc_execute_block+0x369a>
                        word_bit.parameter.t = On;
 8010020:	f89d 3072 	ldrb.w	r3, [sp, #114]	; 0x72
 8010024:	f043 0310 	orr.w	r3, r3, #16
 8010028:	f88d 3072 	strb.w	r3, [sp, #114]	; 0x72
                        gc_block.values.t = isnan(value) ? 0xFFFFFFFF : int_value;
 801002c:	eeb4 8a48 	vcmp.f32	s16, s16
 8010030:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010034:	d604      	bvs.n	8010040 <gc_execute_block+0xc60>
 8010036:	4622      	mov	r2, r4
 8010038:	4b7c      	ldr	r3, [pc, #496]	; (801022c <gc_execute_block+0xe4c>)
 801003a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
                        break;
 801003e:	e663      	b.n	800fd08 <gc_execute_block+0x928>
                        gc_block.values.t = isnan(value) ? 0xFFFFFFFF : int_value;
 8010040:	f04f 32ff 	mov.w	r2, #4294967295
 8010044:	e7f8      	b.n	8010038 <gc_execute_block+0xc58>
                        axis_words.x = On;
 8010046:	f04b 0b01 	orr.w	fp, fp, #1
                        word_bit.parameter.x = On;
 801004a:	f89d 3073 	ldrb.w	r3, [sp, #115]	; 0x73
 801004e:	f043 0301 	orr.w	r3, r3, #1
 8010052:	f88d 3073 	strb.w	r3, [sp, #115]	; 0x73
                        gc_block.values.xyz[X_AXIS] = value;
 8010056:	4b75      	ldr	r3, [pc, #468]	; (801022c <gc_execute_block+0xe4c>)
 8010058:	ed83 8a18 	vstr	s16, [r3, #96]	; 0x60
                        break;
 801005c:	e654      	b.n	800fd08 <gc_execute_block+0x928>
                        axis_words.y = On;
 801005e:	f04b 0b02 	orr.w	fp, fp, #2
                        word_bit.parameter.y = On;
 8010062:	f89d 3073 	ldrb.w	r3, [sp, #115]	; 0x73
 8010066:	f043 0302 	orr.w	r3, r3, #2
 801006a:	f88d 3073 	strb.w	r3, [sp, #115]	; 0x73
                        gc_block.values.xyz[Y_AXIS] = value;
 801006e:	4b6f      	ldr	r3, [pc, #444]	; (801022c <gc_execute_block+0xe4c>)
 8010070:	ed83 8a19 	vstr	s16, [r3, #100]	; 0x64
                        break;
 8010074:	e648      	b.n	800fd08 <gc_execute_block+0x928>
                        axis_words.z = On;
 8010076:	f04b 0b04 	orr.w	fp, fp, #4
                        word_bit.parameter.z = On;
 801007a:	f89d 3073 	ldrb.w	r3, [sp, #115]	; 0x73
 801007e:	f043 0304 	orr.w	r3, r3, #4
 8010082:	f88d 3073 	strb.w	r3, [sp, #115]	; 0x73
                        gc_block.values.xyz[Z_AXIS] = value;
 8010086:	4b69      	ldr	r3, [pc, #420]	; (801022c <gc_execute_block+0xe4c>)
 8010088:	ed83 8a1a 	vstr	s16, [r3, #104]	; 0x68
                        break;
 801008c:	e63c      	b.n	800fd08 <gc_execute_block+0x928>
                        if(mantissa > 0)
 801008e:	2900      	cmp	r1, #0
 8010090:	f042 84f6 	bne.w	8012a80 <gc_execute_block+0x36a0>
                        word_bit.parameter.$ = On;
 8010094:	f89d 3070 	ldrb.w	r3, [sp, #112]	; 0x70
 8010098:	f043 0301 	orr.w	r3, r3, #1
 801009c:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
                        gc_block.values.$ = (int32_t)value;
 80100a0:	4a62      	ldr	r2, [pc, #392]	; (801022c <gc_execute_block+0xe4c>)
 80100a2:	eefd 7ac8 	vcvt.s32.f32	s15, s16
 80100a6:	edc2 7a1f 	vstr	s15, [r2, #124]	; 0x7c
                        break;
 80100aa:	e62d      	b.n	800fd08 <gc_execute_block+0x928>
    if (axis_words.mask && !axis_command)
 80100ac:	fa5f f38b 	uxtb.w	r3, fp
 80100b0:	b123      	cbz	r3, 80100bc <gc_execute_block+0xcdc>
 80100b2:	f1ba 0f00 	cmp.w	sl, #0
 80100b6:	d101      	bne.n	80100bc <gc_execute_block+0xcdc>
        axis_command = AxisCommand_MotionMode; // Assign implicit motion-mode
 80100b8:	f04f 0a02 	mov.w	sl, #2
    if(gc_state.tool_change && axis_command == AxisCommand_MotionMode && !gc_parser_flags.jog_motion)
 80100bc:	4b5c      	ldr	r3, [pc, #368]	; (8010230 <gc_execute_block+0xe50>)
 80100be:	f893 3077 	ldrb.w	r3, [r3, #119]	; 0x77
 80100c2:	b113      	cbz	r3, 80100ca <gc_execute_block+0xcea>
 80100c4:	f1ba 0f02 	cmp.w	sl, #2
 80100c8:	d051      	beq.n	801016e <gc_execute_block+0xd8e>
    if (gc_block.words.n && gc_block.values.n > MAX_LINE_NUMBER)
 80100ca:	4b58      	ldr	r3, [pc, #352]	; (801022c <gc_execute_block+0xe4c>)
 80100cc:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 80100d0:	f013 0f40 	tst.w	r3, #64	; 0x40
 80100d4:	d006      	beq.n	80100e4 <gc_execute_block+0xd04>
 80100d6:	4a55      	ldr	r2, [pc, #340]	; (801022c <gc_execute_block+0xe4c>)
 80100d8:	f8d2 1080 	ldr.w	r1, [r2, #128]	; 0x80
 80100dc:	4a55      	ldr	r2, [pc, #340]	; (8010234 <gc_execute_block+0xe54>)
 80100de:	4291      	cmp	r1, r2
 80100e0:	f302 84d7 	bgt.w	8012a92 <gc_execute_block+0x36b2>
    if (gc_parser_flags.jog_motion) {
 80100e4:	f018 0f01 	tst.w	r8, #1
 80100e8:	d047      	beq.n	801017a <gc_execute_block+0xd9a>
        if(!gc_block.words.f)
 80100ea:	f013 0f02 	tst.w	r3, #2
 80100ee:	f002 84d3 	beq.w	8012a98 <gc_execute_block+0x36b8>
        if (gc_block.modal.units_imperial)
 80100f2:	4b4e      	ldr	r3, [pc, #312]	; (801022c <gc_execute_block+0xe4c>)
 80100f4:	7adb      	ldrb	r3, [r3, #11]
 80100f6:	b143      	cbz	r3, 801010a <gc_execute_block+0xd2a>
            gc_block.values.f *= MM_PER_INCH;
 80100f8:	4b4c      	ldr	r3, [pc, #304]	; (801022c <gc_execute_block+0xe4c>)
 80100fa:	edd3 7a0e 	vldr	s15, [r3, #56]	; 0x38
 80100fe:	ed9f 7a4e 	vldr	s14, [pc, #312]	; 8010238 <gc_execute_block+0xe58>
 8010102:	ee67 7a87 	vmul.f32	s15, s15, s14
 8010106:	edc3 7a0e 	vstr	s15, [r3, #56]	; 0x38
    if(gc_block.words.$) {
 801010a:	4b48      	ldr	r3, [pc, #288]	; (801022c <gc_execute_block+0xe4c>)
 801010c:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 8010110:	f013 0f01 	tst.w	r3, #1
 8010114:	f000 80d1 	beq.w	80102ba <gc_execute_block+0xeda>
        bool single_spindle_only = (gc_block.words.s && !user_words.s) ||
 8010118:	4b44      	ldr	r3, [pc, #272]	; (801022c <gc_execute_block+0xe4c>)
 801011a:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
                                      command_words.G14 ||
 801011e:	f013 0f08 	tst.w	r3, #8
 8010122:	d005      	beq.n	8010130 <gc_execute_block+0xd50>
        bool single_spindle_only = (gc_block.words.s && !user_words.s) ||
 8010124:	4b45      	ldr	r3, [pc, #276]	; (801023c <gc_execute_block+0xe5c>)
 8010126:	789b      	ldrb	r3, [r3, #2]
 8010128:	f013 0f08 	tst.w	r3, #8
 801012c:	f000 8088 	beq.w	8010240 <gc_execute_block+0xe60>
 8010130:	f017 0f01 	tst.w	r7, #1
 8010134:	d00c      	beq.n	8010150 <gc_execute_block+0xd70>
                                    (command_words.G0 && (gc_block.modal.motion == MotionMode_SpindleSynchronized ||
 8010136:	4b3d      	ldr	r3, [pc, #244]	; (801022c <gc_execute_block+0xe4c>)
 8010138:	891b      	ldrh	r3, [r3, #8]
 801013a:	2b21      	cmp	r3, #33	; 0x21
 801013c:	f000 8090 	beq.w	8010260 <gc_execute_block+0xe80>
 8010140:	f240 124b 	movw	r2, #331	; 0x14b
 8010144:	4293      	cmp	r3, r2
 8010146:	f000 808d 	beq.w	8010264 <gc_execute_block+0xe84>
                                                           gc_block.modal.motion == MotionMode_RigidTapping ||
 801014a:	2b4c      	cmp	r3, #76	; 0x4c
 801014c:	f000 808c 	beq.w	8010268 <gc_execute_block+0xe88>
                                                            gc_block.modal.motion == MotionMode_Threading)) ||
 8010150:	f417 5f00 	tst.w	r7, #8192	; 0x2000
 8010154:	f040 808a 	bne.w	801026c <gc_execute_block+0xe8c>
                                      command_words.G14 ||
 8010158:	f417 2f00 	tst.w	r7, #524288	; 0x80000
 801015c:	f000 8088 	beq.w	8010270 <gc_execute_block+0xe90>
                                       (command_words.M9 && gc_block.override_command == Override_SpindleSpeed);
 8010160:	4b32      	ldr	r3, [pc, #200]	; (801022c <gc_execute_block+0xe4c>)
 8010162:	785b      	ldrb	r3, [r3, #1]
 8010164:	2b33      	cmp	r3, #51	; 0x33
 8010166:	f000 8085 	beq.w	8010274 <gc_execute_block+0xe94>
                                      command_words.G14 ||
 801016a:	2300      	movs	r3, #0
 801016c:	e069      	b.n	8010242 <gc_execute_block+0xe62>
    if(gc_state.tool_change && axis_command == AxisCommand_MotionMode && !gc_parser_flags.jog_motion)
 801016e:	f018 0f01 	tst.w	r8, #1
 8010172:	d1aa      	bne.n	80100ca <gc_execute_block+0xcea>
        FAIL(Status_GcodeToolChangePending); // [Motions (except jogging) not allowed when changing tool]
 8010174:	2428      	movs	r4, #40	; 0x28
 8010176:	f7ff ba09 	b.w	800f58c <gc_execute_block+0x1ac>
    } else if(gc_block.modal.motion == MotionMode_SpindleSynchronized) {
 801017a:	4a2c      	ldr	r2, [pc, #176]	; (801022c <gc_execute_block+0xe4c>)
 801017c:	8912      	ldrh	r2, [r2, #8]
 801017e:	2a21      	cmp	r2, #33	; 0x21
 8010180:	d012      	beq.n	80101a8 <gc_execute_block+0xdc8>
    } else if (gc_block.modal.feed_mode == FeedMode_InverseTime) { // = G93
 8010182:	492a      	ldr	r1, [pc, #168]	; (801022c <gc_execute_block+0xe4c>)
 8010184:	7a89      	ldrb	r1, [r1, #10]
 8010186:	2901      	cmp	r1, #1
 8010188:	d033      	beq.n	80101f2 <gc_execute_block+0xe12>
    } else if (gc_block.modal.feed_mode == FeedMode_UnitsPerMin || gc_block.modal.feed_mode == FeedMode_UnitsPerRev) {
 801018a:	b109      	cbz	r1, 8010190 <gc_execute_block+0xdb0>
 801018c:	2902      	cmp	r1, #2
 801018e:	d1bc      	bne.n	801010a <gc_execute_block+0xd2a>
        if (!gc_block.words.f) {
 8010190:	f013 0f02 	tst.w	r3, #2
 8010194:	d13a      	bne.n	801020c <gc_execute_block+0xe2c>
            if(gc_block.modal.feed_mode == gc_state.modal.feed_mode)
 8010196:	4b26      	ldr	r3, [pc, #152]	; (8010230 <gc_execute_block+0xe50>)
 8010198:	789b      	ldrb	r3, [r3, #2]
 801019a:	4299      	cmp	r1, r3
 801019c:	d1b5      	bne.n	801010a <gc_execute_block+0xd2a>
                gc_block.values.f = gc_state.feed_rate; // Push last state feed rate
 801019e:	4b24      	ldr	r3, [pc, #144]	; (8010230 <gc_execute_block+0xe50>)
 80101a0:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80101a2:	4b22      	ldr	r3, [pc, #136]	; (801022c <gc_execute_block+0xe4c>)
 80101a4:	639a      	str	r2, [r3, #56]	; 0x38
 80101a6:	e7b0      	b.n	801010a <gc_execute_block+0xd2a>
        if (!gc_block.words.k) {
 80101a8:	4b20      	ldr	r3, [pc, #128]	; (801022c <gc_execute_block+0xe4c>)
 80101aa:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 80101ae:	f013 0f40 	tst.w	r3, #64	; 0x40
 80101b2:	d104      	bne.n	80101be <gc_execute_block+0xdde>
            gc_block.values.k = gc_state.distance_per_rev;
 80101b4:	4b1e      	ldr	r3, [pc, #120]	; (8010230 <gc_execute_block+0xe50>)
 80101b6:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 80101b8:	4b1c      	ldr	r3, [pc, #112]	; (801022c <gc_execute_block+0xe4c>)
 80101ba:	649a      	str	r2, [r3, #72]	; 0x48
 80101bc:	e7a5      	b.n	801010a <gc_execute_block+0xd2a>
            gc_block.words.k = Off;
 80101be:	4b1b      	ldr	r3, [pc, #108]	; (801022c <gc_execute_block+0xe4c>)
 80101c0:	f893 2094 	ldrb.w	r2, [r3, #148]	; 0x94
 80101c4:	f36f 1286 	bfc	r2, #6, #1
 80101c8:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
            gc_block.values.k = gc_block.modal.units_imperial ? gc_block.values.ijk[K_VALUE] *= MM_PER_INCH : gc_block.values.ijk[K_VALUE];
 80101cc:	7adb      	ldrb	r3, [r3, #11]
 80101ce:	b163      	cbz	r3, 80101ea <gc_execute_block+0xe0a>
 80101d0:	4b16      	ldr	r3, [pc, #88]	; (801022c <gc_execute_block+0xe4c>)
 80101d2:	edd3 7a11 	vldr	s15, [r3, #68]	; 0x44
 80101d6:	ed9f 7a18 	vldr	s14, [pc, #96]	; 8010238 <gc_execute_block+0xe58>
 80101da:	ee67 7a87 	vmul.f32	s15, s15, s14
 80101de:	edc3 7a11 	vstr	s15, [r3, #68]	; 0x44
 80101e2:	4b12      	ldr	r3, [pc, #72]	; (801022c <gc_execute_block+0xe4c>)
 80101e4:	edc3 7a12 	vstr	s15, [r3, #72]	; 0x48
 80101e8:	e78f      	b.n	801010a <gc_execute_block+0xd2a>
 80101ea:	4b10      	ldr	r3, [pc, #64]	; (801022c <gc_execute_block+0xe4c>)
 80101ec:	edd3 7a11 	vldr	s15, [r3, #68]	; 0x44
 80101f0:	e7f7      	b.n	80101e2 <gc_execute_block+0xe02>
        if (axis_command == AxisCommand_MotionMode) {
 80101f2:	f1ba 0f02 	cmp.w	sl, #2
 80101f6:	d188      	bne.n	801010a <gc_execute_block+0xd2a>
            if (!(gc_block.modal.motion == MotionMode_None || gc_block.modal.motion == MotionMode_Seek)) {
 80101f8:	2a50      	cmp	r2, #80	; 0x50
 80101fa:	d086      	beq.n	801010a <gc_execute_block+0xd2a>
 80101fc:	2a00      	cmp	r2, #0
 80101fe:	d084      	beq.n	801010a <gc_execute_block+0xd2a>
                if (!gc_block.words.f)
 8010200:	f013 0f02 	tst.w	r3, #2
 8010204:	d181      	bne.n	801010a <gc_execute_block+0xd2a>
                    FAIL(Status_GcodeUndefinedFeedRate); // [F word missing]
 8010206:	2416      	movs	r4, #22
 8010208:	f7ff b9c0 	b.w	800f58c <gc_execute_block+0x1ac>
        } else if (gc_block.modal.units_imperial)
 801020c:	4b07      	ldr	r3, [pc, #28]	; (801022c <gc_execute_block+0xe4c>)
 801020e:	7adb      	ldrb	r3, [r3, #11]
 8010210:	2b00      	cmp	r3, #0
 8010212:	f43f af7a 	beq.w	801010a <gc_execute_block+0xd2a>
            gc_block.values.f *= MM_PER_INCH;
 8010216:	4b05      	ldr	r3, [pc, #20]	; (801022c <gc_execute_block+0xe4c>)
 8010218:	edd3 7a0e 	vldr	s15, [r3, #56]	; 0x38
 801021c:	ed9f 7a06 	vldr	s14, [pc, #24]	; 8010238 <gc_execute_block+0xe58>
 8010220:	ee67 7a87 	vmul.f32	s15, s15, s14
 8010224:	edc3 7a0e 	vstr	s15, [r3, #56]	; 0x38
 8010228:	e76f      	b.n	801010a <gc_execute_block+0xd2a>
 801022a:	bf00      	nop
 801022c:	20003298 	.word	0x20003298
 8010230:	20003344 	.word	0x20003344
 8010234:	00989680 	.word	0x00989680
 8010238:	41cb3333 	.word	0x41cb3333
 801023c:	20003438 	.word	0x20003438
                                      command_words.G14 ||
 8010240:	2301      	movs	r3, #1
        if(command_words.M7 || single_spindle_only) {
 8010242:	f417 3f00 	tst.w	r7, #131072	; 0x20000
 8010246:	d101      	bne.n	801024c <gc_execute_block+0xe6c>
 8010248:	2b00      	cmp	r3, #0
 801024a:	d03a      	beq.n	80102c2 <gc_execute_block+0xee2>
            if(gc_block.values.$ < (single_spindle_only ? 0 : -1))
 801024c:	4aa7      	ldr	r2, [pc, #668]	; (80104ec <gc_execute_block+0x110c>)
 801024e:	6fd0      	ldr	r0, [r2, #124]	; 0x7c
 8010250:	b193      	cbz	r3, 8010278 <gc_execute_block+0xe98>
 8010252:	2200      	movs	r2, #0
 8010254:	4290      	cmp	r0, r2
 8010256:	da15      	bge.n	8010284 <gc_execute_block+0xea4>
                FAIL(single_spindle_only ? Status_NegativeValue : Status_GcodeValueOutOfRange);
 8010258:	b18b      	cbz	r3, 801027e <gc_execute_block+0xe9e>
 801025a:	2404      	movs	r4, #4
 801025c:	f7ff b996 	b.w	800f58c <gc_execute_block+0x1ac>
                                      command_words.G14 ||
 8010260:	2301      	movs	r3, #1
 8010262:	e7ee      	b.n	8010242 <gc_execute_block+0xe62>
 8010264:	2301      	movs	r3, #1
 8010266:	e7ec      	b.n	8010242 <gc_execute_block+0xe62>
 8010268:	2301      	movs	r3, #1
 801026a:	e7ea      	b.n	8010242 <gc_execute_block+0xe62>
 801026c:	2301      	movs	r3, #1
 801026e:	e7e8      	b.n	8010242 <gc_execute_block+0xe62>
 8010270:	2300      	movs	r3, #0
 8010272:	e7e6      	b.n	8010242 <gc_execute_block+0xe62>
 8010274:	2301      	movs	r3, #1
 8010276:	e7e4      	b.n	8010242 <gc_execute_block+0xe62>
            if(gc_block.values.$ < (single_spindle_only ? 0 : -1))
 8010278:	f04f 32ff 	mov.w	r2, #4294967295
 801027c:	e7ea      	b.n	8010254 <gc_execute_block+0xe74>
                FAIL(single_spindle_only ? Status_NegativeValue : Status_GcodeValueOutOfRange);
 801027e:	2427      	movs	r4, #39	; 0x27
 8010280:	f7ff b984 	b.w	800f58c <gc_execute_block+0x1ac>
            if(!spindle_is_enabled(gc_block.values.$))
 8010284:	b240      	sxtb	r0, r0
 8010286:	f00d fb51 	bl	801d92c <spindle_is_enabled>
 801028a:	2800      	cmp	r0, #0
 801028c:	f002 8407 	beq.w	8012a9e <gc_execute_block+0x36be>
            if(gc_block.values.$ >= 0)
 8010290:	4b96      	ldr	r3, [pc, #600]	; (80104ec <gc_execute_block+0x110c>)
 8010292:	6fd8      	ldr	r0, [r3, #124]	; 0x7c
 8010294:	2800      	cmp	r0, #0
 8010296:	da07      	bge.n	80102a8 <gc_execute_block+0xec8>
            gc_block.words.$ = Off;
 8010298:	4b94      	ldr	r3, [pc, #592]	; (80104ec <gc_execute_block+0x110c>)
 801029a:	f893 2094 	ldrb.w	r2, [r3, #148]	; 0x94
 801029e:	f36f 0200 	bfc	r2, #0, #1
 80102a2:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
 80102a6:	e00c      	b.n	80102c2 <gc_execute_block+0xee2>
                gc_state.spindle.hal = gc_block.spindle = spindle_get(gc_block.values.$);
 80102a8:	b240      	sxtb	r0, r0
 80102aa:	f00d fb53 	bl	801d954 <spindle_get>
 80102ae:	4a8f      	ldr	r2, [pc, #572]	; (80104ec <gc_execute_block+0x110c>)
 80102b0:	f8c2 00a8 	str.w	r0, [r2, #168]	; 0xa8
 80102b4:	4a8e      	ldr	r2, [pc, #568]	; (80104f0 <gc_execute_block+0x1110>)
 80102b6:	6550      	str	r0, [r2, #84]	; 0x54
 80102b8:	e7ee      	b.n	8010298 <gc_execute_block+0xeb8>
    } else if(gc_block.spindle == NULL)
 80102ba:	4b8c      	ldr	r3, [pc, #560]	; (80104ec <gc_execute_block+0x110c>)
 80102bc:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 80102c0:	b323      	cbz	r3, 801030c <gc_execute_block+0xf2c>
    if(gc_block.modal.feed_mode == FeedMode_UnitsPerRev && !gc_state.spindle.hal->get_data)
 80102c2:	4b8a      	ldr	r3, [pc, #552]	; (80104ec <gc_execute_block+0x110c>)
 80102c4:	7a9b      	ldrb	r3, [r3, #10]
 80102c6:	2b02      	cmp	r3, #2
 80102c8:	d026      	beq.n	8010318 <gc_execute_block+0xf38>
    if (command_words.G14) {
 80102ca:	f3c7 2507 	ubfx	r5, r7, #8, #8
 80102ce:	f417 5f00 	tst.w	r7, #8192	; 0x2000
 80102d2:	d00d      	beq.n	80102f0 <gc_execute_block+0xf10>
        if(gc_block.modal.spindle.rpm_mode == SpindleSpeedMode_CSS) {
 80102d4:	4b85      	ldr	r3, [pc, #532]	; (80104ec <gc_execute_block+0x110c>)
 80102d6:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
 80102da:	2b01      	cmp	r3, #1
 80102dc:	d024      	beq.n	8010328 <gc_execute_block+0xf48>
        } else if(gc_state.modal.spindle.rpm_mode == SpindleSpeedMode_CSS) {
 80102de:	4b84      	ldr	r3, [pc, #528]	; (80104f0 <gc_execute_block+0x1110>)
 80102e0:	7edb      	ldrb	r3, [r3, #27]
 80102e2:	2b01      	cmp	r3, #1
 80102e4:	d04e      	beq.n	8010384 <gc_execute_block+0xfa4>
        gc_state.modal.spindle.rpm_mode = gc_block.modal.spindle.rpm_mode;
 80102e6:	4b81      	ldr	r3, [pc, #516]	; (80104ec <gc_execute_block+0x110c>)
 80102e8:	f893 2023 	ldrb.w	r2, [r3, #35]	; 0x23
 80102ec:	4b80      	ldr	r3, [pc, #512]	; (80104f0 <gc_execute_block+0x1110>)
 80102ee:	76da      	strb	r2, [r3, #27]
    spindle_programmed = gc_block.words.s && !user_words.s;
 80102f0:	4b7e      	ldr	r3, [pc, #504]	; (80104ec <gc_execute_block+0x110c>)
 80102f2:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 80102f6:	f013 0308 	ands.w	r3, r3, #8
 80102fa:	d051      	beq.n	80103a0 <gc_execute_block+0xfc0>
 80102fc:	4a7d      	ldr	r2, [pc, #500]	; (80104f4 <gc_execute_block+0x1114>)
 80102fe:	7892      	ldrb	r2, [r2, #2]
 8010300:	f012 0f08 	tst.w	r2, #8
 8010304:	f000 80cc 	beq.w	80104a0 <gc_execute_block+0x10c0>
 8010308:	2200      	movs	r2, #0
 801030a:	e04a      	b.n	80103a2 <gc_execute_block+0xfc2>
        gc_block.spindle = gc_state.spindle.hal;
 801030c:	4b78      	ldr	r3, [pc, #480]	; (80104f0 <gc_execute_block+0x1110>)
 801030e:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8010310:	4b76      	ldr	r3, [pc, #472]	; (80104ec <gc_execute_block+0x110c>)
 8010312:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
 8010316:	e7d4      	b.n	80102c2 <gc_execute_block+0xee2>
    if(gc_block.modal.feed_mode == FeedMode_UnitsPerRev && !gc_state.spindle.hal->get_data)
 8010318:	4b75      	ldr	r3, [pc, #468]	; (80104f0 <gc_execute_block+0x1110>)
 801031a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801031c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801031e:	2b00      	cmp	r3, #0
 8010320:	d1d3      	bne.n	80102ca <gc_execute_block+0xeea>
        FAIL(Status_GcodeUnsupportedCommand); // [G95 not supported]
 8010322:	2414      	movs	r4, #20
 8010324:	f7ff b932 	b.w	800f58c <gc_execute_block+0x1ac>
            if(!gc_state.spindle.hal->cap.variable)
 8010328:	4b71      	ldr	r3, [pc, #452]	; (80104f0 <gc_execute_block+0x1110>)
 801032a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801032c:	7a5a      	ldrb	r2, [r3, #9]
 801032e:	f012 0f01 	tst.w	r2, #1
 8010332:	f002 83b7 	beq.w	8012aa4 <gc_execute_block+0x36c4>
            if (!gc_block.words.s) // TODO: add check for S0?
 8010336:	4a6d      	ldr	r2, [pc, #436]	; (80104ec <gc_execute_block+0x110c>)
 8010338:	f892 2096 	ldrb.w	r2, [r2, #150]	; 0x96
 801033c:	f012 0f08 	tst.w	r2, #8
 8010340:	f002 83b3 	beq.w	8012aaa <gc_execute_block+0x36ca>
            if (gc_block.words.d) {
 8010344:	4a69      	ldr	r2, [pc, #420]	; (80104ec <gc_execute_block+0x110c>)
 8010346:	f992 2094 	ldrsb.w	r2, [r2, #148]	; 0x94
 801034a:	2a00      	cmp	r2, #0
 801034c:	db03      	blt.n	8010356 <gc_execute_block+0xf76>
                gc_state.spindle.hal->param->css.max_rpm = gc_state.spindle.hal->rpm_max;
 801034e:	685a      	ldr	r2, [r3, #4]
 8010350:	695b      	ldr	r3, [r3, #20]
 8010352:	61d3      	str	r3, [r2, #28]
 8010354:	e7c7      	b.n	80102e6 <gc_execute_block+0xf06>
                gc_state.spindle.hal->param->css.max_rpm = min(gc_block.values.d, gc_state.spindle.hal->rpm_max);
 8010356:	4a65      	ldr	r2, [pc, #404]	; (80104ec <gc_execute_block+0x110c>)
 8010358:	ed92 7a0c 	vldr	s14, [r2, #48]	; 0x30
 801035c:	edd3 7a05 	vldr	s15, [r3, #20]
 8010360:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8010364:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010368:	d501      	bpl.n	801036e <gc_execute_block+0xf8e>
 801036a:	eef0 7a47 	vmov.f32	s15, s14
 801036e:	685b      	ldr	r3, [r3, #4]
 8010370:	edc3 7a07 	vstr	s15, [r3, #28]
                gc_block.words.d = Off;
 8010374:	4b5d      	ldr	r3, [pc, #372]	; (80104ec <gc_execute_block+0x110c>)
 8010376:	f893 2094 	ldrb.w	r2, [r3, #148]	; 0x94
 801037a:	f36f 12c7 	bfc	r2, #7, #1
 801037e:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
 8010382:	e7b0      	b.n	80102e6 <gc_execute_block+0xf06>
            if(gc_state.spindle.css) {
 8010384:	4b5a      	ldr	r3, [pc, #360]	; (80104f0 <gc_execute_block+0x1110>)
 8010386:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8010388:	b123      	cbz	r3, 8010394 <gc_execute_block+0xfb4>
                gc_state.spindle.css = NULL;
 801038a:	4b59      	ldr	r3, [pc, #356]	; (80104f0 <gc_execute_block+0x1110>)
 801038c:	2200      	movs	r2, #0
 801038e:	651a      	str	r2, [r3, #80]	; 0x50
                protocol_buffer_synchronize(); // Empty planner buffer to ensure we get RPM at end of last CSS motion
 8010390:	f007 fc22 	bl	8017bd8 <protocol_buffer_synchronize>
            gc_state.spindle.rpm = gc_state.spindle.hal->param->rpm; // Is it correct to restore latest spindle RPM here?
 8010394:	4b56      	ldr	r3, [pc, #344]	; (80104f0 <gc_execute_block+0x1110>)
 8010396:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8010398:	6852      	ldr	r2, [r2, #4]
 801039a:	6812      	ldr	r2, [r2, #0]
 801039c:	649a      	str	r2, [r3, #72]	; 0x48
 801039e:	e7a2      	b.n	80102e6 <gc_execute_block+0xf06>
    spindle_programmed = gc_block.words.s && !user_words.s;
 80103a0:	2200      	movs	r2, #0
 80103a2:	9207      	str	r2, [sp, #28]
    if (!gc_block.words.s)
 80103a4:	2b00      	cmp	r3, #0
 80103a6:	f040 8082 	bne.w	80104ae <gc_execute_block+0x10ce>
        gc_block.values.s = gc_state.modal.spindle.rpm_mode == SpindleSpeedMode_RPM ? gc_state.spindle.rpm : gc_state.spindle.hal->param->css.max_rpm;
 80103aa:	4b51      	ldr	r3, [pc, #324]	; (80104f0 <gc_execute_block+0x1110>)
 80103ac:	7edb      	ldrb	r3, [r3, #27]
 80103ae:	2b00      	cmp	r3, #0
 80103b0:	d178      	bne.n	80104a4 <gc_execute_block+0x10c4>
 80103b2:	4b4f      	ldr	r3, [pc, #316]	; (80104f0 <gc_execute_block+0x1110>)
 80103b4:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 80103b6:	4b4d      	ldr	r3, [pc, #308]	; (80104ec <gc_execute_block+0x110c>)
 80103b8:	65da      	str	r2, [r3, #92]	; 0x5c
    if(set_tool) { // M61
 80103ba:	9b06      	ldr	r3, [sp, #24]
 80103bc:	2b00      	cmp	r3, #0
 80103be:	f000 80a1 	beq.w	8010504 <gc_execute_block+0x1124>
        if(!gc_block.words.q)
 80103c2:	4b4a      	ldr	r3, [pc, #296]	; (80104ec <gc_execute_block+0x110c>)
 80103c4:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 80103c8:	f013 0f02 	tst.w	r3, #2
 80103cc:	f002 8370 	beq.w	8012ab0 <gc_execute_block+0x36d0>
        if (floorf(gc_block.values.q) - gc_block.values.q != 0.0f)
 80103d0:	4b46      	ldr	r3, [pc, #280]	; (80104ec <gc_execute_block+0x110c>)
 80103d2:	ed93 8a15 	vldr	s16, [r3, #84]	; 0x54
 80103d6:	eeb0 0a48 	vmov.f32	s0, s16
 80103da:	f013 fc4d 	bl	8023c78 <floorf>
 80103de:	ee70 7a48 	vsub.f32	s15, s0, s16
 80103e2:	eef5 7a40 	vcmp.f32	s15, #0.0
 80103e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80103ea:	f042 8364 	bne.w	8012ab6 <gc_execute_block+0x36d6>
        if ((uint32_t)gc_block.values.q > MAX_TOOL_NUMBER)
 80103ee:	eefc 7ac8 	vcvt.u32.f32	s15, s16
 80103f2:	ee17 3a90 	vmov	r3, s15
 80103f6:	f1b3 3fff 	cmp.w	r3, #4294967295
 80103fa:	f002 835f 	beq.w	8012abc <gc_execute_block+0x36dc>
        gc_block.values.t = (uint32_t)gc_block.values.q;
 80103fe:	4a3b      	ldr	r2, [pc, #236]	; (80104ec <gc_execute_block+0x110c>)
 8010400:	edc2 7a23 	vstr	s15, [r2, #140]	; 0x8c
        gc_block.words.q = Off;
 8010404:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 8010408:	f36f 0341 	bfc	r3, #1, #1
 801040c:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
    if(command_words.M10 && port_command) {
 8010410:	f3c7 4907 	ubfx	r9, r7, #16, #8
 8010414:	f019 0410 	ands.w	r4, r9, #16
 8010418:	f000 80b5 	beq.w	8010586 <gc_execute_block+0x11a6>
 801041c:	9b05      	ldr	r3, [sp, #20]
 801041e:	2b00      	cmp	r3, #0
 8010420:	f000 80b1 	beq.w	8010586 <gc_execute_block+0x11a6>
        switch(port_command) {
 8010424:	2b42      	cmp	r3, #66	; 0x42
 8010426:	f000 80e6 	beq.w	80105f6 <gc_execute_block+0x1216>
 801042a:	d878      	bhi.n	801051e <gc_execute_block+0x113e>
 801042c:	3b3e      	subs	r3, #62	; 0x3e
 801042e:	b2db      	uxtb	r3, r3
 8010430:	2b03      	cmp	r3, #3
 8010432:	f200 80a8 	bhi.w	8010586 <gc_execute_block+0x11a6>
                if(!gc_block.words.p)
 8010436:	4b2d      	ldr	r3, [pc, #180]	; (80104ec <gc_execute_block+0x110c>)
 8010438:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 801043c:	f013 0f01 	tst.w	r3, #1
 8010440:	f002 833f 	beq.w	8012ac2 <gc_execute_block+0x36e2>
                if(gc_block.values.p < 0.0f)
 8010444:	4b29      	ldr	r3, [pc, #164]	; (80104ec <gc_execute_block+0x110c>)
 8010446:	edd3 7a14 	vldr	s15, [r3, #80]	; 0x50
 801044a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801044e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010452:	f102 8339 	bmi.w	8012ac8 <gc_execute_block+0x36e8>
                if((uint32_t)gc_block.values.p + 1 > hal.port.num_digital_out)
 8010456:	eebc 7ae7 	vcvt.u32.f32	s14, s15
 801045a:	ee17 3a10 	vmov	r3, s14
 801045e:	3301      	adds	r3, #1
 8010460:	4a25      	ldr	r2, [pc, #148]	; (80104f8 <gc_execute_block+0x1118>)
 8010462:	f892 2115 	ldrb.w	r2, [r2, #277]	; 0x115
 8010466:	4293      	cmp	r3, r2
 8010468:	f202 8331 	bhi.w	8012ace <gc_execute_block+0x36ee>
                gc_block.output_command.is_digital = true;
 801046c:	4a1f      	ldr	r2, [pc, #124]	; (80104ec <gc_execute_block+0x110c>)
 801046e:	2301      	movs	r3, #1
 8010470:	f882 3098 	strb.w	r3, [r2, #152]	; 0x98
                gc_block.output_command.port = (uint8_t)gc_block.values.p;
 8010474:	ee17 3a10 	vmov	r3, s14
 8010478:	f882 309a 	strb.w	r3, [r2, #154]	; 0x9a
                gc_block.output_command.value = port_command == 62 || port_command == 64 ? 1.0f : 0.0f;
 801047c:	9b05      	ldr	r3, [sp, #20]
 801047e:	2b3e      	cmp	r3, #62	; 0x3e
 8010480:	f000 80b7 	beq.w	80105f2 <gc_execute_block+0x1212>
 8010484:	2b40      	cmp	r3, #64	; 0x40
 8010486:	f000 80b2 	beq.w	80105ee <gc_execute_block+0x120e>
 801048a:	2200      	movs	r2, #0
 801048c:	4b17      	ldr	r3, [pc, #92]	; (80104ec <gc_execute_block+0x110c>)
 801048e:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
                gc_block.words.p = Off;
 8010492:	f893 2096 	ldrb.w	r2, [r3, #150]	; 0x96
 8010496:	f36f 0200 	bfc	r2, #0, #1
 801049a:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
                break;
 801049e:	e072      	b.n	8010586 <gc_execute_block+0x11a6>
    spindle_programmed = gc_block.words.s && !user_words.s;
 80104a0:	2201      	movs	r2, #1
 80104a2:	e77e      	b.n	80103a2 <gc_execute_block+0xfc2>
        gc_block.values.s = gc_state.modal.spindle.rpm_mode == SpindleSpeedMode_RPM ? gc_state.spindle.rpm : gc_state.spindle.hal->param->css.max_rpm;
 80104a4:	4b12      	ldr	r3, [pc, #72]	; (80104f0 <gc_execute_block+0x1110>)
 80104a6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80104a8:	685b      	ldr	r3, [r3, #4]
 80104aa:	69da      	ldr	r2, [r3, #28]
 80104ac:	e783      	b.n	80103b6 <gc_execute_block+0xfd6>
    else if(!user_words.s && gc_state.modal.spindle.rpm_mode == SpindleSpeedMode_CSS) {
 80104ae:	4b11      	ldr	r3, [pc, #68]	; (80104f4 <gc_execute_block+0x1114>)
 80104b0:	789b      	ldrb	r3, [r3, #2]
 80104b2:	f013 0f08 	tst.w	r3, #8
 80104b6:	d180      	bne.n	80103ba <gc_execute_block+0xfda>
 80104b8:	4b0d      	ldr	r3, [pc, #52]	; (80104f0 <gc_execute_block+0x1110>)
 80104ba:	7edb      	ldrb	r3, [r3, #27]
 80104bc:	2b01      	cmp	r3, #1
 80104be:	f47f af7c 	bne.w	80103ba <gc_execute_block+0xfda>
        gc_block.values.s *= (gc_block.modal.units_imperial ? MM_PER_INCH * 12.0f : 1000.0f); // convert surface speed to mm/min
 80104c2:	4b0a      	ldr	r3, [pc, #40]	; (80104ec <gc_execute_block+0x110c>)
 80104c4:	edd3 7a17 	vldr	s15, [r3, #92]	; 0x5c
 80104c8:	7adb      	ldrb	r3, [r3, #11]
 80104ca:	b163      	cbz	r3, 80104e6 <gc_execute_block+0x1106>
 80104cc:	ed9f 7a0b 	vldr	s14, [pc, #44]	; 80104fc <gc_execute_block+0x111c>
 80104d0:	ee67 7a87 	vmul.f32	s15, s15, s14
 80104d4:	4b05      	ldr	r3, [pc, #20]	; (80104ec <gc_execute_block+0x110c>)
 80104d6:	edc3 7a17 	vstr	s15, [r3, #92]	; 0x5c
        gc_state.spindle.hal->param->css.surface_speed = gc_block.values.s;
 80104da:	4b05      	ldr	r3, [pc, #20]	; (80104f0 <gc_execute_block+0x1110>)
 80104dc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80104de:	685b      	ldr	r3, [r3, #4]
 80104e0:	edc3 7a04 	vstr	s15, [r3, #16]
 80104e4:	e769      	b.n	80103ba <gc_execute_block+0xfda>
        gc_block.values.s *= (gc_block.modal.units_imperial ? MM_PER_INCH * 12.0f : 1000.0f); // convert surface speed to mm/min
 80104e6:	ed9f 7a06 	vldr	s14, [pc, #24]	; 8010500 <gc_execute_block+0x1120>
 80104ea:	e7f1      	b.n	80104d0 <gc_execute_block+0x10f0>
 80104ec:	20003298 	.word	0x20003298
 80104f0:	20003344 	.word	0x20003344
 80104f4:	20003438 	.word	0x20003438
 80104f8:	2000350c 	.word	0x2000350c
 80104fc:	43986666 	.word	0x43986666
 8010500:	447a0000 	.word	0x447a0000
    } else if (!gc_block.words.t)
 8010504:	4bb6      	ldr	r3, [pc, #728]	; (80107e0 <gc_execute_block+0x1400>)
 8010506:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 801050a:	f013 0f10 	tst.w	r3, #16
 801050e:	f47f af7f 	bne.w	8010410 <gc_execute_block+0x1030>
        gc_block.values.t = gc_state.tool_pending;
 8010512:	4bb4      	ldr	r3, [pc, #720]	; (80107e4 <gc_execute_block+0x1404>)
 8010514:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8010516:	4bb2      	ldr	r3, [pc, #712]	; (80107e0 <gc_execute_block+0x1400>)
 8010518:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
 801051c:	e778      	b.n	8010410 <gc_execute_block+0x1030>
        switch(port_command) {
 801051e:	9b05      	ldr	r3, [sp, #20]
 8010520:	3b43      	subs	r3, #67	; 0x43
 8010522:	b2db      	uxtb	r3, r3
 8010524:	2b01      	cmp	r3, #1
 8010526:	d82e      	bhi.n	8010586 <gc_execute_block+0x11a6>
                if(!(gc_block.words.e || gc_block.words.q))
 8010528:	4bad      	ldr	r3, [pc, #692]	; (80107e0 <gc_execute_block+0x1400>)
 801052a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 801052e:	4aae      	ldr	r2, [pc, #696]	; (80107e8 <gc_execute_block+0x1408>)
 8010530:	421a      	tst	r2, r3
 8010532:	f002 82e7 	beq.w	8012b04 <gc_execute_block+0x3724>
                if((uint32_t)gc_block.values.e + 1 > hal.port.num_analog_out)
 8010536:	4baa      	ldr	r3, [pc, #680]	; (80107e0 <gc_execute_block+0x1400>)
 8010538:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
 801053c:	eebc 7ae7 	vcvt.u32.f32	s14, s15
 8010540:	ee17 3a10 	vmov	r3, s14
 8010544:	3301      	adds	r3, #1
 8010546:	4aa9      	ldr	r2, [pc, #676]	; (80107ec <gc_execute_block+0x140c>)
 8010548:	f892 2117 	ldrb.w	r2, [r2, #279]	; 0x117
 801054c:	4293      	cmp	r3, r2
 801054e:	f202 82dc 	bhi.w	8012b0a <gc_execute_block+0x372a>
                gc_block.output_command.is_digital = false;
 8010552:	4ba3      	ldr	r3, [pc, #652]	; (80107e0 <gc_execute_block+0x1400>)
 8010554:	2100      	movs	r1, #0
 8010556:	f883 1098 	strb.w	r1, [r3, #152]	; 0x98
                gc_block.output_command.port = (uint8_t)gc_block.values.e;
 801055a:	ee17 2a10 	vmov	r2, s14
 801055e:	f883 209a 	strb.w	r2, [r3, #154]	; 0x9a
                gc_block.output_command.value = gc_block.values.q;
 8010562:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 8010566:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801056a:	edc3 7a27 	vstr	s15, [r3, #156]	; 0x9c
                gc_block.words.e = gc_block.words.q = Off;
 801056e:	f893 2096 	ldrb.w	r2, [r3, #150]	; 0x96
 8010572:	f361 0241 	bfi	r2, r1, #1, #1
 8010576:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
 801057a:	f893 2095 	ldrb.w	r2, [r3, #149]	; 0x95
 801057e:	f361 0200 	bfi	r2, r1, #0, #1
 8010582:	f883 2095 	strb.w	r2, [r3, #149]	; 0x95
    if(command_words.M7 && gc_block.modal.spindle.state.ccw) {
 8010586:	f019 0f02 	tst.w	r9, #2
 801058a:	d010      	beq.n	80105ae <gc_execute_block+0x11ce>
 801058c:	4b94      	ldr	r3, [pc, #592]	; (80107e0 <gc_execute_block+0x1400>)
 801058e:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8010592:	f013 0f02 	tst.w	r3, #2
 8010596:	d00a      	beq.n	80105ae <gc_execute_block+0x11ce>
        if(gc_block.spindle == NULL) {
 8010598:	4b91      	ldr	r3, [pc, #580]	; (80107e0 <gc_execute_block+0x1400>)
 801059a:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 801059e:	2b00      	cmp	r3, #0
 80105a0:	f000 809c 	beq.w	80106dc <gc_execute_block+0x12fc>
        } else if(!(gc_block.spindle->cap.direction || gc_block.spindle->cap.laser))
 80105a4:	7a5b      	ldrb	r3, [r3, #9]
 80105a6:	f013 0f0a 	tst.w	r3, #10
 80105aa:	f002 82b1 	beq.w	8012b10 <gc_execute_block+0x3730>
    if (command_words.M9) {
 80105ae:	f019 0f08 	tst.w	r9, #8
 80105b2:	f000 80c8 	beq.w	8010746 <gc_execute_block+0x1366>
        if(!gc_block.words.p)
 80105b6:	4b8a      	ldr	r3, [pc, #552]	; (80107e0 <gc_execute_block+0x1400>)
 80105b8:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 80105bc:	f013 0f01 	tst.w	r3, #1
 80105c0:	f040 80a5 	bne.w	801070e <gc_execute_block+0x132e>
            gc_block.values.p = 1.0f;
 80105c4:	4b86      	ldr	r3, [pc, #536]	; (80107e0 <gc_execute_block+0x1400>)
 80105c6:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 80105ca:	651a      	str	r2, [r3, #80]	; 0x50
        switch(gc_block.override_command) {
 80105cc:	4b84      	ldr	r3, [pc, #528]	; (80107e0 <gc_execute_block+0x1400>)
 80105ce:	785b      	ldrb	r3, [r3, #1]
 80105d0:	3b30      	subs	r3, #48	; 0x30
 80105d2:	2b08      	cmp	r3, #8
 80105d4:	f200 80b7 	bhi.w	8010746 <gc_execute_block+0x1366>
 80105d8:	e8df f013 	tbh	[pc, r3, lsl #1]
 80105dc:	00f400a9 	.word	0x00f400a9
 80105e0:	011f010e 	.word	0x011f010e
 80105e4:	013000b5 	.word	0x013000b5
 80105e8:	00b500b5 	.word	0x00b500b5
 80105ec:	0141      	.short	0x0141
                gc_block.output_command.value = port_command == 62 || port_command == 64 ? 1.0f : 0.0f;
 80105ee:	2201      	movs	r2, #1
 80105f0:	e74c      	b.n	801048c <gc_execute_block+0x10ac>
 80105f2:	2201      	movs	r2, #1
 80105f4:	e74a      	b.n	801048c <gc_execute_block+0x10ac>
                if(!(gc_block.words.l || gc_block.words.q))
 80105f6:	4b7a      	ldr	r3, [pc, #488]	; (80107e0 <gc_execute_block+0x1400>)
 80105f8:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 80105fc:	f412 3f04 	tst.w	r2, #135168	; 0x21000
 8010600:	f002 8268 	beq.w	8012ad4 <gc_execute_block+0x36f4>
                if(gc_block.words.p && gc_block.words.e)
 8010604:	4b7a      	ldr	r3, [pc, #488]	; (80107f0 <gc_execute_block+0x1410>)
 8010606:	4393      	bics	r3, r2
 8010608:	f002 8267 	beq.w	8012ada <gc_execute_block+0x36fa>
                if(gc_block.values.l >= (uint8_t)WaitMode_Max)
 801060c:	4b74      	ldr	r3, [pc, #464]	; (80107e0 <gc_execute_block+0x1400>)
 801060e:	f893 2090 	ldrb.w	r2, [r3, #144]	; 0x90
 8010612:	2a04      	cmp	r2, #4
 8010614:	f202 8264 	bhi.w	8012ae0 <gc_execute_block+0x3700>
                if((wait_mode_t)gc_block.values.l != WaitMode_Immediate && gc_block.values.q == 0.0f)
 8010618:	b13a      	cbz	r2, 801062a <gc_execute_block+0x124a>
 801061a:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 801061e:	eef5 7a40 	vcmp.f32	s15, #0.0
 8010622:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010626:	f002 825e 	beq.w	8012ae6 <gc_execute_block+0x3706>
                if(gc_block.words.p) {
 801062a:	4b6d      	ldr	r3, [pc, #436]	; (80107e0 <gc_execute_block+0x1400>)
 801062c:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8010630:	f013 0f01 	tst.w	r3, #1
 8010634:	d01b      	beq.n	801066e <gc_execute_block+0x128e>
                    if(gc_block.values.p < 0.0f)
 8010636:	4b6a      	ldr	r3, [pc, #424]	; (80107e0 <gc_execute_block+0x1400>)
 8010638:	edd3 7a14 	vldr	s15, [r3, #80]	; 0x50
 801063c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8010640:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010644:	f102 8252 	bmi.w	8012aec <gc_execute_block+0x370c>
                    if((uint32_t)gc_block.values.p + 1 > hal.port.num_digital_in)
 8010648:	eebc 7ae7 	vcvt.u32.f32	s14, s15
 801064c:	ee17 3a10 	vmov	r3, s14
 8010650:	3301      	adds	r3, #1
 8010652:	4966      	ldr	r1, [pc, #408]	; (80107ec <gc_execute_block+0x140c>)
 8010654:	f891 1114 	ldrb.w	r1, [r1, #276]	; 0x114
 8010658:	428b      	cmp	r3, r1
 801065a:	f202 824a 	bhi.w	8012af2 <gc_execute_block+0x3712>
                    gc_block.output_command.is_digital = true;
 801065e:	4960      	ldr	r1, [pc, #384]	; (80107e0 <gc_execute_block+0x1400>)
 8010660:	2301      	movs	r3, #1
 8010662:	f881 3098 	strb.w	r3, [r1, #152]	; 0x98
                    gc_block.output_command.port = (uint8_t)gc_block.values.p;
 8010666:	ee17 3a10 	vmov	r3, s14
 801066a:	f881 309a 	strb.w	r3, [r1, #154]	; 0x9a
                if(gc_block.words.e) {
 801066e:	4b5c      	ldr	r3, [pc, #368]	; (80107e0 <gc_execute_block+0x1400>)
 8010670:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 8010674:	f013 0f01 	tst.w	r3, #1
 8010678:	d018      	beq.n	80106ac <gc_execute_block+0x12cc>
                    if((uint32_t)gc_block.values.e + 1 > hal.port.num_analog_in)
 801067a:	4b59      	ldr	r3, [pc, #356]	; (80107e0 <gc_execute_block+0x1400>)
 801067c:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
 8010680:	eebc 7ae7 	vcvt.u32.f32	s14, s15
 8010684:	ee17 3a10 	vmov	r3, s14
 8010688:	3301      	adds	r3, #1
 801068a:	4958      	ldr	r1, [pc, #352]	; (80107ec <gc_execute_block+0x140c>)
 801068c:	f891 1116 	ldrb.w	r1, [r1, #278]	; 0x116
 8010690:	428b      	cmp	r3, r1
 8010692:	f202 8231 	bhi.w	8012af8 <gc_execute_block+0x3718>
                    if((wait_mode_t)gc_block.values.l != WaitMode_Immediate)
 8010696:	2a00      	cmp	r2, #0
 8010698:	f042 8231 	bne.w	8012afe <gc_execute_block+0x371e>
                    gc_block.output_command.is_digital = false;
 801069c:	4a50      	ldr	r2, [pc, #320]	; (80107e0 <gc_execute_block+0x1400>)
 801069e:	2300      	movs	r3, #0
 80106a0:	f882 3098 	strb.w	r3, [r2, #152]	; 0x98
                    gc_block.output_command.port = (uint8_t)gc_block.values.e;
 80106a4:	ee17 3a10 	vmov	r3, s14
 80106a8:	f882 309a 	strb.w	r3, [r2, #154]	; 0x9a
                gc_block.words.e = gc_block.words.l = gc_block.words.p = gc_block.words.q = Off;
 80106ac:	4b4c      	ldr	r3, [pc, #304]	; (80107e0 <gc_execute_block+0x1400>)
 80106ae:	f893 2096 	ldrb.w	r2, [r3, #150]	; 0x96
 80106b2:	f36f 0241 	bfc	r2, #1, #1
 80106b6:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
 80106ba:	b2d2      	uxtb	r2, r2
 80106bc:	f36f 0200 	bfc	r2, #0, #1
 80106c0:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
 80106c4:	f893 2095 	ldrb.w	r2, [r3, #149]	; 0x95
 80106c8:	f36f 1204 	bfc	r2, #4, #1
 80106cc:	f883 2095 	strb.w	r2, [r3, #149]	; 0x95
 80106d0:	b2d2      	uxtb	r2, r2
 80106d2:	f36f 0200 	bfc	r2, #0, #1
 80106d6:	f883 2095 	strb.w	r2, [r3, #149]	; 0x95
                break;
 80106da:	e754      	b.n	8010586 <gc_execute_block+0x11a6>
                if(spindle_is_enabled(idx) && !(spindle_get(idx)->cap.direction || spindle_get(idx)->cap.laser))
 80106dc:	2000      	movs	r0, #0
 80106de:	f00d f925 	bl	801d92c <spindle_is_enabled>
 80106e2:	2800      	cmp	r0, #0
 80106e4:	f43f af63 	beq.w	80105ae <gc_execute_block+0x11ce>
 80106e8:	2000      	movs	r0, #0
 80106ea:	f00d f933 	bl	801d954 <spindle_get>
 80106ee:	7a43      	ldrb	r3, [r0, #9]
 80106f0:	f013 0f02 	tst.w	r3, #2
 80106f4:	f47f af5b 	bne.w	80105ae <gc_execute_block+0x11ce>
 80106f8:	2000      	movs	r0, #0
 80106fa:	f00d f92b 	bl	801d954 <spindle_get>
 80106fe:	7a43      	ldrb	r3, [r0, #9]
 8010700:	f013 0f08 	tst.w	r3, #8
 8010704:	f47f af53 	bne.w	80105ae <gc_execute_block+0x11ce>
                    FAIL(Status_GcodeUnsupportedCommand);
 8010708:	2414      	movs	r4, #20
 801070a:	f7fe bf3f 	b.w	800f58c <gc_execute_block+0x1ac>
            if(gc_block.values.p < 0.0f)
 801070e:	4b34      	ldr	r3, [pc, #208]	; (80107e0 <gc_execute_block+0x1400>)
 8010710:	edd3 7a14 	vldr	s15, [r3, #80]	; 0x50
 8010714:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8010718:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801071c:	f102 81fb 	bmi.w	8012b16 <gc_execute_block+0x3736>
            gc_block.words.p = Off;
 8010720:	f893 2096 	ldrb.w	r2, [r3, #150]	; 0x96
 8010724:	f36f 0200 	bfc	r2, #0, #1
 8010728:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
 801072c:	e74e      	b.n	80105cc <gc_execute_block+0x11ec>
                gc_block.modal.override_ctrl.feed_rate_disable = Off;
 801072e:	4b2c      	ldr	r3, [pc, #176]	; (80107e0 <gc_execute_block+0x1400>)
 8010730:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
 8010734:	f36f 0200 	bfc	r2, #0, #1
 8010738:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
                gc_block.modal.override_ctrl.spindle_rpm_disable = Off;
 801073c:	b2d2      	uxtb	r2, r2
 801073e:	f36f 0282 	bfc	r2, #2, #1
 8010742:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
    if (command_words.M10 && gc_block.user_mcode) {
 8010746:	b1d4      	cbz	r4, 801077e <gc_execute_block+0x139e>
 8010748:	4b25      	ldr	r3, [pc, #148]	; (80107e0 <gc_execute_block+0x1400>)
 801074a:	885b      	ldrh	r3, [r3, #2]
 801074c:	b1bb      	cbz	r3, 801077e <gc_execute_block+0x139e>
        user_words.mask = gc_block.words.mask;
 801074e:	4824      	ldr	r0, [pc, #144]	; (80107e0 <gc_execute_block+0x1400>)
 8010750:	4601      	mov	r1, r0
 8010752:	f851 2f94 	ldr.w	r2, [r1, #148]!
 8010756:	4b27      	ldr	r3, [pc, #156]	; (80107f4 <gc_execute_block+0x1414>)
 8010758:	601a      	str	r2, [r3, #0]
        if((int_value = (uint_fast16_t)hal.user_mcode.validate(&gc_block, &gc_block.words)))
 801075a:	4b24      	ldr	r3, [pc, #144]	; (80107ec <gc_execute_block+0x140c>)
 801075c:	f8d3 3188 	ldr.w	r3, [r3, #392]	; 0x188
 8010760:	4798      	blx	r3
 8010762:	4604      	mov	r4, r0
 8010764:	2800      	cmp	r0, #0
 8010766:	f47e af11 	bne.w	800f58c <gc_execute_block+0x1ac>
        user_words.mask ^= gc_block.words.mask; // Flag "taken" words for execution
 801076a:	4b1d      	ldr	r3, [pc, #116]	; (80107e0 <gc_execute_block+0x1400>)
 801076c:	f8d3 1094 	ldr.w	r1, [r3, #148]	; 0x94
 8010770:	4a20      	ldr	r2, [pc, #128]	; (80107f4 <gc_execute_block+0x1414>)
 8010772:	6813      	ldr	r3, [r2, #0]
 8010774:	404b      	eors	r3, r1
 8010776:	6013      	str	r3, [r2, #0]
        axis_words.mask = ijk_words.mask = 0;
 8010778:	2300      	movs	r3, #0
 801077a:	9304      	str	r3, [sp, #16]
 801077c:	469b      	mov	fp, r3
    if (gc_block.non_modal_command == NonModal_Dwell) {
 801077e:	4b18      	ldr	r3, [pc, #96]	; (80107e0 <gc_execute_block+0x1400>)
 8010780:	781c      	ldrb	r4, [r3, #0]
 8010782:	2c04      	cmp	r4, #4
 8010784:	d114      	bne.n	80107b0 <gc_execute_block+0x13d0>
        if (!gc_block.words.p)
 8010786:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 801078a:	f013 0f01 	tst.w	r3, #1
 801078e:	f002 81c5 	beq.w	8012b1c <gc_execute_block+0x373c>
        if(gc_block.values.p < 0.0f)
 8010792:	4b13      	ldr	r3, [pc, #76]	; (80107e0 <gc_execute_block+0x1400>)
 8010794:	edd3 7a14 	vldr	s15, [r3, #80]	; 0x50
 8010798:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801079c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80107a0:	f53e aef4 	bmi.w	800f58c <gc_execute_block+0x1ac>
        gc_block.words.p = Off;
 80107a4:	f893 2096 	ldrb.w	r2, [r3, #150]	; 0x96
 80107a8:	f36f 0200 	bfc	r2, #0, #1
 80107ac:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
    gc_get_plane_data(&plane, gc_block.modal.plane_select);
 80107b0:	4c0b      	ldr	r4, [pc, #44]	; (80107e0 <gc_execute_block+0x1400>)
 80107b2:	7ba1      	ldrb	r1, [r4, #14]
 80107b4:	a820      	add	r0, sp, #128	; 0x80
 80107b6:	f7fe fca3 	bl	800f100 <gc_get_plane_data>
    if (gc_block.modal.units_imperial) do { // Axes indices are consistent, so loop may be used.
 80107ba:	7ae3      	ldrb	r3, [r4, #11]
 80107bc:	2b00      	cmp	r3, #0
 80107be:	d07c      	beq.n	80108ba <gc_execute_block+0x14da>
    uint_fast8_t idx = N_AXIS;
 80107c0:	2303      	movs	r3, #3
 80107c2:	e065      	b.n	8010890 <gc_execute_block+0x14b0>
                gc_block.modal.override_ctrl.feed_rate_disable = On;
 80107c4:	4b06      	ldr	r3, [pc, #24]	; (80107e0 <gc_execute_block+0x1400>)
 80107c6:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
 80107ca:	f042 0201 	orr.w	r2, r2, #1
 80107ce:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
                gc_block.modal.override_ctrl.spindle_rpm_disable = On;
 80107d2:	b2d2      	uxtb	r2, r2
 80107d4:	f042 0204 	orr.w	r2, r2, #4
 80107d8:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
                break;
 80107dc:	e7b3      	b.n	8010746 <gc_execute_block+0x1366>
 80107de:	bf00      	nop
 80107e0:	20003298 	.word	0x20003298
 80107e4:	20003344 	.word	0x20003344
 80107e8:	00020100 	.word	0x00020100
 80107ec:	2000350c 	.word	0x2000350c
 80107f0:	00010100 	.word	0x00010100
 80107f4:	20003438 	.word	0x20003438
                gc_block.modal.override_ctrl.feed_rate_disable = gc_block.values.p == 0.0f;
 80107f8:	4bad      	ldr	r3, [pc, #692]	; (8010ab0 <gc_execute_block+0x16d0>)
 80107fa:	edd3 7a14 	vldr	s15, [r3, #80]	; 0x50
 80107fe:	eef5 7a40 	vcmp.f32	s15, #0.0
 8010802:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010806:	bf0c      	ite	eq
 8010808:	2101      	moveq	r1, #1
 801080a:	2100      	movne	r1, #0
 801080c:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
 8010810:	f361 0200 	bfi	r2, r1, #0, #1
 8010814:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
                break;
 8010818:	e795      	b.n	8010746 <gc_execute_block+0x1366>
                gc_block.modal.override_ctrl.spindle_rpm_disable = gc_block.values.p == 0.0f;
 801081a:	4ba5      	ldr	r3, [pc, #660]	; (8010ab0 <gc_execute_block+0x16d0>)
 801081c:	edd3 7a14 	vldr	s15, [r3, #80]	; 0x50
 8010820:	eef5 7a40 	vcmp.f32	s15, #0.0
 8010824:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010828:	bf0c      	ite	eq
 801082a:	2101      	moveq	r1, #1
 801082c:	2100      	movne	r1, #0
 801082e:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
 8010832:	f361 0282 	bfi	r2, r1, #2, #1
 8010836:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
                break;
 801083a:	e784      	b.n	8010746 <gc_execute_block+0x1366>
                gc_block.modal.override_ctrl.feed_hold_disable = gc_block.values.p == 0.0f;
 801083c:	4b9c      	ldr	r3, [pc, #624]	; (8010ab0 <gc_execute_block+0x16d0>)
 801083e:	edd3 7a14 	vldr	s15, [r3, #80]	; 0x50
 8010842:	eef5 7a40 	vcmp.f32	s15, #0.0
 8010846:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801084a:	bf0c      	ite	eq
 801084c:	2101      	moveq	r1, #1
 801084e:	2100      	movne	r1, #0
 8010850:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
 8010854:	f361 0241 	bfi	r2, r1, #1, #1
 8010858:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
                break;
 801085c:	e773      	b.n	8010746 <gc_execute_block+0x1366>
                if(settings.parking.flags.enable_override_control)
 801085e:	4b95      	ldr	r3, [pc, #596]	; (8010ab4 <gc_execute_block+0x16d4>)
 8010860:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 8010864:	f013 0f04 	tst.w	r3, #4
 8010868:	f43f af6d 	beq.w	8010746 <gc_execute_block+0x1366>
                    gc_block.modal.override_ctrl.parking_disable = gc_block.values.p == 0.0f;
 801086c:	4b90      	ldr	r3, [pc, #576]	; (8010ab0 <gc_execute_block+0x16d0>)
 801086e:	edd3 7a14 	vldr	s15, [r3, #80]	; 0x50
 8010872:	eef5 7a40 	vcmp.f32	s15, #0.0
 8010876:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801087a:	bf0c      	ite	eq
 801087c:	2101      	moveq	r1, #1
 801087e:	2100      	movne	r1, #0
 8010880:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
 8010884:	f361 02c3 	bfi	r2, r1, #3, #1
 8010888:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 801088c:	e75b      	b.n	8010746 <gc_execute_block+0x1366>
    } while(idx);
 801088e:	b1a3      	cbz	r3, 80108ba <gc_execute_block+0x14da>
        idx--;
 8010890:	3b01      	subs	r3, #1
        if (bit_istrue(axis_words.mask, bit(idx)))
 8010892:	fa5f f28b 	uxtb.w	r2, fp
 8010896:	40da      	lsrs	r2, r3
 8010898:	f012 0f01 	tst.w	r2, #1
 801089c:	d0f7      	beq.n	801088e <gc_execute_block+0x14ae>
            gc_block.values.xyz[idx] *= MM_PER_INCH;
 801089e:	f103 0118 	add.w	r1, r3, #24
 80108a2:	4a83      	ldr	r2, [pc, #524]	; (8010ab0 <gc_execute_block+0x16d0>)
 80108a4:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 80108a8:	edd2 7a00 	vldr	s15, [r2]
 80108ac:	ed9f 7a82 	vldr	s14, [pc, #520]	; 8010ab8 <gc_execute_block+0x16d8>
 80108b0:	ee67 7a87 	vmul.f32	s15, s15, s14
 80108b4:	edc2 7a00 	vstr	s15, [r2]
 80108b8:	e7e9      	b.n	801088e <gc_execute_block+0x14ae>
    if (command_words.G15 && gc_state.modal.diameter_mode != gc_block.modal.diameter_mode) {
 80108ba:	f015 0f40 	tst.w	r5, #64	; 0x40
 80108be:	d005      	beq.n	80108cc <gc_execute_block+0x14ec>
 80108c0:	4b7e      	ldr	r3, [pc, #504]	; (8010abc <gc_execute_block+0x16dc>)
 80108c2:	795a      	ldrb	r2, [r3, #5]
 80108c4:	4b7a      	ldr	r3, [pc, #488]	; (8010ab0 <gc_execute_block+0x16d0>)
 80108c6:	7b5b      	ldrb	r3, [r3, #13]
 80108c8:	429a      	cmp	r2, r3
 80108ca:	d118      	bne.n	80108fe <gc_execute_block+0x151e>
    if(gc_state.modal.diameter_mode && bit_istrue(axis_words.mask, bit(X_AXIS)))
 80108cc:	4b7b      	ldr	r3, [pc, #492]	; (8010abc <gc_execute_block+0x16dc>)
 80108ce:	795b      	ldrb	r3, [r3, #5]
 80108d0:	b15b      	cbz	r3, 80108ea <gc_execute_block+0x150a>
 80108d2:	f01b 0f01 	tst.w	fp, #1
 80108d6:	d008      	beq.n	80108ea <gc_execute_block+0x150a>
        gc_block.values.xyz[X_AXIS] /= 2.0f;
 80108d8:	4b75      	ldr	r3, [pc, #468]	; (8010ab0 <gc_execute_block+0x16d0>)
 80108da:	edd3 7a18 	vldr	s15, [r3, #96]	; 0x60
 80108de:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 80108e2:	ee67 7a87 	vmul.f32	s15, s15, s14
 80108e6:	edc3 7a18 	vstr	s15, [r3, #96]	; 0x60
    if(axis_command == AxisCommand_Scaling) {
 80108ea:	f1ba 0f04 	cmp.w	sl, #4
 80108ee:	d00c      	beq.n	801090a <gc_execute_block+0x152a>
    if(gc_state.modal.scaling_active) {
 80108f0:	4b72      	ldr	r3, [pc, #456]	; (8010abc <gc_execute_block+0x16dc>)
 80108f2:	7f9b      	ldrb	r3, [r3, #30]
 80108f4:	2b00      	cmp	r3, #0
 80108f6:	f000 80a9 	beq.w	8010a4c <gc_execute_block+0x166c>
        idx = N_AXIS;
 80108fa:	2203      	movs	r2, #3
 80108fc:	e089      	b.n	8010a12 <gc_execute_block+0x1632>
        gc_state.modal.diameter_mode = gc_block.modal.diameter_mode;
 80108fe:	4a6f      	ldr	r2, [pc, #444]	; (8010abc <gc_execute_block+0x16dc>)
 8010900:	7153      	strb	r3, [r2, #5]
        system_add_rt_report(Report_LatheXMode);
 8010902:	2008      	movs	r0, #8
 8010904:	f010 fc9c 	bl	8021240 <system_add_rt_report>
 8010908:	e7e0      	b.n	80108cc <gc_execute_block+0x14ec>
        if(gc_block.modal.scaling_active) {
 801090a:	4b69      	ldr	r3, [pc, #420]	; (8010ab0 <gc_execute_block+0x16d0>)
 801090c:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 8010910:	2b00      	cmp	r3, #0
 8010912:	d05f      	beq.n	80109d4 <gc_execute_block+0x15f4>
            gc_block.modal.scaling_active = false;
 8010914:	4b66      	ldr	r3, [pc, #408]	; (8010ab0 <gc_execute_block+0x16d0>)
 8010916:	2200      	movs	r2, #0
 8010918:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
            if (!axis_words.mask)
 801091c:	fa5f f38b 	uxtb.w	r3, fp
 8010920:	2b00      	cmp	r3, #0
 8010922:	f002 80fe 	beq.w	8012b22 <gc_execute_block+0x3742>
            bool report_scaling = false;
 8010926:	4616      	mov	r6, r2
            idx = N_AXIS;
 8010928:	2403      	movs	r4, #3
 801092a:	e024      	b.n	8010976 <gc_execute_block+0x1596>
                    report_scaling |= scale_factor.ijk[idx] != gc_block.values.xyz[idx];
 801092c:	1ca1      	adds	r1, r4, #2
 801092e:	4a64      	ldr	r2, [pc, #400]	; (8010ac0 <gc_execute_block+0x16e0>)
 8010930:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8010934:	ed92 7a01 	vldr	s14, [r2, #4]
 8010938:	f104 0018 	add.w	r0, r4, #24
 801093c:	495c      	ldr	r1, [pc, #368]	; (8010ab0 <gc_execute_block+0x16d0>)
 801093e:	eb01 0180 	add.w	r1, r1, r0, lsl #2
 8010942:	edd1 7a00 	vldr	s15, [r1]
 8010946:	eeb4 7a67 	vcmp.f32	s14, s15
 801094a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801094e:	bf18      	it	ne
 8010950:	f046 0601 	orrne.w	r6, r6, #1
                    scale_factor.ijk[idx] = gc_block.values.xyz[idx];
 8010954:	edc2 7a01 	vstr	s15, [r2, #4]
                    bit_false(axis_words.mask, bit(idx));
 8010958:	f04f 0b01 	mov.w	fp, #1
 801095c:	fa0b fb04 	lsl.w	fp, fp, r4
 8010960:	ea23 0b0b 	bic.w	fp, r3, fp
                    system_add_rt_report(Report_Scaling);
 8010964:	2002      	movs	r0, #2
 8010966:	f010 fc6b 	bl	8021240 <system_add_rt_report>
 801096a:	e00c      	b.n	8010986 <gc_execute_block+0x15a6>
                gc_block.modal.scaling_active = gc_block.modal.scaling_active || (scale_factor.xyz[idx] != 1.0f);
 801096c:	2301      	movs	r3, #1
 801096e:	4a50      	ldr	r2, [pc, #320]	; (8010ab0 <gc_execute_block+0x16d0>)
 8010970:	f882 3026 	strb.w	r3, [r2, #38]	; 0x26
            } while(idx);
 8010974:	b1e4      	cbz	r4, 80109b0 <gc_execute_block+0x15d0>
                if(bit_istrue(axis_words.mask, bit(--idx))) {
 8010976:	fa5f f38b 	uxtb.w	r3, fp
 801097a:	3c01      	subs	r4, #1
 801097c:	fa23 f204 	lsr.w	r2, r3, r4
 8010980:	f012 0f01 	tst.w	r2, #1
 8010984:	d1d2      	bne.n	801092c <gc_execute_block+0x154c>
                gc_block.modal.scaling_active = gc_block.modal.scaling_active || (scale_factor.xyz[idx] != 1.0f);
 8010986:	4b4a      	ldr	r3, [pc, #296]	; (8010ab0 <gc_execute_block+0x16d0>)
 8010988:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 801098c:	2b00      	cmp	r3, #0
 801098e:	d1ed      	bne.n	801096c <gc_execute_block+0x158c>
 8010990:	4b4b      	ldr	r3, [pc, #300]	; (8010ac0 <gc_execute_block+0x16e0>)
 8010992:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8010996:	ed93 7a00 	vldr	s14, [r3]
 801099a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 801099e:	eeb4 7a67 	vcmp.f32	s14, s15
 80109a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80109a6:	d001      	beq.n	80109ac <gc_execute_block+0x15cc>
 80109a8:	2301      	movs	r3, #1
 80109aa:	e7e0      	b.n	801096e <gc_execute_block+0x158e>
 80109ac:	2300      	movs	r3, #0
 80109ae:	e7de      	b.n	801096e <gc_execute_block+0x158e>
            gc_block.words.mask &= ~axis_words_mask.mask; // Remove axis words.
 80109b0:	4611      	mov	r1, r2
 80109b2:	f8d2 2094 	ldr.w	r2, [r2, #148]	; 0x94
 80109b6:	f022 62e0 	bic.w	r2, r2, #117440512	; 0x7000000
 80109ba:	f8c1 2094 	str.w	r2, [r1, #148]	; 0x94
            report_scaling |= gc_state.modal.scaling_active != gc_block.modal.scaling_active;
 80109be:	4a3f      	ldr	r2, [pc, #252]	; (8010abc <gc_execute_block+0x16dc>)
 80109c0:	7f91      	ldrb	r1, [r2, #30]
            gc_state.modal.scaling_active = gc_block.modal.scaling_active;
 80109c2:	7793      	strb	r3, [r2, #30]
            if(report_scaling)
 80109c4:	428b      	cmp	r3, r1
 80109c6:	d101      	bne.n	80109cc <gc_execute_block+0x15ec>
 80109c8:	2e00      	cmp	r6, #0
 80109ca:	d091      	beq.n	80108f0 <gc_execute_block+0x1510>
                system_add_rt_report(Report_Scaling);
 80109cc:	2002      	movs	r0, #2
 80109ce:	f010 fc37 	bl	8021240 <system_add_rt_report>
 80109d2:	e78d      	b.n	80108f0 <gc_execute_block+0x1510>
            set_scaling(1.0f);
 80109d4:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80109d8:	f7fe faee 	bl	800efb8 <set_scaling>
 80109dc:	e788      	b.n	80108f0 <gc_execute_block+0x1510>
                     gc_block.values.xyz[idx] = (gc_block.values.xyz[idx] - scale_factor.xyz[idx]) * scale_factor.ijk[idx] + scale_factor.xyz[idx];
 80109de:	f102 0118 	add.w	r1, r2, #24
 80109e2:	4b33      	ldr	r3, [pc, #204]	; (8010ab0 <gc_execute_block+0x16d0>)
 80109e4:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 80109e8:	edd3 7a00 	vldr	s15, [r3]
 80109ec:	4934      	ldr	r1, [pc, #208]	; (8010ac0 <gc_execute_block+0x16e0>)
 80109ee:	eb01 0082 	add.w	r0, r1, r2, lsl #2
 80109f2:	ed90 7a00 	vldr	s14, [r0]
 80109f6:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80109fa:	1c90      	adds	r0, r2, #2
 80109fc:	eb01 0180 	add.w	r1, r1, r0, lsl #2
 8010a00:	edd1 6a01 	vldr	s13, [r1, #4]
 8010a04:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8010a08:	ee37 7a27 	vadd.f32	s14, s14, s15
 8010a0c:	ed83 7a00 	vstr	s14, [r3]
        } while(idx);
 8010a10:	b1e2      	cbz	r2, 8010a4c <gc_execute_block+0x166c>
            if(bit_istrue(axis_words.mask, bit(--idx))) {
 8010a12:	fa5f f38b 	uxtb.w	r3, fp
 8010a16:	3a01      	subs	r2, #1
 8010a18:	40d3      	lsrs	r3, r2
 8010a1a:	f013 0f01 	tst.w	r3, #1
 8010a1e:	d0f7      	beq.n	8010a10 <gc_execute_block+0x1630>
                if(gc_block.modal.distance_incremental)
 8010a20:	4b23      	ldr	r3, [pc, #140]	; (8010ab0 <gc_execute_block+0x16d0>)
 8010a22:	7b1b      	ldrb	r3, [r3, #12]
 8010a24:	2b00      	cmp	r3, #0
 8010a26:	d0da      	beq.n	80109de <gc_execute_block+0x15fe>
                     gc_block.values.xyz[idx] *= scale_factor.ijk[idx];
 8010a28:	1c91      	adds	r1, r2, #2
 8010a2a:	4b25      	ldr	r3, [pc, #148]	; (8010ac0 <gc_execute_block+0x16e0>)
 8010a2c:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8010a30:	ed93 7a01 	vldr	s14, [r3, #4]
 8010a34:	f102 0118 	add.w	r1, r2, #24
 8010a38:	4b1d      	ldr	r3, [pc, #116]	; (8010ab0 <gc_execute_block+0x16d0>)
 8010a3a:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8010a3e:	edd3 7a00 	vldr	s15, [r3]
 8010a42:	ee67 7a87 	vmul.f32	s15, s15, s14
 8010a46:	edc3 7a00 	vstr	s15, [r3]
 8010a4a:	e7e1      	b.n	8010a10 <gc_execute_block+0x1630>
    if (command_words.G8) { // Indicates called in block.
 8010a4c:	f015 0f01 	tst.w	r5, #1
 8010a50:	d003      	beq.n	8010a5a <gc_execute_block+0x167a>
        switch(gc_block.modal.tool_offset_mode) {
 8010a52:	4b17      	ldr	r3, [pc, #92]	; (8010ab0 <gc_execute_block+0x16d0>)
 8010a54:	7bdb      	ldrb	r3, [r3, #15]
 8010a56:	2b02      	cmp	r3, #2
 8010a58:	d01a      	beq.n	8010a90 <gc_execute_block+0x16b0>
    if (command_words.G12) { // Check if called in block
 8010a5a:	f015 0f08 	tst.w	r5, #8
 8010a5e:	d005      	beq.n	8010a6c <gc_execute_block+0x168c>
        if (gc_state.modal.coord_system.id != gc_block.modal.coord_system.id && !settings_read_coord_data(gc_block.modal.coord_system.id, &gc_block.modal.coord_system.xyz))
 8010a60:	4b16      	ldr	r3, [pc, #88]	; (8010abc <gc_execute_block+0x16dc>)
 8010a62:	7d1b      	ldrb	r3, [r3, #20]
 8010a64:	4a12      	ldr	r2, [pc, #72]	; (8010ab0 <gc_execute_block+0x16d0>)
 8010a66:	7f10      	ldrb	r0, [r2, #28]
 8010a68:	4283      	cmp	r3, r0
 8010a6a:	d118      	bne.n	8010a9e <gc_execute_block+0x16be>
    switch (gc_block.non_modal_command) {
 8010a6c:	4b10      	ldr	r3, [pc, #64]	; (8010ab0 <gc_execute_block+0x16d0>)
 8010a6e:	781b      	ldrb	r3, [r3, #0]
 8010a70:	2b0a      	cmp	r3, #10
 8010a72:	d027      	beq.n	8010ac4 <gc_execute_block+0x16e4>
 8010a74:	2b5c      	cmp	r3, #92	; 0x5c
 8010a76:	f000 8117 	beq.w	8010ca8 <gc_execute_block+0x18c8>
            if (axis_words.mask && axis_command != AxisCommand_ToolLengthOffset) { // TLO block any axis command.
 8010a7a:	fa5f f48b 	uxtb.w	r4, fp
 8010a7e:	2c00      	cmp	r4, #0
 8010a80:	f000 819c 	beq.w	8010dbc <gc_execute_block+0x19dc>
 8010a84:	f1ba 0f03 	cmp.w	sl, #3
 8010a88:	f000 8198 	beq.w	8010dbc <gc_execute_block+0x19dc>
                idx = N_AXIS;
 8010a8c:	2203      	movs	r2, #3
 8010a8e:	e15d      	b.n	8010d4c <gc_execute_block+0x196c>
                if (!axis_words.mask)
 8010a90:	fa5f f38b 	uxtb.w	r3, fp
 8010a94:	2b00      	cmp	r3, #0
 8010a96:	d1e0      	bne.n	8010a5a <gc_execute_block+0x167a>
                    FAIL(Status_GcodeG43DynamicAxisError);
 8010a98:	2425      	movs	r4, #37	; 0x25
 8010a9a:	f7fe bd77 	b.w	800f58c <gc_execute_block+0x1ac>
        if (gc_state.modal.coord_system.id != gc_block.modal.coord_system.id && !settings_read_coord_data(gc_block.modal.coord_system.id, &gc_block.modal.coord_system.xyz))
 8010a9e:	f102 0110 	add.w	r1, r2, #16
 8010aa2:	f00b ffa7 	bl	801c9f4 <settings_read_coord_data>
 8010aa6:	2800      	cmp	r0, #0
 8010aa8:	d1e0      	bne.n	8010a6c <gc_execute_block+0x168c>
            FAIL(Status_SettingReadFail);
 8010aaa:	2407      	movs	r4, #7
 8010aac:	f7fe bd6e 	b.w	800f58c <gc_execute_block+0x1ac>
 8010ab0:	20003298 	.word	0x20003298
 8010ab4:	20003b14 	.word	0x20003b14
 8010ab8:	41cb3333 	.word	0x41cb3333
 8010abc:	20003344 	.word	0x20003344
 8010ac0:	200003e8 	.word	0x200003e8
            if (!(axis_words.mask || (gc_block.values.l != 20 && gc_block.words.r)))
 8010ac4:	fa5f f48b 	uxtb.w	r4, fp
 8010ac8:	b964      	cbnz	r4, 8010ae4 <gc_execute_block+0x1704>
 8010aca:	4bba      	ldr	r3, [pc, #744]	; (8010db4 <gc_execute_block+0x19d4>)
 8010acc:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
 8010ad0:	2b14      	cmp	r3, #20
 8010ad2:	f002 8029 	beq.w	8012b28 <gc_execute_block+0x3748>
 8010ad6:	4bb7      	ldr	r3, [pc, #732]	; (8010db4 <gc_execute_block+0x19d4>)
 8010ad8:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8010adc:	f013 0f04 	tst.w	r3, #4
 8010ae0:	f002 8025 	beq.w	8012b2e <gc_execute_block+0x374e>
            if (!(gc_block.words.p || gc_block.words.l))
 8010ae4:	4bb3      	ldr	r3, [pc, #716]	; (8010db4 <gc_execute_block+0x19d4>)
 8010ae6:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8010aea:	f413 3f88 	tst.w	r3, #69632	; 0x11000
 8010aee:	f002 8021 	beq.w	8012b34 <gc_execute_block+0x3754>
            if(gc_block.values.p < 0.0f)
 8010af2:	4bb0      	ldr	r3, [pc, #704]	; (8010db4 <gc_execute_block+0x19d4>)
 8010af4:	ed93 0a14 	vldr	s0, [r3, #80]	; 0x50
 8010af8:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8010afc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010b00:	f102 801b 	bmi.w	8012b3a <gc_execute_block+0x375a>
            p_value = (uint8_t)truncf(gc_block.values.p); // Convert p value to int.
 8010b04:	f013 f91e 	bl	8023d44 <truncf>
 8010b08:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8010b0c:	edcd 7a08 	vstr	s15, [sp, #32]
 8010b10:	f89d 3020 	ldrb.w	r3, [sp, #32]
            switch(gc_block.values.l) {
 8010b14:	4aa7      	ldr	r2, [pc, #668]	; (8010db4 <gc_execute_block+0x19d4>)
 8010b16:	f892 2090 	ldrb.w	r2, [r2, #144]	; 0x90
 8010b1a:	2a02      	cmp	r2, #2
 8010b1c:	d004      	beq.n	8010b28 <gc_execute_block+0x1748>
 8010b1e:	2a14      	cmp	r2, #20
 8010b20:	d009      	beq.n	8010b36 <gc_execute_block+0x1756>
 8010b22:	2414      	movs	r4, #20
 8010b24:	f7fe bd32 	b.w	800f58c <gc_execute_block+0x1ac>
                    if (gc_block.words.r)
 8010b28:	4aa2      	ldr	r2, [pc, #648]	; (8010db4 <gc_execute_block+0x19d4>)
 8010b2a:	f892 2096 	ldrb.w	r2, [r2, #150]	; 0x96
 8010b2e:	f012 0f04 	tst.w	r2, #4
 8010b32:	f042 8005 	bne.w	8012b40 <gc_execute_block+0x3760>
                    if (p_value > N_WorkCoordinateSystems)
 8010b36:	2b09      	cmp	r3, #9
 8010b38:	f202 8005 	bhi.w	8012b46 <gc_execute_block+0x3766>
                                                     : (coord_system_id_t)(p_value - 1);    // else adjust index to NVS coordinate data indexing.
 8010b3c:	b963      	cbnz	r3, 8010b58 <gc_execute_block+0x1778>
 8010b3e:	4b9d      	ldr	r3, [pc, #628]	; (8010db4 <gc_execute_block+0x19d4>)
 8010b40:	7f18      	ldrb	r0, [r3, #28]
                    gc_block.values.coord_data.id = p_value == 0
 8010b42:	499c      	ldr	r1, [pc, #624]	; (8010db4 <gc_execute_block+0x19d4>)
 8010b44:	f881 0078 	strb.w	r0, [r1, #120]	; 0x78
                    if (!settings_read_coord_data(gc_block.values.coord_data.id, &gc_block.values.coord_data.xyz))
 8010b48:	316c      	adds	r1, #108	; 0x6c
 8010b4a:	f00b ff53 	bl	801c9f4 <settings_read_coord_data>
 8010b4e:	2800      	cmp	r0, #0
 8010b50:	f001 87fc 	beq.w	8012b4c <gc_execute_block+0x376c>
                    idx = N_AXIS;
 8010b54:	2303      	movs	r3, #3
 8010b56:	e027      	b.n	8010ba8 <gc_execute_block+0x17c8>
                                                     : (coord_system_id_t)(p_value - 1);    // else adjust index to NVS coordinate data indexing.
 8010b58:	3b01      	subs	r3, #1
 8010b5a:	b2d8      	uxtb	r0, r3
 8010b5c:	e7f1      	b.n	8010b42 <gc_execute_block+0x1762>
                                gc_block.values.coord_data.xyz[idx] = gc_state.position[idx] - gc_block.values.xyz[idx] - gc_state.g92_coord_offset[idx] - gc_state.tool_length_offset[idx];
 8010b5e:	4a96      	ldr	r2, [pc, #600]	; (8010db8 <gc_execute_block+0x19d8>)
 8010b60:	f103 0018 	add.w	r0, r3, #24
 8010b64:	eb02 0180 	add.w	r1, r2, r0, lsl #2
 8010b68:	edd1 7a00 	vldr	s15, [r1]
 8010b6c:	4991      	ldr	r1, [pc, #580]	; (8010db4 <gc_execute_block+0x19d4>)
 8010b6e:	eb01 0080 	add.w	r0, r1, r0, lsl #2
 8010b72:	ed90 7a00 	vldr	s14, [r0]
 8010b76:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8010b7a:	f103 001e 	add.w	r0, r3, #30
 8010b7e:	eb02 0080 	add.w	r0, r2, r0, lsl #2
 8010b82:	ed90 7a01 	vldr	s14, [r0, #4]
 8010b86:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8010b8a:	f103 0022 	add.w	r0, r3, #34	; 0x22
 8010b8e:	eb02 0280 	add.w	r2, r2, r0, lsl #2
 8010b92:	ed92 7a00 	vldr	s14, [r2]
 8010b96:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8010b9a:	f103 021a 	add.w	r2, r3, #26
 8010b9e:	eb01 0182 	add.w	r1, r1, r2, lsl #2
 8010ba2:	edc1 7a01 	vstr	s15, [r1, #4]
                    } while(idx);
 8010ba6:	b1b3      	cbz	r3, 8010bd6 <gc_execute_block+0x17f6>
                        if (bit_istrue(axis_words.mask, bit(--idx))) {
 8010ba8:	3b01      	subs	r3, #1
 8010baa:	fa24 f203 	lsr.w	r2, r4, r3
 8010bae:	f012 0f01 	tst.w	r2, #1
 8010bb2:	d0f8      	beq.n	8010ba6 <gc_execute_block+0x17c6>
                            if (gc_block.values.l == 20)
 8010bb4:	4a7f      	ldr	r2, [pc, #508]	; (8010db4 <gc_execute_block+0x19d4>)
 8010bb6:	f892 2090 	ldrb.w	r2, [r2, #144]	; 0x90
 8010bba:	2a14      	cmp	r2, #20
 8010bbc:	d0cf      	beq.n	8010b5e <gc_execute_block+0x177e>
                                gc_block.values.coord_data.xyz[idx] = gc_block.values.xyz[idx];
 8010bbe:	4a7d      	ldr	r2, [pc, #500]	; (8010db4 <gc_execute_block+0x19d4>)
 8010bc0:	f103 0118 	add.w	r1, r3, #24
 8010bc4:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 8010bc8:	6809      	ldr	r1, [r1, #0]
 8010bca:	f103 001a 	add.w	r0, r3, #26
 8010bce:	eb02 0280 	add.w	r2, r2, r0, lsl #2
 8010bd2:	6051      	str	r1, [r2, #4]
 8010bd4:	e7e7      	b.n	8010ba6 <gc_execute_block+0x17c6>
            gc_block.words.l = gc_block.words.p = Off;
 8010bd6:	4b77      	ldr	r3, [pc, #476]	; (8010db4 <gc_execute_block+0x19d4>)
 8010bd8:	f893 2096 	ldrb.w	r2, [r3, #150]	; 0x96
 8010bdc:	f36f 0200 	bfc	r2, #0, #1
 8010be0:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
 8010be4:	f893 2095 	ldrb.w	r2, [r3, #149]	; 0x95
 8010be8:	f36f 1204 	bfc	r2, #4, #1
 8010bec:	f883 2095 	strb.w	r2, [r3, #149]	; 0x95
    if (gc_block.modal.motion == MotionMode_None) {
 8010bf0:	4b70      	ldr	r3, [pc, #448]	; (8010db4 <gc_execute_block+0x19d4>)
 8010bf2:	891d      	ldrh	r5, [r3, #8]
 8010bf4:	2d50      	cmp	r5, #80	; 0x50
 8010bf6:	f000 8134 	beq.w	8010e62 <gc_execute_block+0x1a82>
    } else if (axis_command == AxisCommand_MotionMode) {
 8010bfa:	f1ba 0f02 	cmp.w	sl, #2
 8010bfe:	f000 813c 	beq.w	8010e7a <gc_execute_block+0x1a9a>
    if (gc_parser_flags.jog_motion) // Jogging only uses the F feed rate and XYZ value words. N is valid, but S and T are invalid.
 8010c02:	f018 0401 	ands.w	r4, r8, #1
 8010c06:	f000 8762 	beq.w	8011ace <gc_execute_block+0x26ee>
        gc_block.words.n = gc_block.words.f = Off;
 8010c0a:	4b6a      	ldr	r3, [pc, #424]	; (8010db4 <gc_execute_block+0x19d4>)
 8010c0c:	f893 2095 	ldrb.w	r2, [r3, #149]	; 0x95
 8010c10:	f36f 0241 	bfc	r2, #1, #1
 8010c14:	f883 2095 	strb.w	r2, [r3, #149]	; 0x95
 8010c18:	b2d2      	uxtb	r2, r2
 8010c1a:	f36f 1286 	bfc	r2, #6, #1
 8010c1e:	f883 2095 	strb.w	r2, [r3, #149]	; 0x95
    if (axis_command)
 8010c22:	f1ba 0f00 	cmp.w	sl, #0
 8010c26:	d006      	beq.n	8010c36 <gc_execute_block+0x1856>
        gc_block.words.mask &= ~axis_words_mask.mask; // Remove axis words.
 8010c28:	4a62      	ldr	r2, [pc, #392]	; (8010db4 <gc_execute_block+0x19d4>)
 8010c2a:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 8010c2e:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
 8010c32:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
    if (gc_block.words.mask)
 8010c36:	4b5f      	ldr	r3, [pc, #380]	; (8010db4 <gc_execute_block+0x19d4>)
 8010c38:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8010c3c:	2b00      	cmp	r3, #0
 8010c3e:	f042 8026 	bne.w	8012c8e <gc_execute_block+0x38ae>
    memset(&plan_data, 0, sizeof(plan_line_data_t)); // Zero plan_data struct
 8010c42:	2228      	movs	r2, #40	; 0x28
 8010c44:	2100      	movs	r1, #0
 8010c46:	a812      	add	r0, sp, #72	; 0x48
 8010c48:	f011 ff95 	bl	8022b76 <memset>
    if (gc_parser_flags.jog_motion) {
 8010c4c:	2c00      	cmp	r4, #0
 8010c4e:	f000 8771 	beq.w	8011b34 <gc_execute_block+0x2754>
        if (command_words.mask & ~jog_groups.mask)
 8010c52:	f037 0349 	bics.w	r3, r7, #73	; 0x49
 8010c56:	f042 801d 	bne.w	8012c94 <gc_execute_block+0x38b4>
        if (!(gc_block.non_modal_command == NonModal_AbsoluteOverride || gc_block.non_modal_command == NonModal_NoAction))
 8010c5a:	4b56      	ldr	r3, [pc, #344]	; (8010db4 <gc_execute_block+0x19d4>)
 8010c5c:	781b      	ldrb	r3, [r3, #0]
 8010c5e:	2b35      	cmp	r3, #53	; 0x35
 8010c60:	d002      	beq.n	8010c68 <gc_execute_block+0x1888>
 8010c62:	2b00      	cmp	r3, #0
 8010c64:	f042 8019 	bne.w	8012c9a <gc_execute_block+0x38ba>
        memcpy(&plan_data.spindle, &gc_state.spindle, sizeof(spindle_t));
 8010c68:	4c53      	ldr	r4, [pc, #332]	; (8010db8 <gc_execute_block+0x19d8>)
 8010c6a:	ad13      	add	r5, sp, #76	; 0x4c
 8010c6c:	f104 0348 	add.w	r3, r4, #72	; 0x48
 8010c70:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8010c72:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
        plan_data.spindle.state = gc_state.modal.spindle.state;
 8010c76:	7ea3      	ldrb	r3, [r4, #26]
 8010c78:	f88d 3050 	strb.w	r3, [sp, #80]	; 0x50
        plan_data.condition.coolant = gc_state.modal.coolant;
 8010c7c:	7e63      	ldrb	r3, [r4, #25]
 8010c7e:	f88d 305e 	strb.w	r3, [sp, #94]	; 0x5e
        plan_data.condition.is_rpm_rate_adjusted = gc_state.is_rpm_rate_adjusted || (gc_state.modal.spindle.state.ccw && gc_state.spindle.hal->cap.laser);
 8010c82:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 8010c86:	2b00      	cmp	r3, #0
 8010c88:	f040 873a 	bne.w	8011b00 <gc_execute_block+0x2720>
 8010c8c:	7ea3      	ldrb	r3, [r4, #26]
 8010c8e:	f013 0f02 	tst.w	r3, #2
 8010c92:	f000 874b 	beq.w	8011b2c <gc_execute_block+0x274c>
 8010c96:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8010c98:	7a5b      	ldrb	r3, [r3, #9]
 8010c9a:	f013 0f08 	tst.w	r3, #8
 8010c9e:	f040 8747 	bne.w	8011b30 <gc_execute_block+0x2750>
 8010ca2:	2300      	movs	r3, #0
 8010ca4:	f000 bf2d 	b.w	8011b02 <gc_execute_block+0x2722>
            if (!axis_words.mask)
 8010ca8:	fa5f f08b 	uxtb.w	r0, fp
 8010cac:	2800      	cmp	r0, #0
 8010cae:	f001 8750 	beq.w	8012b52 <gc_execute_block+0x3772>
            idx = N_AXIS;
 8010cb2:	2303      	movs	r3, #3
 8010cb4:	e00d      	b.n	8010cd2 <gc_execute_block+0x18f2>
                    gc_block.values.xyz[idx] = gc_state.g92_coord_offset[idx];
 8010cb6:	f103 011e 	add.w	r1, r3, #30
 8010cba:	4a3f      	ldr	r2, [pc, #252]	; (8010db8 <gc_execute_block+0x19d8>)
 8010cbc:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8010cc0:	6854      	ldr	r4, [r2, #4]
 8010cc2:	f103 0118 	add.w	r1, r3, #24
 8010cc6:	4a3b      	ldr	r2, [pc, #236]	; (8010db4 <gc_execute_block+0x19d4>)
 8010cc8:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8010ccc:	6014      	str	r4, [r2, #0]
            } while(idx);
 8010cce:	2b00      	cmp	r3, #0
 8010cd0:	d08e      	beq.n	8010bf0 <gc_execute_block+0x1810>
                if (bit_istrue(axis_words.mask, bit(--idx))) {
 8010cd2:	3b01      	subs	r3, #1
 8010cd4:	fa20 f203 	lsr.w	r2, r0, r3
 8010cd8:	f012 0f01 	tst.w	r2, #1
 8010cdc:	d0eb      	beq.n	8010cb6 <gc_execute_block+0x18d6>
                    gc_block.values.xyz[idx] = gc_state.position[idx] - gc_block.modal.coord_system.xyz[idx] - gc_block.values.xyz[idx] - gc_state.tool_length_offset[idx];
 8010cde:	4936      	ldr	r1, [pc, #216]	; (8010db8 <gc_execute_block+0x19d8>)
 8010ce0:	f103 0518 	add.w	r5, r3, #24
 8010ce4:	eb01 0285 	add.w	r2, r1, r5, lsl #2
 8010ce8:	edd2 7a00 	vldr	s15, [r2]
 8010cec:	4a31      	ldr	r2, [pc, #196]	; (8010db4 <gc_execute_block+0x19d4>)
 8010cee:	1d1c      	adds	r4, r3, #4
 8010cf0:	eb02 0484 	add.w	r4, r2, r4, lsl #2
 8010cf4:	ed94 7a00 	vldr	s14, [r4]
 8010cf8:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8010cfc:	eb02 0285 	add.w	r2, r2, r5, lsl #2
 8010d00:	ed92 7a00 	vldr	s14, [r2]
 8010d04:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8010d08:	f103 0422 	add.w	r4, r3, #34	; 0x22
 8010d0c:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 8010d10:	ed91 7a00 	vldr	s14, [r1]
 8010d14:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8010d18:	edc2 7a00 	vstr	s15, [r2]
 8010d1c:	e7d7      	b.n	8010cce <gc_execute_block+0x18ee>
                    else if (gc_block.non_modal_command != NonModal_AbsoluteOverride) {
 8010d1e:	2b35      	cmp	r3, #53	; 0x35
 8010d20:	d012      	beq.n	8010d48 <gc_execute_block+0x1968>
                        if (gc_block.modal.distance_incremental)
 8010d22:	4924      	ldr	r1, [pc, #144]	; (8010db4 <gc_execute_block+0x19d4>)
 8010d24:	7b09      	ldrb	r1, [r1, #12]
 8010d26:	b311      	cbz	r1, 8010d6e <gc_execute_block+0x198e>
                            gc_block.values.xyz[idx] += gc_state.position[idx];
 8010d28:	f102 0018 	add.w	r0, r2, #24
 8010d2c:	4922      	ldr	r1, [pc, #136]	; (8010db8 <gc_execute_block+0x19d8>)
 8010d2e:	eb01 0180 	add.w	r1, r1, r0, lsl #2
 8010d32:	ed91 7a00 	vldr	s14, [r1]
 8010d36:	491f      	ldr	r1, [pc, #124]	; (8010db4 <gc_execute_block+0x19d4>)
 8010d38:	eb01 0180 	add.w	r1, r1, r0, lsl #2
 8010d3c:	edd1 7a00 	vldr	s15, [r1]
 8010d40:	ee77 7a87 	vadd.f32	s15, s15, s14
 8010d44:	edc1 7a00 	vstr	s15, [r1]
                } while(idx);
 8010d48:	2a00      	cmp	r2, #0
 8010d4a:	d037      	beq.n	8010dbc <gc_execute_block+0x19dc>
                    if (bit_isfalse(axis_words.mask, bit(--idx)))
 8010d4c:	3a01      	subs	r2, #1
 8010d4e:	fa24 f102 	lsr.w	r1, r4, r2
 8010d52:	f011 0f01 	tst.w	r1, #1
 8010d56:	d1e2      	bne.n	8010d1e <gc_execute_block+0x193e>
                        gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
 8010d58:	f102 0118 	add.w	r1, r2, #24
 8010d5c:	4816      	ldr	r0, [pc, #88]	; (8010db8 <gc_execute_block+0x19d8>)
 8010d5e:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 8010d62:	6805      	ldr	r5, [r0, #0]
 8010d64:	4813      	ldr	r0, [pc, #76]	; (8010db4 <gc_execute_block+0x19d4>)
 8010d66:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8010d6a:	600d      	str	r5, [r1, #0]
 8010d6c:	e7ec      	b.n	8010d48 <gc_execute_block+0x1968>
    return gc_block->modal.coord_system.xyz[idx] + gc_state.g92_coord_offset[idx] + gc_state.tool_length_offset[idx];
 8010d6e:	4911      	ldr	r1, [pc, #68]	; (8010db4 <gc_execute_block+0x19d4>)
 8010d70:	1d10      	adds	r0, r2, #4
 8010d72:	eb01 0080 	add.w	r0, r1, r0, lsl #2
 8010d76:	ed90 7a00 	vldr	s14, [r0]
 8010d7a:	480f      	ldr	r0, [pc, #60]	; (8010db8 <gc_execute_block+0x19d8>)
 8010d7c:	f102 051e 	add.w	r5, r2, #30
 8010d80:	eb00 0585 	add.w	r5, r0, r5, lsl #2
 8010d84:	edd5 7a01 	vldr	s15, [r5, #4]
 8010d88:	ee77 7a87 	vadd.f32	s15, s15, s14
 8010d8c:	f102 0522 	add.w	r5, r2, #34	; 0x22
 8010d90:	eb00 0085 	add.w	r0, r0, r5, lsl #2
 8010d94:	ed90 7a00 	vldr	s14, [r0]
 8010d98:	ee37 7a27 	vadd.f32	s14, s14, s15
                            gc_block.values.xyz[idx] += gc_get_block_offset(&gc_block, idx);
 8010d9c:	f102 0018 	add.w	r0, r2, #24
 8010da0:	eb01 0180 	add.w	r1, r1, r0, lsl #2
 8010da4:	edd1 7a00 	vldr	s15, [r1]
 8010da8:	ee77 7a87 	vadd.f32	s15, s15, s14
 8010dac:	edc1 7a00 	vstr	s15, [r1]
 8010db0:	e7ca      	b.n	8010d48 <gc_execute_block+0x1968>
 8010db2:	bf00      	nop
 8010db4:	20003298 	.word	0x20003298
 8010db8:	20003344 	.word	0x20003344
            switch (gc_block.non_modal_command) {
 8010dbc:	2b35      	cmp	r3, #53	; 0x35
 8010dbe:	d046      	beq.n	8010e4e <gc_execute_block+0x1a6e>
 8010dc0:	d811      	bhi.n	8010de6 <gc_execute_block+0x1a06>
 8010dc2:	2b1c      	cmp	r3, #28
 8010dc4:	d002      	beq.n	8010dcc <gc_execute_block+0x19ec>
 8010dc6:	2b1e      	cmp	r3, #30
 8010dc8:	f47f af12 	bne.w	8010bf0 <gc_execute_block+0x1810>
                    if (!settings_read_coord_data(gc_block.non_modal_command == NonModal_GoHome_0 ? CoordinateSystem_G28 : CoordinateSystem_G30, &gc_block.values.coord_data.xyz))
 8010dcc:	2b1c      	cmp	r3, #28
 8010dce:	d026      	beq.n	8010e1e <gc_execute_block+0x1a3e>
 8010dd0:	200a      	movs	r0, #10
 8010dd2:	4985      	ldr	r1, [pc, #532]	; (8010fe8 <gc_execute_block+0x1c08>)
 8010dd4:	f00b fe0e 	bl	801c9f4 <settings_read_coord_data>
 8010dd8:	2800      	cmp	r0, #0
 8010dda:	f001 86bd 	beq.w	8012b58 <gc_execute_block+0x3778>
                    if (axis_words.mask) {
 8010dde:	2c00      	cmp	r4, #0
 8010de0:	d03d      	beq.n	8010e5e <gc_execute_block+0x1a7e>
                        idx = N_AXIS;
 8010de2:	2303      	movs	r3, #3
 8010de4:	e020      	b.n	8010e28 <gc_execute_block+0x1a48>
 8010de6:	2b41      	cmp	r3, #65	; 0x41
 8010de8:	f47f af02 	bne.w	8010bf0 <gc_execute_block+0x1810>
                    if(!gc_block.words.p)
 8010dec:	4b7f      	ldr	r3, [pc, #508]	; (8010fec <gc_execute_block+0x1c0c>)
 8010dee:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8010df2:	f013 0f01 	tst.w	r3, #1
 8010df6:	f001 86b2 	beq.w	8012b5e <gc_execute_block+0x377e>
                    if(gc_block.values.p > 65535.0f)
 8010dfa:	4b7c      	ldr	r3, [pc, #496]	; (8010fec <gc_execute_block+0x1c0c>)
 8010dfc:	ed93 7a14 	vldr	s14, [r3, #80]	; 0x50
 8010e00:	eddf 7a7b 	vldr	s15, [pc, #492]	; 8010ff0 <gc_execute_block+0x1c10>
 8010e04:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8010e08:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010e0c:	f301 86aa 	bgt.w	8012b64 <gc_execute_block+0x3784>
                    gc_block.words.p = Off;
 8010e10:	f893 2096 	ldrb.w	r2, [r3, #150]	; 0x96
 8010e14:	f36f 0200 	bfc	r2, #0, #1
 8010e18:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
                    break;
 8010e1c:	e6e8      	b.n	8010bf0 <gc_execute_block+0x1810>
                    if (!settings_read_coord_data(gc_block.non_modal_command == NonModal_GoHome_0 ? CoordinateSystem_G28 : CoordinateSystem_G30, &gc_block.values.coord_data.xyz))
 8010e1e:	2009      	movs	r0, #9
 8010e20:	e7d7      	b.n	8010dd2 <gc_execute_block+0x19f2>
                        } while(idx);
 8010e22:	2b00      	cmp	r3, #0
 8010e24:	f43f aee4 	beq.w	8010bf0 <gc_execute_block+0x1810>
                            if (bit_isfalse(axis_words.mask, bit(--idx)))
 8010e28:	3b01      	subs	r3, #1
 8010e2a:	fa24 f203 	lsr.w	r2, r4, r3
 8010e2e:	f012 0f01 	tst.w	r2, #1
 8010e32:	d1f6      	bne.n	8010e22 <gc_execute_block+0x1a42>
                                gc_block.values.coord_data.xyz[idx] = gc_state.position[idx];
 8010e34:	f103 0118 	add.w	r1, r3, #24
 8010e38:	4a6e      	ldr	r2, [pc, #440]	; (8010ff4 <gc_execute_block+0x1c14>)
 8010e3a:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8010e3e:	6810      	ldr	r0, [r2, #0]
 8010e40:	f103 011a 	add.w	r1, r3, #26
 8010e44:	4a69      	ldr	r2, [pc, #420]	; (8010fec <gc_execute_block+0x1c0c>)
 8010e46:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8010e4a:	6050      	str	r0, [r2, #4]
 8010e4c:	e7e9      	b.n	8010e22 <gc_execute_block+0x1a42>
                    if (!(gc_block.modal.motion == MotionMode_Seek || gc_block.modal.motion == MotionMode_Linear))
 8010e4e:	4b67      	ldr	r3, [pc, #412]	; (8010fec <gc_execute_block+0x1c0c>)
 8010e50:	891b      	ldrh	r3, [r3, #8]
 8010e52:	2b01      	cmp	r3, #1
 8010e54:	f67f aecc 	bls.w	8010bf0 <gc_execute_block+0x1810>
                        FAIL(Status_GcodeG53InvalidMotionMode); // [G53 G0/1 not active]
 8010e58:	241e      	movs	r4, #30
 8010e5a:	f7fe bb97 	b.w	800f58c <gc_execute_block+0x1ac>
                        axis_command = AxisCommand_None; // Set to none if no intermediate motion.
 8010e5e:	46a2      	mov	sl, r4
 8010e60:	e6c6      	b.n	8010bf0 <gc_execute_block+0x1810>
        if (axis_words.mask && axis_command != AxisCommand_NonModal) // [No axis words allowed]
 8010e62:	fa5f f38b 	uxtb.w	r3, fp
 8010e66:	b11b      	cbz	r3, 8010e70 <gc_execute_block+0x1a90>
 8010e68:	f1ba 0f01 	cmp.w	sl, #1
 8010e6c:	f041 867d 	bne.w	8012b6a <gc_execute_block+0x378a>
        gc_block.modal.retract_mode = CCRetractMode_Previous;
 8010e70:	4b5e      	ldr	r3, [pc, #376]	; (8010fec <gc_execute_block+0x1c0c>)
 8010e72:	2200      	movs	r2, #0
 8010e74:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
 8010e78:	e6c3      	b.n	8010c02 <gc_execute_block+0x1822>
        gc_parser_flags.motion_mode_changed = gc_block.modal.motion != gc_state.modal.motion;
 8010e7a:	4b5e      	ldr	r3, [pc, #376]	; (8010ff4 <gc_execute_block+0x1c14>)
 8010e7c:	8819      	ldrh	r1, [r3, #0]
 8010e7e:	1a6b      	subs	r3, r5, r1
 8010e80:	bf18      	it	ne
 8010e82:	2301      	movne	r3, #1
 8010e84:	f363 2849 	bfi	r8, r3, #9, #1
        if (gc_block.modal.motion == MotionMode_Seek) {
 8010e88:	b935      	cbnz	r5, 8010e98 <gc_execute_block+0x1ab8>
            if (!axis_words.mask)
 8010e8a:	fa5f f38b 	uxtb.w	r3, fp
 8010e8e:	2b00      	cmp	r3, #0
 8010e90:	f47f aeb7 	bne.w	8010c02 <gc_execute_block+0x1822>
                axis_command = AxisCommand_None;
 8010e94:	469a      	mov	sl, r3
 8010e96:	e6b4      	b.n	8010c02 <gc_execute_block+0x1822>
            if(!gc_block.modal.canned_cycle_active)
 8010e98:	4b54      	ldr	r3, [pc, #336]	; (8010fec <gc_execute_block+0x1c0c>)
 8010e9a:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 8010e9e:	9308      	str	r3, [sp, #32]
 8010ea0:	b91b      	cbnz	r3, 8010eaa <gc_execute_block+0x1aca>
                gc_block.modal.retract_mode = CCRetractMode_Previous;
 8010ea2:	4b52      	ldr	r3, [pc, #328]	; (8010fec <gc_execute_block+0x1c0c>)
 8010ea4:	2200      	movs	r2, #0
 8010ea6:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
            if(gc_block.modal.spindle.rpm_mode == SpindleSpeedMode_CSS && (!gc_block.modal.spindle.state.on || gc_block.values.s == 0.0f))
 8010eaa:	4b50      	ldr	r3, [pc, #320]	; (8010fec <gc_execute_block+0x1c0c>)
 8010eac:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
 8010eb0:	2b01      	cmp	r3, #1
 8010eb2:	d074      	beq.n	8010f9e <gc_execute_block+0x1bbe>
            if (gc_block.modal.motion == MotionMode_SpindleSynchronized) {
 8010eb4:	2d21      	cmp	r5, #33	; 0x21
 8010eb6:	f000 8085 	beq.w	8010fc4 <gc_execute_block+0x1be4>
            } else if (gc_block.modal.motion == MotionMode_Threading) {
 8010eba:	2d4c      	cmp	r5, #76	; 0x4c
 8010ebc:	f000 809e 	beq.w	8010ffc <gc_execute_block+0x1c1c>
            } else if (gc_block.values.f == 0.0f)
 8010ec0:	4b4a      	ldr	r3, [pc, #296]	; (8010fec <gc_execute_block+0x1c0c>)
 8010ec2:	edd3 7a0e 	vldr	s15, [r3, #56]	; 0x38
 8010ec6:	eef5 7a40 	vcmp.f32	s15, #0.0
 8010eca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010ece:	f001 8688 	beq.w	8012be2 <gc_execute_block+0x3802>
            if (gc_block.modal.canned_cycle_active) {
 8010ed2:	9b08      	ldr	r3, [sp, #32]
 8010ed4:	2b00      	cmp	r3, #0
 8010ed6:	f000 8332 	beq.w	801153e <gc_execute_block+0x215e>
                if(gc_parser_flags.canned_cycle_change) {
 8010eda:	f018 0102 	ands.w	r1, r8, #2
 8010ede:	d02e      	beq.n	8010f3e <gc_execute_block+0x1b5e>
                    if(gc_state.modal.feed_mode == FeedMode_InverseTime)
 8010ee0:	4b44      	ldr	r3, [pc, #272]	; (8010ff4 <gc_execute_block+0x1c14>)
 8010ee2:	789b      	ldrb	r3, [r3, #2]
 8010ee4:	2b01      	cmp	r3, #1
 8010ee6:	f001 867f 	beq.w	8012be8 <gc_execute_block+0x3808>
                    if(!gc_block.words.r)
 8010eea:	4b40      	ldr	r3, [pc, #256]	; (8010fec <gc_execute_block+0x1c0c>)
 8010eec:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8010ef0:	f013 0f04 	tst.w	r3, #4
 8010ef4:	f001 867b 	beq.w	8012bee <gc_execute_block+0x380e>
                    if(!(axis_words.mask & bit(plane.axis_linear)))
 8010ef8:	fa5f f38b 	uxtb.w	r3, fp
 8010efc:	f89d 2082 	ldrb.w	r2, [sp, #130]	; 0x82
 8010f00:	40d3      	lsrs	r3, r2
 8010f02:	f013 0f01 	tst.w	r3, #1
 8010f06:	f001 8675 	beq.w	8012bf4 <gc_execute_block+0x3814>
                    gc_state.canned.dwell = 0.0f;
 8010f0a:	4b3a      	ldr	r3, [pc, #232]	; (8010ff4 <gc_execute_block+0x1c14>)
 8010f0c:	2400      	movs	r4, #0
 8010f0e:	639c      	str	r4, [r3, #56]	; 0x38
                    gc_state.canned.xyz[plane.axis_0] = 0.0f;
 8010f10:	f89d 0080 	ldrb.w	r0, [sp, #128]	; 0x80
 8010f14:	300a      	adds	r0, #10
 8010f16:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8010f1a:	6004      	str	r4, [r0, #0]
                    gc_state.canned.xyz[plane.axis_1] = 0.0f;
 8010f1c:	f89d 0081 	ldrb.w	r0, [sp, #129]	; 0x81
 8010f20:	300a      	adds	r0, #10
 8010f22:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8010f26:	6004      	str	r4, [r0, #0]
                    gc_state.canned.rapid_retract = On;
 8010f28:	2001      	movs	r0, #1
 8010f2a:	f883 0044 	strb.w	r0, [r3, #68]	; 0x44
                    gc_state.canned.spindle_off = Off;
 8010f2e:	2000      	movs	r0, #0
 8010f30:	f883 0045 	strb.w	r0, [r3, #69]	; 0x45
                    gc_state.canned.prev_position = gc_state.position[plane.axis_linear];
 8010f34:	3218      	adds	r2, #24
 8010f36:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8010f3a:	6812      	ldr	r2, [r2, #0]
 8010f3c:	63da      	str	r2, [r3, #60]	; 0x3c
                if(!gc_block.words.l)
 8010f3e:	4b2b      	ldr	r3, [pc, #172]	; (8010fec <gc_execute_block+0x1c0c>)
 8010f40:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 8010f44:	f013 0f10 	tst.w	r3, #16
 8010f48:	f040 81ec 	bne.w	8011324 <gc_execute_block+0x1f44>
                    gc_block.values.l = 1;
 8010f4c:	4b27      	ldr	r3, [pc, #156]	; (8010fec <gc_execute_block+0x1c0c>)
 8010f4e:	2201      	movs	r2, #1
 8010f50:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90
                if(gc_block.words.r)
 8010f54:	4b25      	ldr	r3, [pc, #148]	; (8010fec <gc_execute_block+0x1c0c>)
 8010f56:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8010f5a:	f013 0f04 	tst.w	r3, #4
 8010f5e:	d01c      	beq.n	8010f9a <gc_execute_block+0x1bba>
                    gc_state.canned.retract_position = gc_block.values.r * (gc_block.modal.units_imperial ? MM_PER_INCH : 1.0f) +
 8010f60:	4b22      	ldr	r3, [pc, #136]	; (8010fec <gc_execute_block+0x1c0c>)
 8010f62:	edd3 7a16 	vldr	s15, [r3, #88]	; 0x58
 8010f66:	7adb      	ldrb	r3, [r3, #11]
 8010f68:	2b00      	cmp	r3, #0
 8010f6a:	f000 81e4 	beq.w	8011336 <gc_execute_block+0x1f56>
 8010f6e:	ed9f 7a22 	vldr	s14, [pc, #136]	; 8010ff8 <gc_execute_block+0x1c18>
 8010f72:	ee27 7a87 	vmul.f32	s14, s15, s14
                                                        (gc_block.modal.distance_incremental
 8010f76:	4b1d      	ldr	r3, [pc, #116]	; (8010fec <gc_execute_block+0x1c0c>)
 8010f78:	7b1b      	ldrb	r3, [r3, #12]
                                                          : gc_get_block_offset(&gc_block, plane.axis_linear));
 8010f7a:	2b00      	cmp	r3, #0
 8010f7c:	f000 81de 	beq.w	801133c <gc_execute_block+0x1f5c>
                                                          ? gc_state.position[plane.axis_linear]
 8010f80:	f89d 2082 	ldrb.w	r2, [sp, #130]	; 0x82
                                                          : gc_get_block_offset(&gc_block, plane.axis_linear));
 8010f84:	3218      	adds	r2, #24
 8010f86:	4b1b      	ldr	r3, [pc, #108]	; (8010ff4 <gc_execute_block+0x1c14>)
 8010f88:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8010f8c:	edd3 7a00 	vldr	s15, [r3]
                    gc_state.canned.retract_position = gc_block.values.r * (gc_block.modal.units_imperial ? MM_PER_INCH : 1.0f) +
 8010f90:	ee77 7a27 	vadd.f32	s15, s14, s15
 8010f94:	4b17      	ldr	r3, [pc, #92]	; (8010ff4 <gc_execute_block+0x1c14>)
 8010f96:	edc3 7a10 	vstr	s15, [r3, #64]	; 0x40
 8010f9a:	2303      	movs	r3, #3
 8010f9c:	e1fe      	b.n	801139c <gc_execute_block+0x1fbc>
            if(gc_block.modal.spindle.rpm_mode == SpindleSpeedMode_CSS && (!gc_block.modal.spindle.state.on || gc_block.values.s == 0.0f))
 8010f9e:	4b13      	ldr	r3, [pc, #76]	; (8010fec <gc_execute_block+0x1c0c>)
 8010fa0:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8010fa4:	f013 0f01 	tst.w	r3, #1
 8010fa8:	f001 85e2 	beq.w	8012b70 <gc_execute_block+0x3790>
 8010fac:	4b0f      	ldr	r3, [pc, #60]	; (8010fec <gc_execute_block+0x1c0c>)
 8010fae:	edd3 7a17 	vldr	s15, [r3, #92]	; 0x5c
 8010fb2:	eef5 7a40 	vcmp.f32	s15, #0.0
 8010fb6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010fba:	f47f af7b 	bne.w	8010eb4 <gc_execute_block+0x1ad4>
                 FAIL(Status_GcodeSpindleNotRunning);
 8010fbe:	2429      	movs	r4, #41	; 0x29
 8010fc0:	f7fe bae4 	b.w	800f58c <gc_execute_block+0x1ac>
                if(!gc_state.spindle.hal->get_data)
 8010fc4:	4b0b      	ldr	r3, [pc, #44]	; (8010ff4 <gc_execute_block+0x1c14>)
 8010fc6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8010fc8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8010fca:	2b00      	cmp	r3, #0
 8010fcc:	f001 85d3 	beq.w	8012b76 <gc_execute_block+0x3796>
                if(gc_block.values.k == 0.0f)
 8010fd0:	4b06      	ldr	r3, [pc, #24]	; (8010fec <gc_execute_block+0x1c0c>)
 8010fd2:	edd3 7a12 	vldr	s15, [r3, #72]	; 0x48
 8010fd6:	eef5 7a40 	vcmp.f32	s15, #0.0
 8010fda:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010fde:	f001 85cd 	beq.w	8012b7c <gc_execute_block+0x379c>
                gc_parser_flags.spindle_force_sync = On;
 8010fe2:	f048 0820 	orr.w	r8, r8, #32
 8010fe6:	e774      	b.n	8010ed2 <gc_execute_block+0x1af2>
 8010fe8:	20003304 	.word	0x20003304
 8010fec:	20003298 	.word	0x20003298
 8010ff0:	477fff00 	.word	0x477fff00
 8010ff4:	20003344 	.word	0x20003344
 8010ff8:	41cb3333 	.word	0x41cb3333
                if(!gc_state.spindle.hal->get_data)
 8010ffc:	4baf      	ldr	r3, [pc, #700]	; (80112bc <gc_execute_block+0x1edc>)
 8010ffe:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8011000:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8011002:	2a00      	cmp	r2, #0
 8011004:	f001 85bd 	beq.w	8012b82 <gc_execute_block+0x37a2>
                if(gc_block.modal.plane_select != PlaneSelect_ZX)
 8011008:	4aad      	ldr	r2, [pc, #692]	; (80112c0 <gc_execute_block+0x1ee0>)
 801100a:	7b92      	ldrb	r2, [r2, #14]
 801100c:	2a01      	cmp	r2, #1
 801100e:	f041 85bb 	bne.w	8012b88 <gc_execute_block+0x37a8>
                if(axis_words.mask & ~(bit(X_AXIS)|bit(Z_AXIS)))
 8011012:	fa5f f48b 	uxtb.w	r4, fp
 8011016:	f01b 0ffa 	tst.w	fp, #250	; 0xfa
 801101a:	f041 85b8 	bne.w	8012b8e <gc_execute_block+0x37ae>
                if(gc_block.words.r && gc_block.values.r < 1.0f)
 801101e:	4aa8      	ldr	r2, [pc, #672]	; (80112c0 <gc_execute_block+0x1ee0>)
 8011020:	f892 2096 	ldrb.w	r2, [r2, #150]	; 0x96
 8011024:	9209      	str	r2, [sp, #36]	; 0x24
 8011026:	f012 0204 	ands.w	r2, r2, #4
 801102a:	920a      	str	r2, [sp, #40]	; 0x28
 801102c:	d00a      	beq.n	8011044 <gc_execute_block+0x1c64>
 801102e:	4aa4      	ldr	r2, [pc, #656]	; (80112c0 <gc_execute_block+0x1ee0>)
 8011030:	ed92 7a16 	vldr	s14, [r2, #88]	; 0x58
 8011034:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8011038:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801103c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011040:	f101 85a8 	bmi.w	8012b94 <gc_execute_block+0x37b4>
                if(!axis_words.z || !(gc_block.words.i || gc_block.words.j || gc_block.words.k || gc_block.words.p))
 8011044:	f014 0f04 	tst.w	r4, #4
 8011048:	f001 85a7 	beq.w	8012b9a <gc_execute_block+0x37ba>
 801104c:	4a9c      	ldr	r2, [pc, #624]	; (80112c0 <gc_execute_block+0x1ee0>)
 801104e:	f8d2 0094 	ldr.w	r0, [r2, #148]	; 0x94
 8011052:	4a9c      	ldr	r2, [pc, #624]	; (80112c4 <gc_execute_block+0x1ee4>)
 8011054:	4002      	ands	r2, r0
 8011056:	2a00      	cmp	r2, #0
 8011058:	f001 85a2 	beq.w	8012ba0 <gc_execute_block+0x37c0>
                if(gc_block.values.p < 0.0f || gc_block.values.ijk[J_VALUE] < 0.0f || gc_block.values.ijk[K_VALUE] < 0.0f)
 801105c:	4a98      	ldr	r2, [pc, #608]	; (80112c0 <gc_execute_block+0x1ee0>)
 801105e:	ed92 aa14 	vldr	s20, [r2, #80]	; 0x50
 8011062:	eeb5 aac0 	vcmpe.f32	s20, #0.0
 8011066:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801106a:	f101 859c 	bmi.w	8012ba6 <gc_execute_block+0x37c6>
 801106e:	ed92 9a10 	vldr	s18, [r2, #64]	; 0x40
 8011072:	eeb5 9ac0 	vcmpe.f32	s18, #0.0
 8011076:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801107a:	f101 8597 	bmi.w	8012bac <gc_execute_block+0x37cc>
 801107e:	edd2 9a11 	vldr	s19, [r2, #68]	; 0x44
 8011082:	eef5 9ac0 	vcmpe.f32	s19, #0.0
 8011086:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801108a:	f101 8592 	bmi.w	8012bb2 <gc_execute_block+0x37d2>
                if(gc_block.values.ijk[I_VALUE] == 0.0f ||
 801108e:	edd2 8a0f 	vldr	s17, [r2, #60]	; 0x3c
 8011092:	eef5 8a40 	vcmp.f32	s17, #0.0
 8011096:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801109a:	f001 858d 	beq.w	8012bb8 <gc_execute_block+0x37d8>
 801109e:	eeb5 9a40 	vcmp.f32	s18, #0.0
 80110a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80110a6:	f001 858a 	beq.w	8012bbe <gc_execute_block+0x37de>
                    gc_block.values.ijk[J_VALUE] == 0.0f ||
 80110aa:	eeb4 9ae9 	vcmpe.f32	s18, s19
 80110ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80110b2:	f281 8587 	bge.w	8012bc4 <gc_execute_block+0x37e4>
                      (gc_block.words.l && (gc_taper_type)gc_block.values.l > Taper_Both))
 80110b6:	f892 6095 	ldrb.w	r6, [r2, #149]	; 0x95
                     gc_block.values.ijk[K_VALUE] <= gc_block.values.ijk[J_VALUE] ||
 80110ba:	f016 0210 	ands.w	r2, r6, #16
 80110be:	920b      	str	r2, [sp, #44]	; 0x2c
 80110c0:	d005      	beq.n	80110ce <gc_execute_block+0x1cee>
                      (gc_block.words.l && (gc_taper_type)gc_block.values.l > Taper_Both))
 80110c2:	4a7f      	ldr	r2, [pc, #508]	; (80112c0 <gc_execute_block+0x1ee0>)
 80110c4:	f892 2090 	ldrb.w	r2, [r2, #144]	; 0x90
 80110c8:	2a03      	cmp	r2, #3
 80110ca:	f201 857e 	bhi.w	8012bca <gc_execute_block+0x37ea>
                if(gc_state.spindle.rpm < gc_state.spindle.hal->rpm_min || gc_state.spindle.rpm > gc_state.spindle.hal->rpm_max)
 80110ce:	4a7b      	ldr	r2, [pc, #492]	; (80112bc <gc_execute_block+0x1edc>)
 80110d0:	edd2 7a12 	vldr	s15, [r2, #72]	; 0x48
 80110d4:	ed93 7a04 	vldr	s14, [r3, #16]
 80110d8:	eef4 7ac7 	vcmpe.f32	s15, s14
 80110dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80110e0:	f101 8576 	bmi.w	8012bd0 <gc_execute_block+0x37f0>
 80110e4:	ed93 7a05 	vldr	s14, [r3, #20]
 80110e8:	eef4 7ac7 	vcmpe.f32	s15, s14
 80110ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80110f0:	f301 8571 	bgt.w	8012bd6 <gc_execute_block+0x37f6>
                if(gc_block.modal.motion != gc_state.modal.motion) {
 80110f4:	428d      	cmp	r5, r1
 80110f6:	f040 80d4 	bne.w	80112a2 <gc_execute_block+0x1ec2>
                thread.pitch = gc_block.values.p;
 80110fa:	4b73      	ldr	r3, [pc, #460]	; (80112c8 <gc_execute_block+0x1ee8>)
 80110fc:	ed83 aa00 	vstr	s20, [r3]
                thread.z_final = gc_block.values.xyz[Z_AXIS];
 8011100:	4a6f      	ldr	r2, [pc, #444]	; (80112c0 <gc_execute_block+0x1ee0>)
 8011102:	ed92 8a1a 	vldr	s16, [r2, #104]	; 0x68
 8011106:	ed83 8a01 	vstr	s16, [r3, #4]
                thread.cut_direction = gc_block.values.ijk[I_VALUE] < 0.0f ? -1.0f : 1.0f;
 801110a:	eef5 8ac0 	vcmpe.f32	s17, #0.0
 801110e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011112:	f100 80d0 	bmi.w	80112b6 <gc_execute_block+0x1ed6>
 8011116:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 801111a:	4b6b      	ldr	r3, [pc, #428]	; (80112c8 <gc_execute_block+0x1ee8>)
 801111c:	625a      	str	r2, [r3, #36]	; 0x24
                thread.peak = fabsf(gc_block.values.ijk[I_VALUE]);
 801111e:	eef0 8ae8 	vabs.f32	s17, s17
 8011122:	edc3 8a02 	vstr	s17, [r3, #8]
                thread.initial_depth = gc_block.values.ijk[J_VALUE];
 8011126:	ed83 9a03 	vstr	s18, [r3, #12]
                thread.depth = gc_block.values.ijk[K_VALUE];
 801112a:	edc3 9a04 	vstr	s19, [r3, #16]
                if(gc_block.modal.units_imperial) {
 801112e:	4b64      	ldr	r3, [pc, #400]	; (80112c0 <gc_execute_block+0x1ee0>)
 8011130:	7adb      	ldrb	r3, [r3, #11]
 8011132:	b173      	cbz	r3, 8011152 <gc_execute_block+0x1d72>
                    thread.peak *= MM_PER_INCH;
 8011134:	4b64      	ldr	r3, [pc, #400]	; (80112c8 <gc_execute_block+0x1ee8>)
 8011136:	eddf 7a65 	vldr	s15, [pc, #404]	; 80112cc <gc_execute_block+0x1eec>
 801113a:	ee68 8aa7 	vmul.f32	s17, s17, s15
 801113e:	edc3 8a02 	vstr	s17, [r3, #8]
                    thread.initial_depth *= MM_PER_INCH;
 8011142:	ee29 9a27 	vmul.f32	s18, s18, s15
 8011146:	ed83 9a03 	vstr	s18, [r3, #12]
                    thread.depth *= MM_PER_INCH;
 801114a:	ee69 9aa7 	vmul.f32	s19, s19, s15
 801114e:	edc3 9a04 	vstr	s19, [r3, #16]
                if(gc_block.modal.diameter_mode) {
 8011152:	4b5b      	ldr	r3, [pc, #364]	; (80112c0 <gc_execute_block+0x1ee0>)
 8011154:	7b5b      	ldrb	r3, [r3, #13]
 8011156:	b1a3      	cbz	r3, 8011182 <gc_execute_block+0x1da2>
                    thread.peak /= 2.0f;
 8011158:	4b5b      	ldr	r3, [pc, #364]	; (80112c8 <gc_execute_block+0x1ee8>)
 801115a:	edd3 7a02 	vldr	s15, [r3, #8]
 801115e:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 8011162:	ee67 7a87 	vmul.f32	s15, s15, s14
 8011166:	edc3 7a02 	vstr	s15, [r3, #8]
                    thread.initial_depth /= 2.0f;
 801116a:	edd3 7a03 	vldr	s15, [r3, #12]
 801116e:	ee67 7a87 	vmul.f32	s15, s15, s14
 8011172:	edc3 7a03 	vstr	s15, [r3, #12]
                    thread.depth /= 2.0f;
 8011176:	edd3 7a04 	vldr	s15, [r3, #16]
 801117a:	ee67 7a87 	vmul.f32	s15, s15, s14
 801117e:	edc3 7a04 	vstr	s15, [r3, #16]
                if(axis_words.x) {
 8011182:	f014 0f01 	tst.w	r4, #1
 8011186:	f040 80a5 	bne.w	80112d4 <gc_execute_block+0x1ef4>
                if(gc_block.words.h)
 801118a:	f016 0f08 	tst.w	r6, #8
 801118e:	d004      	beq.n	801119a <gc_execute_block+0x1dba>
                    thread.spring_passes = (uint_fast16_t)gc_block.values.h;
 8011190:	4b4b      	ldr	r3, [pc, #300]	; (80112c0 <gc_execute_block+0x1ee0>)
 8011192:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8011196:	4b4c      	ldr	r3, [pc, #304]	; (80112c8 <gc_execute_block+0x1ee8>)
 8011198:	629a      	str	r2, [r3, #40]	; 0x28
                if(gc_block.words.l)
 801119a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801119c:	b12b      	cbz	r3, 80111aa <gc_execute_block+0x1dca>
                    thread.end_taper_type = (gc_taper_type)gc_block.values.l;
 801119e:	4b48      	ldr	r3, [pc, #288]	; (80112c0 <gc_execute_block+0x1ee0>)
 80111a0:	f893 2090 	ldrb.w	r2, [r3, #144]	; 0x90
 80111a4:	4b48      	ldr	r3, [pc, #288]	; (80112c8 <gc_execute_block+0x1ee8>)
 80111a6:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
                if(gc_block.words.e)
 80111aa:	f016 0f01 	tst.w	r6, #1
 80111ae:	d003      	beq.n	80111b8 <gc_execute_block+0x1dd8>
                    thread.end_taper_length = gc_block.values.e;
 80111b0:	4b43      	ldr	r3, [pc, #268]	; (80112c0 <gc_execute_block+0x1ee0>)
 80111b2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80111b4:	4b44      	ldr	r3, [pc, #272]	; (80112c8 <gc_execute_block+0x1ee8>)
 80111b6:	61da      	str	r2, [r3, #28]
                if(thread.end_taper_length <= 0.0f || thread.end_taper_type == Taper_None) {
 80111b8:	4b43      	ldr	r3, [pc, #268]	; (80112c8 <gc_execute_block+0x1ee8>)
 80111ba:	edd3 7a07 	vldr	s15, [r3, #28]
 80111be:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80111c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80111c6:	d902      	bls.n	80111ce <gc_execute_block+0x1dee>
 80111c8:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 80111cc:	b92b      	cbnz	r3, 80111da <gc_execute_block+0x1dfa>
                    thread.end_taper_length = 0.0f;
 80111ce:	4b3e      	ldr	r3, [pc, #248]	; (80112c8 <gc_execute_block+0x1ee8>)
 80111d0:	2200      	movs	r2, #0
 80111d2:	61da      	str	r2, [r3, #28]
                    thread.end_taper_type = Taper_None;
 80111d4:	2200      	movs	r2, #0
 80111d6:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
                if(thread.end_taper_type != Taper_None && thread.end_taper_length > abs(thread.z_final - gc_state.position[Z_AXIS]) / 2.0f)
 80111da:	4b3b      	ldr	r3, [pc, #236]	; (80112c8 <gc_execute_block+0x1ee8>)
 80111dc:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 80111e0:	b1e3      	cbz	r3, 801121c <gc_execute_block+0x1e3c>
 80111e2:	4b39      	ldr	r3, [pc, #228]	; (80112c8 <gc_execute_block+0x1ee8>)
 80111e4:	ed93 7a07 	vldr	s14, [r3, #28]
 80111e8:	4b34      	ldr	r3, [pc, #208]	; (80112bc <gc_execute_block+0x1edc>)
 80111ea:	edd3 7a1a 	vldr	s15, [r3, #104]	; 0x68
 80111ee:	ee78 7a67 	vsub.f32	s15, s16, s15
 80111f2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80111f6:	ee17 3a90 	vmov	r3, s15
 80111fa:	2b00      	cmp	r3, #0
 80111fc:	bfb8      	it	lt
 80111fe:	425b      	neglt	r3, r3
 8011200:	ee07 3a90 	vmov	s15, r3
 8011204:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8011208:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 801120c:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8011210:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8011214:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011218:	f301 84e0 	bgt.w	8012bdc <gc_execute_block+0x37fc>
                if(gc_block.words.r)
 801121c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801121e:	b11b      	cbz	r3, 8011228 <gc_execute_block+0x1e48>
                    thread.depth_degression = gc_block.values.r;
 8011220:	4b27      	ldr	r3, [pc, #156]	; (80112c0 <gc_execute_block+0x1ee0>)
 8011222:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8011224:	4b28      	ldr	r3, [pc, #160]	; (80112c8 <gc_execute_block+0x1ee8>)
 8011226:	615a      	str	r2, [r3, #20]
                if(gc_block.words.q)
 8011228:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801122a:	f013 0f02 	tst.w	r3, #2
 801122e:	d003      	beq.n	8011238 <gc_execute_block+0x1e58>
                    thread.infeed_angle = gc_block.values.q;
 8011230:	4b23      	ldr	r3, [pc, #140]	; (80112c0 <gc_execute_block+0x1ee0>)
 8011232:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8011234:	4b24      	ldr	r3, [pc, #144]	; (80112c8 <gc_execute_block+0x1ee8>)
 8011236:	621a      	str	r2, [r3, #32]
                gc_parser_flags.spindle_force_sync = On;
 8011238:	f048 0820 	orr.w	r8, r8, #32
                gc_block.words.e = gc_block.words.h = gc_block.words.i = gc_block.words.j = gc_block.words.k = gc_block.words.l = gc_block.words.p = gc_block.words.q = gc_block.words.r = Off;
 801123c:	4b20      	ldr	r3, [pc, #128]	; (80112c0 <gc_execute_block+0x1ee0>)
 801123e:	f893 2096 	ldrb.w	r2, [r3, #150]	; 0x96
 8011242:	f36f 0282 	bfc	r2, #2, #1
 8011246:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
 801124a:	b2d2      	uxtb	r2, r2
 801124c:	f36f 0241 	bfc	r2, #1, #1
 8011250:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
 8011254:	b2d2      	uxtb	r2, r2
 8011256:	f36f 0200 	bfc	r2, #0, #1
 801125a:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
 801125e:	f893 2095 	ldrb.w	r2, [r3, #149]	; 0x95
 8011262:	f36f 1204 	bfc	r2, #4, #1
 8011266:	f883 2095 	strb.w	r2, [r3, #149]	; 0x95
 801126a:	f893 2094 	ldrb.w	r2, [r3, #148]	; 0x94
 801126e:	f36f 1286 	bfc	r2, #6, #1
 8011272:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
 8011276:	b2d2      	uxtb	r2, r2
 8011278:	f36f 1245 	bfc	r2, #5, #1
 801127c:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
 8011280:	b2d2      	uxtb	r2, r2
 8011282:	f36f 1204 	bfc	r2, #4, #1
 8011286:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
 801128a:	f893 2095 	ldrb.w	r2, [r3, #149]	; 0x95
 801128e:	f36f 02c3 	bfc	r2, #3, #1
 8011292:	f883 2095 	strb.w	r2, [r3, #149]	; 0x95
 8011296:	b2d2      	uxtb	r2, r2
 8011298:	f36f 0200 	bfc	r2, #0, #1
 801129c:	f883 2095 	strb.w	r2, [r3, #149]	; 0x95
 80112a0:	e617      	b.n	8010ed2 <gc_execute_block+0x1af2>
                    memset(&thread, 0, sizeof(gc_thread_data));
 80112a2:	2230      	movs	r2, #48	; 0x30
 80112a4:	2100      	movs	r1, #0
 80112a6:	4808      	ldr	r0, [pc, #32]	; (80112c8 <gc_execute_block+0x1ee8>)
 80112a8:	f011 fc65 	bl	8022b76 <memset>
                    thread.depth_degression = 1.0f;
 80112ac:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 80112b0:	4a05      	ldr	r2, [pc, #20]	; (80112c8 <gc_execute_block+0x1ee8>)
 80112b2:	6153      	str	r3, [r2, #20]
 80112b4:	e721      	b.n	80110fa <gc_execute_block+0x1d1a>
                thread.cut_direction = gc_block.values.ijk[I_VALUE] < 0.0f ? -1.0f : 1.0f;
 80112b6:	4a06      	ldr	r2, [pc, #24]	; (80112d0 <gc_execute_block+0x1ef0>)
 80112b8:	e72f      	b.n	801111a <gc_execute_block+0x1d3a>
 80112ba:	bf00      	nop
 80112bc:	20003344 	.word	0x20003344
 80112c0:	20003298 	.word	0x20003298
 80112c4:	00010070 	.word	0x00010070
 80112c8:	200033e0 	.word	0x200033e0
 80112cc:	41cb3333 	.word	0x41cb3333
 80112d0:	bf800000 	.word	0xbf800000
                    thread.main_taper_height = gc_block.values.xyz[X_AXIS] - gc_get_block_offset(&gc_block, X_AXIS);
 80112d4:	4bb4      	ldr	r3, [pc, #720]	; (80115a8 <gc_execute_block+0x21c8>)
 80112d6:	edd3 7a18 	vldr	s15, [r3, #96]	; 0x60
    return gc_block->modal.coord_system.xyz[idx] + gc_state.g92_coord_offset[idx] + gc_state.tool_length_offset[idx];
 80112da:	ed93 7a04 	vldr	s14, [r3, #16]
 80112de:	4ab3      	ldr	r2, [pc, #716]	; (80115ac <gc_execute_block+0x21cc>)
 80112e0:	edd2 6a1f 	vldr	s13, [r2, #124]	; 0x7c
 80112e4:	ee37 7a26 	vadd.f32	s14, s14, s13
 80112e8:	edd2 6a22 	vldr	s13, [r2, #136]	; 0x88
 80112ec:	ee37 7a26 	vadd.f32	s14, s14, s13
                    thread.main_taper_height = gc_block.values.xyz[X_AXIS] - gc_get_block_offset(&gc_block, X_AXIS);
 80112f0:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80112f4:	4cae      	ldr	r4, [pc, #696]	; (80115b0 <gc_execute_block+0x21d0>)
 80112f6:	edc4 7a06 	vstr	s15, [r4, #24]
                    gc_block.values.p = fabsf(thread.z_final - gc_state.position[Z_AXIS]);
 80112fa:	edd2 8a1a 	vldr	s17, [r2, #104]	; 0x68
 80112fe:	ee78 8a68 	vsub.f32	s17, s16, s17
 8011302:	eef0 8ae8 	vabs.f32	s17, s17
 8011306:	edc3 8a14 	vstr	s17, [r3, #80]	; 0x50
    return sqrtf(x * x + y * y);
 801130a:	ee28 0aa8 	vmul.f32	s0, s17, s17
 801130e:	ee07 0aa7 	vmla.f32	s0, s15, s15
 8011312:	f012 fb5d 	bl	80239d0 <sqrtf>
                    thread.pitch = thread.pitch * hypot_f(thread.main_taper_height, gc_block.values.p) / gc_block.values.p;
 8011316:	ee2a aa00 	vmul.f32	s20, s20, s0
 801131a:	eeca 7a28 	vdiv.f32	s15, s20, s17
 801131e:	edc4 7a00 	vstr	s15, [r4]
 8011322:	e732      	b.n	801118a <gc_execute_block+0x1daa>
                else if(gc_block.values.l <= 0)
 8011324:	4ba0      	ldr	r3, [pc, #640]	; (80115a8 <gc_execute_block+0x21c8>)
 8011326:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
 801132a:	2b00      	cmp	r3, #0
 801132c:	f47f ae12 	bne.w	8010f54 <gc_execute_block+0x1b74>
                    FAIL(Status_NonPositiveValue); // [L <= 0]
 8011330:	2413      	movs	r4, #19
 8011332:	f7fe b92b 	b.w	800f58c <gc_execute_block+0x1ac>
                    gc_state.canned.retract_position = gc_block.values.r * (gc_block.modal.units_imperial ? MM_PER_INCH : 1.0f) +
 8011336:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 801133a:	e61a      	b.n	8010f72 <gc_execute_block+0x1b92>
                                                          : gc_get_block_offset(&gc_block, plane.axis_linear));
 801133c:	f89d 3082 	ldrb.w	r3, [sp, #130]	; 0x82
    return gc_block->modal.coord_system.xyz[idx] + gc_state.g92_coord_offset[idx] + gc_state.tool_length_offset[idx];
 8011340:	1d18      	adds	r0, r3, #4
 8011342:	4a99      	ldr	r2, [pc, #612]	; (80115a8 <gc_execute_block+0x21c8>)
 8011344:	eb02 0280 	add.w	r2, r2, r0, lsl #2
 8011348:	edd2 7a00 	vldr	s15, [r2]
 801134c:	4a97      	ldr	r2, [pc, #604]	; (80115ac <gc_execute_block+0x21cc>)
 801134e:	f103 001e 	add.w	r0, r3, #30
 8011352:	eb02 0080 	add.w	r0, r2, r0, lsl #2
 8011356:	edd0 6a01 	vldr	s13, [r0, #4]
 801135a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 801135e:	3322      	adds	r3, #34	; 0x22
 8011360:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8011364:	edd2 6a00 	vldr	s13, [r2]
 8011368:	ee77 7aa6 	vadd.f32	s15, s15, s13
 801136c:	e610      	b.n	8010f90 <gc_execute_block+0x1bb0>
                        else if(gc_block.modal.distance_incremental)
 801136e:	4a8e      	ldr	r2, [pc, #568]	; (80115a8 <gc_execute_block+0x21c8>)
 8011370:	7b12      	ldrb	r2, [r2, #12]
 8011372:	b192      	cbz	r2, 801139a <gc_execute_block+0x1fba>
                            gc_state.canned.xyz[idx] = gc_state.canned.retract_position + (gc_state.canned.xyz[idx] - gc_state.position[idx]);
 8011374:	4a8d      	ldr	r2, [pc, #564]	; (80115ac <gc_execute_block+0x21cc>)
 8011376:	ed92 7a10 	vldr	s14, [r2, #64]	; 0x40
 801137a:	f103 0018 	add.w	r0, r3, #24
 801137e:	eb02 0080 	add.w	r0, r2, r0, lsl #2
 8011382:	edd0 6a00 	vldr	s13, [r0]
 8011386:	ee77 7ae6 	vsub.f32	s15, s15, s13
 801138a:	ee77 7a27 	vadd.f32	s15, s14, s15
 801138e:	f103 000a 	add.w	r0, r3, #10
 8011392:	eb02 0280 	add.w	r2, r2, r0, lsl #2
 8011396:	edc2 7a00 	vstr	s15, [r2]
                } while(idx);
 801139a:	b343      	cbz	r3, 80113ee <gc_execute_block+0x200e>
                    if(bit_istrue(axis_words.mask, bit(--idx))) {
 801139c:	fa5f f28b 	uxtb.w	r2, fp
 80113a0:	3b01      	subs	r3, #1
 80113a2:	40da      	lsrs	r2, r3
 80113a4:	f012 0f01 	tst.w	r2, #1
 80113a8:	d0f7      	beq.n	801139a <gc_execute_block+0x1fba>
                        gc_state.canned.xyz[idx] = gc_block.values.xyz[idx];
 80113aa:	f103 0018 	add.w	r0, r3, #24
 80113ae:	4a7e      	ldr	r2, [pc, #504]	; (80115a8 <gc_execute_block+0x21c8>)
 80113b0:	eb02 0280 	add.w	r2, r2, r0, lsl #2
 80113b4:	edd2 7a00 	vldr	s15, [r2]
 80113b8:	f103 000a 	add.w	r0, r3, #10
 80113bc:	4a7b      	ldr	r2, [pc, #492]	; (80115ac <gc_execute_block+0x21cc>)
 80113be:	eb02 0280 	add.w	r2, r2, r0, lsl #2
 80113c2:	edc2 7a00 	vstr	s15, [r2]
                        if(idx != plane.axis_linear)
 80113c6:	f89d 2082 	ldrb.w	r2, [sp, #130]	; 0x82
 80113ca:	429a      	cmp	r2, r3
 80113cc:	d0cf      	beq.n	801136e <gc_execute_block+0x1f8e>
                            gc_state.canned.xyz[idx] -= gc_state.position[idx];
 80113ce:	4a77      	ldr	r2, [pc, #476]	; (80115ac <gc_execute_block+0x21cc>)
 80113d0:	f103 0018 	add.w	r0, r3, #24
 80113d4:	eb02 0080 	add.w	r0, r2, r0, lsl #2
 80113d8:	ed90 7a00 	vldr	s14, [r0]
 80113dc:	f103 000a 	add.w	r0, r3, #10
 80113e0:	eb02 0280 	add.w	r2, r2, r0, lsl #2
 80113e4:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80113e8:	edc2 7a00 	vstr	s15, [r2]
 80113ec:	e7d5      	b.n	801139a <gc_execute_block+0x1fba>
                if(gc_state.canned.retract_position < gc_state.canned.xyz[plane.axis_linear])
 80113ee:	4b6f      	ldr	r3, [pc, #444]	; (80115ac <gc_execute_block+0x21cc>)
 80113f0:	edd3 7a10 	vldr	s15, [r3, #64]	; 0x40
 80113f4:	f89d 2082 	ldrb.w	r2, [sp, #130]	; 0x82
 80113f8:	320a      	adds	r2, #10
 80113fa:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80113fe:	ed93 7a00 	vldr	s14, [r3]
 8011402:	eef4 7ac7 	vcmpe.f32	s15, s14
 8011406:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801140a:	f101 83f6 	bmi.w	8012bfa <gc_execute_block+0x381a>
                gc_block.words.r = gc_block.words.l = Off; // Remove single-meaning value words.
 801140e:	4b66      	ldr	r3, [pc, #408]	; (80115a8 <gc_execute_block+0x21c8>)
 8011410:	f893 2095 	ldrb.w	r2, [r3, #149]	; 0x95
 8011414:	f36f 1204 	bfc	r2, #4, #1
 8011418:	f883 2095 	strb.w	r2, [r3, #149]	; 0x95
 801141c:	f893 2096 	ldrb.w	r2, [r3, #150]	; 0x96
 8011420:	f36f 0282 	bfc	r2, #2, #1
 8011424:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
                switch (gc_block.modal.motion) {
 8011428:	f1a5 0349 	sub.w	r3, r5, #73	; 0x49
 801142c:	2b10      	cmp	r3, #16
 801142e:	f63f abe8 	bhi.w	8010c02 <gc_execute_block+0x1822>
 8011432:	a201      	add	r2, pc, #4	; (adr r2, 8011438 <gc_execute_block+0x2058>)
 8011434:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8011438:	080114e5 	.word	0x080114e5
 801143c:	08010c03 	.word	0x08010c03
 8011440:	08010c03 	.word	0x08010c03
 8011444:	08010c03 	.word	0x08010c03
 8011448:	08010c03 	.word	0x08010c03
 801144c:	08010c03 	.word	0x08010c03
 8011450:	08010c03 	.word	0x08010c03
 8011454:	08010c03 	.word	0x08010c03
 8011458:	080114c1 	.word	0x080114c1
 801145c:	0801148f 	.word	0x0801148f
 8011460:	080114e5 	.word	0x080114e5
 8011464:	08010c03 	.word	0x08010c03
 8011468:	080114c1 	.word	0x080114c1
 801146c:	0801147d 	.word	0x0801147d
 8011470:	08010c03 	.word	0x08010c03
 8011474:	08010c03 	.word	0x08010c03
 8011478:	0801147d 	.word	0x0801147d
                        gc_state.canned.spindle_off = gc_block.modal.motion == MotionMode_CannedCycle86;
 801147c:	2d56      	cmp	r5, #86	; 0x56
 801147e:	bf14      	ite	ne
 8011480:	2200      	movne	r2, #0
 8011482:	2201      	moveq	r2, #1
 8011484:	4b49      	ldr	r3, [pc, #292]	; (80115ac <gc_execute_block+0x21cc>)
 8011486:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
                        gc_state.canned.rapid_retract = gc_block.modal.motion == MotionMode_CannedCycle86;
 801148a:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
                        if(gc_block.words.p) {
 801148e:	4b46      	ldr	r3, [pc, #280]	; (80115a8 <gc_execute_block+0x21c8>)
 8011490:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8011494:	f013 0f01 	tst.w	r3, #1
 8011498:	d01f      	beq.n	80114da <gc_execute_block+0x20fa>
                            if(gc_block.values.p < 0.0f)
 801149a:	4b43      	ldr	r3, [pc, #268]	; (80115a8 <gc_execute_block+0x21c8>)
 801149c:	edd3 6a14 	vldr	s13, [r3, #80]	; 0x50
 80114a0:	eef5 6ac0 	vcmpe.f32	s13, #0.0
 80114a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80114a8:	f101 83aa 	bmi.w	8012c00 <gc_execute_block+0x3820>
                            gc_state.canned.dwell = gc_block.values.p;
 80114ac:	4b3f      	ldr	r3, [pc, #252]	; (80115ac <gc_execute_block+0x21cc>)
 80114ae:	edc3 6a0e 	vstr	s13, [r3, #56]	; 0x38
                            gc_block.words.p = Off; // Remove single-meaning value word.
 80114b2:	4b3d      	ldr	r3, [pc, #244]	; (80115a8 <gc_execute_block+0x21c8>)
 80114b4:	f893 2096 	ldrb.w	r2, [r3, #150]	; 0x96
 80114b8:	f36f 0200 	bfc	r2, #0, #1
 80114bc:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
                        gc_state.canned.delta = - gc_state.canned.xyz[plane.axis_linear] + gc_state.canned.retract_position;
 80114c0:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80114c4:	4b39      	ldr	r3, [pc, #228]	; (80115ac <gc_execute_block+0x21cc>)
 80114c6:	edc3 7a0d 	vstr	s15, [r3, #52]	; 0x34
                        if(gc_block.modal.motion == MotionMode_CannedCycle85)
 80114ca:	2d55      	cmp	r5, #85	; 0x55
 80114cc:	f47f ab99 	bne.w	8010c02 <gc_execute_block+0x1822>
                            gc_state.canned.rapid_retract = Off;
 80114d0:	2200      	movs	r2, #0
 80114d2:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 80114d6:	f7ff bb94 	b.w	8010c02 <gc_execute_block+0x1822>
                        } else if(gc_parser_flags.canned_cycle_change)
 80114da:	2900      	cmp	r1, #0
 80114dc:	d0f0      	beq.n	80114c0 <gc_execute_block+0x20e0>
                            FAIL(Status_GcodeValueWordMissing);
 80114de:	241c      	movs	r4, #28
 80114e0:	f7fe b854 	b.w	800f58c <gc_execute_block+0x1ac>
                        if(gc_block.words.q) {
 80114e4:	4b30      	ldr	r3, [pc, #192]	; (80115a8 <gc_execute_block+0x21c8>)
 80114e6:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 80114ea:	f013 0f02 	tst.w	r3, #2
 80114ee:	d021      	beq.n	8011534 <gc_execute_block+0x2154>
                            if(gc_block.values.q <= 0.0f)
 80114f0:	4b2d      	ldr	r3, [pc, #180]	; (80115a8 <gc_execute_block+0x21c8>)
 80114f2:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 80114f6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80114fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80114fe:	f241 8382 	bls.w	8012c06 <gc_execute_block+0x3826>
                            gc_state.canned.delta = gc_block.values.q * (gc_block.modal.units_imperial ? MM_PER_INCH : 1.0f);
 8011502:	7adb      	ldrb	r3, [r3, #11]
 8011504:	b19b      	cbz	r3, 801152e <gc_execute_block+0x214e>
 8011506:	ed9f 7a2b 	vldr	s14, [pc, #172]	; 80115b4 <gc_execute_block+0x21d4>
 801150a:	ee67 7a87 	vmul.f32	s15, s15, s14
 801150e:	4b27      	ldr	r3, [pc, #156]	; (80115ac <gc_execute_block+0x21cc>)
 8011510:	edc3 7a0d 	vstr	s15, [r3, #52]	; 0x34
                            gc_block.words.q = Off; // Remove single-meaning value word.
 8011514:	4b24      	ldr	r3, [pc, #144]	; (80115a8 <gc_execute_block+0x21c8>)
 8011516:	f893 2096 	ldrb.w	r2, [r3, #150]	; 0x96
 801151a:	f36f 0241 	bfc	r2, #1, #1
 801151e:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
                        gc_state.canned.dwell = 0.25f;
 8011522:	4b22      	ldr	r3, [pc, #136]	; (80115ac <gc_execute_block+0x21cc>)
 8011524:	f04f 527a 	mov.w	r2, #1048576000	; 0x3e800000
 8011528:	639a      	str	r2, [r3, #56]	; 0x38
                        break;
 801152a:	f7ff bb6a 	b.w	8010c02 <gc_execute_block+0x1822>
                            gc_state.canned.delta = gc_block.values.q * (gc_block.modal.units_imperial ? MM_PER_INCH : 1.0f);
 801152e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8011532:	e7ea      	b.n	801150a <gc_execute_block+0x212a>
                        } else if(gc_parser_flags.canned_cycle_change)
 8011534:	2900      	cmp	r1, #0
 8011536:	d0f4      	beq.n	8011522 <gc_execute_block+0x2142>
                            FAIL(Status_GcodeValueWordMissing);
 8011538:	241c      	movs	r4, #28
 801153a:	f7fe b827 	b.w	800f58c <gc_execute_block+0x1ac>
            } else switch (gc_block.modal.motion) {
 801153e:	2d05      	cmp	r5, #5
 8011540:	d814      	bhi.n	801156c <gc_execute_block+0x218c>
 8011542:	b22b      	sxth	r3, r5
 8011544:	2b00      	cmp	r3, #0
 8011546:	f43f ab5c 	beq.w	8010c02 <gc_execute_block+0x1822>
 801154a:	1e6b      	subs	r3, r5, #1
 801154c:	2b04      	cmp	r3, #4
 801154e:	f63f ab58 	bhi.w	8010c02 <gc_execute_block+0x1822>
 8011552:	a201      	add	r2, pc, #4	; (adr r2, 8011558 <gc_execute_block+0x2178>)
 8011554:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8011558:	08011599 	.word	0x08011599
 801155c:	080115b9 	.word	0x080115b9
 8011560:	080115bd 	.word	0x080115bd
 8011564:	08010c03 	.word	0x08010c03
 8011568:	080118cd 	.word	0x080118cd
 801156c:	2d33      	cmp	r5, #51	; 0x33
 801156e:	f000 8248 	beq.w	8011a02 <gc_execute_block+0x2622>
 8011572:	f4ff ab46 	bcc.w	8010c02 <gc_execute_block+0x1822>
 8011576:	2d8f      	cmp	r5, #143	; 0x8f
 8011578:	f63f ab43 	bhi.w	8010c02 <gc_execute_block+0x1822>
 801157c:	2d8c      	cmp	r5, #140	; 0x8c
 801157e:	f4ff ab40 	bcc.w	8010c02 <gc_execute_block+0x1822>
 8011582:	f1a5 038c 	sub.w	r3, r5, #140	; 0x8c
 8011586:	2b03      	cmp	r3, #3
 8011588:	f63f ab3b 	bhi.w	8010c02 <gc_execute_block+0x1822>
 801158c:	e8df f013 	tbh	[pc, r3, lsl #1]
 8011590:	02850287 	.word	0x02850287
 8011594:	02850287 	.word	0x02850287
                    if (!axis_words.mask)
 8011598:	fa5f f38b 	uxtb.w	r3, fp
 801159c:	2b00      	cmp	r3, #0
 801159e:	f47f ab30 	bne.w	8010c02 <gc_execute_block+0x1822>
                        axis_command = AxisCommand_None;
 80115a2:	469a      	mov	sl, r3
 80115a4:	f7ff bb2d 	b.w	8010c02 <gc_execute_block+0x1822>
 80115a8:	20003298 	.word	0x20003298
 80115ac:	20003344 	.word	0x20003344
 80115b0:	200033e0 	.word	0x200033e0
 80115b4:	41cb3333 	.word	0x41cb3333
                    gc_parser_flags.arc_is_clockwise = On;
 80115b8:	f048 0804 	orr.w	r8, r8, #4
                    if (!axis_words.mask)
 80115bc:	fa5f f18b 	uxtb.w	r1, fp
 80115c0:	2900      	cmp	r1, #0
 80115c2:	f001 8323 	beq.w	8012c0c <gc_execute_block+0x382c>
                    if (!(axis_words.mask & (bit(plane.axis_0)|bit(plane.axis_1))))
 80115c6:	f89d 3080 	ldrb.w	r3, [sp, #128]	; 0x80
 80115ca:	2201      	movs	r2, #1
 80115cc:	fa02 f303 	lsl.w	r3, r2, r3
 80115d0:	f89d 0081 	ldrb.w	r0, [sp, #129]	; 0x81
 80115d4:	4082      	lsls	r2, r0
 80115d6:	4313      	orrs	r3, r2
 80115d8:	4219      	tst	r1, r3
 80115da:	f001 831a 	beq.w	8012c12 <gc_execute_block+0x3832>
                    if (gc_block.words.p) { // Number of turns
 80115de:	4bb4      	ldr	r3, [pc, #720]	; (80118b0 <gc_execute_block+0x24d0>)
 80115e0:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 80115e4:	f013 0f01 	tst.w	r3, #1
 80115e8:	f040 80a3 	bne.w	8011732 <gc_execute_block+0x2352>
                        gc_block.arc_turns = 1;
 80115ec:	4bb0      	ldr	r3, [pc, #704]	; (80118b0 <gc_execute_block+0x24d0>)
 80115ee:	2201      	movs	r2, #1
 80115f0:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
                    x = gc_block.values.xyz[plane.axis_0] - gc_state.position[plane.axis_0]; // Delta x between current position and target
 80115f4:	f89d 4080 	ldrb.w	r4, [sp, #128]	; 0x80
 80115f8:	49ad      	ldr	r1, [pc, #692]	; (80118b0 <gc_execute_block+0x24d0>)
 80115fa:	f104 0218 	add.w	r2, r4, #24
 80115fe:	eb01 0382 	add.w	r3, r1, r2, lsl #2
 8011602:	edd3 7a00 	vldr	s15, [r3]
 8011606:	4bab      	ldr	r3, [pc, #684]	; (80118b4 <gc_execute_block+0x24d4>)
 8011608:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 801160c:	ed92 7a00 	vldr	s14, [r2]
 8011610:	ee37 9ac7 	vsub.f32	s18, s15, s14
                    y = gc_block.values.xyz[plane.axis_1] - gc_state.position[plane.axis_1]; // Delta y between current position and target
 8011614:	f89d 5081 	ldrb.w	r5, [sp, #129]	; 0x81
 8011618:	f105 0218 	add.w	r2, r5, #24
 801161c:	eb01 0082 	add.w	r0, r1, r2, lsl #2
 8011620:	ed90 8a00 	vldr	s16, [r0]
 8011624:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8011628:	edd3 7a00 	vldr	s15, [r3]
 801162c:	ee38 8a67 	vsub.f32	s16, s16, s15
                    if (gc_block.words.r) { // Arc Radius Mode
 8011630:	f891 3096 	ldrb.w	r3, [r1, #150]	; 0x96
 8011634:	f013 0f04 	tst.w	r3, #4
 8011638:	f000 80a2 	beq.w	8011780 <gc_execute_block+0x23a0>
                        gc_block.words.r = Off;
 801163c:	f891 3096 	ldrb.w	r3, [r1, #150]	; 0x96
 8011640:	f36f 0382 	bfc	r3, #2, #1
 8011644:	f881 3096 	strb.w	r3, [r1, #150]	; 0x96
                        if (isequal_position_vector(gc_state.position, gc_block.values.xyz))
 8011648:	220c      	movs	r2, #12
 801164a:	3160      	adds	r1, #96	; 0x60
 801164c:	489a      	ldr	r0, [pc, #616]	; (80118b8 <gc_execute_block+0x24d8>)
 801164e:	f011 fa82 	bl	8022b56 <memcmp>
 8011652:	2800      	cmp	r0, #0
 8011654:	f001 82e6 	beq.w	8012c24 <gc_execute_block+0x3844>
                        if (gc_block.modal.units_imperial)
 8011658:	4b95      	ldr	r3, [pc, #596]	; (80118b0 <gc_execute_block+0x24d0>)
 801165a:	7adb      	ldrb	r3, [r3, #11]
 801165c:	b143      	cbz	r3, 8011670 <gc_execute_block+0x2290>
                            gc_block.values.r *= MM_PER_INCH;
 801165e:	4b94      	ldr	r3, [pc, #592]	; (80118b0 <gc_execute_block+0x24d0>)
 8011660:	edd3 7a16 	vldr	s15, [r3, #88]	; 0x58
 8011664:	ed9f 7a95 	vldr	s14, [pc, #596]	; 80118bc <gc_execute_block+0x24dc>
 8011668:	ee67 7a87 	vmul.f32	s15, s15, s14
 801166c:	edc3 7a16 	vstr	s15, [r3, #88]	; 0x58
                        if(gc_state.modal.scaling_active)
 8011670:	4b90      	ldr	r3, [pc, #576]	; (80118b4 <gc_execute_block+0x24d4>)
 8011672:	7f9b      	ldrb	r3, [r3, #30]
 8011674:	b1cb      	cbz	r3, 80116aa <gc_execute_block+0x22ca>
                            gc_block.values.r *= (scale_factor.ijk[plane.axis_0] > scale_factor.ijk[plane.axis_1]
 8011676:	4b8e      	ldr	r3, [pc, #568]	; (80118b0 <gc_execute_block+0x24d0>)
 8011678:	edd3 7a16 	vldr	s15, [r3, #88]	; 0x58
 801167c:	4b90      	ldr	r3, [pc, #576]	; (80118c0 <gc_execute_block+0x24e0>)
 801167e:	1ca2      	adds	r2, r4, #2
 8011680:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8011684:	edd2 6a01 	vldr	s13, [r2, #4]
 8011688:	1caa      	adds	r2, r5, #2
 801168a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 801168e:	ed93 7a01 	vldr	s14, [r3, #4]
                                                   : scale_factor.ijk[plane.axis_1]);
 8011692:	eef4 6ac7 	vcmpe.f32	s13, s14
 8011696:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801169a:	dd01      	ble.n	80116a0 <gc_execute_block+0x22c0>
 801169c:	eeb0 7a66 	vmov.f32	s14, s13
                            gc_block.values.r *= (scale_factor.ijk[plane.axis_0] > scale_factor.ijk[plane.axis_1]
 80116a0:	ee67 7a87 	vmul.f32	s15, s15, s14
 80116a4:	4b82      	ldr	r3, [pc, #520]	; (80118b0 <gc_execute_block+0x24d0>)
 80116a6:	edc3 7a16 	vstr	s15, [r3, #88]	; 0x58
                        float h_x2_div_d = 4.0f * gc_block.values.r * gc_block.values.r - x * x - y * y;
 80116aa:	4b81      	ldr	r3, [pc, #516]	; (80118b0 <gc_execute_block+0x24d0>)
 80116ac:	edd3 8a16 	vldr	s17, [r3, #88]	; 0x58
 80116b0:	eef1 7a00 	vmov.f32	s15, #16	; 0x40800000  4.0
 80116b4:	ee68 7aa7 	vmul.f32	s15, s17, s15
 80116b8:	ee69 aa09 	vmul.f32	s21, s18, s18
 80116bc:	eeb0 0a6a 	vmov.f32	s0, s21
 80116c0:	ee18 0aa7 	vnmls.f32	s0, s17, s15
 80116c4:	ee28 aa08 	vmul.f32	s20, s16, s16
 80116c8:	ee30 0a4a 	vsub.f32	s0, s0, s20
                        if (h_x2_div_d < 0.0f)
 80116cc:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 80116d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80116d4:	f101 82a9 	bmi.w	8012c2a <gc_execute_block+0x384a>
                        h_x2_div_d = -sqrtf(h_x2_div_d) / hypot_f(x, y); // == -(h * 2 / d)
 80116d8:	f012 f97a 	bl	80239d0 <sqrtf>
 80116dc:	eef1 9a40 	vneg.f32	s19, s0
    return sqrtf(x * x + y * y);
 80116e0:	ee3a 0a8a 	vadd.f32	s0, s21, s20
 80116e4:	f012 f974 	bl	80239d0 <sqrtf>
                        h_x2_div_d = -sqrtf(h_x2_div_d) / hypot_f(x, y); // == -(h * 2 / d)
 80116e8:	eec9 7a80 	vdiv.f32	s15, s19, s0
                        if (gc_block.modal.motion == MotionMode_CcwArc)
 80116ec:	4b70      	ldr	r3, [pc, #448]	; (80118b0 <gc_execute_block+0x24d0>)
 80116ee:	891b      	ldrh	r3, [r3, #8]
 80116f0:	2b03      	cmp	r3, #3
 80116f2:	d03a      	beq.n	801176a <gc_execute_block+0x238a>
                        if (gc_block.values.r < 0.0f) {
 80116f4:	eef5 8ac0 	vcmpe.f32	s17, #0.0
 80116f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80116fc:	d438      	bmi.n	8011770 <gc_execute_block+0x2390>
                        gc_block.values.ijk[plane.axis_0] = 0.5f * (x - (y * h_x2_div_d));
 80116fe:	eeb0 7a49 	vmov.f32	s14, s18
 8011702:	ee07 7ac8 	vmls.f32	s14, s15, s16
 8011706:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 801170a:	ee27 7a26 	vmul.f32	s14, s14, s13
 801170e:	4b68      	ldr	r3, [pc, #416]	; (80118b0 <gc_execute_block+0x24d0>)
 8011710:	f104 020e 	add.w	r2, r4, #14
 8011714:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8011718:	ed82 7a01 	vstr	s14, [r2, #4]
                        gc_block.values.ijk[plane.axis_1] = 0.5f * (y + (x * h_x2_div_d));
 801171c:	ee07 8a89 	vmla.f32	s16, s15, s18
 8011720:	ee68 7a26 	vmul.f32	s15, s16, s13
 8011724:	350e      	adds	r5, #14
 8011726:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 801172a:	edc3 7a01 	vstr	s15, [r3, #4]
 801172e:	f7ff ba68 	b.w	8010c02 <gc_execute_block+0x1822>
                        if(!isintf(gc_block.values.p))
 8011732:	4b5f      	ldr	r3, [pc, #380]	; (80118b0 <gc_execute_block+0x24d0>)
 8011734:	ed93 0a14 	vldr	s0, [r3, #80]	; 0x50
 8011738:	f004 f97a 	bl	8015a30 <isintf>
 801173c:	2800      	cmp	r0, #0
 801173e:	f001 826b 	beq.w	8012c18 <gc_execute_block+0x3838>
                        gc_block.arc_turns = (uint32_t)truncf(gc_block.values.p);
 8011742:	4a5b      	ldr	r2, [pc, #364]	; (80118b0 <gc_execute_block+0x24d0>)
 8011744:	edd2 7a14 	vldr	s15, [r2, #80]	; 0x50
 8011748:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801174c:	ee17 3a90 	vmov	r3, s15
 8011750:	edc2 7a29 	vstr	s15, [r2, #164]	; 0xa4
                        if(gc_block.arc_turns == 0)
 8011754:	2b00      	cmp	r3, #0
 8011756:	f001 8262 	beq.w	8012c1e <gc_execute_block+0x383e>
                        gc_block.words.p = Off;
 801175a:	4613      	mov	r3, r2
 801175c:	f892 2096 	ldrb.w	r2, [r2, #150]	; 0x96
 8011760:	f36f 0200 	bfc	r2, #0, #1
 8011764:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
 8011768:	e744      	b.n	80115f4 <gc_execute_block+0x2214>
                            h_x2_div_d = -h_x2_div_d;
 801176a:	eef1 7a67 	vneg.f32	s15, s15
 801176e:	e7c1      	b.n	80116f4 <gc_execute_block+0x2314>
                            h_x2_div_d = -h_x2_div_d;
 8011770:	eef1 7a67 	vneg.f32	s15, s15
                            gc_block.values.r = -gc_block.values.r; // Finished with r. Set to positive for mc_arc
 8011774:	eef1 8a68 	vneg.f32	s17, s17
 8011778:	4b4d      	ldr	r3, [pc, #308]	; (80118b0 <gc_execute_block+0x24d0>)
 801177a:	edc3 8a16 	vstr	s17, [r3, #88]	; 0x58
 801177e:	e7be      	b.n	80116fe <gc_execute_block+0x231e>
                        if (!(ijk_words.mask & (bit(plane.axis_0)|bit(plane.axis_1))))
 8011780:	9804      	ldr	r0, [sp, #16]
 8011782:	4602      	mov	r2, r0
 8011784:	2301      	movs	r3, #1
 8011786:	fa03 f104 	lsl.w	r1, r3, r4
 801178a:	40ab      	lsls	r3, r5
 801178c:	430b      	orrs	r3, r1
 801178e:	4218      	tst	r0, r3
 8011790:	f001 824e 	beq.w	8012c30 <gc_execute_block+0x3850>
                        gc_block.words.i = gc_block.words.j = gc_block.words.k = Off;
 8011794:	4b46      	ldr	r3, [pc, #280]	; (80118b0 <gc_execute_block+0x24d0>)
 8011796:	f893 1094 	ldrb.w	r1, [r3, #148]	; 0x94
 801179a:	f36f 1186 	bfc	r1, #6, #1
 801179e:	f883 1094 	strb.w	r1, [r3, #148]	; 0x94
 80117a2:	b2c9      	uxtb	r1, r1
 80117a4:	f36f 1145 	bfc	r1, #5, #1
 80117a8:	f883 1094 	strb.w	r1, [r3, #148]	; 0x94
 80117ac:	b2c9      	uxtb	r1, r1
 80117ae:	f36f 1104 	bfc	r1, #4, #1
 80117b2:	f883 1094 	strb.w	r1, [r3, #148]	; 0x94
                        if (gc_block.modal.units_imperial) {
 80117b6:	7adb      	ldrb	r3, [r3, #11]
 80117b8:	b1b3      	cbz	r3, 80117e8 <gc_execute_block+0x2408>
                            idx = 3;
 80117ba:	2303      	movs	r3, #3
 80117bc:	e000      	b.n	80117c0 <gc_execute_block+0x23e0>
                            } while(idx);
 80117be:	b19b      	cbz	r3, 80117e8 <gc_execute_block+0x2408>
                                idx--;
 80117c0:	3b01      	subs	r3, #1
                                if (ijk_words.mask & bit(idx))
 80117c2:	fa22 f103 	lsr.w	r1, r2, r3
 80117c6:	f011 0f01 	tst.w	r1, #1
 80117ca:	d0f8      	beq.n	80117be <gc_execute_block+0x23de>
                                    gc_block.values.ijk[idx] *= MM_PER_INCH;
 80117cc:	f103 000e 	add.w	r0, r3, #14
 80117d0:	4937      	ldr	r1, [pc, #220]	; (80118b0 <gc_execute_block+0x24d0>)
 80117d2:	eb01 0180 	add.w	r1, r1, r0, lsl #2
 80117d6:	edd1 7a01 	vldr	s15, [r1, #4]
 80117da:	ed9f 7a38 	vldr	s14, [pc, #224]	; 80118bc <gc_execute_block+0x24dc>
 80117de:	ee67 7a87 	vmul.f32	s15, s15, s14
 80117e2:	edc1 7a01 	vstr	s15, [r1, #4]
 80117e6:	e7ea      	b.n	80117be <gc_execute_block+0x23de>
                        if(gc_state.modal.scaling_active) {
 80117e8:	4b32      	ldr	r3, [pc, #200]	; (80118b4 <gc_execute_block+0x24d4>)
 80117ea:	7f9b      	ldrb	r3, [r3, #30]
 80117ec:	b1d3      	cbz	r3, 8011824 <gc_execute_block+0x2444>
                            idx = 3;
 80117ee:	2103      	movs	r1, #3
 80117f0:	e000      	b.n	80117f4 <gc_execute_block+0x2414>
                            } while(idx);
 80117f2:	b1b9      	cbz	r1, 8011824 <gc_execute_block+0x2444>
                                if (ijk_words.mask & bit(--idx))
 80117f4:	3901      	subs	r1, #1
 80117f6:	fa22 f301 	lsr.w	r3, r2, r1
 80117fa:	f013 0f01 	tst.w	r3, #1
 80117fe:	d0f8      	beq.n	80117f2 <gc_execute_block+0x2412>
                                    gc_block.values.ijk[idx] *= scale_factor.ijk[idx];
 8011800:	1c88      	adds	r0, r1, #2
 8011802:	4b2f      	ldr	r3, [pc, #188]	; (80118c0 <gc_execute_block+0x24e0>)
 8011804:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 8011808:	ed93 7a01 	vldr	s14, [r3, #4]
 801180c:	f101 000e 	add.w	r0, r1, #14
 8011810:	4b27      	ldr	r3, [pc, #156]	; (80118b0 <gc_execute_block+0x24d0>)
 8011812:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 8011816:	edd3 7a01 	vldr	s15, [r3, #4]
 801181a:	ee67 7a87 	vmul.f32	s15, s15, s14
 801181e:	edc3 7a01 	vstr	s15, [r3, #4]
 8011822:	e7e6      	b.n	80117f2 <gc_execute_block+0x2412>
                        x -= gc_block.values.ijk[plane.axis_0]; // Delta x between circle center and target
 8011824:	4e22      	ldr	r6, [pc, #136]	; (80118b0 <gc_execute_block+0x24d0>)
 8011826:	f104 030e 	add.w	r3, r4, #14
 801182a:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 801182e:	edd3 9a01 	vldr	s19, [r3, #4]
 8011832:	ee79 7a69 	vsub.f32	s15, s18, s19
                        y -= gc_block.values.ijk[plane.axis_1]; // Delta y between circle center and target
 8011836:	f105 030e 	add.w	r3, r5, #14
 801183a:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 801183e:	edd3 8a01 	vldr	s17, [r3, #4]
 8011842:	ee38 8a68 	vsub.f32	s16, s16, s17
    return sqrtf(x * x + y * y);
 8011846:	ee28 8a08 	vmul.f32	s16, s16, s16
 801184a:	eeb0 0a48 	vmov.f32	s0, s16
 801184e:	ee07 0aa7 	vmla.f32	s0, s15, s15
 8011852:	f012 f8bd 	bl	80239d0 <sqrtf>
 8011856:	eeb0 8a40 	vmov.f32	s16, s0
 801185a:	ee68 8aa8 	vmul.f32	s17, s17, s17
 801185e:	eeb0 0a68 	vmov.f32	s0, s17
 8011862:	ee09 0aa9 	vmla.f32	s0, s19, s19
 8011866:	f012 f8b3 	bl	80239d0 <sqrtf>
                        gc_block.values.r = hypot_f(gc_block.values.ijk[plane.axis_0], gc_block.values.ijk[plane.axis_1]);
 801186a:	ed86 0a16 	vstr	s0, [r6, #88]	; 0x58
                        float delta_r = fabsf(target_r - gc_block.values.r);
 801186e:	ee78 7a40 	vsub.f32	s15, s16, s0
 8011872:	eef0 7ae7 	vabs.f32	s15, s15
                        if (delta_r > 0.005f) {
 8011876:	eddf 6a13 	vldr	s13, [pc, #76]	; 80118c4 <gc_execute_block+0x24e4>
 801187a:	eef4 7ae6 	vcmpe.f32	s15, s13
 801187e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011882:	f77f a9be 	ble.w	8010c02 <gc_execute_block+0x1822>
                            if (delta_r > 0.5f)
 8011886:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 801188a:	eef4 7ae6 	vcmpe.f32	s15, s13
 801188e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011892:	f301 81d0 	bgt.w	8012c36 <gc_execute_block+0x3856>
                            if (delta_r > (0.001f * gc_block.values.r))
 8011896:	eddf 6a0c 	vldr	s13, [pc, #48]	; 80118c8 <gc_execute_block+0x24e8>
 801189a:	ee20 7a26 	vmul.f32	s14, s0, s13
 801189e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80118a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80118a6:	f57f a9ac 	bpl.w	8010c02 <gc_execute_block+0x1822>
                                FAIL(Status_GcodeInvalidTarget); // [Arc definition error] > 0.005mm AND 0.1% radius
 80118aa:	2421      	movs	r4, #33	; 0x21
 80118ac:	f7fd be6e 	b.w	800f58c <gc_execute_block+0x1ac>
 80118b0:	20003298 	.word	0x20003298
 80118b4:	20003344 	.word	0x20003344
 80118b8:	200033a4 	.word	0x200033a4
 80118bc:	41cb3333 	.word	0x41cb3333
 80118c0:	200003e8 	.word	0x200003e8
 80118c4:	3ba3d70a 	.word	0x3ba3d70a
 80118c8:	3a83126f 	.word	0x3a83126f
                    if(gc_block.modal.plane_select != PlaneSelect_XY)
 80118cc:	4bb9      	ldr	r3, [pc, #740]	; (8011bb4 <gc_execute_block+0x27d4>)
 80118ce:	7b9b      	ldrb	r3, [r3, #14]
 80118d0:	2b00      	cmp	r3, #0
 80118d2:	f041 81b3 	bne.w	8012c3c <gc_execute_block+0x385c>
                    if (axis_words.mask & ~(bit(X_AXIS)|bit(Y_AXIS)))
 80118d6:	f01b 0ffc 	tst.w	fp, #252	; 0xfc
 80118da:	f041 81b2 	bne.w	8012c42 <gc_execute_block+0x3862>
                    if((gc_block.words.mask & pq_words.mask) != pq_words.mask)
 80118de:	4bb5      	ldr	r3, [pc, #724]	; (8011bb4 <gc_execute_block+0x27d4>)
 80118e0:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80118e4:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
 80118e8:	f5b2 3f40 	cmp.w	r2, #196608	; 0x30000
 80118ec:	f041 81ba 	bne.w	8012c64 <gc_execute_block+0x3884>
                    if(gc_parser_flags.motion_mode_changed && (gc_block.words.mask & ij_words.mask) != ij_words.mask)
 80118f0:	f418 7f00 	tst.w	r8, #512	; 0x200
 80118f4:	d004      	beq.n	8011900 <gc_execute_block+0x2520>
 80118f6:	f003 0330 	and.w	r3, r3, #48	; 0x30
 80118fa:	2b30      	cmp	r3, #48	; 0x30
 80118fc:	f041 81b5 	bne.w	8012c6a <gc_execute_block+0x388a>
                    if(!(gc_block.words.i || gc_block.words.j)) {
 8011900:	4bac      	ldr	r3, [pc, #688]	; (8011bb4 <gc_execute_block+0x27d4>)
 8011902:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 8011906:	f013 0f30 	tst.w	r3, #48	; 0x30
 801190a:	d151      	bne.n	80119b0 <gc_execute_block+0x25d0>
                        gc_block.values.ijk[I_VALUE] = - gc_block.values.p;
 801190c:	4ba9      	ldr	r3, [pc, #676]	; (8011bb4 <gc_execute_block+0x27d4>)
 801190e:	edd3 7a14 	vldr	s15, [r3, #80]	; 0x50
 8011912:	eef1 7a67 	vneg.f32	s15, s15
 8011916:	edc3 7a0f 	vstr	s15, [r3, #60]	; 0x3c
                        gc_block.values.ijk[J_VALUE] = - gc_block.values.q;
 801191a:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 801191e:	eef1 7a67 	vneg.f32	s15, s15
 8011922:	edc3 7a10 	vstr	s15, [r3, #64]	; 0x40
                    if (gc_block.modal.units_imperial) {
 8011926:	4ba3      	ldr	r3, [pc, #652]	; (8011bb4 <gc_execute_block+0x27d4>)
 8011928:	7adb      	ldrb	r3, [r3, #11]
 801192a:	b173      	cbz	r3, 801194a <gc_execute_block+0x256a>
                        gc_block.values.p *= MM_PER_INCH;
 801192c:	4ba1      	ldr	r3, [pc, #644]	; (8011bb4 <gc_execute_block+0x27d4>)
 801192e:	edd3 7a14 	vldr	s15, [r3, #80]	; 0x50
 8011932:	ed9f 7aa1 	vldr	s14, [pc, #644]	; 8011bb8 <gc_execute_block+0x27d8>
 8011936:	ee67 7a87 	vmul.f32	s15, s15, s14
 801193a:	edc3 7a14 	vstr	s15, [r3, #80]	; 0x50
                        gc_block.values.q *= MM_PER_INCH;
 801193e:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 8011942:	ee67 7a87 	vmul.f32	s15, s15, s14
 8011946:	edc3 7a15 	vstr	s15, [r3, #84]	; 0x54
                    if(gc_state.modal.scaling_active) {
 801194a:	4b9c      	ldr	r3, [pc, #624]	; (8011bbc <gc_execute_block+0x27dc>)
 801194c:	7f9b      	ldrb	r3, [r3, #30]
 801194e:	b18b      	cbz	r3, 8011974 <gc_execute_block+0x2594>
                        gc_block.values.p *= scale_factor.ijk[X_AXIS];
 8011950:	4a9b      	ldr	r2, [pc, #620]	; (8011bc0 <gc_execute_block+0x27e0>)
 8011952:	ed92 7a03 	vldr	s14, [r2, #12]
 8011956:	4b97      	ldr	r3, [pc, #604]	; (8011bb4 <gc_execute_block+0x27d4>)
 8011958:	edd3 7a14 	vldr	s15, [r3, #80]	; 0x50
 801195c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8011960:	edc3 7a14 	vstr	s15, [r3, #80]	; 0x50
                        gc_block.values.q *= scale_factor.ijk[Y_AXIS];
 8011964:	ed92 7a04 	vldr	s14, [r2, #16]
 8011968:	edd3 7a15 	vldr	s15, [r3, #84]	; 0x54
 801196c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8011970:	edc3 7a15 	vstr	s15, [r3, #84]	; 0x54
                    gc_state.modal.spline_pq[X_AXIS] = gc_block.values.p;
 8011974:	4b8f      	ldr	r3, [pc, #572]	; (8011bb4 <gc_execute_block+0x27d4>)
 8011976:	6d19      	ldr	r1, [r3, #80]	; 0x50
 8011978:	4a90      	ldr	r2, [pc, #576]	; (8011bbc <gc_execute_block+0x27dc>)
 801197a:	6211      	str	r1, [r2, #32]
                    gc_state.modal.spline_pq[Y_AXIS] = gc_block.values.q;
 801197c:	6d59      	ldr	r1, [r3, #84]	; 0x54
 801197e:	6251      	str	r1, [r2, #36]	; 0x24
                    gc_block.words.p = gc_block.words.q = gc_block.words.i = gc_block.words.j = Off;
 8011980:	f893 2094 	ldrb.w	r2, [r3, #148]	; 0x94
 8011984:	f36f 1245 	bfc	r2, #5, #1
 8011988:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
 801198c:	b2d2      	uxtb	r2, r2
 801198e:	f36f 1204 	bfc	r2, #4, #1
 8011992:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
 8011996:	f893 2096 	ldrb.w	r2, [r3, #150]	; 0x96
 801199a:	f36f 0241 	bfc	r2, #1, #1
 801199e:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
 80119a2:	b2d2      	uxtb	r2, r2
 80119a4:	f36f 0200 	bfc	r2, #0, #1
 80119a8:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
                    break;
 80119ac:	f7ff b929 	b.w	8010c02 <gc_execute_block+0x1822>
                        if (gc_block.modal.units_imperial) {
 80119b0:	4b80      	ldr	r3, [pc, #512]	; (8011bb4 <gc_execute_block+0x27d4>)
 80119b2:	7adb      	ldrb	r3, [r3, #11]
 80119b4:	b173      	cbz	r3, 80119d4 <gc_execute_block+0x25f4>
                            gc_block.values.ijk[I_VALUE] *= MM_PER_INCH;
 80119b6:	4b7f      	ldr	r3, [pc, #508]	; (8011bb4 <gc_execute_block+0x27d4>)
 80119b8:	edd3 7a0f 	vldr	s15, [r3, #60]	; 0x3c
 80119bc:	ed9f 7a7e 	vldr	s14, [pc, #504]	; 8011bb8 <gc_execute_block+0x27d8>
 80119c0:	ee67 7a87 	vmul.f32	s15, s15, s14
 80119c4:	edc3 7a0f 	vstr	s15, [r3, #60]	; 0x3c
                            gc_block.values.ijk[J_VALUE] *= MM_PER_INCH;
 80119c8:	edd3 7a10 	vldr	s15, [r3, #64]	; 0x40
 80119cc:	ee67 7a87 	vmul.f32	s15, s15, s14
 80119d0:	edc3 7a10 	vstr	s15, [r3, #64]	; 0x40
                        if(gc_state.modal.scaling_active) {
 80119d4:	4b79      	ldr	r3, [pc, #484]	; (8011bbc <gc_execute_block+0x27dc>)
 80119d6:	7f9b      	ldrb	r3, [r3, #30]
 80119d8:	2b00      	cmp	r3, #0
 80119da:	d0a4      	beq.n	8011926 <gc_execute_block+0x2546>
                            gc_block.values.ijk[I_VALUE] *= scale_factor.ijk[X_AXIS];
 80119dc:	4a78      	ldr	r2, [pc, #480]	; (8011bc0 <gc_execute_block+0x27e0>)
 80119de:	ed92 7a03 	vldr	s14, [r2, #12]
 80119e2:	4b74      	ldr	r3, [pc, #464]	; (8011bb4 <gc_execute_block+0x27d4>)
 80119e4:	edd3 7a0f 	vldr	s15, [r3, #60]	; 0x3c
 80119e8:	ee67 7a87 	vmul.f32	s15, s15, s14
 80119ec:	edc3 7a0f 	vstr	s15, [r3, #60]	; 0x3c
                            gc_block.values.ijk[J_VALUE] *= scale_factor.ijk[Y_AXIS];
 80119f0:	ed92 7a04 	vldr	s14, [r2, #16]
 80119f4:	edd3 7a10 	vldr	s15, [r3, #64]	; 0x40
 80119f8:	ee67 7a87 	vmul.f32	s15, s15, s14
 80119fc:	edc3 7a10 	vstr	s15, [r3, #64]	; 0x40
 8011a00:	e791      	b.n	8011926 <gc_execute_block+0x2546>
                    if(gc_block.modal.plane_select != PlaneSelect_XY)
 8011a02:	4b6c      	ldr	r3, [pc, #432]	; (8011bb4 <gc_execute_block+0x27d4>)
 8011a04:	7b9b      	ldrb	r3, [r3, #14]
 8011a06:	2b00      	cmp	r3, #0
 8011a08:	f041 8132 	bne.w	8012c70 <gc_execute_block+0x3890>
                    if (axis_words.mask & ~(bit(X_AXIS)|bit(Y_AXIS)))
 8011a0c:	f01b 0ffc 	tst.w	fp, #252	; 0xfc
 8011a10:	f041 8131 	bne.w	8012c76 <gc_execute_block+0x3896>
                    if((gc_block.words.mask & ij_words.mask) != ij_words.mask)
 8011a14:	4b67      	ldr	r3, [pc, #412]	; (8011bb4 <gc_execute_block+0x27d4>)
 8011a16:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8011a1a:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8011a1e:	2b30      	cmp	r3, #48	; 0x30
 8011a20:	f041 812c 	bne.w	8012c7c <gc_execute_block+0x389c>
                    if(gc_block.values.ijk[I_VALUE] == 0.0f && gc_block.values.ijk[I_VALUE] == 0.0f)
 8011a24:	4b63      	ldr	r3, [pc, #396]	; (8011bb4 <gc_execute_block+0x27d4>)
 8011a26:	edd3 7a0f 	vldr	s15, [r3, #60]	; 0x3c
 8011a2a:	eef5 7a40 	vcmp.f32	s15, #0.0
 8011a2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011a32:	f001 8126 	beq.w	8012c82 <gc_execute_block+0x38a2>
                    if (gc_block.modal.units_imperial) {
 8011a36:	7adb      	ldrb	r3, [r3, #11]
 8011a38:	b163      	cbz	r3, 8011a54 <gc_execute_block+0x2674>
                        gc_block.values.ijk[I_VALUE] *= MM_PER_INCH;
 8011a3a:	4b5e      	ldr	r3, [pc, #376]	; (8011bb4 <gc_execute_block+0x27d4>)
 8011a3c:	ed9f 7a5e 	vldr	s14, [pc, #376]	; 8011bb8 <gc_execute_block+0x27d8>
 8011a40:	ee67 7a87 	vmul.f32	s15, s15, s14
 8011a44:	edc3 7a0f 	vstr	s15, [r3, #60]	; 0x3c
                        gc_block.values.ijk[J_VALUE] *= MM_PER_INCH;
 8011a48:	edd3 7a10 	vldr	s15, [r3, #64]	; 0x40
 8011a4c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8011a50:	edc3 7a10 	vstr	s15, [r3, #64]	; 0x40
                    if(gc_state.modal.scaling_active) {
 8011a54:	4b59      	ldr	r3, [pc, #356]	; (8011bbc <gc_execute_block+0x27dc>)
 8011a56:	7f9b      	ldrb	r3, [r3, #30]
 8011a58:	b18b      	cbz	r3, 8011a7e <gc_execute_block+0x269e>
                        gc_block.values.ijk[I_VALUE] *= scale_factor.ijk[X_AXIS];
 8011a5a:	4a59      	ldr	r2, [pc, #356]	; (8011bc0 <gc_execute_block+0x27e0>)
 8011a5c:	ed92 7a03 	vldr	s14, [r2, #12]
 8011a60:	4b54      	ldr	r3, [pc, #336]	; (8011bb4 <gc_execute_block+0x27d4>)
 8011a62:	edd3 7a0f 	vldr	s15, [r3, #60]	; 0x3c
 8011a66:	ee67 7a87 	vmul.f32	s15, s15, s14
 8011a6a:	edc3 7a0f 	vstr	s15, [r3, #60]	; 0x3c
                        gc_block.values.ijk[J_VALUE] *= scale_factor.ijk[Y_AXIS];
 8011a6e:	ed92 7a04 	vldr	s14, [r2, #16]
 8011a72:	edd3 7a10 	vldr	s15, [r3, #64]	; 0x40
 8011a76:	ee67 7a87 	vmul.f32	s15, s15, s14
 8011a7a:	edc3 7a10 	vstr	s15, [r3, #64]	; 0x40
                    gc_block.words.i = gc_block.words.j = Off;
 8011a7e:	4b4d      	ldr	r3, [pc, #308]	; (8011bb4 <gc_execute_block+0x27d4>)
 8011a80:	f893 2094 	ldrb.w	r2, [r3, #148]	; 0x94
 8011a84:	f36f 1245 	bfc	r2, #5, #1
 8011a88:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
 8011a8c:	b2d2      	uxtb	r2, r2
 8011a8e:	f36f 1204 	bfc	r2, #4, #1
 8011a92:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
                    break;
 8011a96:	f7ff b8b4 	b.w	8010c02 <gc_execute_block+0x1822>
                    gc_parser_flags.probe_is_no_error = On;
 8011a9a:	f048 0810 	orr.w	r8, r8, #16
                    if(gc_block.modal.motion == MotionMode_ProbeAway || gc_block.modal.motion == MotionMode_ProbeAwayNoError)
 8011a9e:	f1a5 038e 	sub.w	r3, r5, #142	; 0x8e
 8011aa2:	b29b      	uxth	r3, r3
 8011aa4:	2b01      	cmp	r3, #1
 8011aa6:	d90f      	bls.n	8011ac8 <gc_execute_block+0x26e8>
                    if (!axis_words.mask)
 8011aa8:	fa5f f38b 	uxtb.w	r3, fp
 8011aac:	2b00      	cmp	r3, #0
 8011aae:	f001 80eb 	beq.w	8012c88 <gc_execute_block+0x38a8>
                    if (isequal_position_vector(gc_state.position, gc_block.values.xyz))
 8011ab2:	220c      	movs	r2, #12
 8011ab4:	4943      	ldr	r1, [pc, #268]	; (8011bc4 <gc_execute_block+0x27e4>)
 8011ab6:	4844      	ldr	r0, [pc, #272]	; (8011bc8 <gc_execute_block+0x27e8>)
 8011ab8:	f011 f84d 	bl	8022b56 <memcmp>
 8011abc:	2800      	cmp	r0, #0
 8011abe:	f47f a8a0 	bne.w	8010c02 <gc_execute_block+0x1822>
                        FAIL(Status_GcodeInvalidTarget); // [Invalid target]
 8011ac2:	2421      	movs	r4, #33	; 0x21
 8011ac4:	f7fd bd62 	b.w	800f58c <gc_execute_block+0x1ac>
                        gc_parser_flags.probe_is_away = On;
 8011ac8:	f048 0808 	orr.w	r8, r8, #8
 8011acc:	e7ec      	b.n	8011aa8 <gc_execute_block+0x26c8>
        gc_block.words.n = gc_block.words.f = gc_block.words.s = gc_block.words.t = Off;
 8011ace:	4b39      	ldr	r3, [pc, #228]	; (8011bb4 <gc_execute_block+0x27d4>)
 8011ad0:	f893 2096 	ldrb.w	r2, [r3, #150]	; 0x96
 8011ad4:	f36f 1204 	bfc	r2, #4, #1
 8011ad8:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
 8011adc:	b2d2      	uxtb	r2, r2
 8011ade:	f36f 02c3 	bfc	r2, #3, #1
 8011ae2:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
 8011ae6:	f893 2095 	ldrb.w	r2, [r3, #149]	; 0x95
 8011aea:	f36f 0241 	bfc	r2, #1, #1
 8011aee:	f883 2095 	strb.w	r2, [r3, #149]	; 0x95
 8011af2:	b2d2      	uxtb	r2, r2
 8011af4:	f36f 1286 	bfc	r2, #6, #1
 8011af8:	f883 2095 	strb.w	r2, [r3, #149]	; 0x95
 8011afc:	f7ff b891 	b.w	8010c22 <gc_execute_block+0x1842>
        plan_data.condition.is_rpm_rate_adjusted = gc_state.is_rpm_rate_adjusted || (gc_state.modal.spindle.state.ccw && gc_state.spindle.hal->cap.laser);
 8011b00:	2301      	movs	r3, #1
 8011b02:	f89d 205c 	ldrb.w	r2, [sp, #92]	; 0x5c
 8011b06:	f363 1286 	bfi	r2, r3, #6, #1
 8011b0a:	f88d 205c 	strb.w	r2, [sp, #92]	; 0x5c
        if ((status_code_t)(int_value = (uint_fast16_t)mc_jog_execute(&plan_data, &gc_block)) == Status_OK)
 8011b0e:	4929      	ldr	r1, [pc, #164]	; (8011bb4 <gc_execute_block+0x27d4>)
 8011b10:	a812      	add	r0, sp, #72	; 0x48
 8011b12:	f002 fe39 	bl	8014788 <mc_jog_execute>
 8011b16:	4604      	mov	r4, r0
 8011b18:	2800      	cmp	r0, #0
 8011b1a:	f47d ad37 	bne.w	800f58c <gc_execute_block+0x1ac>
            memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_state.position));
 8011b1e:	4b2a      	ldr	r3, [pc, #168]	; (8011bc8 <gc_execute_block+0x27e8>)
 8011b20:	4a28      	ldr	r2, [pc, #160]	; (8011bc4 <gc_execute_block+0x27e4>)
 8011b22:	ca07      	ldmia	r2, {r0, r1, r2}
 8011b24:	e883 0007 	stmia.w	r3, {r0, r1, r2}
        return (status_code_t)int_value;
 8011b28:	f7fd bd30 	b.w	800f58c <gc_execute_block+0x1ac>
        plan_data.condition.is_rpm_rate_adjusted = gc_state.is_rpm_rate_adjusted || (gc_state.modal.spindle.state.ccw && gc_state.spindle.hal->cap.laser);
 8011b2c:	2300      	movs	r3, #0
 8011b2e:	e7e8      	b.n	8011b02 <gc_execute_block+0x2722>
 8011b30:	2301      	movs	r3, #1
 8011b32:	e7e6      	b.n	8011b02 <gc_execute_block+0x2722>
    if(gc_state.spindle.hal->cap.laser) {
 8011b34:	4b21      	ldr	r3, [pc, #132]	; (8011bbc <gc_execute_block+0x27dc>)
 8011b36:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8011b38:	7a5b      	ldrb	r3, [r3, #9]
 8011b3a:	f013 0f08 	tst.w	r3, #8
 8011b3e:	d05b      	beq.n	8011bf8 <gc_execute_block+0x2818>
        if(!motion_is_lasercut(gc_block.modal.motion))
 8011b40:	4b1c      	ldr	r3, [pc, #112]	; (8011bb4 <gc_execute_block+0x27d4>)
 8011b42:	891b      	ldrh	r3, [r3, #8]
    return motion == MotionMode_Linear || motion == MotionMode_CwArc || motion == MotionMode_CcwArc || motion == MotionMode_CubicSpline || motion == MotionMode_QuadraticSpline;
 8011b44:	1e5a      	subs	r2, r3, #1
 8011b46:	b292      	uxth	r2, r2
 8011b48:	2a02      	cmp	r2, #2
 8011b4a:	d907      	bls.n	8011b5c <gc_execute_block+0x277c>
 8011b4c:	2b05      	cmp	r3, #5
 8011b4e:	d020      	beq.n	8011b92 <gc_execute_block+0x27b2>
 8011b50:	2b33      	cmp	r3, #51	; 0x33
 8011b52:	d001      	beq.n	8011b58 <gc_execute_block+0x2778>
 8011b54:	2300      	movs	r3, #0
 8011b56:	e002      	b.n	8011b5e <gc_execute_block+0x277e>
 8011b58:	2301      	movs	r3, #1
 8011b5a:	e000      	b.n	8011b5e <gc_execute_block+0x277e>
 8011b5c:	2301      	movs	r3, #1
        if(!motion_is_lasercut(gc_block.modal.motion))
 8011b5e:	b90b      	cbnz	r3, 8011b64 <gc_execute_block+0x2784>
            gc_parser_flags.laser_disable = On;
 8011b60:	f048 0840 	orr.w	r8, r8, #64	; 0x40
        if(axis_words.mask && (axis_command == AxisCommand_MotionMode))
 8011b64:	fa5f f38b 	uxtb.w	r3, fp
 8011b68:	b113      	cbz	r3, 8011b70 <gc_execute_block+0x2790>
 8011b6a:	f1ba 0f02 	cmp.w	sl, #2
 8011b6e:	d012      	beq.n	8011b96 <gc_execute_block+0x27b6>
        else if(gc_state.modal.spindle.state.on && !gc_state.modal.spindle.state.ccw) {
 8011b70:	4b12      	ldr	r3, [pc, #72]	; (8011bbc <gc_execute_block+0x27dc>)
 8011b72:	7e9b      	ldrb	r3, [r3, #26]
 8011b74:	f003 0303 	and.w	r3, r3, #3
 8011b78:	2b01      	cmp	r3, #1
 8011b7a:	d00f      	beq.n	8011b9c <gc_execute_block+0x27bc>
        gc_state.is_rpm_rate_adjusted = gc_state.modal.spindle.state.ccw && !gc_parser_flags.laser_disable;
 8011b7c:	4b0f      	ldr	r3, [pc, #60]	; (8011bbc <gc_execute_block+0x27dc>)
 8011b7e:	7e9b      	ldrb	r3, [r3, #26]
 8011b80:	f013 0f02 	tst.w	r3, #2
 8011b84:	d034      	beq.n	8011bf0 <gc_execute_block+0x2810>
 8011b86:	f018 0f40 	tst.w	r8, #64	; 0x40
 8011b8a:	f000 80ad 	beq.w	8011ce8 <gc_execute_block+0x2908>
 8011b8e:	2300      	movs	r3, #0
 8011b90:	e02f      	b.n	8011bf2 <gc_execute_block+0x2812>
    return motion == MotionMode_Linear || motion == MotionMode_CwArc || motion == MotionMode_CcwArc || motion == MotionMode_CubicSpline || motion == MotionMode_QuadraticSpline;
 8011b92:	2301      	movs	r3, #1
 8011b94:	e7e3      	b.n	8011b5e <gc_execute_block+0x277e>
            gc_parser_flags.laser_is_motion = On;
 8011b96:	f048 0880 	orr.w	r8, r8, #128	; 0x80
 8011b9a:	e7ef      	b.n	8011b7c <gc_execute_block+0x279c>
            if(motion_is_lasercut(gc_state.modal.motion)) {
 8011b9c:	4b07      	ldr	r3, [pc, #28]	; (8011bbc <gc_execute_block+0x27dc>)
 8011b9e:	881b      	ldrh	r3, [r3, #0]
    return motion == MotionMode_Linear || motion == MotionMode_CwArc || motion == MotionMode_CcwArc || motion == MotionMode_CubicSpline || motion == MotionMode_QuadraticSpline;
 8011ba0:	1e5a      	subs	r2, r3, #1
 8011ba2:	b292      	uxth	r2, r2
 8011ba4:	2a02      	cmp	r2, #2
 8011ba6:	d913      	bls.n	8011bd0 <gc_execute_block+0x27f0>
 8011ba8:	2b05      	cmp	r3, #5
 8011baa:	d019      	beq.n	8011be0 <gc_execute_block+0x2800>
 8011bac:	2b33      	cmp	r3, #51	; 0x33
 8011bae:	d00d      	beq.n	8011bcc <gc_execute_block+0x27ec>
 8011bb0:	2300      	movs	r3, #0
 8011bb2:	e00e      	b.n	8011bd2 <gc_execute_block+0x27f2>
 8011bb4:	20003298 	.word	0x20003298
 8011bb8:	41cb3333 	.word	0x41cb3333
 8011bbc:	20003344 	.word	0x20003344
 8011bc0:	200003e8 	.word	0x200003e8
 8011bc4:	200032f8 	.word	0x200032f8
 8011bc8:	200033a4 	.word	0x200033a4
 8011bcc:	2301      	movs	r3, #1
 8011bce:	e000      	b.n	8011bd2 <gc_execute_block+0x27f2>
 8011bd0:	2301      	movs	r3, #1
            if(motion_is_lasercut(gc_state.modal.motion)) {
 8011bd2:	b13b      	cbz	r3, 8011be4 <gc_execute_block+0x2804>
                if(gc_parser_flags.laser_disable)
 8011bd4:	f018 0f40 	tst.w	r8, #64	; 0x40
 8011bd8:	d0d0      	beq.n	8011b7c <gc_execute_block+0x279c>
                    gc_parser_flags.spindle_force_sync = On; // Change from G1/2/3 motion mode.
 8011bda:	f048 0820 	orr.w	r8, r8, #32
 8011bde:	e7cd      	b.n	8011b7c <gc_execute_block+0x279c>
    return motion == MotionMode_Linear || motion == MotionMode_CwArc || motion == MotionMode_CcwArc || motion == MotionMode_CubicSpline || motion == MotionMode_QuadraticSpline;
 8011be0:	2301      	movs	r3, #1
 8011be2:	e7f6      	b.n	8011bd2 <gc_execute_block+0x27f2>
            } else if(!gc_parser_flags.laser_disable) // When changing to a G1 motion mode without axis words from a non-G1/2/3 motion mode.
 8011be4:	f018 0f40 	tst.w	r8, #64	; 0x40
 8011be8:	d1c8      	bne.n	8011b7c <gc_execute_block+0x279c>
                gc_parser_flags.spindle_force_sync = On;
 8011bea:	f048 0820 	orr.w	r8, r8, #32
 8011bee:	e7c5      	b.n	8011b7c <gc_execute_block+0x279c>
        gc_state.is_rpm_rate_adjusted = gc_state.modal.spindle.state.ccw && !gc_parser_flags.laser_disable;
 8011bf0:	2300      	movs	r3, #0
 8011bf2:	4a92      	ldr	r2, [pc, #584]	; (8011e3c <gc_execute_block+0x2a5c>)
 8011bf4:	f882 3076 	strb.w	r3, [r2, #118]	; 0x76
    gc_state.line_number = gc_block.values.n;
 8011bf8:	4b91      	ldr	r3, [pc, #580]	; (8011e40 <gc_execute_block+0x2a60>)
 8011bfa:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8011bfe:	4a8f      	ldr	r2, [pc, #572]	; (8011e3c <gc_execute_block+0x2a5c>)
 8011c00:	66d3      	str	r3, [r2, #108]	; 0x6c
    plan_data.line_number = gc_state.line_number; // Record data for planner use.
 8011c02:	9319      	str	r3, [sp, #100]	; 0x64
    bool check_mode = state_get() == STATE_CHECK_MODE;
 8011c04:	f00c fcee 	bl	801e5e4 <state_get>
 8011c08:	9004      	str	r0, [sp, #16]
 8011c0a:	2802      	cmp	r0, #2
 8011c0c:	bf14      	ite	ne
 8011c0e:	2200      	movne	r2, #0
 8011c10:	2201      	moveq	r2, #1
 8011c12:	9209      	str	r2, [sp, #36]	; 0x24
    if(message && !check_mode && (plan_data.message = malloc(strlen(message) + 1)))
 8011c14:	9d21      	ldr	r5, [sp, #132]	; 0x84
 8011c16:	b10d      	cbz	r5, 8011c1c <gc_execute_block+0x283c>
 8011c18:	2802      	cmp	r0, #2
 8011c1a:	d167      	bne.n	8011cec <gc_execute_block+0x290c>
    gc_state.modal.feed_mode = gc_block.modal.feed_mode;
 8011c1c:	4b88      	ldr	r3, [pc, #544]	; (8011e40 <gc_execute_block+0x2a60>)
 8011c1e:	7a9b      	ldrb	r3, [r3, #10]
 8011c20:	4a86      	ldr	r2, [pc, #536]	; (8011e3c <gc_execute_block+0x2a5c>)
 8011c22:	7093      	strb	r3, [r2, #2]
    if (gc_state.modal.feed_mode == FeedMode_InverseTime)
 8011c24:	2b01      	cmp	r3, #1
 8011c26:	d06e      	beq.n	8011d06 <gc_execute_block+0x2926>
    gc_state.feed_rate = gc_block.values.f; // Always copy this value. See feed rate error-checking.
 8011c28:	4b85      	ldr	r3, [pc, #532]	; (8011e40 <gc_execute_block+0x2a60>)
 8011c2a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8011c2c:	4b83      	ldr	r3, [pc, #524]	; (8011e3c <gc_execute_block+0x2a5c>)
 8011c2e:	659a      	str	r2, [r3, #88]	; 0x58
    plan_data.feed_rate = gc_state.feed_rate; // Record data for planner use.
 8011c30:	9212      	str	r2, [sp, #72]	; 0x48
    if(gc_state.modal.spindle.rpm_mode == SpindleSpeedMode_CSS) {
 8011c32:	7edb      	ldrb	r3, [r3, #27]
 8011c34:	2b01      	cmp	r3, #1
 8011c36:	d06d      	beq.n	8011d14 <gc_execute_block+0x2934>
    if(!user_words.s && ((gc_state.spindle.rpm != gc_block.values.s) || gc_parser_flags.spindle_force_sync)) {
 8011c38:	4b82      	ldr	r3, [pc, #520]	; (8011e44 <gc_execute_block+0x2a64>)
 8011c3a:	789b      	ldrb	r3, [r3, #2]
 8011c3c:	f013 0f08 	tst.w	r3, #8
 8011c40:	d12e      	bne.n	8011ca0 <gc_execute_block+0x28c0>
 8011c42:	4b7e      	ldr	r3, [pc, #504]	; (8011e3c <gc_execute_block+0x2a5c>)
 8011c44:	edd3 7a12 	vldr	s15, [r3, #72]	; 0x48
 8011c48:	4b7d      	ldr	r3, [pc, #500]	; (8011e40 <gc_execute_block+0x2a60>)
 8011c4a:	ed93 0a17 	vldr	s0, [r3, #92]	; 0x5c
 8011c4e:	eef4 7a40 	vcmp.f32	s15, s0
 8011c52:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011c56:	d102      	bne.n	8011c5e <gc_execute_block+0x287e>
 8011c58:	f018 0f20 	tst.w	r8, #32
 8011c5c:	d020      	beq.n	8011ca0 <gc_execute_block+0x28c0>
        if(gc_state.modal.spindle.state.on && !gc_parser_flags.laser_is_motion) {
 8011c5e:	4b77      	ldr	r3, [pc, #476]	; (8011e3c <gc_execute_block+0x2a5c>)
 8011c60:	7e9b      	ldrb	r3, [r3, #26]
 8011c62:	f013 0f01 	tst.w	r3, #1
 8011c66:	d017      	beq.n	8011c98 <gc_execute_block+0x28b8>
 8011c68:	fa5f f288 	uxtb.w	r2, r8
 8011c6c:	f018 0f80 	tst.w	r8, #128	; 0x80
 8011c70:	d112      	bne.n	8011c98 <gc_execute_block+0x28b8>
            if(gc_block.spindle) {
 8011c72:	4b73      	ldr	r3, [pc, #460]	; (8011e40 <gc_execute_block+0x2a60>)
 8011c74:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 8011c78:	b173      	cbz	r3, 8011c98 <gc_execute_block+0x28b8>
                gc_block.spindle->param->rpm = gc_block.values.s;
 8011c7a:	685b      	ldr	r3, [r3, #4]
 8011c7c:	ed83 0a00 	vstr	s0, [r3]
                spindle_sync(gc_block.spindle, gc_state.modal.spindle.state, gc_parser_flags.laser_disable ? 0.0f : gc_block.values.s);
 8011c80:	4b6f      	ldr	r3, [pc, #444]	; (8011e40 <gc_execute_block+0x2a60>)
 8011c82:	f8d3 00a8 	ldr.w	r0, [r3, #168]	; 0xa8
 8011c86:	f012 0f40 	tst.w	r2, #64	; 0x40
 8011c8a:	d001      	beq.n	8011c90 <gc_execute_block+0x28b0>
 8011c8c:	ed9f 0a6e 	vldr	s0, [pc, #440]	; 8011e48 <gc_execute_block+0x2a68>
 8011c90:	4b6a      	ldr	r3, [pc, #424]	; (8011e3c <gc_execute_block+0x2a5c>)
 8011c92:	7e99      	ldrb	r1, [r3, #26]
 8011c94:	f00b ffa2 	bl	801dbdc <spindle_sync>
        gc_state.spindle.rpm = gc_block.values.s; // Update spindle speed state.
 8011c98:	4b69      	ldr	r3, [pc, #420]	; (8011e40 <gc_execute_block+0x2a60>)
 8011c9a:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8011c9c:	4b67      	ldr	r3, [pc, #412]	; (8011e3c <gc_execute_block+0x2a5c>)
 8011c9e:	649a      	str	r2, [r3, #72]	; 0x48
    if (!gc_parser_flags.laser_disable)
 8011ca0:	f018 0f40 	tst.w	r8, #64	; 0x40
 8011ca4:	f040 8081 	bne.w	8011daa <gc_execute_block+0x29ca>
        memcpy(&plan_data.spindle, &gc_state.spindle, sizeof(spindle_t)); // Record data for planner use.
 8011ca8:	ad13      	add	r5, sp, #76	; 0x4c
 8011caa:	4b68      	ldr	r3, [pc, #416]	; (8011e4c <gc_execute_block+0x2a6c>)
 8011cac:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8011cae:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
    if(gc_state.tool_pending != gc_block.values.t && !check_mode) {
 8011cb2:	4b62      	ldr	r3, [pc, #392]	; (8011e3c <gc_execute_block+0x2a5c>)
 8011cb4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8011cb6:	4a62      	ldr	r2, [pc, #392]	; (8011e40 <gc_execute_block+0x2a60>)
 8011cb8:	f8d2 008c 	ldr.w	r0, [r2, #140]	; 0x8c
 8011cbc:	4283      	cmp	r3, r0
 8011cbe:	d002      	beq.n	8011cc6 <gc_execute_block+0x28e6>
 8011cc0:	9b04      	ldr	r3, [sp, #16]
 8011cc2:	2b02      	cmp	r3, #2
 8011cc4:	d175      	bne.n	8011db2 <gc_execute_block+0x29d2>
    if(port_command) {
 8011cc6:	9b05      	ldr	r3, [sp, #20]
 8011cc8:	2b00      	cmp	r3, #0
 8011cca:	f000 80cc 	beq.w	8011e66 <gc_execute_block+0x2a86>
        switch(port_command) {
 8011cce:	3b3e      	subs	r3, #62	; 0x3e
 8011cd0:	2b06      	cmp	r3, #6
 8011cd2:	f200 80c8 	bhi.w	8011e66 <gc_execute_block+0x2a86>
 8011cd6:	e8df f013 	tbh	[pc, r3, lsl #1]
 8011cda:	00c3      	.short	0x00c3
 8011cdc:	011400c3 	.word	0x011400c3
 8011ce0:	01270114 	.word	0x01270114
 8011ce4:	013f013b 	.word	0x013f013b
        gc_state.is_rpm_rate_adjusted = gc_state.modal.spindle.state.ccw && !gc_parser_flags.laser_disable;
 8011ce8:	2301      	movs	r3, #1
 8011cea:	e782      	b.n	8011bf2 <gc_execute_block+0x2812>
    if(message && !check_mode && (plan_data.message = malloc(strlen(message) + 1)))
 8011cec:	4628      	mov	r0, r5
 8011cee:	f7f6 f9b1 	bl	8008054 <strlen>
 8011cf2:	3001      	adds	r0, #1
 8011cf4:	f010 fbdc 	bl	80224b0 <malloc>
 8011cf8:	901a      	str	r0, [sp, #104]	; 0x68
 8011cfa:	2800      	cmp	r0, #0
 8011cfc:	d08e      	beq.n	8011c1c <gc_execute_block+0x283c>
        strcpy(plan_data.message, message);
 8011cfe:	4629      	mov	r1, r5
 8011d00:	f011 f88e 	bl	8022e20 <strcpy>
 8011d04:	e78a      	b.n	8011c1c <gc_execute_block+0x283c>
        plan_data.condition.inverse_time = On; // Set condition flag for planner use.
 8011d06:	f89d 305c 	ldrb.w	r3, [sp, #92]	; 0x5c
 8011d0a:	f043 0320 	orr.w	r3, r3, #32
 8011d0e:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
 8011d12:	e789      	b.n	8011c28 <gc_execute_block+0x2848>
        if(gc_block.modal.motion != MotionMode_None && gc_block.modal.motion != MotionMode_Seek) {
 8011d14:	4b4a      	ldr	r3, [pc, #296]	; (8011e40 <gc_execute_block+0x2a60>)
 8011d16:	891b      	ldrh	r3, [r3, #8]
 8011d18:	2b50      	cmp	r3, #80	; 0x50
 8011d1a:	d039      	beq.n	8011d90 <gc_execute_block+0x29b0>
 8011d1c:	2b00      	cmp	r3, #0
 8011d1e:	d037      	beq.n	8011d90 <gc_execute_block+0x29b0>
            gc_state.spindle.css = &gc_state.spindle.hal->param->css;
 8011d20:	4d46      	ldr	r5, [pc, #280]	; (8011e3c <gc_execute_block+0x2a5c>)
 8011d22:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8011d24:	685b      	ldr	r3, [r3, #4]
 8011d26:	3310      	adds	r3, #16
 8011d28:	652b      	str	r3, [r5, #80]	; 0x50
            gc_state.spindle.css->axis = plane.axis_1;
 8011d2a:	f89d 2081 	ldrb.w	r2, [sp, #129]	; 0x81
 8011d2e:	615a      	str	r2, [r3, #20]
            gc_state.spindle.css->tool_offset = gc_get_offset(gc_state.spindle.css->axis);
 8011d30:	6d2e      	ldr	r6, [r5, #80]	; 0x50
 8011d32:	6970      	ldr	r0, [r6, #20]
 8011d34:	f7fd f972 	bl	800f01c <gc_get_offset>
 8011d38:	ed86 0a04 	vstr	s0, [r6, #16]
            float pos = gc_state.position[gc_state.spindle.css->axis] - gc_state.spindle.css->tool_offset;
 8011d3c:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 8011d3e:	695a      	ldr	r2, [r3, #20]
 8011d40:	3218      	adds	r2, #24
 8011d42:	eb05 0582 	add.w	r5, r5, r2, lsl #2
 8011d46:	edd5 7a00 	vldr	s15, [r5]
 8011d4a:	ed93 7a04 	vldr	s14, [r3, #16]
 8011d4e:	ee77 7ac7 	vsub.f32	s15, s15, s14
            gc_block.values.s = pos <= 0.0f ? gc_state.spindle.css->max_rpm : min(gc_state.spindle.css->max_rpm, gc_state.spindle.css->surface_speed / (pos * (float)(2.0f * M_PI)));
 8011d52:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8011d56:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011d5a:	d911      	bls.n	8011d80 <gc_execute_block+0x29a0>
 8011d5c:	edd3 6a03 	vldr	s13, [r3, #12]
 8011d60:	ed93 6a00 	vldr	s12, [r3]
 8011d64:	ed9f 7a3a 	vldr	s14, [pc, #232]	; 8011e50 <gc_execute_block+0x2a70>
 8011d68:	ee67 7a87 	vmul.f32	s15, s15, s14
 8011d6c:	ee86 7a27 	vdiv.f32	s14, s12, s15
 8011d70:	eef4 6ac7 	vcmpe.f32	s13, s14
 8011d74:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011d78:	d504      	bpl.n	8011d84 <gc_execute_block+0x29a4>
 8011d7a:	eeb0 7a66 	vmov.f32	s14, s13
 8011d7e:	e001      	b.n	8011d84 <gc_execute_block+0x29a4>
 8011d80:	ed93 7a03 	vldr	s14, [r3, #12]
 8011d84:	4b2e      	ldr	r3, [pc, #184]	; (8011e40 <gc_execute_block+0x2a60>)
 8011d86:	ed83 7a17 	vstr	s14, [r3, #92]	; 0x5c
            gc_parser_flags.spindle_force_sync = On;
 8011d8a:	f048 0820 	orr.w	r8, r8, #32
        if(gc_block.modal.motion != MotionMode_None && gc_block.modal.motion != MotionMode_Seek) {
 8011d8e:	e753      	b.n	8011c38 <gc_execute_block+0x2858>
            if(gc_state.spindle.css) {
 8011d90:	4b2a      	ldr	r3, [pc, #168]	; (8011e3c <gc_execute_block+0x2a5c>)
 8011d92:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8011d94:	b123      	cbz	r3, 8011da0 <gc_execute_block+0x29c0>
                gc_state.spindle.css = NULL;
 8011d96:	4b29      	ldr	r3, [pc, #164]	; (8011e3c <gc_execute_block+0x2a5c>)
 8011d98:	2200      	movs	r2, #0
 8011d9a:	651a      	str	r2, [r3, #80]	; 0x50
                protocol_buffer_synchronize(); // Empty planner buffer to ensure we get RPM at end of last CSS motion
 8011d9c:	f005 ff1c 	bl	8017bd8 <protocol_buffer_synchronize>
            gc_block.values.s = gc_state.spindle.rpm; //gc_state.spindle.hal->param->rpm; // Keep current RPM
 8011da0:	4b26      	ldr	r3, [pc, #152]	; (8011e3c <gc_execute_block+0x2a5c>)
 8011da2:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8011da4:	4b26      	ldr	r3, [pc, #152]	; (8011e40 <gc_execute_block+0x2a60>)
 8011da6:	65da      	str	r2, [r3, #92]	; 0x5c
 8011da8:	e746      	b.n	8011c38 <gc_execute_block+0x2858>
        plan_data.spindle.hal = gc_state.spindle.hal;
 8011daa:	4b24      	ldr	r3, [pc, #144]	; (8011e3c <gc_execute_block+0x2a5c>)
 8011dac:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8011dae:	9316      	str	r3, [sp, #88]	; 0x58
 8011db0:	e77f      	b.n	8011cb2 <gc_execute_block+0x28d2>
        tool_data_t *pending_tool = tool_get_pending((gc_state.tool_pending = gc_block.values.t));
 8011db2:	4b22      	ldr	r3, [pc, #136]	; (8011e3c <gc_execute_block+0x2a5c>)
 8011db4:	6718      	str	r0, [r3, #112]	; 0x70
 8011db6:	f7fd f8b1 	bl	800ef1c <tool_get_pending>
 8011dba:	9008      	str	r0, [sp, #32]
        if(set_tool || settings.tool_change.mode == ToolChange_Ignore || !(hal.stream.suspend_read || hal.tool.change)) {
 8011dbc:	9b06      	ldr	r3, [sp, #24]
 8011dbe:	b963      	cbnz	r3, 8011dda <gc_execute_block+0x29fa>
 8011dc0:	4b24      	ldr	r3, [pc, #144]	; (8011e54 <gc_execute_block+0x2a74>)
 8011dc2:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8011dc6:	2b04      	cmp	r3, #4
 8011dc8:	d007      	beq.n	8011dda <gc_execute_block+0x29fa>
 8011dca:	4b23      	ldr	r3, [pc, #140]	; (8011e58 <gc_execute_block+0x2a78>)
 8011dcc:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 8011dd0:	bb2b      	cbnz	r3, 8011e1e <gc_execute_block+0x2a3e>
 8011dd2:	4b21      	ldr	r3, [pc, #132]	; (8011e58 <gc_execute_block+0x2a78>)
 8011dd4:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 8011dd8:	bb0b      	cbnz	r3, 8011e1e <gc_execute_block+0x2a3e>
    gc_state.tool->tool_id = tool->tool_id;
 8011dda:	4b18      	ldr	r3, [pc, #96]	; (8011e3c <gc_execute_block+0x2a5c>)
 8011ddc:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8011de0:	9a08      	ldr	r2, [sp, #32]
 8011de2:	6912      	ldr	r2, [r2, #16]
 8011de4:	611a      	str	r2, [r3, #16]
            if(grbl.on_tool_selected) {
 8011de6:	4b1d      	ldr	r3, [pc, #116]	; (8011e5c <gc_execute_block+0x2a7c>)
 8011de8:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8011dec:	b163      	cbz	r3, 8011e08 <gc_execute_block+0x2a28>
                spindle_state_t state = gc_state.modal.spindle.state;
 8011dee:	4d13      	ldr	r5, [pc, #76]	; (8011e3c <gc_execute_block+0x2a5c>)
 8011df0:	7eae      	ldrb	r6, [r5, #26]
                grbl.on_tool_selected(gc_state.tool);
 8011df2:	f8d5 0094 	ldr.w	r0, [r5, #148]	; 0x94
 8011df6:	4798      	blx	r3
                if(state.value != gc_state.modal.spindle.state.value)
 8011df8:	b2f6      	uxtb	r6, r6
 8011dfa:	7eab      	ldrb	r3, [r5, #26]
 8011dfc:	429e      	cmp	r6, r3
 8011dfe:	d003      	beq.n	8011e08 <gc_execute_block+0x2a28>
                    gc_block.modal.spindle.state = gc_state.modal.spindle.state;
 8011e00:	7eaa      	ldrb	r2, [r5, #26]
 8011e02:	4b0f      	ldr	r3, [pc, #60]	; (8011e40 <gc_execute_block+0x2a60>)
 8011e04:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
            if(grbl.on_tool_changed)
 8011e08:	4b14      	ldr	r3, [pc, #80]	; (8011e5c <gc_execute_block+0x2a7c>)
 8011e0a:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8011e0e:	b11b      	cbz	r3, 8011e18 <gc_execute_block+0x2a38>
                grbl.on_tool_changed(gc_state.tool);
 8011e10:	4a0a      	ldr	r2, [pc, #40]	; (8011e3c <gc_execute_block+0x2a5c>)
 8011e12:	f8d2 0094 	ldr.w	r0, [r2, #148]	; 0x94
 8011e16:	4798      	blx	r3
            system_add_rt_report(Report_Tool);
 8011e18:	2080      	movs	r0, #128	; 0x80
 8011e1a:	f00f fa11 	bl	8021240 <system_add_rt_report>
        if(hal.tool.select)
 8011e1e:	4b0e      	ldr	r3, [pc, #56]	; (8011e58 <gc_execute_block+0x2a78>)
 8011e20:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8011e24:	b12b      	cbz	r3, 8011e32 <gc_execute_block+0x2a52>
            hal.tool.select(pending_tool, !set_tool);
 8011e26:	9a06      	ldr	r2, [sp, #24]
 8011e28:	f082 0101 	eor.w	r1, r2, #1
 8011e2c:	9808      	ldr	r0, [sp, #32]
 8011e2e:	4798      	blx	r3
 8011e30:	e749      	b.n	8011cc6 <gc_execute_block+0x28e6>
            system_add_rt_report(Report_Tool);
 8011e32:	2080      	movs	r0, #128	; 0x80
 8011e34:	f00f fa04 	bl	8021240 <system_add_rt_report>
 8011e38:	e745      	b.n	8011cc6 <gc_execute_block+0x28e6>
 8011e3a:	bf00      	nop
 8011e3c:	20003344 	.word	0x20003344
 8011e40:	20003298 	.word	0x20003298
 8011e44:	20003438 	.word	0x20003438
 8011e48:	00000000 	.word	0x00000000
 8011e4c:	2000338c 	.word	0x2000338c
 8011e50:	40c90fdb 	.word	0x40c90fdb
 8011e54:	20003b14 	.word	0x20003b14
 8011e58:	2000350c 	.word	0x2000350c
 8011e5c:	2000343c 	.word	0x2000343c
                add_output_command(&gc_block.output_command);
 8011e60:	487f      	ldr	r0, [pc, #508]	; (8012060 <gc_execute_block+0x2c80>)
 8011e62:	f7fd f83d 	bl	800eee0 <add_output_command>
    if (command_words.M6 && !set_tool && !check_mode) {
 8011e66:	f019 0f01 	tst.w	r9, #1
 8011e6a:	d004      	beq.n	8011e76 <gc_execute_block+0x2a96>
 8011e6c:	9b06      	ldr	r3, [sp, #24]
 8011e6e:	b913      	cbnz	r3, 8011e76 <gc_execute_block+0x2a96>
 8011e70:	9b04      	ldr	r3, [sp, #16]
 8011e72:	2b02      	cmp	r3, #2
 8011e74:	d17c      	bne.n	8011f70 <gc_execute_block+0x2b90>
    if (gc_state.modal.spindle.state.value != gc_block.modal.spindle.state.value) {
 8011e76:	4b7b      	ldr	r3, [pc, #492]	; (8012064 <gc_execute_block+0x2c84>)
 8011e78:	7e9a      	ldrb	r2, [r3, #26]
 8011e7a:	4b7b      	ldr	r3, [pc, #492]	; (8012068 <gc_execute_block+0x2c88>)
 8011e7c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8011e80:	429a      	cmp	r2, r3
 8011e82:	d01b      	beq.n	8011ebc <gc_execute_block+0x2adc>
        if(gc_block.spindle) {
 8011e84:	4b78      	ldr	r3, [pc, #480]	; (8012068 <gc_execute_block+0x2c88>)
 8011e86:	f8d3 00a8 	ldr.w	r0, [r3, #168]	; 0xa8
 8011e8a:	2800      	cmp	r0, #0
 8011e8c:	f000 80cc 	beq.w	8012028 <gc_execute_block+0x2c48>
            if((spindle_programmed = spindle_sync(gc_block.spindle, gc_block.modal.spindle.state, plan_data.spindle.rpm)))
 8011e90:	ed9d 0a13 	vldr	s0, [sp, #76]	; 0x4c
 8011e94:	f893 1022 	ldrb.w	r1, [r3, #34]	; 0x22
 8011e98:	f00b fea0 	bl	801dbdc <spindle_sync>
 8011e9c:	9007      	str	r0, [sp, #28]
 8011e9e:	b130      	cbz	r0, 8011eae <gc_execute_block+0x2ace>
                gc_block.spindle->param->state = gc_block.modal.spindle.state;
 8011ea0:	4b71      	ldr	r3, [pc, #452]	; (8012068 <gc_execute_block+0x2c88>)
 8011ea2:	f8d3 20a8 	ldr.w	r2, [r3, #168]	; 0xa8
 8011ea6:	6852      	ldr	r2, [r2, #4]
 8011ea8:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8011eac:	7213      	strb	r3, [r2, #8]
        if(spindle_programmed)
 8011eae:	9b07      	ldr	r3, [sp, #28]
 8011eb0:	b123      	cbz	r3, 8011ebc <gc_execute_block+0x2adc>
            gc_state.modal.spindle.state = gc_block.modal.spindle.state;
 8011eb2:	4b6d      	ldr	r3, [pc, #436]	; (8012068 <gc_execute_block+0x2c88>)
 8011eb4:	f893 2022 	ldrb.w	r2, [r3, #34]	; 0x22
 8011eb8:	4b6a      	ldr	r3, [pc, #424]	; (8012064 <gc_execute_block+0x2c84>)
 8011eba:	769a      	strb	r2, [r3, #26]
    if(spindle_programmed && grbl.on_spindle_programmed)
 8011ebc:	9b07      	ldr	r3, [sp, #28]
 8011ebe:	b14b      	cbz	r3, 8011ed4 <gc_execute_block+0x2af4>
 8011ec0:	4b6a      	ldr	r3, [pc, #424]	; (801206c <gc_execute_block+0x2c8c>)
 8011ec2:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 8011ec4:	b135      	cbz	r5, 8011ed4 <gc_execute_block+0x2af4>
        grbl.on_spindle_programmed(gc_state.spindle.hal, gc_state.modal.spindle.state, gc_state.spindle.rpm, gc_state.modal.spindle.rpm_mode);
 8011ec6:	4b67      	ldr	r3, [pc, #412]	; (8012064 <gc_execute_block+0x2c84>)
 8011ec8:	7eda      	ldrb	r2, [r3, #27]
 8011eca:	ed93 0a12 	vldr	s0, [r3, #72]	; 0x48
 8011ece:	7e99      	ldrb	r1, [r3, #26]
 8011ed0:	6d58      	ldr	r0, [r3, #84]	; 0x54
 8011ed2:	47a8      	blx	r5
    plan_data.spindle.state = gc_state.modal.spindle.state; // Set condition flag for planner use.
 8011ed4:	4b63      	ldr	r3, [pc, #396]	; (8012064 <gc_execute_block+0x2c84>)
 8011ed6:	7e9a      	ldrb	r2, [r3, #26]
 8011ed8:	f88d 2050 	strb.w	r2, [sp, #80]	; 0x50
    plan_data.condition.is_rpm_rate_adjusted = gc_state.is_rpm_rate_adjusted;
 8011edc:	f893 3076 	ldrb.w	r3, [r3, #118]	; 0x76
 8011ee0:	f89d 205c 	ldrb.w	r2, [sp, #92]	; 0x5c
 8011ee4:	f363 1286 	bfi	r2, r3, #6, #1
 8011ee8:	f88d 205c 	strb.w	r2, [sp, #92]	; 0x5c
    plan_data.condition.is_laser_ppi_mode = gc_state.is_rpm_rate_adjusted && gc_state.is_laser_ppi_mode;
 8011eec:	2b00      	cmp	r3, #0
 8011eee:	f000 80c5 	beq.w	801207c <gc_execute_block+0x2c9c>
 8011ef2:	4b5c      	ldr	r3, [pc, #368]	; (8012064 <gc_execute_block+0x2c84>)
 8011ef4:	f893 3075 	ldrb.w	r3, [r3, #117]	; 0x75
 8011ef8:	2b00      	cmp	r3, #0
 8011efa:	f000 80c0 	beq.w	801207e <gc_execute_block+0x2c9e>
 8011efe:	2301      	movs	r3, #1
 8011f00:	e0bd      	b.n	801207e <gc_execute_block+0x2c9e>
                hal.port.digital_out(gc_block.output_command.port, gc_block.output_command.value != 0.0f);
 8011f02:	4b5b      	ldr	r3, [pc, #364]	; (8012070 <gc_execute_block+0x2c90>)
 8011f04:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8011f08:	4b57      	ldr	r3, [pc, #348]	; (8012068 <gc_execute_block+0x2c88>)
 8011f0a:	edd3 7a27 	vldr	s15, [r3, #156]	; 0x9c
 8011f0e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8011f12:	eef5 7a40 	vcmp.f32	s15, #0.0
 8011f16:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011f1a:	bf14      	ite	ne
 8011f1c:	2101      	movne	r1, #1
 8011f1e:	2100      	moveq	r1, #0
 8011f20:	f893 009a 	ldrb.w	r0, [r3, #154]	; 0x9a
 8011f24:	4790      	blx	r2
                break;
 8011f26:	e79e      	b.n	8011e66 <gc_execute_block+0x2a86>
                sys.var5399 = hal.port.wait_on_input((io_port_type_t)gc_block.output_command.is_digital, gc_block.output_command.port, (wait_mode_t)gc_block.values.l, gc_block.values.q);
 8011f28:	4b51      	ldr	r3, [pc, #324]	; (8012070 <gc_execute_block+0x2c90>)
 8011f2a:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
 8011f2e:	484e      	ldr	r0, [pc, #312]	; (8012068 <gc_execute_block+0x2c88>)
 8011f30:	ed90 0a15 	vldr	s0, [r0, #84]	; 0x54
 8011f34:	f890 2090 	ldrb.w	r2, [r0, #144]	; 0x90
 8011f38:	f890 109a 	ldrb.w	r1, [r0, #154]	; 0x9a
 8011f3c:	f890 0098 	ldrb.w	r0, [r0, #152]	; 0x98
 8011f40:	4798      	blx	r3
 8011f42:	4b4c      	ldr	r3, [pc, #304]	; (8012074 <gc_execute_block+0x2c94>)
 8011f44:	6518      	str	r0, [r3, #80]	; 0x50
                system_add_rt_report(Report_M66Result);
 8011f46:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8011f4a:	f00f f979 	bl	8021240 <system_add_rt_report>
                break;
 8011f4e:	e78a      	b.n	8011e66 <gc_execute_block+0x2a86>
                add_output_command(&gc_block.output_command);
 8011f50:	4843      	ldr	r0, [pc, #268]	; (8012060 <gc_execute_block+0x2c80>)
 8011f52:	f7fc ffc5 	bl	800eee0 <add_output_command>
                break;
 8011f56:	e786      	b.n	8011e66 <gc_execute_block+0x2a86>
                hal.port.analog_out(gc_block.output_command.port, gc_block.output_command.value);
 8011f58:	4b45      	ldr	r3, [pc, #276]	; (8012070 <gc_execute_block+0x2c90>)
 8011f5a:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
 8011f5e:	4b42      	ldr	r3, [pc, #264]	; (8012068 <gc_execute_block+0x2c88>)
 8011f60:	edd3 7a27 	vldr	s15, [r3, #156]	; 0x9c
 8011f64:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
 8011f68:	f893 009a 	ldrb.w	r0, [r3, #154]	; 0x9a
 8011f6c:	4790      	blx	r2
                break;
 8011f6e:	e77a      	b.n	8011e66 <gc_execute_block+0x2a86>
        tool_data_t *pending_tool = tool_get_pending(gc_state.tool_pending);
 8011f70:	4b3c      	ldr	r3, [pc, #240]	; (8012064 <gc_execute_block+0x2c84>)
 8011f72:	6f18      	ldr	r0, [r3, #112]	; 0x70
 8011f74:	f7fc ffd2 	bl	800ef1c <tool_get_pending>
 8011f78:	4605      	mov	r5, r0
        protocol_buffer_synchronize();
 8011f7a:	f005 fe2d 	bl	8017bd8 <protocol_buffer_synchronize>
        if(plan_data.message) {
 8011f7e:	981a      	ldr	r0, [sp, #104]	; 0x68
 8011f80:	b118      	cbz	r0, 8011f8a <gc_execute_block+0x2baa>
            output_message(plan_data.message);
 8011f82:	f7fc ffe3 	bl	800ef4c <output_message>
            plan_data.message = NULL;
 8011f86:	2300      	movs	r3, #0
 8011f88:	931a      	str	r3, [sp, #104]	; 0x68
        if(pending_tool->tool_id != gc_state.tool->tool_id) {
 8011f8a:	692a      	ldr	r2, [r5, #16]
 8011f8c:	4b35      	ldr	r3, [pc, #212]	; (8012064 <gc_execute_block+0x2c84>)
 8011f8e:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8011f92:	691b      	ldr	r3, [r3, #16]
 8011f94:	429a      	cmp	r2, r3
 8011f96:	f43f af6e 	beq.w	8011e76 <gc_execute_block+0x2a96>
            if(grbl.on_tool_selected) {
 8011f9a:	4b34      	ldr	r3, [pc, #208]	; (801206c <gc_execute_block+0x2c8c>)
 8011f9c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8011fa0:	b17b      	cbz	r3, 8011fc2 <gc_execute_block+0x2be2>
                spindle_state_t state = gc_state.modal.spindle.state;
 8011fa2:	f8df 90c0 	ldr.w	r9, [pc, #192]	; 8012064 <gc_execute_block+0x2c84>
 8011fa6:	f899 601a 	ldrb.w	r6, [r9, #26]
                grbl.on_tool_selected(pending_tool);
 8011faa:	4628      	mov	r0, r5
 8011fac:	4798      	blx	r3
                if(state.value != gc_state.modal.spindle.state.value)
 8011fae:	b2f6      	uxtb	r6, r6
 8011fb0:	f899 301a 	ldrb.w	r3, [r9, #26]
 8011fb4:	429e      	cmp	r6, r3
 8011fb6:	d004      	beq.n	8011fc2 <gc_execute_block+0x2be2>
                    gc_block.modal.spindle.state = gc_state.modal.spindle.state;
 8011fb8:	f899 201a 	ldrb.w	r2, [r9, #26]
 8011fbc:	4b2a      	ldr	r3, [pc, #168]	; (8012068 <gc_execute_block+0x2c88>)
 8011fbe:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
            if(hal.tool.change) { // ATC
 8011fc2:	4b2b      	ldr	r3, [pc, #172]	; (8012070 <gc_execute_block+0x2c90>)
 8011fc4:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 8011fc8:	b30b      	cbz	r3, 801200e <gc_execute_block+0x2c2e>
                if((int_value = (uint_fast16_t)hal.tool.change(&gc_state)) != Status_OK) {
 8011fca:	4826      	ldr	r0, [pc, #152]	; (8012064 <gc_execute_block+0x2c84>)
 8011fcc:	4798      	blx	r3
 8011fce:	b110      	cbz	r0, 8011fd6 <gc_execute_block+0x2bf6>
                        FAIL((status_code_t)int_value);
 8011fd0:	4604      	mov	r4, r0
 8011fd2:	f7fd badb 	b.w	800f58c <gc_execute_block+0x1ac>
                system_add_rt_report(Report_Tool);
 8011fd6:	2080      	movs	r0, #128	; 0x80
 8011fd8:	f00f f932 	bl	8021240 <system_add_rt_report>
    gc_state.tool->tool_id = tool->tool_id;
 8011fdc:	4b21      	ldr	r3, [pc, #132]	; (8012064 <gc_execute_block+0x2c84>)
 8011fde:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8011fe2:	692a      	ldr	r2, [r5, #16]
 8011fe4:	611a      	str	r2, [r3, #16]
            if(grbl.on_tool_changed && state_get() != STATE_TOOL_CHANGE)
 8011fe6:	4b21      	ldr	r3, [pc, #132]	; (801206c <gc_execute_block+0x2c8c>)
 8011fe8:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8011fec:	2b00      	cmp	r3, #0
 8011fee:	f43f af42 	beq.w	8011e76 <gc_execute_block+0x2a96>
 8011ff2:	f00c faf7 	bl	801e5e4 <state_get>
 8011ff6:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8011ffa:	f43f af3c 	beq.w	8011e76 <gc_execute_block+0x2a96>
                grbl.on_tool_changed(gc_state.tool);
 8011ffe:	4b1b      	ldr	r3, [pc, #108]	; (801206c <gc_execute_block+0x2c8c>)
 8012000:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8012004:	4a17      	ldr	r2, [pc, #92]	; (8012064 <gc_execute_block+0x2c84>)
 8012006:	f8d2 0094 	ldr.w	r0, [r2, #148]	; 0x94
 801200a:	4798      	blx	r3
 801200c:	e733      	b.n	8011e76 <gc_execute_block+0x2a96>
                gc_state.tool_change = true;
 801200e:	4b15      	ldr	r3, [pc, #84]	; (8012064 <gc_execute_block+0x2c84>)
 8012010:	2201      	movs	r2, #1
 8012012:	f883 2077 	strb.w	r2, [r3, #119]	; 0x77
                system_set_exec_state_flag(EXEC_TOOL_CHANGE);   // Set up program pause for manual tool change
 8012016:	4b16      	ldr	r3, [pc, #88]	; (8012070 <gc_execute_block+0x2c90>)
 8012018:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801201a:	f44f 7100 	mov.w	r1, #512	; 0x200
 801201e:	4816      	ldr	r0, [pc, #88]	; (8012078 <gc_execute_block+0x2c98>)
 8012020:	4798      	blx	r3
                protocol_execute_realtime();                    // Execute...
 8012022:	f005 fb13 	bl	801764c <protocol_execute_realtime>
 8012026:	e7d9      	b.n	8011fdc <gc_execute_block+0x2bfc>
                if(spindle_is_enabled(--idx)) {
 8012028:	2000      	movs	r0, #0
 801202a:	f00b fc7f 	bl	801d92c <spindle_is_enabled>
 801202e:	2800      	cmp	r0, #0
 8012030:	f43f af3d 	beq.w	8011eae <gc_execute_block+0x2ace>
                    spindle_ptrs_t *spindle = spindle_get(idx);
 8012034:	2000      	movs	r0, #0
 8012036:	f00b fc8d 	bl	801d954 <spindle_get>
 801203a:	4605      	mov	r5, r0
                    if(spindle_sync(spindle, gc_block.modal.spindle.state, plan_data.spindle.rpm)) {
 801203c:	ed9d 0a13 	vldr	s0, [sp, #76]	; 0x4c
 8012040:	4b09      	ldr	r3, [pc, #36]	; (8012068 <gc_execute_block+0x2c88>)
 8012042:	f893 1022 	ldrb.w	r1, [r3, #34]	; 0x22
 8012046:	f00b fdc9 	bl	801dbdc <spindle_sync>
 801204a:	2800      	cmp	r0, #0
 801204c:	f43f af2f 	beq.w	8011eae <gc_execute_block+0x2ace>
                        spindle->param->state = gc_block.modal.spindle.state;
 8012050:	686a      	ldr	r2, [r5, #4]
 8012052:	4905      	ldr	r1, [pc, #20]	; (8012068 <gc_execute_block+0x2c88>)
 8012054:	f891 1022 	ldrb.w	r1, [r1, #34]	; 0x22
 8012058:	7211      	strb	r1, [r2, #8]
                        spindle_programmed = true;
 801205a:	9007      	str	r0, [sp, #28]
 801205c:	e729      	b.n	8011eb2 <gc_execute_block+0x2ad2>
 801205e:	bf00      	nop
 8012060:	20003330 	.word	0x20003330
 8012064:	20003344 	.word	0x20003344
 8012068:	20003298 	.word	0x20003298
 801206c:	2000343c 	.word	0x2000343c
 8012070:	2000350c 	.word	0x2000350c
 8012074:	200036c4 	.word	0x200036c4
 8012078:	2000370c 	.word	0x2000370c
    plan_data.condition.is_laser_ppi_mode = gc_state.is_rpm_rate_adjusted && gc_state.is_laser_ppi_mode;
 801207c:	2300      	movs	r3, #0
 801207e:	f89d 205c 	ldrb.w	r2, [sp, #92]	; 0x5c
 8012082:	f363 12c7 	bfi	r2, r3, #7, #1
 8012086:	f88d 205c 	strb.w	r2, [sp, #92]	; 0x5c
    if (gc_parser_flags.set_coolant && gc_state.modal.coolant.value != gc_block.modal.coolant.value) {
 801208a:	f418 7f80 	tst.w	r8, #256	; 0x100
 801208e:	d006      	beq.n	801209e <gc_execute_block+0x2cbe>
 8012090:	4b87      	ldr	r3, [pc, #540]	; (80122b0 <gc_execute_block+0x2ed0>)
 8012092:	7e5a      	ldrb	r2, [r3, #25]
 8012094:	4b87      	ldr	r3, [pc, #540]	; (80122b4 <gc_execute_block+0x2ed4>)
 8012096:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 801209a:	429a      	cmp	r2, r3
 801209c:	d159      	bne.n	8012152 <gc_execute_block+0x2d72>
    plan_data.condition.coolant = gc_state.modal.coolant; // Set condition flag for planner use.
 801209e:	4b84      	ldr	r3, [pc, #528]	; (80122b0 <gc_execute_block+0x2ed0>)
 80120a0:	7e5a      	ldrb	r2, [r3, #25]
 80120a2:	f88d 205e 	strb.w	r2, [sp, #94]	; 0x5e
    sys.override_delay.flags = 0;
 80120a6:	4a84      	ldr	r2, [pc, #528]	; (80122b8 <gc_execute_block+0x2ed8>)
 80120a8:	2100      	movs	r1, #0
 80120aa:	f882 102c 	strb.w	r1, [r2, #44]	; 0x2c
    if (gc_state.modal.override_ctrl.value != gc_block.modal.override_ctrl.value) {
 80120ae:	7f1a      	ldrb	r2, [r3, #28]
 80120b0:	4b80      	ldr	r3, [pc, #512]	; (80122b4 <gc_execute_block+0x2ed4>)
 80120b2:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 80120b6:	429a      	cmp	r2, r3
 80120b8:	d01e      	beq.n	80120f8 <gc_execute_block+0x2d18>
        gc_state.modal.override_ctrl = gc_block.modal.override_ctrl;
 80120ba:	4a7d      	ldr	r2, [pc, #500]	; (80122b0 <gc_execute_block+0x2ed0>)
 80120bc:	4b7d      	ldr	r3, [pc, #500]	; (80122b4 <gc_execute_block+0x2ed4>)
 80120be:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 80120c2:	7713      	strb	r3, [r2, #28]
        gc_state.modal.spindle.state.override_disable = gc_state.spindle.hal->param->state.override_disable = gc_state.modal.override_ctrl.spindle_rpm_disable;
 80120c4:	6d53      	ldr	r3, [r2, #84]	; 0x54
 80120c6:	6859      	ldr	r1, [r3, #4]
 80120c8:	7f13      	ldrb	r3, [r2, #28]
 80120ca:	f3c3 0380 	ubfx	r3, r3, #2, #1
 80120ce:	7a08      	ldrb	r0, [r1, #8]
 80120d0:	f363 1004 	bfi	r0, r3, #4, #1
 80120d4:	7208      	strb	r0, [r1, #8]
 80120d6:	7e91      	ldrb	r1, [r2, #26]
 80120d8:	f363 1104 	bfi	r1, r3, #4, #1
 80120dc:	7691      	strb	r1, [r2, #26]
        if(gc_state.modal.override_ctrl.feed_rate_disable)
 80120de:	7f13      	ldrb	r3, [r2, #28]
 80120e0:	f013 0f01 	tst.w	r3, #1
 80120e4:	d142      	bne.n	801216c <gc_execute_block+0x2d8c>
        if(gc_state.modal.override_ctrl.spindle_rpm_disable)
 80120e6:	4b72      	ldr	r3, [pc, #456]	; (80122b0 <gc_execute_block+0x2ed0>)
 80120e8:	7f1b      	ldrb	r3, [r3, #28]
 80120ea:	f013 0f04 	tst.w	r3, #4
 80120ee:	d142      	bne.n	8012176 <gc_execute_block+0x2d96>
        mc_override_ctrl_update(gc_state.modal.override_ctrl); // NOTE: must be called last!
 80120f0:	4b6f      	ldr	r3, [pc, #444]	; (80122b0 <gc_execute_block+0x2ed0>)
 80120f2:	7f18      	ldrb	r0, [r3, #28]
 80120f4:	f002 fe02 	bl	8014cfc <mc_override_ctrl_update>
    if(gc_block.user_mcode && !check_mode) {
 80120f8:	4b6e      	ldr	r3, [pc, #440]	; (80122b4 <gc_execute_block+0x2ed4>)
 80120fa:	885b      	ldrh	r3, [r3, #2]
 80120fc:	b1ab      	cbz	r3, 801212a <gc_execute_block+0x2d4a>
 80120fe:	9b04      	ldr	r3, [sp, #16]
 8012100:	2b02      	cmp	r3, #2
 8012102:	d012      	beq.n	801212a <gc_execute_block+0x2d4a>
        if(gc_block.user_mcode_sync)
 8012104:	4b6b      	ldr	r3, [pc, #428]	; (80122b4 <gc_execute_block+0x2ed4>)
 8012106:	791b      	ldrb	r3, [r3, #4]
 8012108:	2b00      	cmp	r3, #0
 801210a:	d13a      	bne.n	8012182 <gc_execute_block+0x2da2>
        gc_block.words.mask = user_words.mask;
 801210c:	4b6b      	ldr	r3, [pc, #428]	; (80122bc <gc_execute_block+0x2edc>)
 801210e:	681b      	ldr	r3, [r3, #0]
 8012110:	4d68      	ldr	r5, [pc, #416]	; (80122b4 <gc_execute_block+0x2ed4>)
 8012112:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
        hal.user_mcode.execute(state_get(), &gc_block);
 8012116:	4b6a      	ldr	r3, [pc, #424]	; (80122c0 <gc_execute_block+0x2ee0>)
 8012118:	f8d3 618c 	ldr.w	r6, [r3, #396]	; 0x18c
 801211c:	f00c fa62 	bl	801e5e4 <state_get>
 8012120:	4629      	mov	r1, r5
 8012122:	47b0      	blx	r6
        gc_block.words.mask = 0;
 8012124:	2300      	movs	r3, #0
 8012126:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
    if (gc_block.non_modal_command == NonModal_Dwell)
 801212a:	4b62      	ldr	r3, [pc, #392]	; (80122b4 <gc_execute_block+0x2ed4>)
 801212c:	781b      	ldrb	r3, [r3, #0]
 801212e:	2b04      	cmp	r3, #4
 8012130:	d02a      	beq.n	8012188 <gc_execute_block+0x2da8>
    gc_state.modal.plane_select = gc_block.modal.plane_select;
 8012132:	4a60      	ldr	r2, [pc, #384]	; (80122b4 <gc_execute_block+0x2ed4>)
 8012134:	7b91      	ldrb	r1, [r2, #14]
 8012136:	4b5e      	ldr	r3, [pc, #376]	; (80122b0 <gc_execute_block+0x2ed0>)
 8012138:	7199      	strb	r1, [r3, #6]
    gc_state.modal.units_imperial = gc_block.modal.units_imperial;
 801213a:	7ad2      	ldrb	r2, [r2, #11]
 801213c:	70da      	strb	r2, [r3, #3]
    if (command_words.G8) { // Indicates a change.
 801213e:	f417 7f80 	tst.w	r7, #256	; 0x100
 8012142:	d060      	beq.n	8012206 <gc_execute_block+0x2e26>
        gc_state.modal.tool_offset_mode = gc_block.modal.tool_offset_mode;
 8012144:	4b5b      	ldr	r3, [pc, #364]	; (80122b4 <gc_execute_block+0x2ed4>)
 8012146:	7bd8      	ldrb	r0, [r3, #15]
 8012148:	4b59      	ldr	r3, [pc, #356]	; (80122b0 <gc_execute_block+0x2ed0>)
 801214a:	71d8      	strb	r0, [r3, #7]
        bool tlo_changed = false;
 801214c:	2100      	movs	r1, #0
        idx = N_AXIS;
 801214e:	2203      	movs	r2, #3
 8012150:	e031      	b.n	80121b6 <gc_execute_block+0x2dd6>
        if(coolant_sync(gc_block.modal.coolant))
 8012152:	4b58      	ldr	r3, [pc, #352]	; (80122b4 <gc_execute_block+0x2ed4>)
 8012154:	f893 0021 	ldrb.w	r0, [r3, #33]	; 0x21
 8012158:	f7fc fe52 	bl	800ee00 <coolant_sync>
 801215c:	2800      	cmp	r0, #0
 801215e:	d09e      	beq.n	801209e <gc_execute_block+0x2cbe>
            gc_state.modal.coolant = gc_block.modal.coolant;
 8012160:	4b54      	ldr	r3, [pc, #336]	; (80122b4 <gc_execute_block+0x2ed4>)
 8012162:	f893 2021 	ldrb.w	r2, [r3, #33]	; 0x21
 8012166:	4b52      	ldr	r3, [pc, #328]	; (80122b0 <gc_execute_block+0x2ed0>)
 8012168:	765a      	strb	r2, [r3, #25]
 801216a:	e798      	b.n	801209e <gc_execute_block+0x2cbe>
            plan_feed_override(0, 0);
 801216c:	2100      	movs	r1, #0
 801216e:	4608      	mov	r0, r1
 8012170:	f004 fdbc 	bl	8016cec <plan_feed_override>
 8012174:	e7b7      	b.n	80120e6 <gc_execute_block+0x2d06>
            spindle_set_override(gc_state.spindle.hal, DEFAULT_SPINDLE_RPM_OVERRIDE);
 8012176:	2164      	movs	r1, #100	; 0x64
 8012178:	4b4d      	ldr	r3, [pc, #308]	; (80122b0 <gc_execute_block+0x2ed0>)
 801217a:	6d58      	ldr	r0, [r3, #84]	; 0x54
 801217c:	f00b fd92 	bl	801dca4 <spindle_set_override>
 8012180:	e7b6      	b.n	80120f0 <gc_execute_block+0x2d10>
            protocol_buffer_synchronize(); // Ensure user defined mcode is executed when specified in program.
 8012182:	f005 fd29 	bl	8017bd8 <protocol_buffer_synchronize>
 8012186:	e7c1      	b.n	801210c <gc_execute_block+0x2d2c>
        mc_dwell(gc_block.values.p);
 8012188:	4b4a      	ldr	r3, [pc, #296]	; (80122b4 <gc_execute_block+0x2ed4>)
 801218a:	ed93 0a14 	vldr	s0, [r3, #80]	; 0x50
 801218e:	f002 fb3f 	bl	8014810 <mc_dwell>
 8012192:	e7ce      	b.n	8012132 <gc_execute_block+0x2d52>
                    tlo_changed |= gc_state.tool_length_offset[idx] != 0.0f;
 8012194:	f102 0522 	add.w	r5, r2, #34	; 0x22
 8012198:	4b45      	ldr	r3, [pc, #276]	; (80122b0 <gc_execute_block+0x2ed0>)
 801219a:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 801219e:	edd3 7a00 	vldr	s15, [r3]
 80121a2:	eef5 7a40 	vcmp.f32	s15, #0.0
 80121a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80121aa:	bf18      	it	ne
 80121ac:	f041 0101 	orrne.w	r1, r1, #1
                    gc_state.tool_length_offset[idx] = 0.0f;
 80121b0:	2500      	movs	r5, #0
 80121b2:	601d      	str	r5, [r3, #0]
        } while(idx);
 80121b4:	b332      	cbz	r2, 8012204 <gc_execute_block+0x2e24>
            idx--;
 80121b6:	3a01      	subs	r2, #1
            switch(gc_state.modal.tool_offset_mode) {
 80121b8:	2800      	cmp	r0, #0
 80121ba:	d0eb      	beq.n	8012194 <gc_execute_block+0x2db4>
 80121bc:	2802      	cmp	r0, #2
 80121be:	d1f9      	bne.n	80121b4 <gc_execute_block+0x2dd4>
                    if (bit_istrue(axis_words.mask, bit(idx)) && gc_state.tool_length_offset[idx] != gc_block.values.xyz[idx]) {
 80121c0:	fa5f f38b 	uxtb.w	r3, fp
 80121c4:	40d3      	lsrs	r3, r2
 80121c6:	f013 0f01 	tst.w	r3, #1
 80121ca:	d0f3      	beq.n	80121b4 <gc_execute_block+0x2dd4>
 80121cc:	f102 0522 	add.w	r5, r2, #34	; 0x22
 80121d0:	4b37      	ldr	r3, [pc, #220]	; (80122b0 <gc_execute_block+0x2ed0>)
 80121d2:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 80121d6:	ed93 7a00 	vldr	s14, [r3]
 80121da:	f102 0518 	add.w	r5, r2, #24
 80121de:	4b35      	ldr	r3, [pc, #212]	; (80122b4 <gc_execute_block+0x2ed4>)
 80121e0:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 80121e4:	edd3 7a00 	vldr	s15, [r3]
 80121e8:	eeb4 7a67 	vcmp.f32	s14, s15
 80121ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80121f0:	d0e0      	beq.n	80121b4 <gc_execute_block+0x2dd4>
                        gc_state.tool_length_offset[idx] = gc_block.values.xyz[idx];
 80121f2:	f102 0122 	add.w	r1, r2, #34	; 0x22
 80121f6:	4b2e      	ldr	r3, [pc, #184]	; (80122b0 <gc_execute_block+0x2ed0>)
 80121f8:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 80121fc:	edc3 7a00 	vstr	s15, [r3]
                        tlo_changed = true;
 8012200:	2101      	movs	r1, #1
 8012202:	e7d7      	b.n	80121b4 <gc_execute_block+0x2dd4>
        if(tlo_changed) {
 8012204:	bb49      	cbnz	r1, 801225a <gc_execute_block+0x2e7a>
    if (gc_state.modal.coord_system.id != gc_block.modal.coord_system.id) {
 8012206:	4b2a      	ldr	r3, [pc, #168]	; (80122b0 <gc_execute_block+0x2ed0>)
 8012208:	7d1a      	ldrb	r2, [r3, #20]
 801220a:	4b2a      	ldr	r3, [pc, #168]	; (80122b4 <gc_execute_block+0x2ed4>)
 801220c:	7f1b      	ldrb	r3, [r3, #28]
 801220e:	429a      	cmp	r2, r3
 8012210:	d12a      	bne.n	8012268 <gc_execute_block+0x2e88>
    gc_state.modal.distance_incremental = gc_block.modal.distance_incremental;
 8012212:	4b28      	ldr	r3, [pc, #160]	; (80122b4 <gc_execute_block+0x2ed4>)
 8012214:	7b19      	ldrb	r1, [r3, #12]
 8012216:	4a26      	ldr	r2, [pc, #152]	; (80122b0 <gc_execute_block+0x2ed0>)
 8012218:	7111      	strb	r1, [r2, #4]
    gc_state.modal.retract_mode = gc_block.modal.retract_mode;
 801221a:	f893 1025 	ldrb.w	r1, [r3, #37]	; 0x25
 801221e:	7751      	strb	r1, [r2, #29]
    switch(gc_block.non_modal_command) {
 8012220:	781b      	ldrb	r3, [r3, #0]
 8012222:	2b41      	cmp	r3, #65	; 0x41
 8012224:	d852      	bhi.n	80122cc <gc_execute_block+0x2eec>
 8012226:	2b1c      	cmp	r3, #28
 8012228:	d22a      	bcs.n	8012280 <gc_execute_block+0x2ea0>
 801222a:	2b0a      	cmp	r3, #10
 801222c:	d17e      	bne.n	801232c <gc_execute_block+0x2f4c>
                settings_write_coord_data(gc_block.values.coord_data.id, &gc_block.values.coord_data.xyz);
 801222e:	4d21      	ldr	r5, [pc, #132]	; (80122b4 <gc_execute_block+0x2ed4>)
 8012230:	f105 016c 	add.w	r1, r5, #108	; 0x6c
 8012234:	f895 0078 	ldrb.w	r0, [r5, #120]	; 0x78
 8012238:	f00a fbb8 	bl	801c9ac <settings_write_coord_data>
                if (gc_state.modal.coord_system.id == gc_block.values.coord_data.id) {
 801223c:	4b1c      	ldr	r3, [pc, #112]	; (80122b0 <gc_execute_block+0x2ed0>)
 801223e:	7d1a      	ldrb	r2, [r3, #20]
 8012240:	f895 3078 	ldrb.w	r3, [r5, #120]	; 0x78
 8012244:	429a      	cmp	r2, r3
 8012246:	d171      	bne.n	801232c <gc_execute_block+0x2f4c>
                    memcpy(gc_state.modal.coord_system.xyz, gc_block.values.coord_data.xyz, sizeof(gc_state.modal.coord_system.xyz));
 8012248:	4b1e      	ldr	r3, [pc, #120]	; (80122c4 <gc_execute_block+0x2ee4>)
 801224a:	f105 026c 	add.w	r2, r5, #108	; 0x6c
 801224e:	ca07      	ldmia	r2, {r0, r1, r2}
 8012250:	e883 0007 	stmia.w	r3, {r0, r1, r2}
                    system_flag_wco_change();
 8012254:	f00f f852 	bl	80212fc <system_flag_wco_change>
 8012258:	e068      	b.n	801232c <gc_execute_block+0x2f4c>
            system_add_rt_report(Report_ToolOffset);
 801225a:	f44f 6080 	mov.w	r0, #1024	; 0x400
 801225e:	f00e ffef 	bl	8021240 <system_add_rt_report>
            system_flag_wco_change();
 8012262:	f00f f84b 	bl	80212fc <system_flag_wco_change>
 8012266:	e7ce      	b.n	8012206 <gc_execute_block+0x2e26>
        memcpy(&gc_state.modal.coord_system, &gc_block.modal.coord_system, sizeof(gc_state.modal.coord_system));
 8012268:	4d16      	ldr	r5, [pc, #88]	; (80122c4 <gc_execute_block+0x2ee4>)
 801226a:	4b17      	ldr	r3, [pc, #92]	; (80122c8 <gc_execute_block+0x2ee8>)
 801226c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801226e:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
        system_add_rt_report(Report_GWCO);
 8012272:	f44f 7000 	mov.w	r0, #512	; 0x200
 8012276:	f00e ffe3 	bl	8021240 <system_add_rt_report>
        system_flag_wco_change();
 801227a:	f00f f83f 	bl	80212fc <system_flag_wco_change>
 801227e:	e7c8      	b.n	8012212 <gc_execute_block+0x2e32>
    switch(gc_block.non_modal_command) {
 8012280:	3b1c      	subs	r3, #28
 8012282:	2b25      	cmp	r3, #37	; 0x25
 8012284:	d852      	bhi.n	801232c <gc_execute_block+0x2f4c>
 8012286:	e8df f003 	tbb	[pc, r3]
 801228a:	513a      	.short	0x513a
 801228c:	5151513a 	.word	0x5151513a
 8012290:	51515151 	.word	0x51515151
 8012294:	517c5177 	.word	0x517c5177
 8012298:	51515151 	.word	0x51515151
 801229c:	51515151 	.word	0x51515151
 80122a0:	51515151 	.word	0x51515151
 80122a4:	51515151 	.word	0x51515151
 80122a8:	51515151 	.word	0x51515151
 80122ac:	81515151 	.word	0x81515151
 80122b0:	20003344 	.word	0x20003344
 80122b4:	20003298 	.word	0x20003298
 80122b8:	200036c4 	.word	0x200036c4
 80122bc:	20003438 	.word	0x20003438
 80122c0:	2000350c 	.word	0x2000350c
 80122c4:	2000334c 	.word	0x2000334c
 80122c8:	200032a8 	.word	0x200032a8
 80122cc:	2b7a      	cmp	r3, #122	; 0x7a
 80122ce:	d82d      	bhi.n	801232c <gc_execute_block+0x2f4c>
 80122d0:	2b5c      	cmp	r3, #92	; 0x5c
 80122d2:	d32b      	bcc.n	801232c <gc_execute_block+0x2f4c>
 80122d4:	3b5c      	subs	r3, #92	; 0x5c
 80122d6:	2b1e      	cmp	r3, #30
 80122d8:	d828      	bhi.n	801232c <gc_execute_block+0x2f4c>
 80122da:	e8df f003 	tbb	[pc, r3]
 80122de:	276a      	.short	0x276a
 80122e0:	27272727 	.word	0x27272727
 80122e4:	27272727 	.word	0x27272727
 80122e8:	27272781 	.word	0x27272781
 80122ec:	27272727 	.word	0x27272727
 80122f0:	27992727 	.word	0x27992727
 80122f4:	27272727 	.word	0x27272727
 80122f8:	27272727 	.word	0x27272727
 80122fc:	a5          	.byte	0xa5
 80122fd:	00          	.byte	0x00
            plan_data.condition.rapid_motion = On; // Set rapid motion condition flag.
 80122fe:	f89d 305c 	ldrb.w	r3, [sp, #92]	; 0x5c
 8012302:	f043 0301 	orr.w	r3, r3, #1
 8012306:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
            if (axis_command)
 801230a:	f1ba 0f00 	cmp.w	sl, #0
 801230e:	d12e      	bne.n	801236e <gc_execute_block+0x2f8e>
            mc_line(gc_block.values.coord_data.xyz, &plan_data);
 8012310:	4da5      	ldr	r5, [pc, #660]	; (80125a8 <gc_execute_block+0x31c8>)
 8012312:	a912      	add	r1, sp, #72	; 0x48
 8012314:	4628      	mov	r0, r5
 8012316:	f001 fc4f 	bl	8013bb8 <mc_line>
            memcpy(gc_state.position, gc_block.values.coord_data.xyz, sizeof(gc_state.position));
 801231a:	4ba4      	ldr	r3, [pc, #656]	; (80125ac <gc_execute_block+0x31cc>)
 801231c:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8012320:	e883 0007 	stmia.w	r3, {r0, r1, r2}
            set_scaling(1.0f);
 8012324:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8012328:	f7fc fe46 	bl	800efb8 <set_scaling>
    gc_state.modal.motion = gc_block.modal.motion;
 801232c:	4aa0      	ldr	r2, [pc, #640]	; (80125b0 <gc_execute_block+0x31d0>)
 801232e:	8910      	ldrh	r0, [r2, #8]
 8012330:	4ba0      	ldr	r3, [pc, #640]	; (80125b4 <gc_execute_block+0x31d4>)
 8012332:	8018      	strh	r0, [r3, #0]
    gc_state.modal.canned_cycle_active = gc_block.modal.canned_cycle_active;
 8012334:	f892 2027 	ldrb.w	r2, [r2, #39]	; 0x27
 8012338:	77da      	strb	r2, [r3, #31]
    if (gc_state.modal.motion != MotionMode_None && axis_command == AxisCommand_MotionMode) {
 801233a:	2850      	cmp	r0, #80	; 0x50
 801233c:	d002      	beq.n	8012344 <gc_execute_block+0x2f64>
 801233e:	f1ba 0f02 	cmp.w	sl, #2
 8012342:	d07c      	beq.n	801243e <gc_execute_block+0x305e>
    if(plan_data.message)
 8012344:	981a      	ldr	r0, [sp, #104]	; 0x68
 8012346:	b108      	cbz	r0, 801234c <gc_execute_block+0x2f6c>
        output_message(plan_data.message);
 8012348:	f7fc fe00 	bl	800ef4c <output_message>
    gc_state.modal.program_flow = gc_block.modal.program_flow;
 801234c:	4b98      	ldr	r3, [pc, #608]	; (80125b0 <gc_execute_block+0x31d0>)
 801234e:	f893 3020 	ldrb.w	r3, [r3, #32]
 8012352:	4a98      	ldr	r2, [pc, #608]	; (80125b4 <gc_execute_block+0x31d4>)
 8012354:	7613      	strb	r3, [r2, #24]
    if(gc_state.modal.program_flow || sys.flags.single_block) {
 8012356:	2b00      	cmp	r3, #0
 8012358:	f040 821e 	bne.w	8012798 <gc_execute_block+0x33b8>
 801235c:	4a96      	ldr	r2, [pc, #600]	; (80125b8 <gc_execute_block+0x31d8>)
 801235e:	f992 2016 	ldrsb.w	r2, [r2, #22]
 8012362:	2a00      	cmp	r2, #0
 8012364:	f2c0 8218 	blt.w	8012798 <gc_execute_block+0x33b8>
    return Status_OK;
 8012368:	461c      	mov	r4, r3
 801236a:	f7fd b90f 	b.w	800f58c <gc_execute_block+0x1ac>
                mc_line(gc_block.values.xyz, &plan_data);
 801236e:	a912      	add	r1, sp, #72	; 0x48
 8012370:	4892      	ldr	r0, [pc, #584]	; (80125bc <gc_execute_block+0x31dc>)
 8012372:	f001 fc21 	bl	8013bb8 <mc_line>
 8012376:	e7cb      	b.n	8012310 <gc_execute_block+0x2f30>
            settings_write_coord_data(CoordinateSystem_G28, &gc_state.position);
 8012378:	498c      	ldr	r1, [pc, #560]	; (80125ac <gc_execute_block+0x31cc>)
 801237a:	2009      	movs	r0, #9
 801237c:	f00a fb16 	bl	801c9ac <settings_write_coord_data>
            break;
 8012380:	e7d4      	b.n	801232c <gc_execute_block+0x2f4c>
            settings_write_coord_data(CoordinateSystem_G30, &gc_state.position);
 8012382:	498a      	ldr	r1, [pc, #552]	; (80125ac <gc_execute_block+0x31cc>)
 8012384:	200a      	movs	r0, #10
 8012386:	f00a fb11 	bl	801c9ac <settings_write_coord_data>
            break;
 801238a:	e7cf      	b.n	801232c <gc_execute_block+0x2f4c>
                status_code_t status = grbl.on_macro_execute((macro_id_t)gc_block.values.p);
 801238c:	4b8c      	ldr	r3, [pc, #560]	; (80125c0 <gc_execute_block+0x31e0>)
 801238e:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 8012392:	4a87      	ldr	r2, [pc, #540]	; (80125b0 <gc_execute_block+0x31d0>)
 8012394:	edd2 7a14 	vldr	s15, [r2, #80]	; 0x50
 8012398:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801239c:	ee17 2a90 	vmov	r2, s15
 80123a0:	b290      	uxth	r0, r2
 80123a2:	4798      	blx	r3
 80123a4:	4604      	mov	r4, r0
                return status == Status_Unhandled ? Status_GcodeValueOutOfRange : status;
 80123a6:	2854      	cmp	r0, #84	; 0x54
 80123a8:	f47d a8f0 	bne.w	800f58c <gc_execute_block+0x1ac>
 80123ac:	2427      	movs	r4, #39	; 0x27
 80123ae:	f7fd b8ed 	b.w	800f58c <gc_execute_block+0x1ac>
            gc_state.g92_coord_offset_applied = true; // TODO: check for all zero?
 80123b2:	4b80      	ldr	r3, [pc, #512]	; (80125b4 <gc_execute_block+0x31d4>)
 80123b4:	2201      	movs	r2, #1
 80123b6:	f883 207a 	strb.w	r2, [r3, #122]	; 0x7a
            memcpy(gc_state.g92_coord_offset, gc_block.values.xyz, sizeof(gc_state.g92_coord_offset));
 80123ba:	337c      	adds	r3, #124	; 0x7c
 80123bc:	4a7f      	ldr	r2, [pc, #508]	; (80125bc <gc_execute_block+0x31dc>)
 80123be:	ca07      	ldmia	r2, {r0, r1, r2}
 80123c0:	e883 0007 	stmia.w	r3, {r0, r1, r2}
            if(!settings.flags.g92_is_volatile)
 80123c4:	4b7f      	ldr	r3, [pc, #508]	; (80125c4 <gc_execute_block+0x31e4>)
 80123c6:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
 80123ca:	f013 0f02 	tst.w	r3, #2
 80123ce:	d002      	beq.n	80123d6 <gc_execute_block+0x2ff6>
            system_flag_wco_change();
 80123d0:	f00e ff94 	bl	80212fc <system_flag_wco_change>
            break;
 80123d4:	e7aa      	b.n	801232c <gc_execute_block+0x2f4c>
                settings_write_coord_data(CoordinateSystem_G92, &gc_state.g92_coord_offset); // Save G92 offsets to non-volatile storage
 80123d6:	497c      	ldr	r1, [pc, #496]	; (80125c8 <gc_execute_block+0x31e8>)
 80123d8:	200b      	movs	r0, #11
 80123da:	f00a fae7 	bl	801c9ac <settings_write_coord_data>
 80123de:	e7f7      	b.n	80123d0 <gc_execute_block+0x2ff0>
            gc_state.g92_coord_offset_applied = false;
 80123e0:	4a74      	ldr	r2, [pc, #464]	; (80125b4 <gc_execute_block+0x31d4>)
 80123e2:	2300      	movs	r3, #0
 80123e4:	f882 307a 	strb.w	r3, [r2, #122]	; 0x7a
            clear_vector(gc_state.g92_coord_offset); // Disable G92 offsets by zeroing offset vector.
 80123e8:	f102 017c 	add.w	r1, r2, #124	; 0x7c
 80123ec:	67d3      	str	r3, [r2, #124]	; 0x7c
 80123ee:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
 80123f2:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
            if(!settings.flags.g92_is_volatile)
 80123f6:	4b73      	ldr	r3, [pc, #460]	; (80125c4 <gc_execute_block+0x31e4>)
 80123f8:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
 80123fc:	f013 0f02 	tst.w	r3, #2
 8012400:	d002      	beq.n	8012408 <gc_execute_block+0x3028>
            system_flag_wco_change();
 8012402:	f00e ff7b 	bl	80212fc <system_flag_wco_change>
            break;
 8012406:	e791      	b.n	801232c <gc_execute_block+0x2f4c>
                settings_write_coord_data(CoordinateSystem_G92, &gc_state.g92_coord_offset); // Save G92 offsets to non-volatile storage
 8012408:	200b      	movs	r0, #11
 801240a:	f00a facf 	bl	801c9ac <settings_write_coord_data>
 801240e:	e7f8      	b.n	8012402 <gc_execute_block+0x3022>
            gc_state.g92_coord_offset_applied = false;
 8012410:	4a68      	ldr	r2, [pc, #416]	; (80125b4 <gc_execute_block+0x31d4>)
 8012412:	2300      	movs	r3, #0
 8012414:	f882 307a 	strb.w	r3, [r2, #122]	; 0x7a
            clear_vector(gc_state.g92_coord_offset); // Disable G92 offsets by zeroing offset vector.
 8012418:	67d3      	str	r3, [r2, #124]	; 0x7c
 801241a:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
 801241e:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
            system_flag_wco_change();
 8012422:	f00e ff6b 	bl	80212fc <system_flag_wco_change>
            break;
 8012426:	e781      	b.n	801232c <gc_execute_block+0x2f4c>
            gc_state.g92_coord_offset_applied = true; // TODO: check for all zero?
 8012428:	4962      	ldr	r1, [pc, #392]	; (80125b4 <gc_execute_block+0x31d4>)
 801242a:	2301      	movs	r3, #1
 801242c:	f881 307a 	strb.w	r3, [r1, #122]	; 0x7a
            settings_read_coord_data(CoordinateSystem_G92, &gc_state.g92_coord_offset); // Restore G92 offsets from non-volatile storage
 8012430:	317c      	adds	r1, #124	; 0x7c
 8012432:	200b      	movs	r0, #11
 8012434:	f00a fade 	bl	801c9f4 <settings_read_coord_data>
            system_flag_wco_change();
 8012438:	f00e ff60 	bl	80212fc <system_flag_wco_change>
            break;
 801243c:	e776      	b.n	801232c <gc_execute_block+0x2f4c>
        plan_data.output_commands = output_commands;
 801243e:	4b63      	ldr	r3, [pc, #396]	; (80125cc <gc_execute_block+0x31ec>)
 8012440:	681a      	ldr	r2, [r3, #0]
 8012442:	921b      	str	r2, [sp, #108]	; 0x6c
        output_commands = NULL;
 8012444:	2200      	movs	r2, #0
 8012446:	601a      	str	r2, [r3, #0]
        switch(gc_state.modal.motion) {
 8012448:	2853      	cmp	r0, #83	; 0x53
 801244a:	d858      	bhi.n	80124fe <gc_execute_block+0x311e>
 801244c:	2853      	cmp	r0, #83	; 0x53
 801244e:	f200 8182 	bhi.w	8012756 <gc_execute_block+0x3376>
 8012452:	e8df f010 	tbh	[pc, r0, lsl #1]
 8012456:	007e      	.short	0x007e
 8012458:	008a006d 	.word	0x008a006d
 801245c:	0180008a 	.word	0x0180008a
 8012460:	018000bd 	.word	0x018000bd
 8012464:	01800180 	.word	0x01800180
 8012468:	01800180 	.word	0x01800180
 801246c:	01800180 	.word	0x01800180
 8012470:	01800180 	.word	0x01800180
 8012474:	01800180 	.word	0x01800180
 8012478:	01800180 	.word	0x01800180
 801247c:	01800180 	.word	0x01800180
 8012480:	01800180 	.word	0x01800180
 8012484:	01800180 	.word	0x01800180
 8012488:	01800180 	.word	0x01800180
 801248c:	01800180 	.word	0x01800180
 8012490:	01800180 	.word	0x01800180
 8012494:	01800180 	.word	0x01800180
 8012498:	0180012b 	.word	0x0180012b
 801249c:	01800180 	.word	0x01800180
 80124a0:	01800180 	.word	0x01800180
 80124a4:	01800180 	.word	0x01800180
 80124a8:	01800180 	.word	0x01800180
 80124ac:	01800180 	.word	0x01800180
 80124b0:	01800180 	.word	0x01800180
 80124b4:	01800180 	.word	0x01800180
 80124b8:	01800180 	.word	0x01800180
 80124bc:	018000e9 	.word	0x018000e9
 80124c0:	01800180 	.word	0x01800180
 80124c4:	01800180 	.word	0x01800180
 80124c8:	01800180 	.word	0x01800180
 80124cc:	01800180 	.word	0x01800180
 80124d0:	01800180 	.word	0x01800180
 80124d4:	01800180 	.word	0x01800180
 80124d8:	01800180 	.word	0x01800180
 80124dc:	01800180 	.word	0x01800180
 80124e0:	01800180 	.word	0x01800180
 80124e4:	01800180 	.word	0x01800180
 80124e8:	01800166 	.word	0x01800166
 80124ec:	014b0180 	.word	0x014b0180
 80124f0:	01800180 	.word	0x01800180
 80124f4:	01800180 	.word	0x01800180
 80124f8:	01660166 	.word	0x01660166
 80124fc:	0166      	.short	0x0166
 80124fe:	f1a0 038c 	sub.w	r3, r0, #140	; 0x8c
 8012502:	b29b      	uxth	r3, r3
 8012504:	2b03      	cmp	r3, #3
 8012506:	f200 812c 	bhi.w	8012762 <gc_execute_block+0x3382>
                plan_data.condition.no_feed_override = !settings.probe.allow_feed_override;
 801250a:	4b2e      	ldr	r3, [pc, #184]	; (80125c4 <gc_execute_block+0x31e4>)
 801250c:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
 8012510:	091b      	lsrs	r3, r3, #4
 8012512:	f083 0301 	eor.w	r3, r3, #1
 8012516:	f89d 205c 	ldrb.w	r2, [sp, #92]	; 0x5c
 801251a:	f363 1204 	bfi	r2, r3, #4, #1
 801251e:	f88d 205c 	strb.w	r2, [sp, #92]	; 0x5c
                gc_update_pos = (pos_update_t)mc_probe_cycle(gc_block.values.xyz, &plan_data, gc_parser_flags);
 8012522:	4642      	mov	r2, r8
 8012524:	a912      	add	r1, sp, #72	; 0x48
 8012526:	4825      	ldr	r0, [pc, #148]	; (80125bc <gc_execute_block+0x31dc>)
 8012528:	f002 faac 	bl	8014a84 <mc_probe_cycle>
 801252c:	4605      	mov	r5, r0
                break;
 801252e:	e113      	b.n	8012758 <gc_execute_block+0x3378>
                if(gc_state.modal.feed_mode == FeedMode_UnitsPerRev) {
 8012530:	4b20      	ldr	r3, [pc, #128]	; (80125b4 <gc_execute_block+0x31d4>)
 8012532:	789b      	ldrb	r3, [r3, #2]
 8012534:	2b02      	cmp	r3, #2
 8012536:	d005      	beq.n	8012544 <gc_execute_block+0x3164>
                mc_line(gc_block.values.xyz, &plan_data);
 8012538:	a912      	add	r1, sp, #72	; 0x48
 801253a:	4820      	ldr	r0, [pc, #128]	; (80125bc <gc_execute_block+0x31dc>)
 801253c:	f001 fb3c 	bl	8013bb8 <mc_line>
        pos_update_t gc_update_pos = GCUpdatePos_Target;
 8012540:	4625      	mov	r5, r4
                break;
 8012542:	e109      	b.n	8012758 <gc_execute_block+0x3378>
                    plan_data.spindle.state.synchronized = On;
 8012544:	f89d 3050 	ldrb.w	r3, [sp, #80]	; 0x50
 8012548:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 801254c:	f88d 3050 	strb.w	r3, [sp, #80]	; 0x50
 8012550:	e7f2      	b.n	8012538 <gc_execute_block+0x3158>
                plan_data.condition.rapid_motion = On; // Set rapid motion condition flag.
 8012552:	f89d 305c 	ldrb.w	r3, [sp, #92]	; 0x5c
 8012556:	f043 0301 	orr.w	r3, r3, #1
 801255a:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
                mc_line(gc_block.values.xyz, &plan_data);
 801255e:	a912      	add	r1, sp, #72	; 0x48
 8012560:	4816      	ldr	r0, [pc, #88]	; (80125bc <gc_execute_block+0x31dc>)
 8012562:	f001 fb29 	bl	8013bb8 <mc_line>
        pos_update_t gc_update_pos = GCUpdatePos_Target;
 8012566:	4625      	mov	r5, r4
                break;
 8012568:	e0f6      	b.n	8012758 <gc_execute_block+0x3378>
                mc_arc(gc_block.values.xyz, &plan_data, gc_state.position, gc_block.values.ijk, gc_block.values.r,
 801256a:	4b11      	ldr	r3, [pc, #68]	; (80125b0 <gc_execute_block+0x31d0>)
 801256c:	ed93 0a16 	vldr	s0, [r3, #88]	; 0x58
 8012570:	f018 0f04 	tst.w	r8, #4
 8012574:	d012      	beq.n	801259c <gc_execute_block+0x31bc>
                        plane, gc_parser_flags.arc_is_clockwise ? gc_block.arc_turns : - gc_block.arc_turns);
 8012576:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
                mc_arc(gc_block.values.xyz, &plan_data, gc_state.position, gc_block.values.ijk, gc_block.values.r,
 801257a:	480d      	ldr	r0, [pc, #52]	; (80125b0 <gc_execute_block+0x31d0>)
 801257c:	9301      	str	r3, [sp, #4]
 801257e:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8012580:	f8ad 3000 	strh.w	r3, [sp]
 8012584:	0c1b      	lsrs	r3, r3, #16
 8012586:	f88d 3002 	strb.w	r3, [sp, #2]
 801258a:	f100 033c 	add.w	r3, r0, #60	; 0x3c
 801258e:	4a07      	ldr	r2, [pc, #28]	; (80125ac <gc_execute_block+0x31cc>)
 8012590:	a912      	add	r1, sp, #72	; 0x48
 8012592:	3060      	adds	r0, #96	; 0x60
 8012594:	f001 fb5c 	bl	8013c50 <mc_arc>
        pos_update_t gc_update_pos = GCUpdatePos_Target;
 8012598:	4625      	mov	r5, r4
                break;
 801259a:	e0dd      	b.n	8012758 <gc_execute_block+0x3378>
                        plane, gc_parser_flags.arc_is_clockwise ? gc_block.arc_turns : - gc_block.arc_turns);
 801259c:	4b04      	ldr	r3, [pc, #16]	; (80125b0 <gc_execute_block+0x31d0>)
 801259e:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 80125a2:	425b      	negs	r3, r3
 80125a4:	e7e9      	b.n	801257a <gc_execute_block+0x319a>
 80125a6:	bf00      	nop
 80125a8:	20003304 	.word	0x20003304
 80125ac:	200033a4 	.word	0x200033a4
 80125b0:	20003298 	.word	0x20003298
 80125b4:	20003344 	.word	0x20003344
 80125b8:	200036c4 	.word	0x200036c4
 80125bc:	200032f8 	.word	0x200032f8
 80125c0:	2000343c 	.word	0x2000343c
 80125c4:	20003b14 	.word	0x20003b14
 80125c8:	200033c0 	.word	0x200033c0
 80125cc:	200033dc 	.word	0x200033dc
                        .x = gc_state.position[X_AXIS] + gc_block.values.ijk[X_AXIS],
 80125d0:	4aaf      	ldr	r2, [pc, #700]	; (8012890 <gc_execute_block+0x34b0>)
 80125d2:	edd2 7a18 	vldr	s15, [r2, #96]	; 0x60
 80125d6:	48af      	ldr	r0, [pc, #700]	; (8012894 <gc_execute_block+0x34b4>)
 80125d8:	ed90 7a0f 	vldr	s14, [r0, #60]	; 0x3c
 80125dc:	ee77 7a87 	vadd.f32	s15, s15, s14
                    point_2d cp1 = {
 80125e0:	edcd 7a0d 	vstr	s15, [sp, #52]	; 0x34
                        .y = gc_state.position[Y_AXIS] + gc_block.values.ijk[Y_AXIS]
 80125e4:	edd2 7a19 	vldr	s15, [r2, #100]	; 0x64
 80125e8:	ed90 7a10 	vldr	s14, [r0, #64]	; 0x40
 80125ec:	ee77 7a87 	vadd.f32	s15, s15, s14
                    point_2d cp1 = {
 80125f0:	edcd 7a0e 	vstr	s15, [sp, #56]	; 0x38
                        .x = gc_block.values.xyz[X_AXIS] + gc_state.modal.spline_pq[X_AXIS],
 80125f4:	edd0 7a18 	vldr	s15, [r0, #96]	; 0x60
 80125f8:	ed92 7a08 	vldr	s14, [r2, #32]
 80125fc:	ee77 7a87 	vadd.f32	s15, s15, s14
                    point_2d cp2 = {
 8012600:	edcd 7a0f 	vstr	s15, [sp, #60]	; 0x3c
                        .y = gc_block.values.xyz[Y_AXIS] + gc_state.modal.spline_pq[Y_AXIS]
 8012604:	edd0 7a19 	vldr	s15, [r0, #100]	; 0x64
 8012608:	ed92 7a09 	vldr	s14, [r2, #36]	; 0x24
 801260c:	ee77 7a87 	vadd.f32	s15, s15, s14
                    point_2d cp2 = {
 8012610:	edcd 7a10 	vstr	s15, [sp, #64]	; 0x40
                    mc_cubic_b_spline(gc_block.values.xyz, &plan_data, gc_state.position, cp1.values, cp2.values);
 8012614:	ab0f      	add	r3, sp, #60	; 0x3c
 8012616:	9300      	str	r3, [sp, #0]
 8012618:	ab0d      	add	r3, sp, #52	; 0x34
 801261a:	3260      	adds	r2, #96	; 0x60
 801261c:	a912      	add	r1, sp, #72	; 0x48
 801261e:	3060      	adds	r0, #96	; 0x60
 8012620:	f001 fd88 	bl	8014134 <mc_cubic_b_spline>
        pos_update_t gc_update_pos = GCUpdatePos_Target;
 8012624:	4625      	mov	r5, r4
                break;
 8012626:	e097      	b.n	8012758 <gc_execute_block+0x3378>
                        .x = gc_state.position[X_AXIS] + (gc_block.values.ijk[X_AXIS] * 2.0f) / 3.0f,
 8012628:	4a99      	ldr	r2, [pc, #612]	; (8012890 <gc_execute_block+0x34b0>)
 801262a:	ed92 7a18 	vldr	s14, [r2, #96]	; 0x60
 801262e:	4899      	ldr	r0, [pc, #612]	; (8012894 <gc_execute_block+0x34b4>)
 8012630:	ed90 5a0f 	vldr	s10, [r0, #60]	; 0x3c
 8012634:	ee35 6a05 	vadd.f32	s12, s10, s10
 8012638:	eef0 6a08 	vmov.f32	s13, #8	; 0x40400000  3.0
 801263c:	eec6 7a26 	vdiv.f32	s15, s12, s13
 8012640:	ee77 7a27 	vadd.f32	s15, s14, s15
                    point_2d cp1 = {
 8012644:	edcd 7a0d 	vstr	s15, [sp, #52]	; 0x34
                        .y = gc_state.position[Y_AXIS] + (gc_block.values.ijk[Y_AXIS] * 2.0f) / 3.0f
 8012648:	edd2 7a19 	vldr	s15, [r2, #100]	; 0x64
 801264c:	edd0 5a10 	vldr	s11, [r0, #64]	; 0x40
 8012650:	ee75 4aa5 	vadd.f32	s9, s11, s11
 8012654:	ee84 6aa6 	vdiv.f32	s12, s9, s13
 8012658:	ee37 6a86 	vadd.f32	s12, s15, s12
                    point_2d cp1 = {
 801265c:	ed8d 6a0e 	vstr	s12, [sp, #56]	; 0x38
                        .x = gc_block.values.xyz[X_AXIS] + ((gc_state.position[X_AXIS] + gc_block.values.ijk[X_AXIS] - gc_block.values.xyz[X_AXIS]) * 2.0f) / 3.0f,
 8012660:	ed90 6a18 	vldr	s12, [r0, #96]	; 0x60
 8012664:	ee37 7a05 	vadd.f32	s14, s14, s10
 8012668:	ee37 7a46 	vsub.f32	s14, s14, s12
 801266c:	ee37 7a07 	vadd.f32	s14, s14, s14
 8012670:	ee87 5a26 	vdiv.f32	s10, s14, s13
 8012674:	ee36 6a05 	vadd.f32	s12, s12, s10
                    point_2d cp2 = {
 8012678:	ed8d 6a0f 	vstr	s12, [sp, #60]	; 0x3c
                        .y = gc_block.values.xyz[Y_AXIS] + ((gc_state.position[Y_AXIS] + gc_block.values.ijk[Y_AXIS] - gc_block.values.xyz[Y_AXIS]) * 2.0f) / 3.0f
 801267c:	ed90 7a19 	vldr	s14, [r0, #100]	; 0x64
 8012680:	ee77 7aa5 	vadd.f32	s15, s15, s11
 8012684:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8012688:	ee77 7aa7 	vadd.f32	s15, s15, s15
 801268c:	ee87 6aa6 	vdiv.f32	s12, s15, s13
 8012690:	ee37 7a06 	vadd.f32	s14, s14, s12
                    point_2d cp2 = {
 8012694:	ed8d 7a10 	vstr	s14, [sp, #64]	; 0x40
                    mc_cubic_b_spline(gc_block.values.xyz, &plan_data, gc_state.position, cp1.values, cp2.values);
 8012698:	ab0f      	add	r3, sp, #60	; 0x3c
 801269a:	9300      	str	r3, [sp, #0]
 801269c:	ab0d      	add	r3, sp, #52	; 0x34
 801269e:	3260      	adds	r2, #96	; 0x60
 80126a0:	a912      	add	r1, sp, #72	; 0x48
 80126a2:	3060      	adds	r0, #96	; 0x60
 80126a4:	f001 fd46 	bl	8014134 <mc_cubic_b_spline>
        pos_update_t gc_update_pos = GCUpdatePos_Target;
 80126a8:	4625      	mov	r5, r4
                break;
 80126aa:	e055      	b.n	8012758 <gc_execute_block+0x3378>
                    protocol_buffer_synchronize(); // Wait until any previous moves are finished.
 80126ac:	f005 fa94 	bl	8017bd8 <protocol_buffer_synchronize>
                    gc_override_flags_t overrides = sys.override.control; // Save current override disable status.
 80126b0:	4b79      	ldr	r3, [pc, #484]	; (8012898 <gc_execute_block+0x34b8>)
 80126b2:	f893 6029 	ldrb.w	r6, [r3, #41]	; 0x29
                    status_code_t status = init_sync_motion(&plan_data, gc_block.values.k);
 80126b6:	4b77      	ldr	r3, [pc, #476]	; (8012894 <gc_execute_block+0x34b4>)
 80126b8:	ed93 0a12 	vldr	s0, [r3, #72]	; 0x48
 80126bc:	a812      	add	r0, sp, #72	; 0x48
 80126be:	f7fc fbb5 	bl	800ee2c <init_sync_motion>
                    if(status != Status_OK)
 80126c2:	4605      	mov	r5, r0
 80126c4:	b110      	cbz	r0, 80126cc <gc_execute_block+0x32ec>
                        FAIL(status);
 80126c6:	4604      	mov	r4, r0
 80126c8:	f7fc bf60 	b.w	800f58c <gc_execute_block+0x1ac>
                    plan_data.spindle.state.synchronized = On;
 80126cc:	f89d 3050 	ldrb.w	r3, [sp, #80]	; 0x50
 80126d0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80126d4:	f88d 3050 	strb.w	r3, [sp, #80]	; 0x50
                    mc_line(gc_block.values.xyz, &plan_data);
 80126d8:	a912      	add	r1, sp, #72	; 0x48
 80126da:	4870      	ldr	r0, [pc, #448]	; (801289c <gc_execute_block+0x34bc>)
 80126dc:	f001 fa6c 	bl	8013bb8 <mc_line>
                    protocol_buffer_synchronize();    // Wait until synchronized move is finished,
 80126e0:	f005 fa7a 	bl	8017bd8 <protocol_buffer_synchronize>
                    sys.override.control = overrides; // then restore previous override disable status.
 80126e4:	4b6c      	ldr	r3, [pc, #432]	; (8012898 <gc_execute_block+0x34b8>)
 80126e6:	f883 6029 	strb.w	r6, [r3, #41]	; 0x29
                break;
 80126ea:	e035      	b.n	8012758 <gc_execute_block+0x3378>
                    protocol_buffer_synchronize(); // Wait until any previous moves are finished.
 80126ec:	f005 fa74 	bl	8017bd8 <protocol_buffer_synchronize>
                    gc_override_flags_t overrides = sys.override.control; // Save current override disable status.
 80126f0:	4b69      	ldr	r3, [pc, #420]	; (8012898 <gc_execute_block+0x34b8>)
 80126f2:	f893 6029 	ldrb.w	r6, [r3, #41]	; 0x29
                    status_code_t status = init_sync_motion(&plan_data, thread.pitch);
 80126f6:	4b6a      	ldr	r3, [pc, #424]	; (80128a0 <gc_execute_block+0x34c0>)
 80126f8:	ed93 0a00 	vldr	s0, [r3]
 80126fc:	a812      	add	r0, sp, #72	; 0x48
 80126fe:	f7fc fb95 	bl	800ee2c <init_sync_motion>
                    if(status != Status_OK)
 8012702:	4605      	mov	r5, r0
 8012704:	b110      	cbz	r0, 801270c <gc_execute_block+0x332c>
                        FAIL(status);
 8012706:	4604      	mov	r4, r0
 8012708:	f7fc bf40 	b.w	800f58c <gc_execute_block+0x1ac>
                    mc_thread(&plan_data, gc_state.position, &thread, overrides.feed_hold_disable);
 801270c:	f3c6 0340 	ubfx	r3, r6, #1, #1
 8012710:	4a63      	ldr	r2, [pc, #396]	; (80128a0 <gc_execute_block+0x34c0>)
 8012712:	4964      	ldr	r1, [pc, #400]	; (80128a4 <gc_execute_block+0x34c4>)
 8012714:	a812      	add	r0, sp, #72	; 0x48
 8012716:	f001 feb7 	bl	8014488 <mc_thread>
                    sys.override.control = overrides; // then restore previous override disable status.
 801271a:	4b5f      	ldr	r3, [pc, #380]	; (8012898 <gc_execute_block+0x34b8>)
 801271c:	f883 6029 	strb.w	r6, [r3, #41]	; 0x29
                break;
 8012720:	e01a      	b.n	8012758 <gc_execute_block+0x3378>
                plan_data.spindle.rpm = gc_block.values.s;
 8012722:	495c      	ldr	r1, [pc, #368]	; (8012894 <gc_execute_block+0x34b4>)
 8012724:	6dcb      	ldr	r3, [r1, #92]	; 0x5c
 8012726:	9313      	str	r3, [sp, #76]	; 0x4c
                gc_state.canned.retract_mode = gc_state.modal.retract_mode;
 8012728:	4b59      	ldr	r3, [pc, #356]	; (8012890 <gc_execute_block+0x34b0>)
 801272a:	7f5a      	ldrb	r2, [r3, #29]
 801272c:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
                mc_canned_drill(gc_state.modal.motion, gc_block.values.xyz, &plan_data, gc_state.position, plane, gc_block.values.l, &gc_state.canned);
 8012730:	f891 2090 	ldrb.w	r2, [r1, #144]	; 0x90
 8012734:	f103 0528 	add.w	r5, r3, #40	; 0x28
 8012738:	9502      	str	r5, [sp, #8]
 801273a:	9201      	str	r2, [sp, #4]
 801273c:	9a20      	ldr	r2, [sp, #128]	; 0x80
 801273e:	f8ad 2000 	strh.w	r2, [sp]
 8012742:	0c12      	lsrs	r2, r2, #16
 8012744:	f88d 2002 	strb.w	r2, [sp, #2]
 8012748:	3360      	adds	r3, #96	; 0x60
 801274a:	aa12      	add	r2, sp, #72	; 0x48
 801274c:	3160      	adds	r1, #96	; 0x60
 801274e:	f002 f873 	bl	8014838 <mc_canned_drill>
        pos_update_t gc_update_pos = GCUpdatePos_Target;
 8012752:	4625      	mov	r5, r4
                break;
 8012754:	e000      	b.n	8012758 <gc_execute_block+0x3378>
        switch(gc_state.modal.motion) {
 8012756:	4625      	mov	r5, r4
        if(sys.cancel)
 8012758:	4b4f      	ldr	r3, [pc, #316]	; (8012898 <gc_execute_block+0x34b8>)
 801275a:	785b      	ldrb	r3, [r3, #1]
 801275c:	b93b      	cbnz	r3, 801276e <gc_execute_block+0x338e>
 801275e:	46aa      	mov	sl, r5
 8012760:	e005      	b.n	801276e <gc_execute_block+0x338e>
        switch(gc_state.modal.motion) {
 8012762:	4625      	mov	r5, r4
 8012764:	e7f8      	b.n	8012758 <gc_execute_block+0x3378>
            free(plan_data.output_commands);
 8012766:	4628      	mov	r0, r5
 8012768:	f00f feaa 	bl	80224c0 <free>
            plan_data.output_commands = next;
 801276c:	951b      	str	r5, [sp, #108]	; 0x6c
        while(plan_data.output_commands) {
 801276e:	9d1b      	ldr	r5, [sp, #108]	; 0x6c
 8012770:	2d00      	cmp	r5, #0
 8012772:	d1f8      	bne.n	8012766 <gc_execute_block+0x3386>
        if (gc_update_pos == GCUpdatePos_Target)
 8012774:	f1ba 0f00 	cmp.w	sl, #0
 8012778:	d105      	bne.n	8012786 <gc_execute_block+0x33a6>
            memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_state.position)); // gc_state.position[] = gc_block.values.xyz[]
 801277a:	4b4a      	ldr	r3, [pc, #296]	; (80128a4 <gc_execute_block+0x34c4>)
 801277c:	4a47      	ldr	r2, [pc, #284]	; (801289c <gc_execute_block+0x34bc>)
 801277e:	ca07      	ldmia	r2, {r0, r1, r2}
 8012780:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 8012784:	e5de      	b.n	8012344 <gc_execute_block+0x2f64>
        else if (gc_update_pos == GCUpdatePos_System)
 8012786:	f1ba 0f01 	cmp.w	sl, #1
 801278a:	f47f addb 	bne.w	8012344 <gc_execute_block+0x2f64>
            gc_sync_position(); // gc_state.position[] = sys.position
 801278e:	4946      	ldr	r1, [pc, #280]	; (80128a8 <gc_execute_block+0x34c8>)
 8012790:	4844      	ldr	r0, [pc, #272]	; (80128a4 <gc_execute_block+0x34c4>)
 8012792:	f00e fc23 	bl	8020fdc <system_convert_array_steps_to_mpos>
 8012796:	e5d5      	b.n	8012344 <gc_execute_block+0x2f64>
        protocol_buffer_synchronize(); // Sync and finish all remaining buffered motions before moving on.
 8012798:	f005 fa1e 	bl	8017bd8 <protocol_buffer_synchronize>
        if(gc_state.modal.program_flow == ProgramFlow_Return) {
 801279c:	4b3c      	ldr	r3, [pc, #240]	; (8012890 <gc_execute_block+0x34b0>)
 801279e:	7e1b      	ldrb	r3, [r3, #24]
 80127a0:	2b63      	cmp	r3, #99	; 0x63
 80127a2:	d06e      	beq.n	8012882 <gc_execute_block+0x34a2>
        } else if(gc_state.modal.program_flow == ProgramFlow_Paused || gc_block.modal.program_flow == ProgramFlow_OptionalStop || gc_block.modal.program_flow == ProgramFlow_CompletedM60 || sys.flags.single_block) {
 80127a4:	2b03      	cmp	r3, #3
 80127a6:	f000 8085 	beq.w	80128b4 <gc_execute_block+0x34d4>
 80127aa:	4b3a      	ldr	r3, [pc, #232]	; (8012894 <gc_execute_block+0x34b4>)
 80127ac:	f893 3020 	ldrb.w	r3, [r3, #32]
 80127b0:	2b01      	cmp	r3, #1
 80127b2:	d07f      	beq.n	80128b4 <gc_execute_block+0x34d4>
 80127b4:	2b3c      	cmp	r3, #60	; 0x3c
 80127b6:	d07d      	beq.n	80128b4 <gc_execute_block+0x34d4>
 80127b8:	4a37      	ldr	r2, [pc, #220]	; (8012898 <gc_execute_block+0x34b8>)
 80127ba:	f992 2016 	ldrsb.w	r2, [r2, #22]
 80127be:	2a00      	cmp	r2, #0
 80127c0:	db78      	blt.n	80128b4 <gc_execute_block+0x34d4>
            if(!check_mode && gc_block.modal.program_flow == ProgramFlow_CompletedM30 && hal.pallet_shuttle)
 80127c2:	9a04      	ldr	r2, [sp, #16]
 80127c4:	2a02      	cmp	r2, #2
 80127c6:	d002      	beq.n	80127ce <gc_execute_block+0x33ee>
 80127c8:	2b1e      	cmp	r3, #30
 80127ca:	f000 808e 	beq.w	80128ea <gc_execute_block+0x350a>
            gc_state.file_run = false;
 80127ce:	4b30      	ldr	r3, [pc, #192]	; (8012890 <gc_execute_block+0x34b0>)
 80127d0:	2200      	movs	r2, #0
 80127d2:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74
            gc_state.modal.motion = MotionMode_Linear;
 80127d6:	2101      	movs	r1, #1
 80127d8:	8019      	strh	r1, [r3, #0]
            gc_block.modal.canned_cycle_active = false;
 80127da:	492e      	ldr	r1, [pc, #184]	; (8012894 <gc_execute_block+0x34b4>)
 80127dc:	f881 2027 	strb.w	r2, [r1, #39]	; 0x27
            gc_state.modal.plane_select = PlaneSelect_XY;
 80127e0:	719a      	strb	r2, [r3, #6]
            gc_state.modal.spindle.rpm_mode = SpindleSpeedMode_RPM; // NOTE: not compliant with linuxcnc (?)
 80127e2:	76da      	strb	r2, [r3, #27]
            gc_state.modal.distance_incremental = false;
 80127e4:	711a      	strb	r2, [r3, #4]
            gc_state.modal.feed_mode = FeedMode_UnitsPerMin;
 80127e6:	709a      	strb	r2, [r3, #2]
            if(gc_state.modal.coord_system.id != CoordinateSystem_G54) {
 80127e8:	7d1b      	ldrb	r3, [r3, #20]
 80127ea:	2b00      	cmp	r3, #0
 80127ec:	f040 8085 	bne.w	80128fa <gc_execute_block+0x351a>
            gc_state.modal.spindle.state = (spindle_state_t){0};
 80127f0:	4b27      	ldr	r3, [pc, #156]	; (8012890 <gc_execute_block+0x34b0>)
 80127f2:	2000      	movs	r0, #0
 80127f4:	7698      	strb	r0, [r3, #26]
            gc_state.modal.coolant = (coolant_state_t){0};
 80127f6:	7658      	strb	r0, [r3, #25]
            gc_state.modal.override_ctrl.feed_rate_disable = Off;
 80127f8:	7f1a      	ldrb	r2, [r3, #28]
 80127fa:	f360 0200 	bfi	r2, r0, #0, #1
 80127fe:	771a      	strb	r2, [r3, #28]
            gc_state.modal.override_ctrl.spindle_rpm_disable = Off;
 8012800:	b2d2      	uxtb	r2, r2
 8012802:	f360 0282 	bfi	r2, r0, #2, #1
 8012806:	771a      	strb	r2, [r3, #28]
                if((spindle = spindle_get(--idx))) {
 8012808:	f00b f8a4 	bl	801d954 <spindle_get>
 801280c:	b168      	cbz	r0, 801282a <gc_execute_block+0x344a>
                    spindle->param->state.override_disable = Off;
 801280e:	6842      	ldr	r2, [r0, #4]
 8012810:	7a11      	ldrb	r1, [r2, #8]
 8012812:	f36f 1104 	bfc	r1, #4, #1
 8012816:	7211      	strb	r1, [r2, #8]
                    if(settings.flags.restore_overrides)
 8012818:	4a24      	ldr	r2, [pc, #144]	; (80128ac <gc_execute_block+0x34cc>)
 801281a:	f892 20fe 	ldrb.w	r2, [r2, #254]	; 0xfe
 801281e:	f012 0f02 	tst.w	r2, #2
 8012822:	d002      	beq.n	801282a <gc_execute_block+0x344a>
                        spindle->param->override_pct = DEFAULT_SPINDLE_RPM_OVERRIDE;
 8012824:	6843      	ldr	r3, [r0, #4]
 8012826:	2264      	movs	r2, #100	; 0x64
 8012828:	60da      	str	r2, [r3, #12]
            if(settings.parking.flags.enabled)
 801282a:	4b20      	ldr	r3, [pc, #128]	; (80128ac <gc_execute_block+0x34cc>)
 801282c:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 8012830:	f013 0f01 	tst.w	r3, #1
 8012834:	d00a      	beq.n	801284c <gc_execute_block+0x346c>
                gc_state.modal.override_ctrl.parking_disable = settings.parking.flags.enable_override_control &&
 8012836:	f003 0306 	and.w	r3, r3, #6
 801283a:	2b06      	cmp	r3, #6
 801283c:	bf14      	ite	ne
 801283e:	2300      	movne	r3, #0
 8012840:	2301      	moveq	r3, #1
 8012842:	4a13      	ldr	r2, [pc, #76]	; (8012890 <gc_execute_block+0x34b0>)
 8012844:	7f11      	ldrb	r1, [r2, #28]
 8012846:	f363 01c3 	bfi	r1, r3, #3, #1
 801284a:	7711      	strb	r1, [r2, #28]
            sys.override.control = gc_state.modal.override_ctrl;
 801284c:	4b10      	ldr	r3, [pc, #64]	; (8012890 <gc_execute_block+0x34b0>)
 801284e:	7f1a      	ldrb	r2, [r3, #28]
 8012850:	4b11      	ldr	r3, [pc, #68]	; (8012898 <gc_execute_block+0x34b8>)
 8012852:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
            if(settings.flags.restore_overrides) {
 8012856:	4b15      	ldr	r3, [pc, #84]	; (80128ac <gc_execute_block+0x34cc>)
 8012858:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 801285c:	f013 0f02 	tst.w	r3, #2
 8012860:	d003      	beq.n	801286a <gc_execute_block+0x348a>
                sys.override.feed_rate = DEFAULT_FEED_OVERRIDE;
 8012862:	4b0d      	ldr	r3, [pc, #52]	; (8012898 <gc_execute_block+0x34b8>)
 8012864:	2264      	movs	r2, #100	; 0x64
 8012866:	61da      	str	r2, [r3, #28]
                sys.override.rapid_rate = DEFAULT_RAPID_OVERRIDE;
 8012868:	621a      	str	r2, [r3, #32]
            if (!check_mode) {
 801286a:	9b04      	ldr	r3, [sp, #16]
 801286c:	2b02      	cmp	r3, #2
 801286e:	d14b      	bne.n	8012908 <gc_execute_block+0x3528>
            if(grbl.on_program_completed)
 8012870:	4b0f      	ldr	r3, [pc, #60]	; (80128b0 <gc_execute_block+0x34d0>)
 8012872:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012874:	2b00      	cmp	r3, #0
 8012876:	d076      	beq.n	8012966 <gc_execute_block+0x3586>
                grbl.on_program_completed(gc_state.modal.program_flow, check_mode);
 8012878:	9909      	ldr	r1, [sp, #36]	; 0x24
 801287a:	4a05      	ldr	r2, [pc, #20]	; (8012890 <gc_execute_block+0x34b0>)
 801287c:	7e10      	ldrb	r0, [r2, #24]
 801287e:	4798      	blx	r3
 8012880:	e071      	b.n	8012966 <gc_execute_block+0x3586>
            if(grbl.on_macro_return)
 8012882:	4b0b      	ldr	r3, [pc, #44]	; (80128b0 <gc_execute_block+0x34d0>)
 8012884:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 8012888:	b31b      	cbz	r3, 80128d2 <gc_execute_block+0x34f2>
                grbl.on_macro_return();
 801288a:	4798      	blx	r3
 801288c:	e021      	b.n	80128d2 <gc_execute_block+0x34f2>
 801288e:	bf00      	nop
 8012890:	20003344 	.word	0x20003344
 8012894:	20003298 	.word	0x20003298
 8012898:	200036c4 	.word	0x200036c4
 801289c:	200032f8 	.word	0x200032f8
 80128a0:	200033e0 	.word	0x200033e0
 80128a4:	200033a4 	.word	0x200033a4
 80128a8:	2000374c 	.word	0x2000374c
 80128ac:	20003b14 	.word	0x20003b14
 80128b0:	2000343c 	.word	0x2000343c
            if(!check_mode) {
 80128b4:	9b04      	ldr	r3, [sp, #16]
 80128b6:	2b02      	cmp	r3, #2
 80128b8:	d00b      	beq.n	80128d2 <gc_execute_block+0x34f2>
                if(gc_block.modal.program_flow == ProgramFlow_CompletedM60 && hal.pallet_shuttle)
 80128ba:	4be3      	ldr	r3, [pc, #908]	; (8012c48 <gc_execute_block+0x3868>)
 80128bc:	f893 3020 	ldrb.w	r3, [r3, #32]
 80128c0:	2b3c      	cmp	r3, #60	; 0x3c
 80128c2:	d00b      	beq.n	80128dc <gc_execute_block+0x34fc>
                system_set_exec_state_flag(EXEC_FEED_HOLD); // Use feed hold for program pause.
 80128c4:	4be1      	ldr	r3, [pc, #900]	; (8012c4c <gc_execute_block+0x386c>)
 80128c6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80128c8:	2108      	movs	r1, #8
 80128ca:	48e1      	ldr	r0, [pc, #900]	; (8012c50 <gc_execute_block+0x3870>)
 80128cc:	4798      	blx	r3
                protocol_execute_realtime(); // Execute suspend.
 80128ce:	f004 febd 	bl	801764c <protocol_execute_realtime>
        gc_state.modal.program_flow = ProgramFlow_Running; // Reset program flow.
 80128d2:	4be0      	ldr	r3, [pc, #896]	; (8012c54 <gc_execute_block+0x3874>)
 80128d4:	2200      	movs	r2, #0
 80128d6:	761a      	strb	r2, [r3, #24]
 80128d8:	f7fc be58 	b.w	800f58c <gc_execute_block+0x1ac>
                if(gc_block.modal.program_flow == ProgramFlow_CompletedM60 && hal.pallet_shuttle)
 80128dc:	4bdb      	ldr	r3, [pc, #876]	; (8012c4c <gc_execute_block+0x386c>)
 80128de:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
 80128e2:	2b00      	cmp	r3, #0
 80128e4:	d0ee      	beq.n	80128c4 <gc_execute_block+0x34e4>
                    hal.pallet_shuttle();
 80128e6:	4798      	blx	r3
 80128e8:	e7ec      	b.n	80128c4 <gc_execute_block+0x34e4>
            if(!check_mode && gc_block.modal.program_flow == ProgramFlow_CompletedM30 && hal.pallet_shuttle)
 80128ea:	4bd8      	ldr	r3, [pc, #864]	; (8012c4c <gc_execute_block+0x386c>)
 80128ec:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
 80128f0:	2b00      	cmp	r3, #0
 80128f2:	f43f af6c 	beq.w	80127ce <gc_execute_block+0x33ee>
                hal.pallet_shuttle();
 80128f6:	4798      	blx	r3
 80128f8:	e769      	b.n	80127ce <gc_execute_block+0x33ee>
                gc_state.modal.coord_system.id = CoordinateSystem_G54;
 80128fa:	4bd6      	ldr	r3, [pc, #856]	; (8012c54 <gc_execute_block+0x3874>)
 80128fc:	751a      	strb	r2, [r3, #20]
                system_add_rt_report(Report_GWCO);
 80128fe:	f44f 7000 	mov.w	r0, #512	; 0x200
 8012902:	f00e fc9d 	bl	8021240 <system_add_rt_report>
 8012906:	e773      	b.n	80127f0 <gc_execute_block+0x3410>
                if (!(settings_read_coord_data(gc_state.modal.coord_system.id, &gc_state.modal.coord_system.xyz)))
 8012908:	4bd2      	ldr	r3, [pc, #840]	; (8012c54 <gc_execute_block+0x3874>)
 801290a:	f103 0108 	add.w	r1, r3, #8
 801290e:	7d18      	ldrb	r0, [r3, #20]
 8012910:	f00a f870 	bl	801c9f4 <settings_read_coord_data>
 8012914:	b1d0      	cbz	r0, 801294c <gc_execute_block+0x356c>
                if(settings_read_coord_data(CoordinateSystem_G92, &g92_offset_stored) && !isequal_position_vector(g92_offset_stored, gc_state.g92_coord_offset))
 8012916:	a90f      	add	r1, sp, #60	; 0x3c
 8012918:	200b      	movs	r0, #11
 801291a:	f00a f86b 	bl	801c9f4 <settings_read_coord_data>
 801291e:	b128      	cbz	r0, 801292c <gc_execute_block+0x354c>
 8012920:	220c      	movs	r2, #12
 8012922:	49cd      	ldr	r1, [pc, #820]	; (8012c58 <gc_execute_block+0x3878>)
 8012924:	a80f      	add	r0, sp, #60	; 0x3c
 8012926:	f010 f916 	bl	8022b56 <memcmp>
 801292a:	b990      	cbnz	r0, 8012952 <gc_execute_block+0x3572>
                system_flag_wco_change(); // Set to refresh immediately just in case something altered.
 801292c:	f00e fce6 	bl	80212fc <system_flag_wco_change>
                spindle_all_off();
 8012930:	f00b f9fe 	bl	801dd30 <spindle_all_off>
                hal.coolant.set_state(gc_state.modal.coolant);
 8012934:	4bc5      	ldr	r3, [pc, #788]	; (8012c4c <gc_execute_block+0x386c>)
 8012936:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8012938:	4ac6      	ldr	r2, [pc, #792]	; (8012c54 <gc_execute_block+0x3874>)
 801293a:	7e50      	ldrb	r0, [r2, #25]
 801293c:	4798      	blx	r3
                system_add_rt_report(Report_Spindle); // Set to report change
 801293e:	2010      	movs	r0, #16
 8012940:	f00e fc7e 	bl	8021240 <system_add_rt_report>
                system_add_rt_report(Report_Coolant); // immediately.
 8012944:	2020      	movs	r0, #32
 8012946:	f00e fc7b 	bl	8021240 <system_add_rt_report>
 801294a:	e791      	b.n	8012870 <gc_execute_block+0x3490>
                    FAIL(Status_SettingReadFail);
 801294c:	2407      	movs	r4, #7
 801294e:	f7fc be1d 	b.w	800f58c <gc_execute_block+0x1ac>
                    settings_write_coord_data(CoordinateSystem_G92, &gc_state.g92_coord_offset); // Save G92 offsets to non-volatile storage
 8012952:	49c1      	ldr	r1, [pc, #772]	; (8012c58 <gc_execute_block+0x3878>)
 8012954:	200b      	movs	r0, #11
 8012956:	f00a f829 	bl	801c9ac <settings_write_coord_data>
 801295a:	e7e7      	b.n	801292c <gc_execute_block+0x354c>
                output_command_t *next = output_commands->next;
 801295c:	6885      	ldr	r5, [r0, #8]
                free(output_commands);
 801295e:	f00f fdaf 	bl	80224c0 <free>
                output_commands = next;
 8012962:	4bbe      	ldr	r3, [pc, #760]	; (8012c5c <gc_execute_block+0x387c>)
 8012964:	601d      	str	r5, [r3, #0]
            while(output_commands) {
 8012966:	4bbd      	ldr	r3, [pc, #756]	; (8012c5c <gc_execute_block+0x387c>)
 8012968:	6818      	ldr	r0, [r3, #0]
 801296a:	2800      	cmp	r0, #0
 801296c:	d1f6      	bne.n	801295c <gc_execute_block+0x357c>
            grbl.report.feedback_message(Message_ProgramEnd);
 801296e:	4bbc      	ldr	r3, [pc, #752]	; (8012c60 <gc_execute_block+0x3880>)
 8012970:	68db      	ldr	r3, [r3, #12]
 8012972:	2008      	movs	r0, #8
 8012974:	4798      	blx	r3
 8012976:	e7ac      	b.n	80128d2 <gc_execute_block+0x34f2>
            FAIL(Status_ExpectedCommandLetter); // [Expected word letter]
 8012978:	2401      	movs	r4, #1
 801297a:	f7fc be07 	b.w	800f58c <gc_execute_block+0x1ac>
 801297e:	2401      	movs	r4, #1
 8012980:	f7fc be04 	b.w	800f58c <gc_execute_block+0x1ac>
                FAIL(Status_BadNumberFormat);   // [Expected word value]
 8012984:	2402      	movs	r4, #2
 8012986:	f7fc be01 	b.w	800f58c <gc_execute_block+0x1ac>
 801298a:	2414      	movs	r4, #20
 801298c:	f7fc bdfe 	b.w	800f58c <gc_execute_block+0x1ac>
 8012990:	2414      	movs	r4, #20
 8012992:	f7fc bdfb 	b.w	800f58c <gc_execute_block+0x1ac>
 8012996:	2414      	movs	r4, #20
 8012998:	f7fc bdf8 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeUnsupportedCommand); // [G7 & G8 not supported]
 801299c:	2414      	movs	r4, #20
 801299e:	f7fc bdf5 	b.w	800f58c <gc_execute_block+0x1ac>
                                FAIL(Status_GcodeAxisCommandConflict); // [Axis word/command conflict]
 80129a2:	2418      	movs	r4, #24
 80129a4:	f7fc bdf2 	b.w	800f58c <gc_execute_block+0x1ac>
                                FAIL(Status_GcodeUnsupportedCommand);
 80129a8:	2414      	movs	r4, #20
 80129aa:	f7fc bdef 	b.w	800f58c <gc_execute_block+0x1ac>
                        } else if (int_value == 92) {
 80129ae:	2414      	movs	r4, #20
 80129b0:	f7fc bdec 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeUnsupportedCommand); // [G33.1 not yet supported]
 80129b4:	2414      	movs	r4, #20
 80129b6:	f7fc bde9 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeAxisCommandConflict); // [Axis word/command conflict]
 80129ba:	2418      	movs	r4, #24
 80129bc:	f7fc bde6 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeUnsupportedCommand); // [probing not supported by driver or unsupported G38.x command]
 80129c0:	2414      	movs	r4, #20
 80129c2:	f7fc bde3 	b.w	800f58c <gc_execute_block+0x1ac>
                        if(!(hal.probe.get_state && ((mantissa == 20) || (mantissa == 30) || (mantissa == 40) || (mantissa == 50))))
 80129c6:	2414      	movs	r4, #20
 80129c8:	f7fc bde0 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeAxisCommandConflict); // [Axis word/command conflict]
 80129cc:	2418      	movs	r4, #24
 80129ce:	f7fc bddd 	b.w	800f58c <gc_execute_block+0x1ac>
                                FAIL(Status_GcodeUnsupportedCommand);
 80129d2:	2414      	movs	r4, #20
 80129d4:	f7fc bdda 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeAxisCommandConflict); // [Axis word/command conflict]
 80129d8:	2418      	movs	r4, #24
 80129da:	f7fc bdd7 	b.w	800f58c <gc_execute_block+0x1ac>
                                FAIL(Status_GcodeUnsupportedCommand); // [G90.1 not supported]
 80129de:	2414      	movs	r4, #20
 80129e0:	f7fc bdd4 	b.w	800f58c <gc_execute_block+0x1ac>
 80129e4:	2414      	movs	r4, #20
 80129e6:	f7fc bdd1 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeUnsupportedCommand); // [Unsupported G43.x command]
 80129ea:	2414      	movs	r4, #20
 80129ec:	f7fc bdce 	b.w	800f58c <gc_execute_block+0x1ac>
                                FAIL(Status_GcodeAxisCommandConflict); // [Axis word/command conflict] }
 80129f0:	2418      	movs	r4, #24
 80129f2:	f7fc bdcb 	b.w	800f58c <gc_execute_block+0x1ac>
                        if(int_value == 59 && mantissa > 0) {
 80129f6:	2414      	movs	r4, #20
 80129f8:	f7fc bdc8 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeUnsupportedCommand);
 80129fc:	2414      	movs	r4, #20
 80129fe:	f7fc bdc5 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeUnsupportedCommand);
 8012a02:	2414      	movs	r4, #20
 8012a04:	f7fc bdc2 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_GcodeCommandValueNotInteger); // [Unsupported or invalid Gxx.x command]
 8012a08:	2417      	movs	r4, #23
 8012a0a:	f7fc bdbf 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_GcodeModalGroupViolation);
 8012a0e:	2415      	movs	r4, #21
 8012a10:	f7fc bdbc 	b.w	800f58c <gc_execute_block+0x1ac>
                        FAIL(Status_GcodeWordRepeated); // [Word repeated]
 8012a14:	2419      	movs	r4, #25
 8012a16:	f7fc bdb9 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_GcodeCommandValueNotInteger); // [No Mxx.x commands]
 8012a1a:	2417      	movs	r4, #23
 8012a1c:	f7fc bdb6 	b.w	800f58c <gc_execute_block+0x1ac>
                                    FAIL(Status_GcodeUnsupportedCommand);
 8012a20:	2414      	movs	r4, #20
 8012a22:	f7fc bdb3 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeUnsupportedCommand); // [Unsupported M command]
 8012a26:	2414      	movs	r4, #20
 8012a28:	f7fc bdb0 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeUnsupportedCommand); // [Unsupported M command]
 8012a2c:	2414      	movs	r4, #20
 8012a2e:	f7fc bdad 	b.w	800f58c <gc_execute_block+0x1ac>
 8012a32:	2414      	movs	r4, #20
 8012a34:	f7fc bdaa 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeUnsupportedCommand); // [Unsupported M command]
 8012a38:	2414      	movs	r4, #20
 8012a3a:	f7fc bda7 	b.w	800f58c <gc_execute_block+0x1ac>
 8012a3e:	2414      	movs	r4, #20
 8012a40:	f7fc bda4 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeUnsupportedCommand); // [Unsupported M command]
 8012a44:	2414      	movs	r4, #20
 8012a46:	f7fc bda1 	b.w	800f58c <gc_execute_block+0x1ac>
 8012a4a:	2414      	movs	r4, #20
 8012a4c:	f7fc bd9e 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeUnsupportedCommand);
 8012a50:	2414      	movs	r4, #20
 8012a52:	f7fc bd9b 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_GcodeModalGroupViolation);
 8012a56:	2415      	movs	r4, #21
 8012a58:	f7fc bd98 	b.w	800f58c <gc_execute_block+0x1ac>
 8012a5c:	2414      	movs	r4, #20
 8012a5e:	f7fc bd95 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeCommandValueNotInteger);
 8012a62:	2417      	movs	r4, #23
 8012a64:	f7fc bd92 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeCommandValueNotInteger);
 8012a68:	2417      	movs	r4, #23
 8012a6a:	f7fc bd8f 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeCommandValueNotInteger);
 8012a6e:	2417      	movs	r4, #23
 8012a70:	f7fc bd8c 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeCommandValueNotInteger);
 8012a74:	2417      	movs	r4, #23
 8012a76:	f7fc bd89 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeIllegalToolTableEntry);
 8012a7a:	2426      	movs	r4, #38	; 0x26
 8012a7c:	f7fc bd86 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeCommandValueNotInteger);
 8012a80:	2417      	movs	r4, #23
 8012a82:	f7fc bd83 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_GcodeWordRepeated); // [Word repeated]
 8012a86:	2419      	movs	r4, #25
 8012a88:	f7fc bd80 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_NegativeValue); // [Word value cannot be negative]
 8012a8c:	2404      	movs	r4, #4
 8012a8e:	f7fc bd7d 	b.w	800f58c <gc_execute_block+0x1ac>
        FAIL(Status_GcodeInvalidLineNumber); // [Exceeds max line number]
 8012a92:	241b      	movs	r4, #27
 8012a94:	f7fc bd7a 	b.w	800f58c <gc_execute_block+0x1ac>
            FAIL(Status_GcodeUndefinedFeedRate);
 8012a98:	2416      	movs	r4, #22
 8012a9a:	f7fc bd77 	b.w	800f58c <gc_execute_block+0x1ac>
                FAIL(Status_GcodeValueOutOfRange);
 8012a9e:	2427      	movs	r4, #39	; 0x27
 8012aa0:	f7fc bd74 	b.w	800f58c <gc_execute_block+0x1ac>
                FAIL(Status_GcodeUnsupportedCommand);
 8012aa4:	2414      	movs	r4, #20
 8012aa6:	f7fc bd71 	b.w	800f58c <gc_execute_block+0x1ac>
                FAIL(Status_GcodeValueWordMissing);
 8012aaa:	241c      	movs	r4, #28
 8012aac:	f7fc bd6e 	b.w	800f58c <gc_execute_block+0x1ac>
            FAIL(Status_GcodeValueWordMissing);
 8012ab0:	241c      	movs	r4, #28
 8012ab2:	f7fc bd6b 	b.w	800f58c <gc_execute_block+0x1ac>
            FAIL(Status_GcodeCommandValueNotInteger);
 8012ab6:	2417      	movs	r4, #23
 8012ab8:	f7fc bd68 	b.w	800f58c <gc_execute_block+0x1ac>
            FAIL(Status_GcodeIllegalToolTableEntry);
 8012abc:	2426      	movs	r4, #38	; 0x26
 8012abe:	f7fc bd65 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_GcodeValueWordMissing);
 8012ac2:	241c      	movs	r4, #28
 8012ac4:	f7fc bd62 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_NegativeValue);
 8012ac8:	2404      	movs	r4, #4
 8012aca:	f7fc bd5f 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_GcodeValueOutOfRange);
 8012ace:	2427      	movs	r4, #39	; 0x27
 8012ad0:	f7fc bd5c 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_GcodeValueWordMissing);
 8012ad4:	241c      	movs	r4, #28
 8012ad6:	f7fc bd59 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_ValueWordConflict);
 8012ada:	2430      	movs	r4, #48	; 0x30
 8012adc:	f7fc bd56 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_GcodeValueOutOfRange);
 8012ae0:	2427      	movs	r4, #39	; 0x27
 8012ae2:	f7fc bd53 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_GcodeValueOutOfRange);
 8012ae6:	2427      	movs	r4, #39	; 0x27
 8012ae8:	f7fc bd50 	b.w	800f58c <gc_execute_block+0x1ac>
                        FAIL(Status_NegativeValue);
 8012aec:	2404      	movs	r4, #4
 8012aee:	f7fc bd4d 	b.w	800f58c <gc_execute_block+0x1ac>
                        FAIL(Status_GcodeValueOutOfRange);
 8012af2:	2427      	movs	r4, #39	; 0x27
 8012af4:	f7fc bd4a 	b.w	800f58c <gc_execute_block+0x1ac>
                        FAIL(Status_GcodeValueOutOfRange);
 8012af8:	2427      	movs	r4, #39	; 0x27
 8012afa:	f7fc bd47 	b.w	800f58c <gc_execute_block+0x1ac>
                        FAIL(Status_GcodeValueOutOfRange);
 8012afe:	2427      	movs	r4, #39	; 0x27
 8012b00:	f7fc bd44 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_GcodeValueWordMissing);
 8012b04:	241c      	movs	r4, #28
 8012b06:	f7fc bd41 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_GcodeRPMOutOfRange);
 8012b0a:	242c      	movs	r4, #44	; 0x2c
 8012b0c:	f7fc bd3e 	b.w	800f58c <gc_execute_block+0x1ac>
            FAIL(Status_GcodeUnsupportedCommand);
 8012b10:	2414      	movs	r4, #20
 8012b12:	f7fc bd3b 	b.w	800f58c <gc_execute_block+0x1ac>
                FAIL(Status_NegativeValue);
 8012b16:	2404      	movs	r4, #4
 8012b18:	f7fc bd38 	b.w	800f58c <gc_execute_block+0x1ac>
            FAIL(Status_GcodeValueWordMissing); // [P word missing]
 8012b1c:	241c      	movs	r4, #28
 8012b1e:	f7fc bd35 	b.w	800f58c <gc_execute_block+0x1ac>
                FAIL(Status_GcodeNoAxisWords); // [No axis words]
 8012b22:	241a      	movs	r4, #26
 8012b24:	f7fc bd32 	b.w	800f58c <gc_execute_block+0x1ac>
                FAIL(Status_GcodeNoAxisWords); // [No axis words (or R word for tool offsets)]
 8012b28:	241a      	movs	r4, #26
 8012b2a:	f7fc bd2f 	b.w	800f58c <gc_execute_block+0x1ac>
 8012b2e:	241a      	movs	r4, #26
 8012b30:	f7fc bd2c 	b.w	800f58c <gc_execute_block+0x1ac>
                FAIL(Status_GcodeValueWordMissing); // [P/L word missing]
 8012b34:	241c      	movs	r4, #28
 8012b36:	f7fc bd29 	b.w	800f58c <gc_execute_block+0x1ac>
                FAIL(Status_NegativeValue);
 8012b3a:	2404      	movs	r4, #4
 8012b3c:	f7fc bd26 	b.w	800f58c <gc_execute_block+0x1ac>
                        FAIL(Status_GcodeUnsupportedCommand); // [G10 L2 R not supported]
 8012b40:	2414      	movs	r4, #20
 8012b42:	f7fc bd23 	b.w	800f58c <gc_execute_block+0x1ac>
                        FAIL(Status_GcodeUnsupportedCoordSys); // [Greater than N sys]
 8012b46:	241d      	movs	r4, #29
 8012b48:	f7fc bd20 	b.w	800f58c <gc_execute_block+0x1ac>
                        FAIL(Status_SettingReadFail); // [non-volatile storage read fail]
 8012b4c:	2407      	movs	r4, #7
 8012b4e:	f7fc bd1d 	b.w	800f58c <gc_execute_block+0x1ac>
                FAIL(Status_GcodeNoAxisWords); // [No axis words]
 8012b52:	241a      	movs	r4, #26
 8012b54:	f7fc bd1a 	b.w	800f58c <gc_execute_block+0x1ac>
                        FAIL(Status_SettingReadFail);
 8012b58:	2407      	movs	r4, #7
 8012b5a:	f7fc bd17 	b.w	800f58c <gc_execute_block+0x1ac>
                        FAIL(Status_GcodeValueWordMissing); // [P word missing]
 8012b5e:	241c      	movs	r4, #28
 8012b60:	f7fc bd14 	b.w	800f58c <gc_execute_block+0x1ac>
                        FAIL(Status_GcodeValueOutOfRange); // [P word out of range]
 8012b64:	2427      	movs	r4, #39	; 0x27
 8012b66:	f7fc bd11 	b.w	800f58c <gc_execute_block+0x1ac>
            FAIL(Status_GcodeAxisWordsExist);
 8012b6a:	241f      	movs	r4, #31
 8012b6c:	f7fc bd0e 	b.w	800f58c <gc_execute_block+0x1ac>
                 FAIL(Status_GcodeSpindleNotRunning);
 8012b70:	2429      	movs	r4, #41	; 0x29
 8012b72:	f7fc bd0b 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_GcodeUnsupportedCommand); // [G33, G33.1]
 8012b76:	2414      	movs	r4, #20
 8012b78:	f7fc bd08 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_GcodeValueOutOfRange); // [No distance (pitch) given]
 8012b7c:	2427      	movs	r4, #39	; 0x27
 8012b7e:	f7fc bd05 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_GcodeUnsupportedCommand); // [G76 not supported]
 8012b82:	2414      	movs	r4, #20
 8012b84:	f7fc bd02 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_GcodeIllegalPlane); // [Plane not ZX]
 8012b88:	242a      	movs	r4, #42	; 0x2a
 8012b8a:	f7fc bcff 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_GcodeUnusedWords); // [Only X and Z axis words allowed]
 8012b8e:	2424      	movs	r4, #36	; 0x24
 8012b90:	f7fc bcfc 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_GcodeValueOutOfRange);
 8012b94:	2427      	movs	r4, #39	; 0x27
 8012b96:	f7fc bcf9 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_GcodeValueWordMissing);
 8012b9a:	241c      	movs	r4, #28
 8012b9c:	f7fc bcf6 	b.w	800f58c <gc_execute_block+0x1ac>
 8012ba0:	241c      	movs	r4, #28
 8012ba2:	f7fc bcf3 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_NegativeValue);
 8012ba6:	2404      	movs	r4, #4
 8012ba8:	f7fc bcf0 	b.w	800f58c <gc_execute_block+0x1ac>
 8012bac:	2404      	movs	r4, #4
 8012bae:	f7fc bced 	b.w	800f58c <gc_execute_block+0x1ac>
 8012bb2:	2404      	movs	r4, #4
 8012bb4:	f7fc bcea 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_GcodeValueOutOfRange);
 8012bb8:	2427      	movs	r4, #39	; 0x27
 8012bba:	f7fc bce7 	b.w	800f58c <gc_execute_block+0x1ac>
 8012bbe:	2427      	movs	r4, #39	; 0x27
 8012bc0:	f7fc bce4 	b.w	800f58c <gc_execute_block+0x1ac>
 8012bc4:	2427      	movs	r4, #39	; 0x27
 8012bc6:	f7fc bce1 	b.w	800f58c <gc_execute_block+0x1ac>
 8012bca:	2427      	movs	r4, #39	; 0x27
 8012bcc:	f7fc bcde 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_GcodeRPMOutOfRange);
 8012bd0:	242c      	movs	r4, #44	; 0x2c
 8012bd2:	f7fc bcdb 	b.w	800f58c <gc_execute_block+0x1ac>
 8012bd6:	242c      	movs	r4, #44	; 0x2c
 8012bd8:	f7fc bcd8 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_GcodeValueOutOfRange);
 8012bdc:	2427      	movs	r4, #39	; 0x27
 8012bde:	f7fc bcd5 	b.w	800f58c <gc_execute_block+0x1ac>
                FAIL(Status_GcodeUndefinedFeedRate); // [Feed rate undefined]
 8012be2:	2416      	movs	r4, #22
 8012be4:	f7fc bcd2 	b.w	800f58c <gc_execute_block+0x1ac>
                        FAIL(Status_InvalidStatement);
 8012be8:	2403      	movs	r4, #3
 8012bea:	f7fc bccf 	b.w	800f58c <gc_execute_block+0x1ac>
                        FAIL(Status_GcodeValueWordMissing);
 8012bee:	241c      	movs	r4, #28
 8012bf0:	f7fc bccc 	b.w	800f58c <gc_execute_block+0x1ac>
                        FAIL(Status_GcodeValueWordMissing);
 8012bf4:	241c      	movs	r4, #28
 8012bf6:	f7fc bcc9 	b.w	800f58c <gc_execute_block+0x1ac>
                    FAIL(Status_GcodeInvalidRetractPosition);
 8012bfa:	2436      	movs	r4, #54	; 0x36
 8012bfc:	f7fc bcc6 	b.w	800f58c <gc_execute_block+0x1ac>
                                FAIL(Status_NegativeValue);
 8012c00:	2404      	movs	r4, #4
 8012c02:	f7fc bcc3 	b.w	800f58c <gc_execute_block+0x1ac>
                                FAIL(Status_NegativeValue); // [Q <= 0]
 8012c06:	2404      	movs	r4, #4
 8012c08:	f7fc bcc0 	b.w	800f58c <gc_execute_block+0x1ac>
                        FAIL(Status_GcodeNoAxisWords); // [No axis words]
 8012c0c:	241a      	movs	r4, #26
 8012c0e:	f7fc bcbd 	b.w	800f58c <gc_execute_block+0x1ac>
                        FAIL(Status_GcodeNoAxisWordsInPlane); // [No axis words in plane]
 8012c12:	2420      	movs	r4, #32
 8012c14:	f7fc bcba 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeCommandValueNotInteger); // [P word is not an integer]
 8012c18:	2417      	movs	r4, #23
 8012c1a:	f7fc bcb7 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeValueOutOfRange); // [P word is 0]
 8012c1e:	2427      	movs	r4, #39	; 0x27
 8012c20:	f7fc bcb4 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeInvalidTarget); // [Invalid target]
 8012c24:	2421      	movs	r4, #33	; 0x21
 8012c26:	f7fc bcb1 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeArcRadiusError); // [Arc radius error]
 8012c2a:	2422      	movs	r4, #34	; 0x22
 8012c2c:	f7fc bcae 	b.w	800f58c <gc_execute_block+0x1ac>
                            FAIL(Status_GcodeNoOffsetsInPlane);// [No offsets in plane]
 8012c30:	2423      	movs	r4, #35	; 0x23
 8012c32:	f7fc bcab 	b.w	800f58c <gc_execute_block+0x1ac>
                                FAIL(Status_GcodeInvalidTarget); // [Arc definition error] > 0.5mm
 8012c36:	2421      	movs	r4, #33	; 0x21
 8012c38:	f7fc bca8 	b.w	800f58c <gc_execute_block+0x1ac>
                        FAIL(Status_GcodeIllegalPlane); // [The active plane is not G17]
 8012c3c:	242a      	movs	r4, #42	; 0x2a
 8012c3e:	f7fc bca5 	b.w	800f58c <gc_execute_block+0x1ac>
                        FAIL(Status_GcodeAxisCommandConflict); // [An axis other than X or Y is specified]
 8012c42:	2418      	movs	r4, #24
 8012c44:	f7fc bca2 	b.w	800f58c <gc_execute_block+0x1ac>
 8012c48:	20003298 	.word	0x20003298
 8012c4c:	2000350c 	.word	0x2000350c
 8012c50:	2000370c 	.word	0x2000370c
 8012c54:	20003344 	.word	0x20003344
 8012c58:	200033c0 	.word	0x200033c0
 8012c5c:	200033dc 	.word	0x200033dc
 8012c60:	2000343c 	.word	0x2000343c
                        FAIL(Status_GcodeValueWordMissing); // [P and Q are not both specified]
 8012c64:	241c      	movs	r4, #28
 8012c66:	f7fc bc91 	b.w	800f58c <gc_execute_block+0x1ac>
                        FAIL(Status_GcodeValueWordMissing); // [I or J are unspecified in the first of a series of G5 commands]
 8012c6a:	241c      	movs	r4, #28
 8012c6c:	f7fc bc8e 	b.w	800f58c <gc_execute_block+0x1ac>
                        FAIL(Status_GcodeIllegalPlane); // [The active plane is not G17]
 8012c70:	242a      	movs	r4, #42	; 0x2a
 8012c72:	f7fc bc8b 	b.w	800f58c <gc_execute_block+0x1ac>
                        FAIL(Status_GcodeAxisCommandConflict); // [An axis other than X or Y is specified]
 8012c76:	2418      	movs	r4, #24
 8012c78:	f7fc bc88 	b.w	800f58c <gc_execute_block+0x1ac>
                        FAIL(Status_GcodeValueWordMissing); // [I or J are unspecified]
 8012c7c:	241c      	movs	r4, #28
 8012c7e:	f7fc bc85 	b.w	800f58c <gc_execute_block+0x1ac>
                        FAIL(Status_GcodeValueOutOfRange); // [I or J are zero]
 8012c82:	2427      	movs	r4, #39	; 0x27
 8012c84:	f7fc bc82 	b.w	800f58c <gc_execute_block+0x1ac>
                        FAIL(Status_GcodeNoAxisWords); // [No axis words]
 8012c88:	241a      	movs	r4, #26
 8012c8a:	f7fc bc7f 	b.w	800f58c <gc_execute_block+0x1ac>
        FAIL(Status_GcodeUnusedWords); // [Unused words]
 8012c8e:	2424      	movs	r4, #36	; 0x24
 8012c90:	f7fc bc7c 	b.w	800f58c <gc_execute_block+0x1ac>
            FAIL(Status_InvalidJogCommand);
 8012c94:	2410      	movs	r4, #16
 8012c96:	f7fc bc79 	b.w	800f58c <gc_execute_block+0x1ac>
            FAIL(Status_InvalidJogCommand);
 8012c9a:	2410      	movs	r4, #16
 8012c9c:	f7fc bc76 	b.w	800f58c <gc_execute_block+0x1ac>

08012ca0 <dummy_bool_handler>:
#endif

void dummy_bool_handler (bool arg)
{
    // NOOP
}
 8012ca0:	4770      	bx	lr

08012ca2 <dummy_irq_claim>:
}

static bool dummy_irq_claim (irq_type_t irq, uint_fast8_t id, irq_callback_ptr callback)
{
    return false;
}
 8012ca2:	2000      	movs	r0, #0
 8012ca4:	4770      	bx	lr
	...

08012ca8 <auto_realtime_report>:

    report_message(msg, Message_Plain);
}

static void auto_realtime_report (sys_state_t state)
{
 8012ca8:	b510      	push	{r4, lr}
 8012caa:	4604      	mov	r4, r0
    static uint32_t ms = 0;

    if(sys.flags.auto_reporting) {
 8012cac:	4b0d      	ldr	r3, [pc, #52]	; (8012ce4 <auto_realtime_report+0x3c>)
 8012cae:	7ddb      	ldrb	r3, [r3, #23]
 8012cb0:	f013 0f02 	tst.w	r3, #2
 8012cb4:	d011      	beq.n	8012cda <auto_realtime_report+0x32>

        uint32_t t = hal.get_elapsed_ticks();
 8012cb6:	4b0c      	ldr	r3, [pc, #48]	; (8012ce8 <auto_realtime_report+0x40>)
 8012cb8:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 8012cbc:	4798      	blx	r3

        if(t - ms >= settings.report_interval) {
 8012cbe:	4b0b      	ldr	r3, [pc, #44]	; (8012cec <auto_realtime_report+0x44>)
 8012cc0:	681b      	ldr	r3, [r3, #0]
 8012cc2:	1ac3      	subs	r3, r0, r3
 8012cc4:	4a0a      	ldr	r2, [pc, #40]	; (8012cf0 <auto_realtime_report+0x48>)
 8012cc6:	8a92      	ldrh	r2, [r2, #20]
 8012cc8:	4293      	cmp	r3, r2
 8012cca:	d306      	bcc.n	8012cda <auto_realtime_report+0x32>
            ms = t;
 8012ccc:	4b07      	ldr	r3, [pc, #28]	; (8012cec <auto_realtime_report+0x44>)
 8012cce:	6018      	str	r0, [r3, #0]
            system_set_exec_state_flag(EXEC_STATUS_REPORT);
 8012cd0:	4b05      	ldr	r3, [pc, #20]	; (8012ce8 <auto_realtime_report+0x40>)
 8012cd2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8012cd4:	2101      	movs	r1, #1
 8012cd6:	4807      	ldr	r0, [pc, #28]	; (8012cf4 <auto_realtime_report+0x4c>)
 8012cd8:	4798      	blx	r3
        }
    }

    on_execute_realtime(state);
 8012cda:	4b07      	ldr	r3, [pc, #28]	; (8012cf8 <auto_realtime_report+0x50>)
 8012cdc:	681b      	ldr	r3, [r3, #0]
 8012cde:	4620      	mov	r0, r4
 8012ce0:	4798      	blx	r3
}
 8012ce2:	bd10      	pop	{r4, pc}
 8012ce4:	200036c4 	.word	0x200036c4
 8012ce8:	2000350c 	.word	0x2000350c
 8012cec:	200036bc 	.word	0x200036bc
 8012cf0:	20003b14 	.word	0x20003b14
 8012cf4:	2000370c 	.word	0x2000370c
 8012cf8:	200036c0 	.word	0x200036c0

08012cfc <reset_handler>:
{
 8012cfc:	b508      	push	{r3, lr}
    report_init_fns();
 8012cfe:	f008 fc61 	bl	801b5c4 <report_init_fns>
    grbl.on_macro_return = NULL;
 8012d02:	4b02      	ldr	r3, [pc, #8]	; (8012d0c <reset_handler+0x10>)
 8012d04:	2200      	movs	r2, #0
 8012d06:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
}
 8012d0a:	bd08      	pop	{r3, pc}
 8012d0c:	2000343c 	.word	0x2000343c

08012d10 <report_driver_error>:
{
 8012d10:	b510      	push	{r4, lr}
 8012d12:	b08a      	sub	sp, #40	; 0x28
    driver.ok = ~driver.ok;
 8012d14:	4b13      	ldr	r3, [pc, #76]	; (8012d64 <report_driver_error+0x54>)
 8012d16:	f893 e000 	ldrb.w	lr, [r3]
 8012d1a:	ea6f 0e0e 	mvn.w	lr, lr
 8012d1e:	fa5f fe8e 	uxtb.w	lr, lr
 8012d22:	f883 e000 	strb.w	lr, [r3]
    strcpy(msg, "Fatal: Incompatible driver (");
 8012d26:	46ec      	mov	ip, sp
 8012d28:	4c0f      	ldr	r4, [pc, #60]	; (8012d68 <report_driver_error+0x58>)
 8012d2a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8012d2c:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 8012d30:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 8012d34:	e8ac 0007 	stmia.w	ip!, {r0, r1, r2}
 8012d38:	f88c 3000 	strb.w	r3, [ip]
    strcat(msg, uitoa(driver.ok));
 8012d3c:	4670      	mov	r0, lr
 8012d3e:	f002 fd1b 	bl	8015778 <uitoa>
 8012d42:	4601      	mov	r1, r0
 8012d44:	4668      	mov	r0, sp
 8012d46:	f00f ff1e 	bl	8022b86 <strcat>
    strcat(msg, ")");
 8012d4a:	4668      	mov	r0, sp
 8012d4c:	f7f5 f982 	bl	8008054 <strlen>
 8012d50:	4b06      	ldr	r3, [pc, #24]	; (8012d6c <report_driver_error+0x5c>)
 8012d52:	881b      	ldrh	r3, [r3, #0]
 8012d54:	f82d 3000 	strh.w	r3, [sp, r0]
    report_message(msg, Message_Plain);
 8012d58:	2100      	movs	r1, #0
 8012d5a:	4668      	mov	r0, sp
 8012d5c:	f006 fa64 	bl	8019228 <report_message>
}
 8012d60:	b00a      	add	sp, #40	; 0x28
 8012d62:	bd10      	pop	{r4, pc}
 8012d64:	20000400 	.word	0x20000400
 8012d68:	080269f4 	.word	0x080269f4
 8012d6c:	08026a14 	.word	0x08026a14

08012d70 <grbl_enter>:

// main entry point

int grbl_enter (void)
{
 8012d70:	b570      	push	{r4, r5, r6, lr}
    assert(NVS_ADDR_STARTUP_BLOCK + N_STARTUP_LINE * (sizeof(stored_line_t) + NVS_CRC_BYTES) < NVS_ADDR_BUILD_INFO);

    bool looping = true;

    // Clear all and set some core function pointers
    memset(&grbl, 0, sizeof(grbl_t));
 8012d72:	4c84      	ldr	r4, [pc, #528]	; (8012f84 <grbl_enter+0x214>)
 8012d74:	22d0      	movs	r2, #208	; 0xd0
 8012d76:	2100      	movs	r1, #0
 8012d78:	4620      	mov	r0, r4
 8012d7a:	f00f fefc 	bl	8022b76 <memset>
    grbl.on_execute_realtime = grbl.on_execute_delay = protocol_execute_noop;
 8012d7e:	4b82      	ldr	r3, [pc, #520]	; (8012f88 <grbl_enter+0x218>)
 8012d80:	63a3      	str	r3, [r4, #56]	; 0x38
 8012d82:	6363      	str	r3, [r4, #52]	; 0x34
    grbl.enqueue_gcode = protocol_enqueue_gcode;
 8012d84:	4b81      	ldr	r3, [pc, #516]	; (8012f8c <grbl_enter+0x21c>)
 8012d86:	f8c4 30c0 	str.w	r3, [r4, #192]	; 0xc0
    grbl.enqueue_realtime_command = stream_enqueue_realtime_command;
 8012d8a:	4b81      	ldr	r3, [pc, #516]	; (8012f90 <grbl_enter+0x220>)
 8012d8c:	f8c4 30c4 	str.w	r3, [r4, #196]	; 0xc4
    grbl.on_report_options = dummy_bool_handler;
 8012d90:	4b80      	ldr	r3, [pc, #512]	; (8012f94 <grbl_enter+0x224>)
 8012d92:	6423      	str	r3, [r4, #64]	; 0x40
    grbl.on_report_command_help = system_command_help;
 8012d94:	4b80      	ldr	r3, [pc, #512]	; (8012f98 <grbl_enter+0x228>)
 8012d96:	6463      	str	r3, [r4, #68]	; 0x44
    grbl.on_get_alarms = alarms_get_details;
 8012d98:	4b80      	ldr	r3, [pc, #512]	; (8012f9c <grbl_enter+0x22c>)
 8012d9a:	6523      	str	r3, [r4, #80]	; 0x50
    grbl.on_get_errors = errors_get_details;
 8012d9c:	4b80      	ldr	r3, [pc, #512]	; (8012fa0 <grbl_enter+0x230>)
 8012d9e:	6563      	str	r3, [r4, #84]	; 0x54
    grbl.on_get_settings = settings_get_details;
 8012da0:	4b80      	ldr	r3, [pc, #512]	; (8012fa4 <grbl_enter+0x234>)
 8012da2:	65a3      	str	r3, [r4, #88]	; 0x58

    // Clear all and set some HAL function pointers
    memset(&hal, 0, sizeof(grbl_hal_t));
 8012da4:	4c80      	ldr	r4, [pc, #512]	; (8012fa8 <grbl_enter+0x238>)
 8012da6:	f44f 72d8 	mov.w	r2, #432	; 0x1b0
 8012daa:	2100      	movs	r1, #0
 8012dac:	4620      	mov	r0, r4
 8012dae:	f00f fee2 	bl	8022b76 <memset>
    hal.version = HAL_VERSION; // Update when signatures and/or contract is changed - driver_init() should fail
 8012db2:	230a      	movs	r3, #10
 8012db4:	6023      	str	r3, [r4, #0]
    hal.driver_reset = reset_handler;
 8012db6:	4b7d      	ldr	r3, [pc, #500]	; (8012fac <grbl_enter+0x23c>)
 8012db8:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
    hal.irq_enable = dummy_handler;
 8012dbc:	4b7c      	ldr	r3, [pc, #496]	; (8012fb0 <grbl_enter+0x240>)
 8012dbe:	64a3      	str	r3, [r4, #72]	; 0x48
    hal.irq_disable = dummy_handler;
 8012dc0:	64e3      	str	r3, [r4, #76]	; 0x4c
    hal.irq_claim = dummy_irq_claim;
 8012dc2:	4b7c      	ldr	r3, [pc, #496]	; (8012fb4 <grbl_enter+0x244>)
 8012dc4:	6523      	str	r3, [r4, #80]	; 0x50
    hal.nvs.size = GRBL_NVS_SIZE;
 8012dc6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8012dca:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
    hal.limits.interrupt_callback = limit_interrupt_handler;
 8012dce:	4b7a      	ldr	r3, [pc, #488]	; (8012fb8 <grbl_enter+0x248>)
 8012dd0:	65e3      	str	r3, [r4, #92]	; 0x5c
    hal.control.interrupt_callback = control_interrupt_handler;
 8012dd2:	4b7a      	ldr	r3, [pc, #488]	; (8012fbc <grbl_enter+0x24c>)
 8012dd4:	66e3      	str	r3, [r4, #108]	; 0x6c
    hal.stepper.interrupt_callback = stepper_driver_interrupt_handler;
 8012dd6:	4b7a      	ldr	r3, [pc, #488]	; (8012fc0 <grbl_enter+0x250>)
 8012dd8:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
    hal.stream_blocking_callback = stream_tx_blocking;
 8012ddc:	4b79      	ldr	r3, [pc, #484]	; (8012fc4 <grbl_enter+0x254>)
 8012dde:	f8c4 31a0 	str.w	r3, [r4, #416]	; 0x1a0
    hal.signals_cap.reset = hal.signals_cap.feed_hold = hal.signals_cap.cycle_start = On;
 8012de2:	f894 31a8 	ldrb.w	r3, [r4, #424]	; 0x1a8
 8012de6:	f043 0304 	orr.w	r3, r3, #4
 8012dea:	f884 31a8 	strb.w	r3, [r4, #424]	; 0x1a8
 8012dee:	b2db      	uxtb	r3, r3
 8012df0:	f043 0302 	orr.w	r3, r3, #2
 8012df4:	f884 31a8 	strb.w	r3, [r4, #424]	; 0x1a8
 8012df8:	b2db      	uxtb	r3, r3
 8012dfa:	f043 0301 	orr.w	r3, r3, #1
 8012dfe:	f884 31a8 	strb.w	r3, [r4, #424]	; 0x1a8

    sys.cold_start = true;
 8012e02:	4e71      	ldr	r6, [pc, #452]	; (8012fc8 <grbl_enter+0x258>)
 8012e04:	2301      	movs	r3, #1
 8012e06:	f886 307d 	strb.w	r3, [r6, #125]	; 0x7d

#if NVSDATA_BUFFER_ENABLE
    nvs_buffer_alloc(); // Allocate memory block for NVS buffer
 8012e0a:	f003 f877 	bl	8015efc <nvs_buffer_alloc>
#endif

    settings_clear();
 8012e0e:	f00a f9e3 	bl	801d1d8 <settings_clear>
    report_init_fns();
 8012e12:	f008 fbd7 	bl	801b5c4 <report_init_fns>

#ifdef KINEMATICS_API
    memset(&kinematics, 0, sizeof(kinematics_t));
#endif

    driver.init = driver_init();
 8012e16:	f7fa fa37 	bl	800d288 <driver_init>
 8012e1a:	4d6c      	ldr	r5, [pc, #432]	; (8012fcc <grbl_enter+0x25c>)
 8012e1c:	782b      	ldrb	r3, [r5, #0]
 8012e1e:	f360 0300 	bfi	r3, r0, #0, #1
 8012e22:	702b      	strb	r3, [r5, #0]
#if POLAR_ROBOT
    polar_init();
#endif

  #if NVSDATA_BUFFER_ENABLE
    nvs_buffer_init();
 8012e24:	f003 f87e 	bl	8015f24 <nvs_buffer_init>
  #endif
    settings_init(); // Load settings from non-volatile storage
 8012e28:	f00a f9e0 	bl	801d1ec <settings_init>

    memset(sys.position, 0, sizeof(sys.position)); // Clear machine position.
 8012e2c:	2300      	movs	r3, #0
 8012e2e:	f8c6 3088 	str.w	r3, [r6, #136]	; 0x88
 8012e32:	f8c6 308c 	str.w	r3, [r6, #140]	; 0x8c
 8012e36:	f8c6 3090 	str.w	r3, [r6, #144]	; 0x90

// check and configure driver

#ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    driver.amass = hal.driver_cap.amass_level >= MAX_AMASS_LEVEL;
 8012e3a:	f894 21a4 	ldrb.w	r2, [r4, #420]	; 0x1a4
 8012e3e:	f002 01c0 	and.w	r1, r2, #192	; 0xc0
 8012e42:	29c0      	cmp	r1, #192	; 0xc0
 8012e44:	bf14      	ite	ne
 8012e46:	2100      	movne	r1, #0
 8012e48:	2101      	moveq	r1, #1
 8012e4a:	7828      	ldrb	r0, [r5, #0]
 8012e4c:	f361 00c3 	bfi	r0, r1, #3, #1
 8012e50:	7028      	strb	r0, [r5, #0]
    hal.driver_cap.amass_level = MAX_AMASS_LEVEL;
 8012e52:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
 8012e56:	f884 21a4 	strb.w	r2, [r4, #420]	; 0x1a4
#else
    hal.driver_cap.amass_level = 0;
#endif

#ifdef DEFAULT_STEP_PULSE_DELAY
    driver.pulse_delay = hal.driver_cap.step_pulse_delay;
 8012e5a:	b2d2      	uxtb	r2, r2
 8012e5c:	f3c2 0280 	ubfx	r2, r2, #2, #1
 8012e60:	b2c1      	uxtb	r1, r0
 8012e62:	f362 1104 	bfi	r1, r2, #4, #1
 8012e66:	7029      	strb	r1, [r5, #0]
/*
#if AXIS_N_SETTINGS > 4
    driver_ok = driver_ok & hal.driver_cap.axes >= AXIS_N_SETTINGS;
#endif
*/
    sys.mpg_mode = false;
 8012e68:	f886 307f 	strb.w	r3, [r6, #127]	; 0x7f

    if(driver.ok == 0xFF)
 8012e6c:	b2cb      	uxtb	r3, r1
 8012e6e:	2bff      	cmp	r3, #255	; 0xff
 8012e70:	d048      	beq.n	8012f04 <grbl_enter+0x194>
        driver.setup = hal.driver_setup(&settings);

    if((driver.spindle = spindle_select(settings.spindle.flags.type))) {
 8012e72:	4b57      	ldr	r3, [pc, #348]	; (8012fd0 <grbl_enter+0x260>)
 8012e74:	f893 00e7 	ldrb.w	r0, [r3, #231]	; 0xe7
 8012e78:	f3c0 0084 	ubfx	r0, r0, #2, #5
 8012e7c:	f00a fda4 	bl	801d9c8 <spindle_select>
 8012e80:	4b52      	ldr	r3, [pc, #328]	; (8012fcc <grbl_enter+0x25c>)
 8012e82:	781a      	ldrb	r2, [r3, #0]
 8012e84:	f360 0282 	bfi	r2, r0, #2, #1
 8012e88:	701a      	strb	r2, [r3, #0]
 8012e8a:	2800      	cmp	r0, #0
 8012e8c:	d046      	beq.n	8012f1c <grbl_enter+0x1ac>
        spindle_ptrs_t *spindle = spindle_get(0);
 8012e8e:	2000      	movs	r0, #0
 8012e90:	f00a fd60 	bl	801d954 <spindle_get>
        driver.spindle = spindle->get_pwm == NULL || spindle->update_pwm != NULL;
 8012e94:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8012e96:	2b00      	cmp	r3, #0
 8012e98:	d03c      	beq.n	8012f14 <grbl_enter+0x1a4>
 8012e9a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8012e9c:	2b00      	cmp	r3, #0
 8012e9e:	d03b      	beq.n	8012f18 <grbl_enter+0x1a8>
 8012ea0:	2101      	movs	r1, #1
 8012ea2:	4b4a      	ldr	r3, [pc, #296]	; (8012fcc <grbl_enter+0x25c>)
 8012ea4:	781a      	ldrb	r2, [r3, #0]
 8012ea6:	f361 0282 	bfi	r2, r1, #2, #1
 8012eaa:	701a      	strb	r2, [r3, #0]
    } else
        driver.spindle = spindle_select(spindle_add_null());

    if(driver.ok != 0xFF) {
 8012eac:	4b47      	ldr	r3, [pc, #284]	; (8012fcc <grbl_enter+0x25c>)
 8012eae:	781b      	ldrb	r3, [r3, #0]
 8012eb0:	2bff      	cmp	r3, #255	; 0xff
 8012eb2:	d13d      	bne.n	8012f30 <grbl_enter+0x1c0>
        sys.alarm = Alarm_SelftestFailed;
        protocol_enqueue_rt_command(report_driver_error);
    }

    hal.stepper.enable(settings.steppers.deenergize);
 8012eb4:	4c3c      	ldr	r4, [pc, #240]	; (8012fa8 <grbl_enter+0x238>)
 8012eb6:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 8012eba:	4a45      	ldr	r2, [pc, #276]	; (8012fd0 <grbl_enter+0x260>)
 8012ebc:	f892 00ec 	ldrb.w	r0, [r2, #236]	; 0xec
 8012ec0:	4798      	blx	r3

    spindle_all_off();
 8012ec2:	f00a ff35 	bl	801dd30 <spindle_all_off>
    hal.coolant.set_state((coolant_state_t){0});
 8012ec6:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8012ec8:	f04f 0000 	mov.w	r0, #0
 8012ecc:	4798      	blx	r3

    if(hal.get_position)
 8012ece:	f8d4 319c 	ldr.w	r3, [r4, #412]	; 0x19c
 8012ed2:	b10b      	cbz	r3, 8012ed8 <grbl_enter+0x168>
        hal.get_position(&sys.position); // TODO: restore on abort when returns true?
 8012ed4:	483f      	ldr	r0, [pc, #252]	; (8012fd4 <grbl_enter+0x264>)
 8012ed6:	4798      	blx	r3

#if ENABLE_BACKLASH_COMPENSATION
    mc_backlash_init((axes_signals_t){AXES_BITMASK});
#endif

    sys.driver_started = sys.alarm != Alarm_SelftestFailed;
 8012ed8:	4a3b      	ldr	r2, [pc, #236]	; (8012fc8 <grbl_enter+0x258>)
 8012eda:	f892 307c 	ldrb.w	r3, [r2, #124]	; 0x7c
 8012ede:	3b10      	subs	r3, #16
 8012ee0:	bf18      	it	ne
 8012ee2:	2301      	movne	r3, #1
 8012ee4:	f882 307e 	strb.w	r3, [r2, #126]	; 0x7e

    // "Wire" homing switches to limit switches if not provided by the driver.
    if(hal.homing.get_state == NULL)
 8012ee8:	4b2f      	ldr	r3, [pc, #188]	; (8012fa8 <grbl_enter+0x238>)
 8012eea:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8012eec:	b343      	cbz	r3, 8012f40 <grbl_enter+0x1d0>
        hal.homing.get_state = hal.limits.get_state;

    if(settings.report_interval) {
 8012eee:	4b38      	ldr	r3, [pc, #224]	; (8012fd0 <grbl_enter+0x260>)
 8012ef0:	8a9b      	ldrh	r3, [r3, #20]
 8012ef2:	b12b      	cbz	r3, 8012f00 <grbl_enter+0x190>
        on_execute_realtime = grbl.on_execute_realtime;
 8012ef4:	4b23      	ldr	r3, [pc, #140]	; (8012f84 <grbl_enter+0x214>)
 8012ef6:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8012ef8:	4a37      	ldr	r2, [pc, #220]	; (8012fd8 <grbl_enter+0x268>)
 8012efa:	6011      	str	r1, [r2, #0]
        grbl.on_execute_realtime = auto_realtime_report;
 8012efc:	4a37      	ldr	r2, [pc, #220]	; (8012fdc <grbl_enter+0x26c>)
 8012efe:	635a      	str	r2, [r3, #52]	; 0x34
        if(hal.driver_cap.mpg_mode)
            protocol_enqueue_realtime_command(sys.mpg_mode ? CMD_STATUS_REPORT_ALL : CMD_STATUS_REPORT);

        // Start Grbl main loop. Processes program inputs and executes them.
        if(!(looping = protocol_main_loop()))
            looping = hal.driver_release == NULL || hal.driver_release();
 8012f00:	2301      	movs	r3, #1
 8012f02:	e074      	b.n	8012fee <grbl_enter+0x27e>
        driver.setup = hal.driver_setup(&settings);
 8012f04:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8012f06:	4832      	ldr	r0, [pc, #200]	; (8012fd0 <grbl_enter+0x260>)
 8012f08:	4798      	blx	r3
 8012f0a:	782a      	ldrb	r2, [r5, #0]
 8012f0c:	f360 0241 	bfi	r2, r0, #1, #1
 8012f10:	702a      	strb	r2, [r5, #0]
 8012f12:	e7ae      	b.n	8012e72 <grbl_enter+0x102>
        driver.spindle = spindle->get_pwm == NULL || spindle->update_pwm != NULL;
 8012f14:	2101      	movs	r1, #1
 8012f16:	e7c4      	b.n	8012ea2 <grbl_enter+0x132>
 8012f18:	2100      	movs	r1, #0
 8012f1a:	e7c2      	b.n	8012ea2 <grbl_enter+0x132>
        driver.spindle = spindle_select(spindle_add_null());
 8012f1c:	f00a fd30 	bl	801d980 <spindle_add_null>
 8012f20:	f00a fd52 	bl	801d9c8 <spindle_select>
 8012f24:	4b29      	ldr	r3, [pc, #164]	; (8012fcc <grbl_enter+0x25c>)
 8012f26:	781a      	ldrb	r2, [r3, #0]
 8012f28:	f360 0282 	bfi	r2, r0, #2, #1
 8012f2c:	701a      	strb	r2, [r3, #0]
 8012f2e:	e7bd      	b.n	8012eac <grbl_enter+0x13c>
        sys.alarm = Alarm_SelftestFailed;
 8012f30:	4b25      	ldr	r3, [pc, #148]	; (8012fc8 <grbl_enter+0x258>)
 8012f32:	2210      	movs	r2, #16
 8012f34:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c
        protocol_enqueue_rt_command(report_driver_error);
 8012f38:	4829      	ldr	r0, [pc, #164]	; (8012fe0 <grbl_enter+0x270>)
 8012f3a:	f005 f897 	bl	801806c <protocol_enqueue_rt_command>
 8012f3e:	e7b9      	b.n	8012eb4 <grbl_enter+0x144>
        hal.homing.get_state = hal.limits.get_state;
 8012f40:	4b19      	ldr	r3, [pc, #100]	; (8012fa8 <grbl_enter+0x238>)
 8012f42:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8012f44:	661a      	str	r2, [r3, #96]	; 0x60
 8012f46:	e7d2      	b.n	8012eee <grbl_enter+0x17e>
            memset(&sys, 0, offsetof(system_t, alarm)); // Clear system variables except state & alarm.
 8012f48:	227c      	movs	r2, #124	; 0x7c
 8012f4a:	2100      	movs	r1, #0
 8012f4c:	481e      	ldr	r0, [pc, #120]	; (8012fc8 <grbl_enter+0x258>)
 8012f4e:	f00f fe12 	bl	8022b76 <memset>
 8012f52:	e05f      	b.n	8013014 <grbl_enter+0x2a4>
                spindle_get(spindle_num)->param->override_pct = DEFAULT_SPINDLE_RPM_OVERRIDE; // Set to 100%
 8012f54:	2000      	movs	r0, #0
 8012f56:	f00a fcfd 	bl	801d954 <spindle_get>
 8012f5a:	6843      	ldr	r3, [r0, #4]
 8012f5c:	2264      	movs	r2, #100	; 0x64
 8012f5e:	60da      	str	r2, [r3, #12]
 8012f60:	e064      	b.n	801302c <grbl_enter+0x2bc>
            tc_init();
 8012f62:	f00e fda9 	bl	8021ab8 <tc_init>
 8012f66:	e0a4      	b.n	80130b2 <grbl_enter+0x342>
        if(!settings.flags.no_unlock_after_estop && state_get() == STATE_ESTOP)
 8012f68:	f00b fb3c 	bl	801e5e4 <state_get>
 8012f6c:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 8012f70:	f040 80a8 	bne.w	80130c4 <grbl_enter+0x354>
            state_set(STATE_ALARM);
 8012f74:	2001      	movs	r0, #1
 8012f76:	f00b fb3b 	bl	801e5f0 <state_set>
 8012f7a:	e0a3      	b.n	80130c4 <grbl_enter+0x354>
            protocol_enqueue_realtime_command(sys.mpg_mode ? CMD_STATUS_REPORT_ALL : CMD_STATUS_REPORT);
 8012f7c:	2080      	movs	r0, #128	; 0x80
 8012f7e:	e0ae      	b.n	80130de <grbl_enter+0x36e>
            looping = hal.driver_release == NULL || hal.driver_release();
 8012f80:	2301      	movs	r3, #1
 8012f82:	e030      	b.n	8012fe6 <grbl_enter+0x276>
 8012f84:	2000343c 	.word	0x2000343c
 8012f88:	080180ad 	.word	0x080180ad
 8012f8c:	08016f99 	.word	0x08016f99
 8012f90:	08020119 	.word	0x08020119
 8012f94:	08012ca1 	.word	0x08012ca1
 8012f98:	08020bd9 	.word	0x08020bd9
 8012f9c:	0800edd5 	.word	0x0800edd5
 8012fa0:	0800ee25 	.word	0x0800ee25
 8012fa4:	0801c2d1 	.word	0x0801c2d1
 8012fa8:	2000350c 	.word	0x2000350c
 8012fac:	08012cfd 	.word	0x08012cfd
 8012fb0:	08015c67 	.word	0x08015c67
 8012fb4:	08012ca3 	.word	0x08012ca3
 8012fb8:	08013319 	.word	0x08013319
 8012fbc:	080207d9 	.word	0x080207d9
 8012fc0:	0801eea5 	.word	0x0801eea5
 8012fc4:	08020071 	.word	0x08020071
 8012fc8:	200036c4 	.word	0x200036c4
 8012fcc:	20000400 	.word	0x20000400
 8012fd0:	20003b14 	.word	0x20003b14
 8012fd4:	2000374c 	.word	0x2000374c
 8012fd8:	200036c0 	.word	0x200036c0
 8012fdc:	08012ca9 	.word	0x08012ca9
 8012fe0:	08012d11 	.word	0x08012d11
 8012fe4:	2301      	movs	r3, #1

        sys.cold_start = false;
 8012fe6:	4a4a      	ldr	r2, [pc, #296]	; (8013110 <grbl_enter+0x3a0>)
 8012fe8:	2100      	movs	r1, #0
 8012fea:	f882 107d 	strb.w	r1, [r2, #125]	; 0x7d
    while(looping) {
 8012fee:	2b00      	cmp	r3, #0
 8012ff0:	f000 8089 	beq.w	8013106 <grbl_enter+0x396>
        report_init_fns();
 8012ff4:	f008 fae6 	bl	801b5c4 <report_init_fns>
        if(!sys.position_lost || settings.homing.flags.keep_on_reset)
 8012ff8:	4b45      	ldr	r3, [pc, #276]	; (8013110 <grbl_enter+0x3a0>)
 8012ffa:	78db      	ldrb	r3, [r3, #3]
 8012ffc:	b12b      	cbz	r3, 801300a <grbl_enter+0x29a>
 8012ffe:	4b45      	ldr	r3, [pc, #276]	; (8013114 <grbl_enter+0x3a4>)
 8013000:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 8013004:	f013 0f40 	tst.w	r3, #64	; 0x40
 8013008:	d09e      	beq.n	8012f48 <grbl_enter+0x1d8>
            memset(&sys, 0, offsetof(system_t, homed)); // Clear system variables except alarm & homed status.
 801300a:	2254      	movs	r2, #84	; 0x54
 801300c:	2100      	movs	r1, #0
 801300e:	4840      	ldr	r0, [pc, #256]	; (8013110 <grbl_enter+0x3a0>)
 8013010:	f00f fdb1 	bl	8022b76 <memset>
        sys.var5399 = -2;                                        // Clear last M66 result
 8013014:	4b3e      	ldr	r3, [pc, #248]	; (8013110 <grbl_enter+0x3a0>)
 8013016:	f06f 0201 	mvn.w	r2, #1
 801301a:	651a      	str	r2, [r3, #80]	; 0x50
        sys.override.feed_rate = DEFAULT_FEED_OVERRIDE;          // Set to 100%
 801301c:	2264      	movs	r2, #100	; 0x64
 801301e:	61da      	str	r2, [r3, #28]
        sys.override.rapid_rate = DEFAULT_RAPID_OVERRIDE;        // Set to 100%
 8013020:	621a      	str	r2, [r3, #32]
            if(spindle_is_enabled(--spindle_num))
 8013022:	2000      	movs	r0, #0
 8013024:	f00a fc82 	bl	801d92c <spindle_is_enabled>
 8013028:	2800      	cmp	r0, #0
 801302a:	d193      	bne.n	8012f54 <grbl_enter+0x1e4>
        sys.flags.auto_reporting = settings.report_interval != 0;
 801302c:	4a39      	ldr	r2, [pc, #228]	; (8013114 <grbl_enter+0x3a4>)
 801302e:	8a93      	ldrh	r3, [r2, #20]
 8013030:	3b00      	subs	r3, #0
 8013032:	bf18      	it	ne
 8013034:	2301      	movne	r3, #1
 8013036:	4936      	ldr	r1, [pc, #216]	; (8013110 <grbl_enter+0x3a0>)
 8013038:	7dc8      	ldrb	r0, [r1, #23]
 801303a:	f363 0041 	bfi	r0, r3, #1, #1
 801303e:	75c8      	strb	r0, [r1, #23]
        if(settings.parking.flags.enabled)
 8013040:	f892 3128 	ldrb.w	r3, [r2, #296]	; 0x128
 8013044:	f013 0f01 	tst.w	r3, #1
 8013048:	d00a      	beq.n	8013060 <grbl_enter+0x2f0>
            sys.override.control.parking_disable = settings.parking.flags.deactivate_upon_init;
 801304a:	f892 3128 	ldrb.w	r3, [r2, #296]	; 0x128
 801304e:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8013052:	460a      	mov	r2, r1
 8013054:	f891 1029 	ldrb.w	r1, [r1, #41]	; 0x29
 8013058:	f363 01c3 	bfi	r1, r3, #3, #1
 801305c:	f882 1029 	strb.w	r1, [r2, #41]	; 0x29
        flush_override_buffers();
 8013060:	f003 f998 	bl	8016394 <flush_override_buffers>
        hal.stream.reset_read_buffer(); // Clear input stream buffer
 8013064:	4c2c      	ldr	r4, [pc, #176]	; (8013118 <grbl_enter+0x3a8>)
 8013066:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 801306a:	4798      	blx	r3
        gc_init();                      // Set g-code parser to default state
 801306c:	f7fc f860 	bl	800f130 <gc_init>
        hal.limits.enable(settings.limits.flags.hard_enabled, false);
 8013070:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8013072:	4a28      	ldr	r2, [pc, #160]	; (8013114 <grbl_enter+0x3a4>)
 8013074:	f892 0124 	ldrb.w	r0, [r2, #292]	; 0x124
 8013078:	2100      	movs	r1, #0
 801307a:	f000 0001 	and.w	r0, r0, #1
 801307e:	4798      	blx	r3
        plan_reset();                   // Clear block buffer and planner variables
 8013080:	f003 fa34 	bl	80164ec <plan_reset>
        st_reset();                     // Clear stepper subsystem variables.
 8013084:	f00c f870 	bl	801f168 <st_reset>
        limits_set_homing_axes();       // Set axes to be homed from settings.
 8013088:	f000 fd44 	bl	8013b14 <limits_set_homing_axes>
        sync_position();
 801308c:	f003 fdf8 	bl	8016c80 <plan_sync_position>
 8013090:	4922      	ldr	r1, [pc, #136]	; (801311c <grbl_enter+0x3ac>)
 8013092:	4823      	ldr	r0, [pc, #140]	; (8013120 <grbl_enter+0x3b0>)
 8013094:	f00d ffa2 	bl	8020fdc <system_convert_array_steps_to_mpos>
        if(hal.stepper.disable_motors)
 8013098:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 801309c:	b113      	cbz	r3, 80130a4 <grbl_enter+0x334>
            hal.stepper.disable_motors((axes_signals_t){0}, SquaringMode_Both);
 801309e:	2100      	movs	r1, #0
 80130a0:	4608      	mov	r0, r1
 80130a2:	4798      	blx	r3
        if(!hal.driver_cap.atc)
 80130a4:	4b1c      	ldr	r3, [pc, #112]	; (8013118 <grbl_enter+0x3a8>)
 80130a6:	f893 31a6 	ldrb.w	r3, [r3, #422]	; 0x1a6
 80130aa:	f013 0f01 	tst.w	r3, #1
 80130ae:	f43f af58 	beq.w	8012f62 <grbl_enter+0x1f2>
        grbl.report.init_message();
 80130b2:	4b1c      	ldr	r3, [pc, #112]	; (8013124 <grbl_enter+0x3b4>)
 80130b4:	681b      	ldr	r3, [r3, #0]
 80130b6:	4798      	blx	r3
        if(!settings.flags.no_unlock_after_estop && state_get() == STATE_ESTOP)
 80130b8:	4b16      	ldr	r3, [pc, #88]	; (8013114 <grbl_enter+0x3a4>)
 80130ba:	f993 30ff 	ldrsb.w	r3, [r3, #255]	; 0xff
 80130be:	2b00      	cmp	r3, #0
 80130c0:	f6bf af52 	bge.w	8012f68 <grbl_enter+0x1f8>
        if(hal.driver_cap.mpg_mode)
 80130c4:	4b14      	ldr	r3, [pc, #80]	; (8013118 <grbl_enter+0x3a8>)
 80130c6:	f893 31a5 	ldrb.w	r3, [r3, #421]	; 0x1a5
 80130ca:	f013 0f40 	tst.w	r3, #64	; 0x40
 80130ce:	d008      	beq.n	80130e2 <grbl_enter+0x372>
            protocol_enqueue_realtime_command(sys.mpg_mode ? CMD_STATUS_REPORT_ALL : CMD_STATUS_REPORT);
 80130d0:	4b0f      	ldr	r3, [pc, #60]	; (8013110 <grbl_enter+0x3a0>)
 80130d2:	f893 307f 	ldrb.w	r3, [r3, #127]	; 0x7f
 80130d6:	2b00      	cmp	r3, #0
 80130d8:	f43f af50 	beq.w	8012f7c <grbl_enter+0x20c>
 80130dc:	2087      	movs	r0, #135	; 0x87
 80130de:	f004 fd8d 	bl	8017bfc <protocol_enqueue_realtime_command>
        if(!(looping = protocol_main_loop()))
 80130e2:	f004 fae3 	bl	80176ac <protocol_main_loop>
 80130e6:	4603      	mov	r3, r0
 80130e8:	2800      	cmp	r0, #0
 80130ea:	f47f af7c 	bne.w	8012fe6 <grbl_enter+0x276>
            looping = hal.driver_release == NULL || hal.driver_release();
 80130ee:	4b0a      	ldr	r3, [pc, #40]	; (8013118 <grbl_enter+0x3a8>)
 80130f0:	f8d3 3174 	ldr.w	r3, [r3, #372]	; 0x174
 80130f4:	2b00      	cmp	r3, #0
 80130f6:	f43f af43 	beq.w	8012f80 <grbl_enter+0x210>
 80130fa:	4798      	blx	r3
 80130fc:	2800      	cmp	r0, #0
 80130fe:	f47f af71 	bne.w	8012fe4 <grbl_enter+0x274>
 8013102:	2300      	movs	r3, #0
 8013104:	e76f      	b.n	8012fe6 <grbl_enter+0x276>
    }

    nvs_buffer_free();
 8013106:	f003 f8c1 	bl	801628c <nvs_buffer_free>

    return 0;
}
 801310a:	2000      	movs	r0, #0
 801310c:	bd70      	pop	{r4, r5, r6, pc}
 801310e:	bf00      	nop
 8013110:	200036c4 	.word	0x200036c4
 8013114:	20003b14 	.word	0x20003b14
 8013118:	2000350c 	.word	0x2000350c
 801311c:	2000374c 	.word	0x2000374c
 8013120:	200033a4 	.word	0x200033a4
 8013124:	2000343c 	.word	0x2000343c

08013128 <homing_signals_select>:
    return state;
}

// Merge (bitwise or) home switch inputs (typically acquired from limits.min and limits.min2).
ISR_CODE static axes_signals_t ISR_FUNC(homing_signals_select)(limit_signals_t signals, axes_signals_t auto_square, squaring_mode_t mode)
{
 8013128:	b082      	sub	sp, #8
 801312a:	9001      	str	r0, [sp, #4]
    axes_signals_t state;

    switch(mode) {
 801312c:	2a01      	cmp	r2, #1
 801312e:	d008      	beq.n	8013142 <homing_signals_select+0x1a>
 8013130:	2a02      	cmp	r2, #2
 8013132:	d00e      	beq.n	8013152 <homing_signals_select+0x2a>

        default:
            break;
    }

    state.mask = signals.min.mask | signals.min2.mask;
 8013134:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8013138:	f89d 3006 	ldrb.w	r3, [sp, #6]

    return state;
}
 801313c:	4318      	orrs	r0, r3
 801313e:	b002      	add	sp, #8
 8013140:	4770      	bx	lr
            signals.min.mask &= ~auto_square.mask;
 8013142:	43c9      	mvns	r1, r1
 8013144:	b249      	sxtb	r1, r1
 8013146:	f89d 3004 	ldrb.w	r3, [sp, #4]
 801314a:	400b      	ands	r3, r1
 801314c:	f88d 3004 	strb.w	r3, [sp, #4]
            break;
 8013150:	e7f0      	b.n	8013134 <homing_signals_select+0xc>
            signals.min2.mask &= ~auto_square.mask;
 8013152:	43c9      	mvns	r1, r1
 8013154:	b249      	sxtb	r1, r1
 8013156:	f89d 3006 	ldrb.w	r3, [sp, #6]
 801315a:	400b      	ands	r3, r1
 801315c:	f88d 3006 	strb.w	r3, [sp, #6]
            break;
 8013160:	e7e8      	b.n	8013134 <homing_signals_select+0xc>
	...

08013164 <limits_get_homing_rate>:
    return true; // Note: failure is returned above if move fails.
}

static float limits_get_homing_rate (axes_signals_t cycle, homing_mode_t mode)
{
    return mode == HomingMode_Locate ? settings.homing.feed_rate : settings.homing.seek_rate;
 8013164:	2901      	cmp	r1, #1
 8013166:	d003      	beq.n	8013170 <limits_get_homing_rate+0xc>
 8013168:	4b03      	ldr	r3, [pc, #12]	; (8013178 <limits_get_homing_rate+0x14>)
 801316a:	ed93 0a42 	vldr	s0, [r3, #264]	; 0x108
}
 801316e:	4770      	bx	lr
    return mode == HomingMode_Locate ? settings.homing.feed_rate : settings.homing.seek_rate;
 8013170:	4b01      	ldr	r3, [pc, #4]	; (8013178 <limits_get_homing_rate+0x14>)
 8013172:	ed93 0a41 	vldr	s0, [r3, #260]	; 0x104
 8013176:	4770      	bx	lr
 8013178:	20003b14 	.word	0x20003b14

0801317c <limits_pull_off>:
{
 801317c:	b570      	push	{r4, r5, r6, lr}
 801317e:	ed2d 8b02 	vpush	{d8}
 8013182:	b08e      	sub	sp, #56	; 0x38
 8013184:	4606      	mov	r6, r0
 8013186:	eeb0 8a40 	vmov.f32	s16, s0
    coord_data_t target = {0};
 801318a:	2400      	movs	r4, #0
 801318c:	940a      	str	r4, [sp, #40]	; 0x28
 801318e:	940b      	str	r4, [sp, #44]	; 0x2c
 8013190:	940c      	str	r4, [sp, #48]	; 0x30
    plan_data_init(&plan_data);
 8013192:	4668      	mov	r0, sp
 8013194:	f003 fde4 	bl	8016d60 <plan_data_init>
    plan_data.condition.system_motion = On;
 8013198:	f89d 3014 	ldrb.w	r3, [sp, #20]
 801319c:	f043 0302 	orr.w	r3, r3, #2
 80131a0:	f88d 3014 	strb.w	r3, [sp, #20]
    plan_data.condition.no_feed_override = On;
 80131a4:	b2db      	uxtb	r3, r3
 80131a6:	f043 0310 	orr.w	r3, r3, #16
 80131aa:	f88d 3014 	strb.w	r3, [sp, #20]
    plan_data.line_number = DEFAULT_HOMING_CYCLE_LINE_NUMBER;
 80131ae:	9407      	str	r4, [sp, #28]
    system_convert_array_steps_to_mpos(target.values, sys.position);
 80131b0:	4949      	ldr	r1, [pc, #292]	; (80132d8 <limits_pull_off+0x15c>)
 80131b2:	a80a      	add	r0, sp, #40	; 0x28
 80131b4:	f00d ff12 	bl	8020fdc <system_convert_array_steps_to_mpos>
    uint_fast8_t n_axis = 0, idx = N_AXIS;
 80131b8:	2303      	movs	r3, #3
 80131ba:	e009      	b.n	80131d0 <limits_pull_off+0x54>
                target.values[idx] -= distance;
 80131bc:	aa0e      	add	r2, sp, #56	; 0x38
 80131be:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 80131c2:	ed52 7a04 	vldr	s15, [r2, #-16]
 80131c6:	ee77 7ac8 	vsub.f32	s15, s15, s16
 80131ca:	ed42 7a04 	vstr	s15, [r2, #-16]
    } while(idx);
 80131ce:	b1c3      	cbz	r3, 8013202 <limits_pull_off+0x86>
        idx--;
 80131d0:	3b01      	subs	r3, #1
        if(bit_istrue(axis.mask, bit(idx))) {
 80131d2:	b2f5      	uxtb	r5, r6
 80131d4:	fa25 f203 	lsr.w	r2, r5, r3
 80131d8:	f012 0f01 	tst.w	r2, #1
 80131dc:	d0f7      	beq.n	80131ce <limits_pull_off+0x52>
            n_axis++;
 80131de:	3401      	adds	r4, #1
            if (bit_istrue(settings.homing.dir_mask.value, bit(idx)))
 80131e0:	4a3e      	ldr	r2, [pc, #248]	; (80132dc <limits_pull_off+0x160>)
 80131e2:	f892 2110 	ldrb.w	r2, [r2, #272]	; 0x110
 80131e6:	40da      	lsrs	r2, r3
 80131e8:	f012 0f01 	tst.w	r2, #1
 80131ec:	d0e6      	beq.n	80131bc <limits_pull_off+0x40>
                target.values[idx] += distance;
 80131ee:	aa0e      	add	r2, sp, #56	; 0x38
 80131f0:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 80131f4:	ed52 7a04 	vldr	s15, [r2, #-16]
 80131f8:	ee77 7a88 	vadd.f32	s15, s15, s16
 80131fc:	ed42 7a04 	vstr	s15, [r2, #-16]
 8013200:	e7e5      	b.n	80131ce <limits_pull_off+0x52>
    plan_data.feed_rate = settings.homing.seek_rate * sqrtf(n_axis); // Adjust so individual axes all move at pull-off rate.
 8013202:	4b36      	ldr	r3, [pc, #216]	; (80132dc <limits_pull_off+0x160>)
 8013204:	ed93 8a42 	vldr	s16, [r3, #264]	; 0x108
 8013208:	ee07 4a90 	vmov	s15, r4
 801320c:	eeb8 0a67 	vcvt.f32.u32	s0, s15
 8013210:	f010 fbde 	bl	80239d0 <sqrtf>
 8013214:	ee28 8a00 	vmul.f32	s16, s16, s0
 8013218:	ed8d 8a00 	vstr	s16, [sp]
    plan_data.condition.coolant = gc_state.modal.coolant;
 801321c:	4b30      	ldr	r3, [pc, #192]	; (80132e0 <limits_pull_off+0x164>)
 801321e:	7e5a      	ldrb	r2, [r3, #25]
 8013220:	f88d 2016 	strb.w	r2, [sp, #22]
    memcpy(&plan_data.spindle, &gc_state.spindle, sizeof(spindle_t));
 8013224:	ac01      	add	r4, sp, #4
 8013226:	3348      	adds	r3, #72	; 0x48
 8013228:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801322a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    plan_buffer_line(target.values, &plan_data);    // Bypass mc_line(). Directly plan homing motion.
 801322e:	4669      	mov	r1, sp
 8013230:	a80a      	add	r0, sp, #40	; 0x28
 8013232:	f003 faff 	bl	8016834 <plan_buffer_line>
    sys.step_control.flags = 0;                 // Clear existing flags and
 8013236:	4b2b      	ldr	r3, [pc, #172]	; (80132e4 <limits_pull_off+0x168>)
 8013238:	2200      	movs	r2, #0
 801323a:	761a      	strb	r2, [r3, #24]
    sys.step_control.execute_sys_motion = On;   // set to execute homing motion.
 801323c:	2204      	movs	r2, #4
 801323e:	761a      	strb	r2, [r3, #24]
    sys.homing_axis_lock.mask = axis.mask;
 8013240:	765d      	strb	r5, [r3, #25]
    st_prep_buffer();   // Prep and fill segment buffer from newly planned block.
 8013242:	f00c f8c5 	bl	801f3d0 <st_prep_buffer>
    st_wake_up();       // Initiate motion.
 8013246:	f00b fde1 	bl	801ee0c <st_wake_up>
 801324a:	e009      	b.n	8013260 <limits_pull_off+0xe4>
                mc_reset(); // Stop motors, if they are running.
 801324c:	f001 fd64 	bl	8014d18 <mc_reset>
                protocol_execute_realtime();
 8013250:	f004 f9fc 	bl	801764c <protocol_execute_realtime>
                return false;
 8013254:	2000      	movs	r0, #0
 8013256:	e03b      	b.n	80132d0 <limits_pull_off+0x154>
        grbl.on_execute_realtime(STATE_HOMING);
 8013258:	4b23      	ldr	r3, [pc, #140]	; (80132e8 <limits_pull_off+0x16c>)
 801325a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801325c:	2004      	movs	r0, #4
 801325e:	4798      	blx	r3
        st_prep_buffer(); // Check and prep segment buffer.
 8013260:	f00c f8b6 	bl	801f3d0 <st_prep_buffer>
        if (sys.rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET | EXEC_CYCLE_COMPLETE)) {
 8013264:	4b1f      	ldr	r3, [pc, #124]	; (80132e4 <limits_pull_off+0x168>)
 8013266:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8013268:	f013 0f64 	tst.w	r3, #100	; 0x64
 801326c:	d0f4      	beq.n	8013258 <limits_pull_off+0xdc>
            uint_fast16_t rt_exec = sys.rt_exec_state;
 801326e:	4b1d      	ldr	r3, [pc, #116]	; (80132e4 <limits_pull_off+0x168>)
 8013270:	6c9c      	ldr	r4, [r3, #72]	; 0x48
            if (rt_exec & EXEC_RESET)
 8013272:	f014 0f20 	tst.w	r4, #32
 8013276:	d004      	beq.n	8013282 <limits_pull_off+0x106>
                system_set_exec_alarm(Alarm_HomingFailReset);
 8013278:	4b1c      	ldr	r3, [pc, #112]	; (80132ec <limits_pull_off+0x170>)
 801327a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801327c:	2106      	movs	r1, #6
 801327e:	481c      	ldr	r0, [pc, #112]	; (80132f0 <limits_pull_off+0x174>)
 8013280:	4798      	blx	r3
            if (rt_exec & EXEC_SAFETY_DOOR)
 8013282:	f014 0f40 	tst.w	r4, #64	; 0x40
 8013286:	d004      	beq.n	8013292 <limits_pull_off+0x116>
                system_set_exec_alarm(Alarm_HomingFailDoor);
 8013288:	4b18      	ldr	r3, [pc, #96]	; (80132ec <limits_pull_off+0x170>)
 801328a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801328c:	2107      	movs	r1, #7
 801328e:	4818      	ldr	r0, [pc, #96]	; (80132f0 <limits_pull_off+0x174>)
 8013290:	4798      	blx	r3
            if (homing_signals_select(hal.homing.get_state(), (axes_signals_t){0}, SquaringMode_Both).mask & axis.mask)
 8013292:	4b16      	ldr	r3, [pc, #88]	; (80132ec <limits_pull_off+0x170>)
 8013294:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8013296:	4798      	blx	r3
 8013298:	900d      	str	r0, [sp, #52]	; 0x34
 801329a:	2200      	movs	r2, #0
 801329c:	4611      	mov	r1, r2
 801329e:	f7ff ff43 	bl	8013128 <homing_signals_select>
 80132a2:	4205      	tst	r5, r0
 80132a4:	d004      	beq.n	80132b0 <limits_pull_off+0x134>
                system_set_exec_alarm(Alarm_FailPulloff);
 80132a6:	4b11      	ldr	r3, [pc, #68]	; (80132ec <limits_pull_off+0x170>)
 80132a8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80132aa:	2108      	movs	r1, #8
 80132ac:	4810      	ldr	r0, [pc, #64]	; (80132f0 <limits_pull_off+0x174>)
 80132ae:	4798      	blx	r3
            if (sys.rt_exec_alarm) {
 80132b0:	4b0c      	ldr	r3, [pc, #48]	; (80132e4 <limits_pull_off+0x168>)
 80132b2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80132b4:	2b00      	cmp	r3, #0
 80132b6:	d1c9      	bne.n	801324c <limits_pull_off+0xd0>
                system_clear_exec_state_flag(EXEC_CYCLE_COMPLETE);
 80132b8:	4b0c      	ldr	r3, [pc, #48]	; (80132ec <limits_pull_off+0x170>)
 80132ba:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80132bc:	4c0d      	ldr	r4, [pc, #52]	; (80132f4 <limits_pull_off+0x178>)
 80132be:	2104      	movs	r1, #4
 80132c0:	4620      	mov	r0, r4
 80132c2:	4798      	blx	r3
    st_reset(); // Immediately force kill steppers and reset step segment buffer.
 80132c4:	f00b ff50 	bl	801f168 <st_reset>
    sys.step_control.flags = 0; // Return step control to normal operation.
 80132c8:	2300      	movs	r3, #0
 80132ca:	f804 3c30 	strb.w	r3, [r4, #-48]
    return true; // Note: failure is returned above if move fails.
 80132ce:	2001      	movs	r0, #1
}
 80132d0:	b00e      	add	sp, #56	; 0x38
 80132d2:	ecbd 8b02 	vpop	{d8}
 80132d6:	bd70      	pop	{r4, r5, r6, pc}
 80132d8:	2000374c 	.word	0x2000374c
 80132dc:	20003b14 	.word	0x20003b14
 80132e0:	20003344 	.word	0x20003344
 80132e4:	200036c4 	.word	0x200036c4
 80132e8:	2000343c 	.word	0x2000343c
 80132ec:	2000350c 	.word	0x2000350c
 80132f0:	20003710 	.word	0x20003710
 80132f4:	2000370c 	.word	0x2000370c

080132f8 <limit_signals_merge>:
{
 80132f8:	b082      	sub	sp, #8
 80132fa:	9001      	str	r0, [sp, #4]
    state.mask = signals.min.mask | signals.min2.mask | signals.max.mask | signals.max2.mask;
 80132fc:	f89d 2004 	ldrb.w	r2, [sp, #4]
 8013300:	f89d 1006 	ldrb.w	r1, [sp, #6]
 8013304:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8013308:	f89d 0007 	ldrb.w	r0, [sp, #7]
 801330c:	430a      	orrs	r2, r1
 801330e:	4313      	orrs	r3, r2
}
 8013310:	4318      	orrs	r0, r3
 8013312:	b002      	add	sp, #8
 8013314:	4770      	bx	lr
	...

08013318 <limit_interrupt_handler>:
{
 8013318:	b500      	push	{lr}
 801331a:	b083      	sub	sp, #12
 801331c:	9001      	str	r0, [sp, #4]
    memcpy(&sys.last_event.limits, &state, sizeof(limit_signals_t));
 801331e:	4b0b      	ldr	r3, [pc, #44]	; (801334c <limit_interrupt_handler+0x34>)
 8013320:	f8c3 0082 	str.w	r0, [r3, #130]	; 0x82
    if (!(state_get() & (STATE_ALARM|STATE_ESTOP)) && !sys.rt_exec_alarm) {
 8013324:	f00b f95e 	bl	801e5e4 <state_get>
 8013328:	f240 1301 	movw	r3, #257	; 0x101
 801332c:	4218      	tst	r0, r3
 801332e:	d102      	bne.n	8013336 <limit_interrupt_handler+0x1e>
 8013330:	4b06      	ldr	r3, [pc, #24]	; (801334c <limit_interrupt_handler+0x34>)
 8013332:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8013334:	b113      	cbz	r3, 801333c <limit_interrupt_handler+0x24>
}
 8013336:	b003      	add	sp, #12
 8013338:	f85d fb04 	ldr.w	pc, [sp], #4
        mc_reset(); // Initiate system kill.
 801333c:	f001 fcec 	bl	8014d18 <mc_reset>
        system_set_exec_alarm(Alarm_HardLimit); // Indicate hard limit critical event
 8013340:	4b03      	ldr	r3, [pc, #12]	; (8013350 <limit_interrupt_handler+0x38>)
 8013342:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8013344:	2101      	movs	r1, #1
 8013346:	4803      	ldr	r0, [pc, #12]	; (8013354 <limit_interrupt_handler+0x3c>)
 8013348:	4798      	blx	r3
}
 801334a:	e7f4      	b.n	8013336 <limit_interrupt_handler+0x1e>
 801334c:	200036c4 	.word	0x200036c4
 8013350:	2000350c 	.word	0x2000350c
 8013354:	20003710 	.word	0x20003710

08013358 <limits_set_work_envelope>:
    uint_fast8_t idx = N_AXIS;
 8013358:	2303      	movs	r3, #3
 801335a:	e067      	b.n	801342c <limits_set_work_envelope+0xd4>
            float pulloff = settings.limits.flags.hard_enabled && bit_istrue(sys.homing.mask, bit(idx)) ? settings.homing.pulloff : 0.0f;
 801335c:	eddf 7a40 	vldr	s15, [pc, #256]	; 8013460 <limits_set_work_envelope+0x108>
            if(settings.homing.flags.force_set_origin) {
 8013360:	4a40      	ldr	r2, [pc, #256]	; (8013464 <limits_set_work_envelope+0x10c>)
 8013362:	f892 2114 	ldrb.w	r2, [r2, #276]	; 0x114
 8013366:	f012 0f08 	tst.w	r2, #8
 801336a:	d039      	beq.n	80133e0 <limits_set_work_envelope+0x88>
                if(bit_isfalse(settings.homing.dir_mask.value, bit(idx))) {
 801336c:	4a3d      	ldr	r2, [pc, #244]	; (8013464 <limits_set_work_envelope+0x10c>)
 801336e:	f892 2110 	ldrb.w	r2, [r2, #272]	; 0x110
 8013372:	40da      	lsrs	r2, r3
 8013374:	f012 0f01 	tst.w	r2, #1
 8013378:	d119      	bne.n	80133ae <limits_set_work_envelope+0x56>
                    sys.work_envelope.min[idx] = settings.axis[idx].max_travel + pulloff;
 801337a:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 801337e:	0091      	lsls	r1, r2, #2
 8013380:	4a38      	ldr	r2, [pc, #224]	; (8013464 <limits_set_work_envelope+0x10c>)
 8013382:	440a      	add	r2, r1
 8013384:	ed92 7a0f 	vldr	s14, [r2, #60]	; 0x3c
 8013388:	ee77 7a27 	vadd.f32	s15, s14, s15
 801338c:	4a36      	ldr	r2, [pc, #216]	; (8013468 <limits_set_work_envelope+0x110>)
 801338e:	f103 0118 	add.w	r1, r3, #24
 8013392:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 8013396:	edc1 7a01 	vstr	s15, [r1, #4]
                    sys.work_envelope.max[idx] = 0.0f;
 801339a:	f103 011a 	add.w	r1, r3, #26
 801339e:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 80133a2:	2100      	movs	r1, #0
 80133a4:	6091      	str	r1, [r2, #8]
 80133a6:	e040      	b.n	801342a <limits_set_work_envelope+0xd2>
            float pulloff = settings.limits.flags.hard_enabled && bit_istrue(sys.homing.mask, bit(idx)) ? settings.homing.pulloff : 0.0f;
 80133a8:	eddf 7a2d 	vldr	s15, [pc, #180]	; 8013460 <limits_set_work_envelope+0x108>
 80133ac:	e7d8      	b.n	8013360 <limits_set_work_envelope+0x8>
                    sys.work_envelope.min[idx] = 0.0f;
 80133ae:	4a2e      	ldr	r2, [pc, #184]	; (8013468 <limits_set_work_envelope+0x110>)
 80133b0:	f103 0118 	add.w	r1, r3, #24
 80133b4:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 80133b8:	2000      	movs	r0, #0
 80133ba:	6048      	str	r0, [r1, #4]
                    sys.work_envelope.max[idx] = - (settings.axis[idx].max_travel + pulloff);
 80133bc:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 80133c0:	0088      	lsls	r0, r1, #2
 80133c2:	4928      	ldr	r1, [pc, #160]	; (8013464 <limits_set_work_envelope+0x10c>)
 80133c4:	4401      	add	r1, r0
 80133c6:	ed91 7a0f 	vldr	s14, [r1, #60]	; 0x3c
 80133ca:	ee77 7a27 	vadd.f32	s15, s14, s15
 80133ce:	eef1 7a67 	vneg.f32	s15, s15
 80133d2:	f103 011a 	add.w	r1, r3, #26
 80133d6:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 80133da:	edc2 7a02 	vstr	s15, [r2, #8]
 80133de:	e024      	b.n	801342a <limits_set_work_envelope+0xd2>
                sys.work_envelope.min[idx] = settings.axis[idx].max_travel + pulloff;
 80133e0:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 80133e4:	0091      	lsls	r1, r2, #2
 80133e6:	4a1f      	ldr	r2, [pc, #124]	; (8013464 <limits_set_work_envelope+0x10c>)
 80133e8:	440a      	add	r2, r1
 80133ea:	ed92 7a0f 	vldr	s14, [r2, #60]	; 0x3c
 80133ee:	ee37 7a27 	vadd.f32	s14, s14, s15
 80133f2:	4a1d      	ldr	r2, [pc, #116]	; (8013468 <limits_set_work_envelope+0x110>)
 80133f4:	f103 0118 	add.w	r1, r3, #24
 80133f8:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 80133fc:	ed81 7a01 	vstr	s14, [r1, #4]
                sys.work_envelope.max[idx] = - pulloff;
 8013400:	eef1 7a67 	vneg.f32	s15, s15
 8013404:	f103 011a 	add.w	r1, r3, #26
 8013408:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 801340c:	edc2 7a02 	vstr	s15, [r2, #8]
 8013410:	e00b      	b.n	801342a <limits_set_work_envelope+0xd2>
            sys.work_envelope.min[idx] = sys.work_envelope.max[idx] = 0.0f;
 8013412:	4a15      	ldr	r2, [pc, #84]	; (8013468 <limits_set_work_envelope+0x110>)
 8013414:	f103 011a 	add.w	r1, r3, #26
 8013418:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 801341c:	2000      	movs	r0, #0
 801341e:	6088      	str	r0, [r1, #8]
 8013420:	f103 0118 	add.w	r1, r3, #24
 8013424:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8013428:	6050      	str	r0, [r2, #4]
    } while(idx);
 801342a:	b1bb      	cbz	r3, 801345c <limits_set_work_envelope+0x104>
        if(sys.homed.mask & bit(--idx)) {
 801342c:	4a0e      	ldr	r2, [pc, #56]	; (8013468 <limits_set_work_envelope+0x110>)
 801342e:	f892 2054 	ldrb.w	r2, [r2, #84]	; 0x54
 8013432:	3b01      	subs	r3, #1
 8013434:	40da      	lsrs	r2, r3
 8013436:	f012 0f01 	tst.w	r2, #1
 801343a:	d0ea      	beq.n	8013412 <limits_set_work_envelope+0xba>
            float pulloff = settings.limits.flags.hard_enabled && bit_istrue(sys.homing.mask, bit(idx)) ? settings.homing.pulloff : 0.0f;
 801343c:	4a09      	ldr	r2, [pc, #36]	; (8013464 <limits_set_work_envelope+0x10c>)
 801343e:	f892 2124 	ldrb.w	r2, [r2, #292]	; 0x124
 8013442:	f012 0f01 	tst.w	r2, #1
 8013446:	d089      	beq.n	801335c <limits_set_work_envelope+0x4>
 8013448:	4a07      	ldr	r2, [pc, #28]	; (8013468 <limits_set_work_envelope+0x110>)
 801344a:	7e92      	ldrb	r2, [r2, #26]
 801344c:	40da      	lsrs	r2, r3
 801344e:	f012 0f01 	tst.w	r2, #1
 8013452:	d0a9      	beq.n	80133a8 <limits_set_work_envelope+0x50>
 8013454:	4a03      	ldr	r2, [pc, #12]	; (8013464 <limits_set_work_envelope+0x10c>)
 8013456:	edd2 7a43 	vldr	s15, [r2, #268]	; 0x10c
 801345a:	e781      	b.n	8013360 <limits_set_work_envelope+0x8>
}
 801345c:	4770      	bx	lr
 801345e:	bf00      	nop
 8013460:	00000000 	.word	0x00000000
 8013464:	20003b14 	.word	0x20003b14
 8013468:	200036c4 	.word	0x200036c4

0801346c <limits_set_machine_positions>:
{
 801346c:	b570      	push	{r4, r5, r6, lr}
 801346e:	ed2d 8b02 	vpush	{d8}
 8013472:	4605      	mov	r5, r0
    float pulloff = add_pulloff ? settings.homing.pulloff : 0.0f;
 8013474:	b119      	cbz	r1, 801347e <limits_set_machine_positions+0x12>
 8013476:	4b2b      	ldr	r3, [pc, #172]	; (8013524 <limits_set_machine_positions+0xb8>)
 8013478:	ed93 8a43 	vldr	s16, [r3, #268]	; 0x10c
 801347c:	e001      	b.n	8013482 <limits_set_machine_positions+0x16>
 801347e:	ed9f 8a2a 	vldr	s16, [pc, #168]	; 8013528 <limits_set_machine_positions+0xbc>
    if(settings.homing.flags.force_set_origin) {
 8013482:	4b28      	ldr	r3, [pc, #160]	; (8013524 <limits_set_machine_positions+0xb8>)
 8013484:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 8013488:	f013 0f08 	tst.w	r3, #8
 801348c:	d015      	beq.n	80134ba <limits_set_machine_positions+0x4e>
    uint_fast8_t idx = N_AXIS;
 801348e:	2203      	movs	r2, #3
 8013490:	e00c      	b.n	80134ac <limits_set_machine_positions+0x40>
                sys.position[idx] = 0;
 8013492:	4b26      	ldr	r3, [pc, #152]	; (801352c <limits_set_machine_positions+0xc0>)
 8013494:	f102 0122 	add.w	r1, r2, #34	; 0x22
 8013498:	2000      	movs	r0, #0
 801349a:	f843 0021 	str.w	r0, [r3, r1, lsl #2]
                sys.home_position[idx] = 0.0f;
 801349e:	f102 0116 	add.w	r1, r2, #22
 80134a2:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 80134a6:	2100      	movs	r1, #0
 80134a8:	6019      	str	r1, [r3, #0]
        } while(idx);
 80134aa:	b3c2      	cbz	r2, 801351e <limits_set_machine_positions+0xb2>
            if (cycle.mask & bit(--idx)) {
 80134ac:	b2eb      	uxtb	r3, r5
 80134ae:	3a01      	subs	r2, #1
 80134b0:	40d3      	lsrs	r3, r2
 80134b2:	f013 0f01 	tst.w	r3, #1
 80134b6:	d0f8      	beq.n	80134aa <limits_set_machine_positions+0x3e>
 80134b8:	e7eb      	b.n	8013492 <limits_set_machine_positions+0x26>
    uint_fast8_t idx = N_AXIS;
 80134ba:	2403      	movs	r4, #3
 80134bc:	e018      	b.n	80134f0 <limits_set_machine_positions+0x84>
                                      : - pulloff;
 80134be:	eef1 7a48 	vneg.f32	s15, s16
            sys.home_position[idx] = bit_istrue(settings.homing.dir_mask.value, bit(idx))
 80134c2:	4e1a      	ldr	r6, [pc, #104]	; (801352c <limits_set_machine_positions+0xc0>)
 80134c4:	f104 0316 	add.w	r3, r4, #22
 80134c8:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 80134cc:	edc3 7a00 	vstr	s15, [r3]
            sys.position[idx] = lroundf(sys.home_position[idx] * settings.axis[idx].steps_per_mm);
 80134d0:	eb04 0284 	add.w	r2, r4, r4, lsl #2
 80134d4:	4b13      	ldr	r3, [pc, #76]	; (8013524 <limits_set_machine_positions+0xb8>)
 80134d6:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80134da:	ed93 0a0c 	vldr	s0, [r3, #48]	; 0x30
 80134de:	ee20 0a27 	vmul.f32	s0, s0, s15
 80134e2:	f010 fb56 	bl	8023b92 <lroundf>
 80134e6:	f104 0322 	add.w	r3, r4, #34	; 0x22
 80134ea:	f846 0023 	str.w	r0, [r6, r3, lsl #2]
    } while(idx);
 80134ee:	b1b4      	cbz	r4, 801351e <limits_set_machine_positions+0xb2>
        if (cycle.mask & bit(--idx)) {
 80134f0:	b2eb      	uxtb	r3, r5
 80134f2:	3c01      	subs	r4, #1
 80134f4:	40e3      	lsrs	r3, r4
 80134f6:	f013 0f01 	tst.w	r3, #1
 80134fa:	d0f8      	beq.n	80134ee <limits_set_machine_positions+0x82>
            sys.home_position[idx] = bit_istrue(settings.homing.dir_mask.value, bit(idx))
 80134fc:	4b09      	ldr	r3, [pc, #36]	; (8013524 <limits_set_machine_positions+0xb8>)
 80134fe:	f893 3110 	ldrb.w	r3, [r3, #272]	; 0x110
 8013502:	40e3      	lsrs	r3, r4
                                      : - pulloff;
 8013504:	f013 0f01 	tst.w	r3, #1
 8013508:	d0d9      	beq.n	80134be <limits_set_machine_positions+0x52>
                                      ? settings.axis[idx].max_travel + pulloff
 801350a:	eb04 0284 	add.w	r2, r4, r4, lsl #2
 801350e:	4b05      	ldr	r3, [pc, #20]	; (8013524 <limits_set_machine_positions+0xb8>)
 8013510:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8013514:	edd3 7a0f 	vldr	s15, [r3, #60]	; 0x3c
                                      : - pulloff;
 8013518:	ee77 7a88 	vadd.f32	s15, s15, s16
 801351c:	e7d1      	b.n	80134c2 <limits_set_machine_positions+0x56>
}
 801351e:	ecbd 8b02 	vpop	{d8}
 8013522:	bd70      	pop	{r4, r5, r6, pc}
 8013524:	20003b14 	.word	0x20003b14
 8013528:	00000000 	.word	0x00000000
 801352c:	200036c4 	.word	0x200036c4

08013530 <limits_homing_cycle>:
// the trigger point of the limit switches. The rapid stops are handled by a system level axis lock
// mask, which prevents the stepper algorithm from executing step pulses. Homing motions typically
// circumvent the processes for executing motions in normal operation.
// NOTE: Only the abort realtime command can interrupt this process.
static bool limits_homing_cycle (axes_signals_t cycle, axes_signals_t auto_square)
{
 8013530:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013534:	ed2d 8b02 	vpush	{d8}
 8013538:	b099      	sub	sp, #100	; 0x64
 801353a:	f88d 000e 	strb.w	r0, [sp, #14]
 801353e:	f88d 100f 	strb.w	r1, [sp, #15]
    if (ABORTED) // Block if system reset has been issued.
 8013542:	4b93      	ldr	r3, [pc, #588]	; (8013790 <limits_homing_cycle+0x260>)
 8013544:	881b      	ldrh	r3, [r3, #0]
 8013546:	2b00      	cmp	r3, #0
 8013548:	f040 8255 	bne.w	80139f6 <limits_homing_cycle+0x4c6>
        return false;

    if(hal.homing.get_feedrate == NULL)
 801354c:	4b91      	ldr	r3, [pc, #580]	; (8013794 <limits_homing_cycle+0x264>)
 801354e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8013550:	b333      	cbz	r3, 80135a0 <limits_homing_cycle+0x70>
        hal.homing.get_feedrate = limits_get_homing_rate;

    int32_t initial_trigger_position = 0, autosquare_fail_distance = 0;
    uint_fast8_t n_cycle = (2 * settings.homing.locate_cycles + 1);
 8013552:	4b91      	ldr	r3, [pc, #580]	; (8013798 <limits_homing_cycle+0x268>)
 8013554:	f893 3111 	ldrb.w	r3, [r3, #273]	; 0x111
 8013558:	005b      	lsls	r3, r3, #1
 801355a:	3301      	adds	r3, #1
 801355c:	9302      	str	r3, [sp, #8]
    limit_signals_t limits_state;
    squaring_mode_t squaring_mode = SquaringMode_Both;
    coord_data_t target;
    plan_line_data_t plan_data;

    plan_data_init(&plan_data);
 801355e:	a806      	add	r0, sp, #24
 8013560:	f003 fbfe 	bl	8016d60 <plan_data_init>
    plan_data.condition.system_motion = On;
 8013564:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
 8013568:	f043 0302 	orr.w	r3, r3, #2
 801356c:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    plan_data.condition.no_feed_override = On;
 8013570:	b2db      	uxtb	r3, r3
 8013572:	f043 0310 	orr.w	r3, r3, #16
 8013576:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    plan_data.line_number = DEFAULT_HOMING_CYCLE_LINE_NUMBER;
 801357a:	2500      	movs	r5, #0
 801357c:	950d      	str	r5, [sp, #52]	; 0x34

    // Initialize plan data struct for homing motion.
    memcpy(&plan_data.spindle, &gc_state.spindle, sizeof(spindle_t));
 801357e:	4e87      	ldr	r6, [pc, #540]	; (801379c <limits_homing_cycle+0x26c>)
 8013580:	ac07      	add	r4, sp, #28
 8013582:	f106 0348 	add.w	r3, r6, #72	; 0x48
 8013586:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8013588:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    plan_data.condition.coolant = gc_state.modal.coolant;
 801358c:	7e73      	ldrb	r3, [r6, #25]
 801358e:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e

    uint_fast8_t idx = N_AXIS;
 8013592:	f04f 0b03 	mov.w	fp, #3
    float max_travel = 0.0f, homing_rate;
 8013596:	eddf 8a82 	vldr	s17, [pc, #520]	; 80137a0 <limits_homing_cycle+0x270>
    uint_fast8_t step_pin[N_AXIS], n_active_axis, dual_motor_axis = 0;
 801359a:	46a9      	mov	r9, r5
 801359c:	465b      	mov	r3, fp
 801359e:	e004      	b.n	80135aa <limits_homing_cycle+0x7a>
        hal.homing.get_feedrate = limits_get_homing_rate;
 80135a0:	4b7c      	ldr	r3, [pc, #496]	; (8013794 <limits_homing_cycle+0x264>)
 80135a2:	4a80      	ldr	r2, [pc, #512]	; (80137a4 <limits_homing_cycle+0x274>)
 80135a4:	665a      	str	r2, [r3, #100]	; 0x64
 80135a6:	e7d4      	b.n	8013552 <limits_homing_cycle+0x22>
            max_travel = max(max_travel, (-HOMING_AXIS_SEARCH_SCALAR) * settings.axis[idx].max_travel);

            if(bit_istrue(auto_square.mask, bit(idx)))
                dual_motor_axis = idx;
        }
    } while(idx);
 80135a8:	b343      	cbz	r3, 80135fc <limits_homing_cycle+0xcc>
        idx--;
 80135aa:	3b01      	subs	r3, #1
        step_pin[idx] = bit(idx);
 80135ac:	2201      	movs	r2, #1
 80135ae:	409a      	lsls	r2, r3
 80135b0:	a918      	add	r1, sp, #96	; 0x60
 80135b2:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 80135b6:	f841 2c10 	str.w	r2, [r1, #-16]
        if(bit_istrue(cycle.mask, bit(idx))) {
 80135ba:	f89d 200e 	ldrb.w	r2, [sp, #14]
 80135be:	fa22 f103 	lsr.w	r1, r2, r3
 80135c2:	f011 0f01 	tst.w	r1, #1
 80135c6:	d0ef      	beq.n	80135a8 <limits_homing_cycle+0x78>
            max_travel = max(max_travel, (-HOMING_AXIS_SEARCH_SCALAR) * settings.axis[idx].max_travel);
 80135c8:	eb03 0083 	add.w	r0, r3, r3, lsl #2
 80135cc:	4972      	ldr	r1, [pc, #456]	; (8013798 <limits_homing_cycle+0x268>)
 80135ce:	eb01 0180 	add.w	r1, r1, r0, lsl #2
 80135d2:	edd1 7a0f 	vldr	s15, [r1, #60]	; 0x3c
 80135d6:	eebf 7a08 	vmov.f32	s14, #248	; 0xbfc00000 -1.5
 80135da:	ee67 7a87 	vmul.f32	s15, s15, s14
 80135de:	eef4 7ae8 	vcmpe.f32	s15, s17
 80135e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80135e6:	d401      	bmi.n	80135ec <limits_homing_cycle+0xbc>
 80135e8:	eef0 8a67 	vmov.f32	s17, s15
            if(bit_istrue(auto_square.mask, bit(idx)))
 80135ec:	f89d 100f 	ldrb.w	r1, [sp, #15]
 80135f0:	40d9      	lsrs	r1, r3
 80135f2:	f011 0f01 	tst.w	r1, #1
 80135f6:	d0d7      	beq.n	80135a8 <limits_homing_cycle+0x78>
                dual_motor_axis = idx;
 80135f8:	4699      	mov	r9, r3
 80135fa:	e7d5      	b.n	80135a8 <limits_homing_cycle+0x78>

    if(max_travel == 0.0f)
 80135fc:	9204      	str	r2, [sp, #16]
 80135fe:	469b      	mov	fp, r3
 8013600:	eef5 8a40 	vcmp.f32	s17, #0.0
 8013604:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013608:	f000 81fb 	beq.w	8013a02 <limits_homing_cycle+0x4d2>
        return true;

    if((homing_rate = hal.homing.get_feedrate(cycle, HomingMode_Seek)) == 0.0f)
 801360c:	4b61      	ldr	r3, [pc, #388]	; (8013794 <limits_homing_cycle+0x264>)
 801360e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8013610:	2100      	movs	r1, #0
 8013612:	f89d 000e 	ldrb.w	r0, [sp, #14]
 8013616:	4798      	blx	r3
 8013618:	eeb0 8a40 	vmov.f32	s16, s0
 801361c:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8013620:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013624:	f000 81ef 	beq.w	8013a06 <limits_homing_cycle+0x4d6>
        return false;

    if(auto_square.mask) {
 8013628:	f89d a00f 	ldrb.w	sl, [sp, #15]
 801362c:	f1ba 0f00 	cmp.w	sl, #0
 8013630:	d031      	beq.n	8013696 <limits_homing_cycle+0x166>
        float fail_distance = (-settings.homing.dual_axis.fail_length_percent / 100.0f) * settings.axis[dual_motor_axis].max_travel;
 8013632:	4b59      	ldr	r3, [pc, #356]	; (8013798 <limits_homing_cycle+0x268>)
 8013634:	ed93 7a46 	vldr	s14, [r3, #280]	; 0x118
 8013638:	eeb1 7a47 	vneg.f32	s14, s14
 801363c:	eddf 6a5a 	vldr	s13, [pc, #360]	; 80137a8 <limits_homing_cycle+0x278>
 8013640:	eec7 7a26 	vdiv.f32	s15, s14, s13
 8013644:	eb09 0289 	add.w	r2, r9, r9, lsl #2
 8013648:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 801364c:	ed92 7a0f 	vldr	s14, [r2, #60]	; 0x3c
 8013650:	ee67 7a87 	vmul.f32	s15, s15, s14
        fail_distance = min(fail_distance, settings.homing.dual_axis.fail_distance_max);
 8013654:	ed93 7a47 	vldr	s14, [r3, #284]	; 0x11c
 8013658:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801365c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013660:	dd01      	ble.n	8013666 <limits_homing_cycle+0x136>
 8013662:	eeb0 7a67 	vmov.f32	s14, s15
        fail_distance = max(fail_distance, settings.homing.dual_axis.fail_distance_min);
 8013666:	4b4c      	ldr	r3, [pc, #304]	; (8013798 <limits_homing_cycle+0x268>)
 8013668:	edd3 6a48 	vldr	s13, [r3, #288]	; 0x120
 801366c:	eef4 6ac7 	vcmpe.f32	s13, s14
 8013670:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013674:	d501      	bpl.n	801367a <limits_homing_cycle+0x14a>
 8013676:	eef0 6a47 	vmov.f32	s13, s14
        autosquare_fail_distance = truncf(fail_distance * settings.axis[dual_motor_axis].steps_per_mm);
 801367a:	eb09 0289 	add.w	r2, r9, r9, lsl #2
 801367e:	4b46      	ldr	r3, [pc, #280]	; (8013798 <limits_homing_cycle+0x268>)
 8013680:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8013684:	edd3 7a0c 	vldr	s15, [r3, #48]	; 0x30
 8013688:	ee67 7aa6 	vmul.f32	s15, s15, s13
 801368c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013690:	edcd 7a01 	vstr	s15, [sp, #4]
 8013694:	e001      	b.n	801369a <limits_homing_cycle+0x16a>
    int32_t initial_trigger_position = 0, autosquare_fail_distance = 0;
 8013696:	2300      	movs	r3, #0
 8013698:	9301      	str	r3, [sp, #4]
 801369a:	2700      	movs	r7, #0
 801369c:	463e      	mov	r6, r7
 801369e:	46b8      	mov	r8, r7
 80136a0:	9700      	str	r7, [sp, #0]
 80136a2:	f8cd b014 	str.w	fp, [sp, #20]
 80136a6:	f89d b00f 	ldrb.w	fp, [sp, #15]
 80136aa:	e136      	b.n	801391a <limits_homing_cycle+0x3ea>
#else
                sys.position[idx] = 0;
#endif
                // Set target direction based on cycle mask and homing cycle approach state.
                if (bit_istrue(settings.homing.dir_mask.value, bit(idx)))
                    target.values[idx] = mode == HomingMode_Pulloff ? max_travel : - max_travel;
 80136ac:	eef0 7a68 	vmov.f32	s15, s17
 80136b0:	aa18      	add	r2, sp, #96	; 0x60
 80136b2:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 80136b6:	ed42 7a08 	vstr	s15, [r2, #-32]	; 0xffffffe0
                else
                    target.values[idx] = mode == HomingMode_Pulloff ? - max_travel : max_travel;

                // Apply axislock to the step port pins active in this cycle.
                axislock.mask |= step_pin[idx];
 80136ba:	aa18      	add	r2, sp, #96	; 0x60
 80136bc:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 80136c0:	f852 2c10 	ldr.w	r2, [r2, #-16]
 80136c4:	4314      	orrs	r4, r2
            }
        } while(idx);
 80136c6:	b333      	cbz	r3, 8013716 <limits_homing_cycle+0x1e6>
            if (bit_istrue(cycle.mask, bit(--idx))) {
 80136c8:	3b01      	subs	r3, #1
 80136ca:	fa21 f203 	lsr.w	r2, r1, r3
 80136ce:	f012 0f01 	tst.w	r2, #1
 80136d2:	d0f8      	beq.n	80136c6 <limits_homing_cycle+0x196>
                n_active_axis++;
 80136d4:	3501      	adds	r5, #1
                sys.position[idx] = 0;
 80136d6:	f103 0222 	add.w	r2, r3, #34	; 0x22
 80136da:	482d      	ldr	r0, [pc, #180]	; (8013790 <limits_homing_cycle+0x260>)
 80136dc:	f04f 0c00 	mov.w	ip, #0
 80136e0:	f840 c022 	str.w	ip, [r0, r2, lsl #2]
                if (bit_istrue(settings.homing.dir_mask.value, bit(idx)))
 80136e4:	4a2c      	ldr	r2, [pc, #176]	; (8013798 <limits_homing_cycle+0x268>)
 80136e6:	f892 2110 	ldrb.w	r2, [r2, #272]	; 0x110
 80136ea:	40da      	lsrs	r2, r3
 80136ec:	f012 0f01 	tst.w	r2, #1
 80136f0:	d004      	beq.n	80136fc <limits_homing_cycle+0x1cc>
                    target.values[idx] = mode == HomingMode_Pulloff ? max_travel : - max_travel;
 80136f2:	2e02      	cmp	r6, #2
 80136f4:	d0da      	beq.n	80136ac <limits_homing_cycle+0x17c>
 80136f6:	eef1 7a68 	vneg.f32	s15, s17
 80136fa:	e7d9      	b.n	80136b0 <limits_homing_cycle+0x180>
                    target.values[idx] = mode == HomingMode_Pulloff ? - max_travel : max_travel;
 80136fc:	2e02      	cmp	r6, #2
 80136fe:	d007      	beq.n	8013710 <limits_homing_cycle+0x1e0>
 8013700:	eef0 7a68 	vmov.f32	s15, s17
 8013704:	aa18      	add	r2, sp, #96	; 0x60
 8013706:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 801370a:	ed42 7a08 	vstr	s15, [r2, #-32]	; 0xffffffe0
 801370e:	e7d4      	b.n	80136ba <limits_homing_cycle+0x18a>
 8013710:	eef1 7a68 	vneg.f32	s15, s17
 8013714:	e7f6      	b.n	8013704 <limits_homing_cycle+0x1d4>
#ifdef KINEMATICS_API
        if(kinematics.homing_cycle_get_feedrate)
            homing_rate = kinematics.homing_cycle_get_feedrate(homing_rate, cycle);
#endif

        if(grbl.on_homing_rate_set)
 8013716:	4b25      	ldr	r3, [pc, #148]	; (80137ac <limits_homing_cycle+0x27c>)
 8013718:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 801371a:	b12b      	cbz	r3, 8013728 <limits_homing_cycle+0x1f8>
            grbl.on_homing_rate_set(cycle, homing_rate, mode);
 801371c:	4631      	mov	r1, r6
 801371e:	eeb0 0a48 	vmov.f32	s0, s16
 8013722:	f89d 000e 	ldrb.w	r0, [sp, #14]
 8013726:	4798      	blx	r3

        homing_rate *= sqrtf(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
 8013728:	ee07 5a90 	vmov	s15, r5
 801372c:	eeb8 0a67 	vcvt.f32.u32	s0, s15
 8013730:	f010 f94e 	bl	80239d0 <sqrtf>
 8013734:	ee28 8a00 	vmul.f32	s16, s16, s0

        // Perform homing cycle. Planner buffer should be empty, as required to initiate the homing cycle.
        plan_data.feed_rate = homing_rate;      // Set current homing rate.
 8013738:	ed8d 8a06 	vstr	s16, [sp, #24]
        sys.homing_axis_lock.mask = axislock.mask;
 801373c:	4d14      	ldr	r5, [pc, #80]	; (8013790 <limits_homing_cycle+0x260>)
 801373e:	766c      	strb	r4, [r5, #25]

#ifdef KINEMATICS_API
        coord_data_t k_target;
        plan_buffer_line(kinematics.transform_from_cartesian(k_target.values, target.values), &plan_data);    // Bypass mc_line(). Directly plan homing motion.;
#else
        plan_buffer_line(target.values, &plan_data);    // Bypass mc_line(). Directly plan homing motion.
 8013740:	a906      	add	r1, sp, #24
 8013742:	a810      	add	r0, sp, #64	; 0x40
 8013744:	f003 f876 	bl	8016834 <plan_buffer_line>
#endif

        sys.step_control.flags = 0;
 8013748:	2300      	movs	r3, #0
 801374a:	762b      	strb	r3, [r5, #24]
        sys.step_control.execute_sys_motion = On; // Set to execute homing motion and clear existing flags.
 801374c:	2304      	movs	r3, #4
 801374e:	762b      	strb	r3, [r5, #24]
        st_prep_buffer();   // Prep and fill segment buffer from newly planned block.
 8013750:	f00b fe3e 	bl	801f3d0 <st_prep_buffer>
        st_wake_up();       // Initiate motion
 8013754:	f00b fb5a 	bl	801ee0c <st_wake_up>
 8013758:	e048      	b.n	80137ec <limits_homing_cycle+0x2bc>
                // Auto squaring check
                if((homing_state.mask & auto_square.mask) && squaring_mode == SquaringMode_Both) {
                    if((autosquare_check = (limits_state.min.mask & auto_square.mask) != (limits_state.min2.mask & auto_square.mask))) {
                        initial_trigger_position = sys.position[dual_motor_axis];
                        homing_state.mask &= ~auto_square.mask;
                        squaring_mode = (limits_state.min.mask & auto_square.mask) ? SquaringMode_A : SquaringMode_B;
 801375a:	f04f 0802 	mov.w	r8, #2
 801375e:	e072      	b.n	8013846 <limits_homing_cycle+0x316>
                        axislock.mask &= ~bit(idx);
#endif
                        if(idx == dual_motor_axis)
                            autosquare_check = false;
                    }
                } while(idx);
 8013760:	b333      	cbz	r3, 80137b0 <limits_homing_cycle+0x280>
                    idx--;
 8013762:	3b01      	subs	r3, #1
                    if ((axislock.mask & step_pin[idx]) && (homing_state.mask & bit(idx))) {
 8013764:	b2e2      	uxtb	r2, r4
 8013766:	a918      	add	r1, sp, #96	; 0x60
 8013768:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 801376c:	f851 1c10 	ldr.w	r1, [r1, #-16]
 8013770:	420a      	tst	r2, r1
 8013772:	d0f5      	beq.n	8013760 <limits_homing_cycle+0x230>
 8013774:	b2e9      	uxtb	r1, r5
 8013776:	40d9      	lsrs	r1, r3
 8013778:	f011 0f01 	tst.w	r1, #1
 801377c:	d0f0      	beq.n	8013760 <limits_homing_cycle+0x230>
                        axislock.mask &= ~bit(idx);
 801377e:	2401      	movs	r4, #1
 8013780:	409c      	lsls	r4, r3
 8013782:	ea22 0404 	bic.w	r4, r2, r4
                        if(idx == dual_motor_axis)
 8013786:	4599      	cmp	r9, r3
 8013788:	d1ea      	bne.n	8013760 <limits_homing_cycle+0x230>
                            autosquare_check = false;
 801378a:	2700      	movs	r7, #0
 801378c:	e7e8      	b.n	8013760 <limits_homing_cycle+0x230>
 801378e:	bf00      	nop
 8013790:	200036c4 	.word	0x200036c4
 8013794:	2000350c 	.word	0x2000350c
 8013798:	20003b14 	.word	0x20003b14
 801379c:	20003344 	.word	0x20003344
 80137a0:	00000000 	.word	0x00000000
 80137a4:	08013165 	.word	0x08013165
 80137a8:	42c80000 	.word	0x42c80000
 80137ac:	2000343c 	.word	0x2000343c

                sys.homing_axis_lock.mask = axislock.mask;
 80137b0:	4b96      	ldr	r3, [pc, #600]	; (8013a0c <limits_homing_cycle+0x4dc>)
 80137b2:	765c      	strb	r4, [r3, #25]

                if (autosquare_check && abs(initial_trigger_position - sys.position[dual_motor_axis]) > autosquare_fail_distance) {
 80137b4:	b167      	cbz	r7, 80137d0 <limits_homing_cycle+0x2a0>
 80137b6:	f109 0322 	add.w	r3, r9, #34	; 0x22
 80137ba:	4a94      	ldr	r2, [pc, #592]	; (8013a0c <limits_homing_cycle+0x4dc>)
 80137bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80137c0:	9a00      	ldr	r2, [sp, #0]
 80137c2:	1ad3      	subs	r3, r2, r3
 80137c4:	2b00      	cmp	r3, #0
 80137c6:	bfb8      	it	lt
 80137c8:	425b      	neglt	r3, r3
 80137ca:	9a01      	ldr	r2, [sp, #4]
 80137cc:	4293      	cmp	r3, r2
 80137ce:	dc42      	bgt.n	8013856 <limits_homing_cycle+0x326>
                    protocol_execute_realtime();
                    return false;
                }
            }

            st_prep_buffer(); // Check and prep segment buffer.
 80137d0:	f00b fdfe 	bl	801f3d0 <st_prep_buffer>

            // Exit routines: No time to run protocol_execute_realtime() in this loop.
            if (sys.rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET | EXEC_CYCLE_COMPLETE)) {
 80137d4:	4b8d      	ldr	r3, [pc, #564]	; (8013a0c <limits_homing_cycle+0x4dc>)
 80137d6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80137d8:	f013 0f64 	tst.w	r3, #100	; 0x64
 80137dc:	d146      	bne.n	801386c <limits_homing_cycle+0x33c>
                    system_clear_exec_state_flag(EXEC_CYCLE_COMPLETE);
                    break;
                }
            }

            grbl.on_execute_realtime(STATE_HOMING);
 80137de:	4b8c      	ldr	r3, [pc, #560]	; (8013a10 <limits_homing_cycle+0x4e0>)
 80137e0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80137e2:	2004      	movs	r0, #4
 80137e4:	4798      	blx	r3

        } while (axislock.mask & AXES_BITMASK);
 80137e6:	f014 0f07 	tst.w	r4, #7
 80137ea:	d066      	beq.n	80138ba <limits_homing_cycle+0x38a>
            if (mode != HomingMode_Pulloff) {
 80137ec:	2e02      	cmp	r6, #2
 80137ee:	d0ef      	beq.n	80137d0 <limits_homing_cycle+0x2a0>
                homing_state = homing_signals_select(limits_state = hal.homing.get_state(), auto_square, squaring_mode);
 80137f0:	4b88      	ldr	r3, [pc, #544]	; (8013a14 <limits_homing_cycle+0x4e4>)
 80137f2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80137f4:	4798      	blx	r3
 80137f6:	9013      	str	r0, [sp, #76]	; 0x4c
 80137f8:	4642      	mov	r2, r8
 80137fa:	4659      	mov	r1, fp
 80137fc:	f7ff fc94 	bl	8013128 <homing_signals_select>
 8013800:	4605      	mov	r5, r0
                if((homing_state.mask & auto_square.mask) && squaring_mode == SquaringMode_Both) {
 8013802:	b2c2      	uxtb	r2, r0
 8013804:	ea1a 0f05 	tst.w	sl, r5
 8013808:	d023      	beq.n	8013852 <limits_homing_cycle+0x322>
 801380a:	f1b8 0f00 	cmp.w	r8, #0
 801380e:	d120      	bne.n	8013852 <limits_homing_cycle+0x322>
                    if((autosquare_check = (limits_state.min.mask & auto_square.mask) != (limits_state.min2.mask & auto_square.mask))) {
 8013810:	f89d 104c 	ldrb.w	r1, [sp, #76]	; 0x4c
 8013814:	f89d 304e 	ldrb.w	r3, [sp, #78]	; 0x4e
 8013818:	404b      	eors	r3, r1
 801381a:	ea0a 0303 	and.w	r3, sl, r3
 801381e:	2b00      	cmp	r3, #0
 8013820:	bf14      	ite	ne
 8013822:	2701      	movne	r7, #1
 8013824:	2700      	moveq	r7, #0
 8013826:	d014      	beq.n	8013852 <limits_homing_cycle+0x322>
                        initial_trigger_position = sys.position[dual_motor_axis];
 8013828:	f109 0322 	add.w	r3, r9, #34	; 0x22
 801382c:	4877      	ldr	r0, [pc, #476]	; (8013a0c <limits_homing_cycle+0x4dc>)
 801382e:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 8013832:	9300      	str	r3, [sp, #0]
                        homing_state.mask &= ~auto_square.mask;
 8013834:	ea6f 050a 	mvn.w	r5, sl
 8013838:	b26d      	sxtb	r5, r5
 801383a:	4015      	ands	r5, r2
                        squaring_mode = (limits_state.min.mask & auto_square.mask) ? SquaringMode_A : SquaringMode_B;
 801383c:	ea1a 0f01 	tst.w	sl, r1
 8013840:	d08b      	beq.n	801375a <limits_homing_cycle+0x22a>
 8013842:	f04f 0801 	mov.w	r8, #1
                        hal.stepper.disable_motors(auto_square, squaring_mode);
 8013846:	4b73      	ldr	r3, [pc, #460]	; (8013a14 <limits_homing_cycle+0x4e4>)
 8013848:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801384c:	4641      	mov	r1, r8
 801384e:	4658      	mov	r0, fp
 8013850:	4798      	blx	r3
                idx = N_AXIS;
 8013852:	2303      	movs	r3, #3
 8013854:	e785      	b.n	8013762 <limits_homing_cycle+0x232>
                    system_set_exec_alarm(Alarm_HomingFailAutoSquaringApproach);
 8013856:	4b6f      	ldr	r3, [pc, #444]	; (8013a14 <limits_homing_cycle+0x4e4>)
 8013858:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801385a:	210f      	movs	r1, #15
 801385c:	486e      	ldr	r0, [pc, #440]	; (8013a18 <limits_homing_cycle+0x4e8>)
 801385e:	4798      	blx	r3
                    mc_reset();
 8013860:	f001 fa5a 	bl	8014d18 <mc_reset>
                    protocol_execute_realtime();
 8013864:	f003 fef2 	bl	801764c <protocol_execute_realtime>
                    return false;
 8013868:	2000      	movs	r0, #0
 801386a:	e0c5      	b.n	80139f8 <limits_homing_cycle+0x4c8>
                uint_fast16_t rt_exec = sys.rt_exec_state;
 801386c:	4b67      	ldr	r3, [pc, #412]	; (8013a0c <limits_homing_cycle+0x4dc>)
 801386e:	6c9c      	ldr	r4, [r3, #72]	; 0x48
                if (rt_exec & EXEC_RESET)
 8013870:	f014 0f20 	tst.w	r4, #32
 8013874:	d004      	beq.n	8013880 <limits_homing_cycle+0x350>
                    system_set_exec_alarm(Alarm_HomingFailReset);
 8013876:	4b67      	ldr	r3, [pc, #412]	; (8013a14 <limits_homing_cycle+0x4e4>)
 8013878:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801387a:	2106      	movs	r1, #6
 801387c:	4866      	ldr	r0, [pc, #408]	; (8013a18 <limits_homing_cycle+0x4e8>)
 801387e:	4798      	blx	r3
                if (rt_exec & EXEC_SAFETY_DOOR)
 8013880:	f014 0f40 	tst.w	r4, #64	; 0x40
 8013884:	d004      	beq.n	8013890 <limits_homing_cycle+0x360>
                    system_set_exec_alarm(Alarm_HomingFailDoor);
 8013886:	4b63      	ldr	r3, [pc, #396]	; (8013a14 <limits_homing_cycle+0x4e4>)
 8013888:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801388a:	2107      	movs	r1, #7
 801388c:	4862      	ldr	r0, [pc, #392]	; (8013a18 <limits_homing_cycle+0x4e8>)
 801388e:	4798      	blx	r3
                if (mode == HomingMode_Pulloff && (homing_signals_select(hal.homing.get_state(), (axes_signals_t){0}, SquaringMode_Both).mask & cycle.mask))
 8013890:	2e02      	cmp	r6, #2
 8013892:	d04c      	beq.n	801392e <limits_homing_cycle+0x3fe>
                if (mode != HomingMode_Pulloff && (rt_exec & EXEC_CYCLE_COMPLETE))
 8013894:	2e02      	cmp	r6, #2
 8013896:	d007      	beq.n	80138a8 <limits_homing_cycle+0x378>
 8013898:	f014 0f04 	tst.w	r4, #4
 801389c:	d004      	beq.n	80138a8 <limits_homing_cycle+0x378>
                    system_set_exec_alarm(Alarm_HomingFailApproach);
 801389e:	4b5d      	ldr	r3, [pc, #372]	; (8013a14 <limits_homing_cycle+0x4e4>)
 80138a0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80138a2:	2109      	movs	r1, #9
 80138a4:	485c      	ldr	r0, [pc, #368]	; (8013a18 <limits_homing_cycle+0x4e8>)
 80138a6:	4798      	blx	r3
                if (sys.rt_exec_alarm) {
 80138a8:	4b58      	ldr	r3, [pc, #352]	; (8013a0c <limits_homing_cycle+0x4dc>)
 80138aa:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80138ac:	2b00      	cmp	r3, #0
 80138ae:	d150      	bne.n	8013952 <limits_homing_cycle+0x422>
                    system_clear_exec_state_flag(EXEC_CYCLE_COMPLETE);
 80138b0:	4b58      	ldr	r3, [pc, #352]	; (8013a14 <limits_homing_cycle+0x4e4>)
 80138b2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80138b4:	2104      	movs	r1, #4
 80138b6:	4859      	ldr	r0, [pc, #356]	; (8013a1c <limits_homing_cycle+0x4ec>)
 80138b8:	4798      	blx	r3

        st_reset(); // Immediately force kill steppers and reset step segment buffer.
 80138ba:	f00b fc55 	bl	801f168 <st_reset>
        hal.delay_ms(settings.homing.debounce_delay, NULL); // Delay to allow transient dynamics to dissipate.
 80138be:	4b55      	ldr	r3, [pc, #340]	; (8013a14 <limits_homing_cycle+0x4e4>)
 80138c0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80138c2:	2100      	movs	r1, #0
 80138c4:	4a56      	ldr	r2, [pc, #344]	; (8013a20 <limits_homing_cycle+0x4f0>)
 80138c6:	f8b2 0112 	ldrh.w	r0, [r2, #274]	; 0x112
 80138ca:	4798      	blx	r3

        // Reverse direction and reset homing rate for cycle(s).
        mode = mode == HomingMode_Pulloff ? HomingMode_Locate : HomingMode_Pulloff;
 80138cc:	2e02      	cmp	r6, #2
 80138ce:	d046      	beq.n	801395e <limits_homing_cycle+0x42e>
 80138d0:	2602      	movs	r6, #2
        homing_rate = hal.homing.get_feedrate(cycle, mode);
 80138d2:	4b50      	ldr	r3, [pc, #320]	; (8013a14 <limits_homing_cycle+0x4e4>)
 80138d4:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80138d6:	4631      	mov	r1, r6
 80138d8:	f89d 000e 	ldrb.w	r0, [sp, #14]
 80138dc:	4798      	blx	r3
 80138de:	eeb0 8a40 	vmov.f32	s16, s0

        // After first cycle, homing enters locating phase. Shorten search to pull-off distance.
        if (mode == HomingMode_Locate) {
 80138e2:	2e01      	cmp	r6, #1
 80138e4:	d03d      	beq.n	8013962 <limits_homing_cycle+0x432>
            // Only one initial pass for auto squared axis when both motors are active
            //if(mode == SquaringMode_Both && auto_square.mask)
            //    cycle.mask &= ~auto_square.mask;
            max_travel = settings.homing.pulloff * HOMING_AXIS_LOCATE_SCALAR;
        } else
            max_travel = settings.homing.pulloff;
 80138e6:	4b4e      	ldr	r3, [pc, #312]	; (8013a20 <limits_homing_cycle+0x4f0>)
 80138e8:	edd3 8a43 	vldr	s17, [r3, #268]	; 0x10c

        if(auto_square.mask) {
 80138ec:	f1ba 0f00 	cmp.w	sl, #0
 80138f0:	d007      	beq.n	8013902 <limits_homing_cycle+0x3d2>
            autosquare_check = false;
            squaring_mode = SquaringMode_Both;
            hal.stepper.disable_motors((axes_signals_t){0}, SquaringMode_Both);
 80138f2:	4b48      	ldr	r3, [pc, #288]	; (8013a14 <limits_homing_cycle+0x4e4>)
 80138f4:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80138f8:	2700      	movs	r7, #0
 80138fa:	4639      	mov	r1, r7
 80138fc:	4638      	mov	r0, r7
 80138fe:	4798      	blx	r3
            squaring_mode = SquaringMode_Both;
 8013900:	46b8      	mov	r8, r7
        }

    } while (homing_rate > 0.0f && cycle.mask && n_cycle-- > 0);
 8013902:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8013906:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801390a:	dd32      	ble.n	8013972 <limits_homing_cycle+0x442>
 801390c:	f89d 300e 	ldrb.w	r3, [sp, #14]
 8013910:	b37b      	cbz	r3, 8013972 <limits_homing_cycle+0x442>
 8013912:	9a02      	ldr	r2, [sp, #8]
 8013914:	1e53      	subs	r3, r2, #1
 8013916:	b362      	cbz	r2, 8013972 <limits_homing_cycle+0x442>
 8013918:	9302      	str	r3, [sp, #8]
        system_convert_array_steps_to_mpos(target.values, sys.position);
 801391a:	4942      	ldr	r1, [pc, #264]	; (8013a24 <limits_homing_cycle+0x4f4>)
 801391c:	a810      	add	r0, sp, #64	; 0x40
 801391e:	f00d fb5d 	bl	8020fdc <system_convert_array_steps_to_mpos>
        axislock = (axes_signals_t){0};
 8013922:	f04f 0400 	mov.w	r4, #0
        n_active_axis = 0;
 8013926:	9d05      	ldr	r5, [sp, #20]
        idx = N_AXIS;
 8013928:	2303      	movs	r3, #3
 801392a:	9904      	ldr	r1, [sp, #16]
 801392c:	e6cc      	b.n	80136c8 <limits_homing_cycle+0x198>
                if (mode == HomingMode_Pulloff && (homing_signals_select(hal.homing.get_state(), (axes_signals_t){0}, SquaringMode_Both).mask & cycle.mask))
 801392e:	4b39      	ldr	r3, [pc, #228]	; (8013a14 <limits_homing_cycle+0x4e4>)
 8013930:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8013932:	4798      	blx	r3
 8013934:	9017      	str	r0, [sp, #92]	; 0x5c
 8013936:	2200      	movs	r2, #0
 8013938:	4611      	mov	r1, r2
 801393a:	f7ff fbf5 	bl	8013128 <homing_signals_select>
 801393e:	f89d 300e 	ldrb.w	r3, [sp, #14]
 8013942:	4203      	tst	r3, r0
 8013944:	d0a6      	beq.n	8013894 <limits_homing_cycle+0x364>
                    system_set_exec_alarm(Alarm_FailPulloff);
 8013946:	4b33      	ldr	r3, [pc, #204]	; (8013a14 <limits_homing_cycle+0x4e4>)
 8013948:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801394a:	2108      	movs	r1, #8
 801394c:	4832      	ldr	r0, [pc, #200]	; (8013a18 <limits_homing_cycle+0x4e8>)
 801394e:	4798      	blx	r3
 8013950:	e7a0      	b.n	8013894 <limits_homing_cycle+0x364>
                    mc_reset(); // Stop motors, if they are running.
 8013952:	f001 f9e1 	bl	8014d18 <mc_reset>
                    protocol_execute_realtime();
 8013956:	f003 fe79 	bl	801764c <protocol_execute_realtime>
                    return false;
 801395a:	2000      	movs	r0, #0
 801395c:	e04c      	b.n	80139f8 <limits_homing_cycle+0x4c8>
        mode = mode == HomingMode_Pulloff ? HomingMode_Locate : HomingMode_Pulloff;
 801395e:	2601      	movs	r6, #1
 8013960:	e7b7      	b.n	80138d2 <limits_homing_cycle+0x3a2>
            max_travel = settings.homing.pulloff * HOMING_AXIS_LOCATE_SCALAR;
 8013962:	4b2f      	ldr	r3, [pc, #188]	; (8013a20 <limits_homing_cycle+0x4f0>)
 8013964:	edd3 8a43 	vldr	s17, [r3, #268]	; 0x10c
 8013968:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 801396c:	ee68 8aa7 	vmul.f32	s17, s17, s15
 8013970:	e7bc      	b.n	80138ec <limits_homing_cycle+0x3bc>

    // Pull off B motor to compensate for switch inaccuracy when configured.
    if(auto_square.mask && settings.axis[dual_motor_axis].dual_axis_offset != 0.0f) {
 8013972:	f1ba 0f00 	cmp.w	sl, #0
 8013976:	d02b      	beq.n	80139d0 <limits_homing_cycle+0x4a0>
 8013978:	eb09 0289 	add.w	r2, r9, r9, lsl #2
 801397c:	4b28      	ldr	r3, [pc, #160]	; (8013a20 <limits_homing_cycle+0x4f0>)
 801397e:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8013982:	edd3 7a10 	vldr	s15, [r3, #64]	; 0x40
 8013986:	eef5 7a40 	vcmp.f32	s15, #0.0
 801398a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801398e:	d01f      	beq.n	80139d0 <limits_homing_cycle+0x4a0>
        hal.stepper.disable_motors(auto_square, settings.axis[dual_motor_axis].dual_axis_offset < 0.0f ? SquaringMode_B : SquaringMode_A);
 8013990:	4b20      	ldr	r3, [pc, #128]	; (8013a14 <limits_homing_cycle+0x4e4>)
 8013992:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8013996:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801399a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801399e:	d428      	bmi.n	80139f2 <limits_homing_cycle+0x4c2>
 80139a0:	2101      	movs	r1, #1
 80139a2:	f89d 400f 	ldrb.w	r4, [sp, #15]
 80139a6:	4620      	mov	r0, r4
 80139a8:	4798      	blx	r3
        if(!limits_pull_off(auto_square, fabs(settings.axis[dual_motor_axis].dual_axis_offset)))
 80139aa:	eb09 0989 	add.w	r9, r9, r9, lsl #2
 80139ae:	4b1c      	ldr	r3, [pc, #112]	; (8013a20 <limits_homing_cycle+0x4f0>)
 80139b0:	eb03 0389 	add.w	r3, r3, r9, lsl #2
 80139b4:	ed93 0a10 	vldr	s0, [r3, #64]	; 0x40
 80139b8:	eeb0 0ac0 	vabs.f32	s0, s0
 80139bc:	4620      	mov	r0, r4
 80139be:	f7ff fbdd 	bl	801317c <limits_pull_off>
 80139c2:	b1c8      	cbz	r0, 80139f8 <limits_homing_cycle+0x4c8>
            return false;
        hal.stepper.disable_motors((axes_signals_t){0}, SquaringMode_Both);
 80139c4:	4b13      	ldr	r3, [pc, #76]	; (8013a14 <limits_homing_cycle+0x4e4>)
 80139c6:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80139ca:	2100      	movs	r1, #0
 80139cc:	4608      	mov	r0, r1
 80139ce:	4798      	blx	r3
    // some initial clearance off the switches and should also help prevent them from falsely
    // triggering when hard limits are enabled or when more than one axes shares a limit pin.
#ifdef KINEMATICS_API
    kinematics.limits_set_machine_positions(cycle);
#else
    limits_set_machine_positions(cycle, true);
 80139d0:	2101      	movs	r1, #1
 80139d2:	f89d 400e 	ldrb.w	r4, [sp, #14]
 80139d6:	4620      	mov	r0, r4
 80139d8:	f7ff fd48 	bl	801346c <limits_set_machine_positions>
#endif

#if ENABLE_BACKLASH_COMPENSATION
    mc_backlash_init(cycle);
#endif
    sys.step_control.flags = 0; // Return step control to normal operation.
 80139dc:	4a0b      	ldr	r2, [pc, #44]	; (8013a0c <limits_homing_cycle+0x4dc>)
 80139de:	2300      	movs	r3, #0
 80139e0:	7613      	strb	r3, [r2, #24]
    sys.homed.mask |= cycle.mask;
 80139e2:	b2e3      	uxtb	r3, r4
 80139e4:	f892 1054 	ldrb.w	r1, [r2, #84]	; 0x54
 80139e8:	430b      	orrs	r3, r1
 80139ea:	f882 3054 	strb.w	r3, [r2, #84]	; 0x54

    return true;
 80139ee:	2001      	movs	r0, #1
 80139f0:	e002      	b.n	80139f8 <limits_homing_cycle+0x4c8>
        hal.stepper.disable_motors(auto_square, settings.axis[dual_motor_axis].dual_axis_offset < 0.0f ? SquaringMode_B : SquaringMode_A);
 80139f2:	2102      	movs	r1, #2
 80139f4:	e7d5      	b.n	80139a2 <limits_homing_cycle+0x472>
        return false;
 80139f6:	2000      	movs	r0, #0
}
 80139f8:	b019      	add	sp, #100	; 0x64
 80139fa:	ecbd 8b02 	vpop	{d8}
 80139fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return true;
 8013a02:	2001      	movs	r0, #1
 8013a04:	e7f8      	b.n	80139f8 <limits_homing_cycle+0x4c8>
        return false;
 8013a06:	2000      	movs	r0, #0
 8013a08:	e7f6      	b.n	80139f8 <limits_homing_cycle+0x4c8>
 8013a0a:	bf00      	nop
 8013a0c:	200036c4 	.word	0x200036c4
 8013a10:	2000343c 	.word	0x2000343c
 8013a14:	2000350c 	.word	0x2000350c
 8013a18:	20003710 	.word	0x20003710
 8013a1c:	2000370c 	.word	0x2000370c
 8013a20:	20003b14 	.word	0x20003b14
 8013a24:	2000374c 	.word	0x2000374c

08013a28 <limits_go_home>:

// Perform homing cycle(s) according to configuration.
// NOTE: only one auto squared axis can be homed at a time.
status_code_t limits_go_home (axes_signals_t cycle)
{
 8013a28:	b570      	push	{r4, r5, r6, lr}
 8013a2a:	b082      	sub	sp, #8
 8013a2c:	4606      	mov	r6, r0
    axes_signals_t auto_square = {0}, auto_squared = {0};
 8013a2e:	2000      	movs	r0, #0
 8013a30:	4604      	mov	r4, r0

    if(hal.stepper.get_ganged)
 8013a32:	4b1f      	ldr	r3, [pc, #124]	; (8013ab0 <limits_go_home+0x88>)
 8013a34:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8013a38:	b10b      	cbz	r3, 8013a3e <limits_go_home+0x16>
        auto_squared = hal.stepper.get_ganged(true);
 8013a3a:	2001      	movs	r0, #1
 8013a3c:	4798      	blx	r3

    auto_squared.mask &= cycle.mask;
 8013a3e:	b2f5      	uxtb	r5, r6

    if(auto_squared.mask) {
 8013a40:	4005      	ands	r5, r0
 8013a42:	d016      	beq.n	8013a72 <limits_go_home+0x4a>

        if(!hal.stepper.disable_motors)
 8013a44:	4b1a      	ldr	r3, [pc, #104]	; (8013ab0 <limits_go_home+0x88>)
 8013a46:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8013a4a:	b35b      	cbz	r3, 8013aa4 <limits_go_home+0x7c>
            return Status_IllegalHomingConfiguration; // Bad driver! - should not happen.

        auto_square.x = On;
 8013a4c:	f04f 0401 	mov.w	r4, #1
        while(!(auto_squared.mask & auto_square.mask))
 8013a50:	e000      	b.n	8013a54 <limits_go_home+0x2c>
            auto_square.mask <<= 1;
 8013a52:	005c      	lsls	r4, r3, #1
        while(!(auto_squared.mask & auto_square.mask))
 8013a54:	b2e3      	uxtb	r3, r4
 8013a56:	4225      	tst	r5, r4
 8013a58:	d0fb      	beq.n	8013a52 <limits_go_home+0x2a>

        if(auto_squared.mask != auto_square.mask)
 8013a5a:	429d      	cmp	r5, r3
 8013a5c:	d124      	bne.n	8013aa8 <limits_go_home+0x80>
            return Status_IllegalHomingConfiguration; // Attempt at squaring more than one auto squared axis at the same time.

        if((auto_squared.mask & homing_signals_select(hal.homing.get_state(), (axes_signals_t){0}, SquaringMode_Both).mask) && !limits_pull_off(auto_square, settings.homing.pulloff * HOMING_AXIS_LOCATE_SCALAR))
 8013a5e:	4b14      	ldr	r3, [pc, #80]	; (8013ab0 <limits_go_home+0x88>)
 8013a60:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8013a62:	4798      	blx	r3
 8013a64:	9001      	str	r0, [sp, #4]
 8013a66:	2200      	movs	r2, #0
 8013a68:	4611      	mov	r1, r2
 8013a6a:	f7ff fb5d 	bl	8013128 <homing_signals_select>
 8013a6e:	4205      	tst	r5, r0
 8013a70:	d10a      	bne.n	8013a88 <limits_go_home+0x60>
            return Status_LimitsEngaged; // Auto squaring with limit switch asserted is not allowed.
    }

    tc_clear_tlo_reference(cycle);
 8013a72:	4630      	mov	r0, r6
 8013a74:	f00e f876 	bl	8021b64 <tc_clear_tlo_reference>

    return limits_homing_cycle(cycle, auto_square) ? Status_OK : Status_Unhandled;
 8013a78:	4621      	mov	r1, r4
 8013a7a:	4630      	mov	r0, r6
 8013a7c:	f7ff fd58 	bl	8013530 <limits_homing_cycle>
 8013a80:	b1a0      	cbz	r0, 8013aac <limits_go_home+0x84>
 8013a82:	2000      	movs	r0, #0
}
 8013a84:	b002      	add	sp, #8
 8013a86:	bd70      	pop	{r4, r5, r6, pc}
        if((auto_squared.mask & homing_signals_select(hal.homing.get_state(), (axes_signals_t){0}, SquaringMode_Both).mask) && !limits_pull_off(auto_square, settings.homing.pulloff * HOMING_AXIS_LOCATE_SCALAR))
 8013a88:	4b0a      	ldr	r3, [pc, #40]	; (8013ab4 <limits_go_home+0x8c>)
 8013a8a:	ed93 0a43 	vldr	s0, [r3, #268]	; 0x10c
 8013a8e:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 8013a92:	ee20 0a27 	vmul.f32	s0, s0, s15
 8013a96:	4620      	mov	r0, r4
 8013a98:	f7ff fb70 	bl	801317c <limits_pull_off>
 8013a9c:	2800      	cmp	r0, #0
 8013a9e:	d1e8      	bne.n	8013a72 <limits_go_home+0x4a>
            return Status_LimitsEngaged; // Auto squaring with limit switch asserted is not allowed.
 8013aa0:	202d      	movs	r0, #45	; 0x2d
 8013aa2:	e7ef      	b.n	8013a84 <limits_go_home+0x5c>
            return Status_IllegalHomingConfiguration; // Bad driver! - should not happen.
 8013aa4:	2037      	movs	r0, #55	; 0x37
 8013aa6:	e7ed      	b.n	8013a84 <limits_go_home+0x5c>
            return Status_IllegalHomingConfiguration; // Attempt at squaring more than one auto squared axis at the same time.
 8013aa8:	2037      	movs	r0, #55	; 0x37
 8013aaa:	e7eb      	b.n	8013a84 <limits_go_home+0x5c>
    return limits_homing_cycle(cycle, auto_square) ? Status_OK : Status_Unhandled;
 8013aac:	2054      	movs	r0, #84	; 0x54
 8013aae:	e7e9      	b.n	8013a84 <limits_go_home+0x5c>
 8013ab0:	2000350c 	.word	0x2000350c
 8013ab4:	20003b14 	.word	0x20003b14

08013ab8 <limits_soft_check>:

// Performs a soft limit check. Called from mc_line() only. Assumes the machine has been homed,
// the workspace volume is in all negative space, and the system is in normal operation.
// NOTE: Also used by jogging to block travel outside soft-limit volume.
void limits_soft_check  (float *target)
{
 8013ab8:	b508      	push	{r3, lr}
    if (!system_check_travel_limits(target)) {
 8013aba:	f00d fae5 	bl	8021088 <system_check_travel_limits>
 8013abe:	b100      	cbz	r0, 8013ac2 <limits_soft_check+0xa>
        }
        mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
        system_set_exec_alarm(Alarm_SoftLimit); // Indicate soft limit critical event
        protocol_execute_realtime(); // Execute to enter critical event loop and system abort
    }
}
 8013ac0:	bd08      	pop	{r3, pc}
        sys.flags.soft_limit = On;
 8013ac2:	4a10      	ldr	r2, [pc, #64]	; (8013b04 <limits_soft_check+0x4c>)
 8013ac4:	7d93      	ldrb	r3, [r2, #22]
 8013ac6:	f043 0304 	orr.w	r3, r3, #4
 8013aca:	7593      	strb	r3, [r2, #22]
        if (state_get() == STATE_CYCLE) {
 8013acc:	f00a fd8a 	bl	801e5e4 <state_get>
 8013ad0:	2808      	cmp	r0, #8
 8013ad2:	d10c      	bne.n	8013aee <limits_soft_check+0x36>
            system_set_exec_state_flag(EXEC_FEED_HOLD);
 8013ad4:	4b0c      	ldr	r3, [pc, #48]	; (8013b08 <limits_soft_check+0x50>)
 8013ad6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8013ad8:	2108      	movs	r1, #8
 8013ada:	480c      	ldr	r0, [pc, #48]	; (8013b0c <limits_soft_check+0x54>)
 8013adc:	4798      	blx	r3
                if(!protocol_execute_realtime())
 8013ade:	f003 fdb5 	bl	801764c <protocol_execute_realtime>
 8013ae2:	2800      	cmp	r0, #0
 8013ae4:	d0ec      	beq.n	8013ac0 <limits_soft_check+0x8>
            } while (state_get() != STATE_IDLE);
 8013ae6:	f00a fd7d 	bl	801e5e4 <state_get>
 8013aea:	2800      	cmp	r0, #0
 8013aec:	d1f7      	bne.n	8013ade <limits_soft_check+0x26>
        mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
 8013aee:	f001 f913 	bl	8014d18 <mc_reset>
        system_set_exec_alarm(Alarm_SoftLimit); // Indicate soft limit critical event
 8013af2:	4b05      	ldr	r3, [pc, #20]	; (8013b08 <limits_soft_check+0x50>)
 8013af4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8013af6:	2102      	movs	r1, #2
 8013af8:	4805      	ldr	r0, [pc, #20]	; (8013b10 <limits_soft_check+0x58>)
 8013afa:	4798      	blx	r3
        protocol_execute_realtime(); // Execute to enter critical event loop and system abort
 8013afc:	f003 fda6 	bl	801764c <protocol_execute_realtime>
 8013b00:	e7de      	b.n	8013ac0 <limits_soft_check+0x8>
 8013b02:	bf00      	nop
 8013b04:	200036c4 	.word	0x200036c4
 8013b08:	2000350c 	.word	0x2000350c
 8013b0c:	2000370c 	.word	0x2000370c
 8013b10:	20003710 	.word	0x20003710

08013b14 <limits_set_homing_axes>:
// Set axes to be homed from settings.
void limits_set_homing_axes (void)
{
    uint_fast8_t idx = N_AXIS;

    sys.homing.mask = 0;
 8013b14:	4b0a      	ldr	r3, [pc, #40]	; (8013b40 <limits_set_homing_axes+0x2c>)
 8013b16:	2200      	movs	r2, #0
 8013b18:	769a      	strb	r2, [r3, #26]
    uint_fast8_t idx = N_AXIS;
 8013b1a:	2203      	movs	r2, #3

    do {
        sys.homing.mask |= settings.homing.cycle[--idx].mask;
 8013b1c:	3a01      	subs	r2, #1
 8013b1e:	4b09      	ldr	r3, [pc, #36]	; (8013b44 <limits_set_homing_axes+0x30>)
 8013b20:	4413      	add	r3, r2
 8013b22:	f893 3115 	ldrb.w	r3, [r3, #277]	; 0x115
 8013b26:	4906      	ldr	r1, [pc, #24]	; (8013b40 <limits_set_homing_axes+0x2c>)
 8013b28:	7e88      	ldrb	r0, [r1, #26]
 8013b2a:	4303      	orrs	r3, r0
 8013b2c:	768b      	strb	r3, [r1, #26]
    } while(idx);
 8013b2e:	2a00      	cmp	r2, #0
 8013b30:	d1f4      	bne.n	8013b1c <limits_set_homing_axes+0x8>

    sys.homed.mask &= sys.homing.mask;
 8013b32:	460a      	mov	r2, r1
 8013b34:	f891 1054 	ldrb.w	r1, [r1, #84]	; 0x54
 8013b38:	400b      	ands	r3, r1
 8013b3a:	f882 3054 	strb.w	r3, [r2, #84]	; 0x54
}
 8013b3e:	4770      	bx	lr
 8013b40:	200036c4 	.word	0x200036c4
 8013b44:	20003b14 	.word	0x20003b14

08013b48 <limits_homing_required>:

// Check if homing is required.
bool limits_homing_required (void)
{
    return settings.homing.flags.enabled && settings.homing.flags.init_lock &&
 8013b48:	4b0f      	ldr	r3, [pc, #60]	; (8013b88 <limits_homing_required+0x40>)
 8013b4a:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 8013b4e:	f003 0205 	and.w	r2, r3, #5
            (sys.cold_start || !settings.homing.flags.override_locks) &&
              sys.homing.mask && (sys.homing.mask & sys.homed.mask) != sys.homing.mask;
 8013b52:	2a05      	cmp	r2, #5
 8013b54:	d001      	beq.n	8013b5a <limits_homing_required+0x12>
 8013b56:	2000      	movs	r0, #0
 8013b58:	4770      	bx	lr
            (sys.cold_start || !settings.homing.flags.override_locks) &&
 8013b5a:	4a0c      	ldr	r2, [pc, #48]	; (8013b8c <limits_homing_required+0x44>)
 8013b5c:	f892 207d 	ldrb.w	r2, [r2, #125]	; 0x7d
    return settings.homing.flags.enabled && settings.homing.flags.init_lock &&
 8013b60:	b912      	cbnz	r2, 8013b68 <limits_homing_required+0x20>
            (sys.cold_start || !settings.homing.flags.override_locks) &&
 8013b62:	f013 0f20 	tst.w	r3, #32
 8013b66:	d10b      	bne.n	8013b80 <limits_homing_required+0x38>
              sys.homing.mask && (sys.homing.mask & sys.homed.mask) != sys.homing.mask;
 8013b68:	4b08      	ldr	r3, [pc, #32]	; (8013b8c <limits_homing_required+0x44>)
 8013b6a:	7e9b      	ldrb	r3, [r3, #26]
            (sys.cold_start || !settings.homing.flags.override_locks) &&
 8013b6c:	b153      	cbz	r3, 8013b84 <limits_homing_required+0x3c>
              sys.homing.mask && (sys.homing.mask & sys.homed.mask) != sys.homing.mask;
 8013b6e:	4a07      	ldr	r2, [pc, #28]	; (8013b8c <limits_homing_required+0x44>)
 8013b70:	f892 2054 	ldrb.w	r2, [r2, #84]	; 0x54
 8013b74:	4393      	bics	r3, r2
 8013b76:	d001      	beq.n	8013b7c <limits_homing_required+0x34>
 8013b78:	2001      	movs	r0, #1
}
 8013b7a:	4770      	bx	lr
              sys.homing.mask && (sys.homing.mask & sys.homed.mask) != sys.homing.mask;
 8013b7c:	2000      	movs	r0, #0
 8013b7e:	4770      	bx	lr
 8013b80:	2000      	movs	r0, #0
 8013b82:	4770      	bx	lr
 8013b84:	2000      	movs	r0, #0
 8013b86:	4770      	bx	lr
 8013b88:	20003b14 	.word	0x20003b14
 8013b8c:	200036c4 	.word	0x200036c4

08013b90 <message_get>:
    { .id = Message_ExecuteTPW, .text = "Perform a probe with $TPW first!", .type = Message_Warning},
    { .id = Message_ProbeProtected, .text = "Probe protection activated."}
};

const message_t *message_get (message_code_t id)
{
 8013b90:	4601      	mov	r1, r0
    uint_fast16_t idx = 0;
    const message_t *msg = NULL;
 8013b92:	2000      	movs	r0, #0
    uint_fast16_t idx = 0;
 8013b94:	4603      	mov	r3, r0
 8013b96:	e003      	b.n	8013ba0 <message_get+0x10>

    do {
        if(messages[idx].id == id)
            msg = &messages[idx];
    } while(msg == NULL && ++idx < Message_NextMessage);
 8013b98:	b958      	cbnz	r0, 8013bb2 <message_get+0x22>
 8013b9a:	3301      	adds	r3, #1
 8013b9c:	2b15      	cmp	r3, #21
 8013b9e:	d808      	bhi.n	8013bb2 <message_get+0x22>
        if(messages[idx].id == id)
 8013ba0:	4a04      	ldr	r2, [pc, #16]	; (8013bb4 <message_get+0x24>)
 8013ba2:	f812 2033 	ldrb.w	r2, [r2, r3, lsl #3]
 8013ba6:	428a      	cmp	r2, r1
 8013ba8:	d1f6      	bne.n	8013b98 <message_get+0x8>
            msg = &messages[idx];
 8013baa:	4802      	ldr	r0, [pc, #8]	; (8013bb4 <message_get+0x24>)
 8013bac:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
 8013bb0:	e7f2      	b.n	8013b98 <message_get+0x8>

    return msg;
}
 8013bb2:	4770      	bx	lr
 8013bb4:	08026c38 	.word	0x08026c38

08013bb8 <mc_line>:
// NOTE: This is the primary gateway to the grbl planner. All line motions, including arc line
// segments, must pass through this routine before being passed to the planner. The separation of
// mc_line and plan_buffer_line is done primarily to place non-planner-type functions from being
// in the planner and to let backlash compensation or canned cycle integration simple and direct.
bool mc_line (float *target, plan_line_data_t *pl_data)
{
 8013bb8:	b538      	push	{r3, r4, r5, lr}
 8013bba:	4605      	mov	r5, r0
 8013bbc:	460c      	mov	r4, r1
#endif

    // If enabled, check for soft limit violations. Placed here all line motions are picked up
    // from everywhere in Grbl.
    // NOTE: Block jog motions. Jogging is a special case and soft limits are handled independently.
    if (!pl_data->condition.jog_motion && settings.limits.flags.soft_enabled)
 8013bbe:	7d0b      	ldrb	r3, [r1, #20]
 8013bc0:	f013 0f04 	tst.w	r3, #4
 8013bc4:	d105      	bne.n	8013bd2 <mc_line+0x1a>
 8013bc6:	4b20      	ldr	r3, [pc, #128]	; (8013c48 <mc_line+0x90>)
 8013bc8:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 8013bcc:	f013 0f02 	tst.w	r3, #2
 8013bd0:	d10b      	bne.n	8013bea <mc_line+0x32>
        limits_soft_check(target);

    // If in check gcode mode, prevent motion by blocking planner. Soft limits still work.
    if (state_get() != STATE_CHECK_MODE && protocol_execute_realtime()) {
 8013bd2:	f00a fd07 	bl	801e5e4 <state_get>
 8013bd6:	2802      	cmp	r0, #2
 8013bd8:	d10a      	bne.n	8013bf0 <mc_line+0x38>
        pl_data->feed_rate = feed_rate;
      }
#endif
    }

    return !ABORTED;
 8013bda:	4b1c      	ldr	r3, [pc, #112]	; (8013c4c <mc_line+0x94>)
 8013bdc:	781b      	ldrb	r3, [r3, #0]
 8013bde:	bb73      	cbnz	r3, 8013c3e <mc_line+0x86>
 8013be0:	4b1a      	ldr	r3, [pc, #104]	; (8013c4c <mc_line+0x94>)
 8013be2:	785b      	ldrb	r3, [r3, #1]
 8013be4:	b373      	cbz	r3, 8013c44 <mc_line+0x8c>
 8013be6:	2300      	movs	r3, #0
 8013be8:	e02a      	b.n	8013c40 <mc_line+0x88>
        limits_soft_check(target);
 8013bea:	f7ff ff65 	bl	8013ab8 <limits_soft_check>
 8013bee:	e7f0      	b.n	8013bd2 <mc_line+0x1a>
    if (state_get() != STATE_CHECK_MODE && protocol_execute_realtime()) {
 8013bf0:	f003 fd2c 	bl	801764c <protocol_execute_realtime>
 8013bf4:	2800      	cmp	r0, #0
 8013bf6:	d0f0      	beq.n	8013bda <mc_line+0x22>
            if(!protocol_execute_realtime())    // Check for any run-time commands
 8013bf8:	f003 fd28 	bl	801764c <protocol_execute_realtime>
 8013bfc:	4603      	mov	r3, r0
 8013bfe:	b1f8      	cbz	r0, 8013c40 <mc_line+0x88>
            if(plan_check_full_buffer())
 8013c00:	f002 fd7a 	bl	80166f8 <plan_check_full_buffer>
 8013c04:	b110      	cbz	r0, 8013c0c <mc_line+0x54>
                protocol_auto_cycle_start();    // Auto-cycle start when buffer is full.
 8013c06:	f003 fa05 	bl	8017014 <protocol_auto_cycle_start>
            if(!protocol_execute_realtime())    // Check for any run-time commands
 8013c0a:	e7f5      	b.n	8013bf8 <mc_line+0x40>
        if(!plan_buffer_line(target, pl_data) && pl_data->spindle.hal->cap.laser && pl_data->spindle.state.on && !pl_data->spindle.state.ccw) {
 8013c0c:	4621      	mov	r1, r4
 8013c0e:	4628      	mov	r0, r5
 8013c10:	f002 fe10 	bl	8016834 <plan_buffer_line>
 8013c14:	2800      	cmp	r0, #0
 8013c16:	d1e0      	bne.n	8013bda <mc_line+0x22>
 8013c18:	6923      	ldr	r3, [r4, #16]
 8013c1a:	7a5b      	ldrb	r3, [r3, #9]
 8013c1c:	f013 0f08 	tst.w	r3, #8
 8013c20:	d0db      	beq.n	8013bda <mc_line+0x22>
 8013c22:	7a23      	ldrb	r3, [r4, #8]
 8013c24:	f003 0303 	and.w	r3, r3, #3
 8013c28:	2b01      	cmp	r3, #1
 8013c2a:	d1d6      	bne.n	8013bda <mc_line+0x22>
            protocol_buffer_synchronize();
 8013c2c:	f003 ffd4 	bl	8017bd8 <protocol_buffer_synchronize>
            pl_data->spindle.hal->set_state(pl_data->spindle.state, pl_data->spindle.rpm);
 8013c30:	6923      	ldr	r3, [r4, #16]
 8013c32:	69db      	ldr	r3, [r3, #28]
 8013c34:	ed94 0a01 	vldr	s0, [r4, #4]
 8013c38:	7a20      	ldrb	r0, [r4, #8]
 8013c3a:	4798      	blx	r3
 8013c3c:	e7cd      	b.n	8013bda <mc_line+0x22>
    return !ABORTED;
 8013c3e:	2300      	movs	r3, #0
}
 8013c40:	4618      	mov	r0, r3
 8013c42:	bd38      	pop	{r3, r4, r5, pc}
    return !ABORTED;
 8013c44:	2301      	movs	r3, #1
 8013c46:	e7fb      	b.n	8013c40 <mc_line+0x88>
 8013c48:	20003b14 	.word	0x20003b14
 8013c4c:	200036c4 	.word	0x200036c4

08013c50 <mc_arc>:
// for vector transformation direction.
// The arc is approximated by generating a huge number of tiny, linear segments. The chordal tolerance
// of each segment is configured in settings.arc_tolerance, which is defined to be the maximum normal
// distance from segment to the circle when the end points both lie on the circle.
void mc_arc (float *target, plan_line_data_t *pl_data, float *position, float *offset, float radius, plane_t plane, int32_t turns)
{
 8013c50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013c54:	ed2d 8b06 	vpush	{d8-d10}
 8013c58:	b09d      	sub	sp, #116	; 0x74
 8013c5a:	9011      	str	r0, [sp, #68]	; 0x44
 8013c5c:	9105      	str	r1, [sp, #20]
 8013c5e:	4690      	mov	r8, r2
 8013c60:	461c      	mov	r4, r3
 8013c62:	eeb0 8a40 	vmov.f32	s16, s0
    double center_axis0 = (double)position[plane.axis_0] + (double)offset[plane.axis_0];
 8013c66:	f89d a0b0 	ldrb.w	sl, [sp, #176]	; 0xb0
 8013c6a:	ea4f 098a 	mov.w	r9, sl, lsl #2
 8013c6e:	eb02 058a 	add.w	r5, r2, sl, lsl #2
 8013c72:	6828      	ldr	r0, [r5, #0]
 8013c74:	f7f4 fbb0 	bl	80083d8 <__aeabi_f2d>
 8013c78:	4606      	mov	r6, r0
 8013c7a:	460f      	mov	r7, r1
 8013c7c:	940c      	str	r4, [sp, #48]	; 0x30
 8013c7e:	eb04 0209 	add.w	r2, r4, r9
 8013c82:	9212      	str	r2, [sp, #72]	; 0x48
 8013c84:	6810      	ldr	r0, [r2, #0]
 8013c86:	f7f4 fba7 	bl	80083d8 <__aeabi_f2d>
 8013c8a:	4602      	mov	r2, r0
 8013c8c:	460b      	mov	r3, r1
 8013c8e:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8013c92:	4630      	mov	r0, r6
 8013c94:	4639      	mov	r1, r7
 8013c96:	f7f4 fa41 	bl	800811c <__adddf3>
 8013c9a:	e9cd 0106 	strd	r0, r1, [sp, #24]
    double center_axis1 = (double)position[plane.axis_1] + (double)offset[plane.axis_1];
 8013c9e:	f89d b0b1 	ldrb.w	fp, [sp, #177]	; 0xb1
 8013ca2:	ea4f 048b 	mov.w	r4, fp, lsl #2
 8013ca6:	eb08 018b 	add.w	r1, r8, fp, lsl #2
 8013caa:	9110      	str	r1, [sp, #64]	; 0x40
 8013cac:	6808      	ldr	r0, [r1, #0]
 8013cae:	f7f4 fb93 	bl	80083d8 <__aeabi_f2d>
 8013cb2:	e9cd 0108 	strd	r0, r1, [sp, #32]
 8013cb6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8013cb8:	4423      	add	r3, r4
 8013cba:	9313      	str	r3, [sp, #76]	; 0x4c
 8013cbc:	6818      	ldr	r0, [r3, #0]
 8013cbe:	f7f4 fb8b 	bl	80083d8 <__aeabi_f2d>
 8013cc2:	4606      	mov	r6, r0
 8013cc4:	460f      	mov	r7, r1
 8013cc6:	4602      	mov	r2, r0
 8013cc8:	460b      	mov	r3, r1
 8013cca:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8013cce:	f7f4 fa25 	bl	800811c <__adddf3>
 8013cd2:	e9cd 0108 	strd	r0, r1, [sp, #32]
    double r_axis0 = -(double)offset[plane.axis_0];  // Radius vector from center to current location
 8013cd6:	ed9f 7bbc 	vldr	d7, [pc, #752]	; 8013fc8 <mc_arc+0x378>
 8013cda:	ed8d 7b0a 	vstr	d7, [sp, #40]	; 0x28
 8013cde:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8013ce2:	920a      	str	r2, [sp, #40]	; 0x28
 8013ce4:	f103 4100 	add.w	r1, r3, #2147483648	; 0x80000000
 8013ce8:	910b      	str	r1, [sp, #44]	; 0x2c
    double r_axis1 = -(double)offset[plane.axis_1];
 8013cea:	ed8d 7b02 	vstr	d7, [sp, #8]
 8013cee:	9602      	str	r6, [sp, #8]
 8013cf0:	f107 4100 	add.w	r1, r7, #2147483648	; 0x80000000
 8013cf4:	9103      	str	r1, [sp, #12]
    double rt_axis0 = (double)target[plane.axis_0] - center_axis0;
 8013cf6:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8013cf8:	4499      	add	r9, r3
 8013cfa:	f8d9 0000 	ldr.w	r0, [r9]
 8013cfe:	f7f4 fb6b 	bl	80083d8 <__aeabi_f2d>
 8013d02:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 8013d06:	f7f4 fa07 	bl	8008118 <__aeabi_dsub>
 8013d0a:	4606      	mov	r6, r0
 8013d0c:	460f      	mov	r7, r1
    double rt_axis1 = (double)target[plane.axis_1] - center_axis1;
 8013d0e:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8013d10:	4423      	add	r3, r4
 8013d12:	6818      	ldr	r0, [r3, #0]
 8013d14:	f7f4 fb60 	bl	80083d8 <__aeabi_f2d>
 8013d18:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8013d1c:	f7f4 f9fc 	bl	8008118 <__aeabi_dsub>
    // CCW angle between position and target from circle center. Only one atan2() trig computation required.
    float angular_travel = (float)atan2(r_axis0 * rt_axis1 - r_axis1 * rt_axis0, r_axis0 * rt_axis0 + r_axis1 * rt_axis1);
 8013d20:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
 8013d24:	4602      	mov	r2, r0
 8013d26:	460b      	mov	r3, r1
 8013d28:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 8013d2c:	f7f4 fbac 	bl	8008488 <__aeabi_dmul>
 8013d30:	e9cd 0114 	strd	r0, r1, [sp, #80]	; 0x50
 8013d34:	4632      	mov	r2, r6
 8013d36:	463b      	mov	r3, r7
 8013d38:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8013d3c:	f7f4 fba4 	bl	8008488 <__aeabi_dmul>
 8013d40:	e9cd 0116 	strd	r0, r1, [sp, #88]	; 0x58
 8013d44:	4632      	mov	r2, r6
 8013d46:	463b      	mov	r3, r7
 8013d48:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 8013d4c:	f7f4 fb9c 	bl	8008488 <__aeabi_dmul>
 8013d50:	4606      	mov	r6, r0
 8013d52:	460f      	mov	r7, r1
 8013d54:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
 8013d58:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8013d5c:	f7f4 fb94 	bl	8008488 <__aeabi_dmul>
 8013d60:	4602      	mov	r2, r0
 8013d62:	460b      	mov	r3, r1
 8013d64:	4630      	mov	r0, r6
 8013d66:	4639      	mov	r1, r7
 8013d68:	f7f4 f9d8 	bl	800811c <__adddf3>
 8013d6c:	ec41 0b19 	vmov	d9, r0, r1
 8013d70:	e9dd 2316 	ldrd	r2, r3, [sp, #88]	; 0x58
 8013d74:	e9dd 0114 	ldrd	r0, r1, [sp, #80]	; 0x50
 8013d78:	f7f4 f9ce 	bl	8008118 <__aeabi_dsub>
 8013d7c:	eeb0 1a49 	vmov.f32	s2, s18
 8013d80:	eef0 1a69 	vmov.f32	s3, s19
 8013d84:	ec41 0b10 	vmov	d0, r0, r1
 8013d88:	f00f fdc8 	bl	802391c <atan2>
 8013d8c:	ec51 0b10 	vmov	r0, r1, d0
 8013d90:	f7f4 fe14 	bl	80089bc <__aeabi_d2f>
 8013d94:	ee08 0a90 	vmov	s17, r0

    if (turns > 0) { // Correct atan2 output per direction
 8013d98:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8013d9a:	2b00      	cmp	r3, #0
 8013d9c:	f340 8082 	ble.w	8013ea4 <mc_arc+0x254>
        if (angular_travel >= -ARC_ANGULAR_TRAVEL_EPSILON)
 8013da0:	eddf 7a8f 	vldr	s15, [pc, #572]	; 8013fe0 <mc_arc+0x390>
 8013da4:	eef4 8ae7 	vcmpe.f32	s17, s15
 8013da8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013dac:	db0a      	blt.n	8013dc4 <mc_arc+0x174>
            angular_travel -= 2.0f * M_PI;
 8013dae:	f7f4 fb13 	bl	80083d8 <__aeabi_f2d>
 8013db2:	a387      	add	r3, pc, #540	; (adr r3, 8013fd0 <mc_arc+0x380>)
 8013db4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013db8:	f7f4 f9ae 	bl	8008118 <__aeabi_dsub>
 8013dbc:	f7f4 fdfe 	bl	80089bc <__aeabi_d2f>
 8013dc0:	ee08 0a90 	vmov	s17, r0
    } else if (angular_travel <= ARC_ANGULAR_TRAVEL_EPSILON)
        angular_travel += 2.0f * M_PI;

    if(labs(turns) > 1) {
 8013dc4:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8013dc6:	ea83 76e3 	eor.w	r6, r3, r3, asr #31
 8013dca:	eba6 76e3 	sub.w	r6, r6, r3, asr #31
 8013dce:	2e01      	cmp	r6, #1
 8013dd0:	dc7b      	bgt.n	8013eca <mc_arc+0x27a>

    // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
    // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
    // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
    // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
    uint16_t segments = (uint16_t)floorf(fabsf(0.5f * angular_travel * radius) / sqrtf(settings.arc_tolerance * (2.0f * radius - settings.arc_tolerance)));
 8013dd2:	eeb6 9a00 	vmov.f32	s18, #96	; 0x3f000000  0.5
 8013dd6:	ee28 9a89 	vmul.f32	s18, s17, s18
 8013dda:	ee29 9a08 	vmul.f32	s18, s18, s16
 8013dde:	eeb0 9ac9 	vabs.f32	s18, s18
 8013de2:	4b80      	ldr	r3, [pc, #512]	; (8013fe4 <mc_arc+0x394>)
 8013de4:	ed93 0a02 	vldr	s0, [r3, #8]
 8013de8:	ee38 8a08 	vadd.f32	s16, s16, s16
 8013dec:	ee38 8a40 	vsub.f32	s16, s16, s0
 8013df0:	ee20 0a08 	vmul.f32	s0, s0, s16
 8013df4:	f00f fdec 	bl	80239d0 <sqrtf>
 8013df8:	ee89 0a00 	vdiv.f32	s0, s18, s0
 8013dfc:	f00f ff3c 	bl	8023c78 <floorf>
 8013e00:	eebc 0ac0 	vcvt.u32.f32	s0, s0
 8013e04:	ee10 3a10 	vmov	r3, s0
 8013e08:	b29c      	uxth	r4, r3

    if (segments) {
 8013e0a:	2c00      	cmp	r4, #0
 8013e0c:	f000 8189 	beq.w	8014122 <mc_arc+0x4d2>

        // Multiply inverse feed_rate to compensate for the fact that this movement is approximated
        // by a number of discrete segments. The inverse feed_rate should be correct for the sum of
        // all segments.
        if (pl_data->condition.inverse_time) {
 8013e10:	9a05      	ldr	r2, [sp, #20]
 8013e12:	7d13      	ldrb	r3, [r2, #20]
 8013e14:	f013 0f20 	tst.w	r3, #32
 8013e18:	d00d      	beq.n	8013e36 <mc_arc+0x1e6>
            pl_data->feed_rate *= segments;
 8013e1a:	ee07 4a90 	vmov	s15, r4
 8013e1e:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8013e22:	edd2 7a00 	vldr	s15, [r2]
 8013e26:	ee67 7a87 	vmul.f32	s15, s15, s14
 8013e2a:	edc2 7a00 	vstr	s15, [r2]
            pl_data->condition.inverse_time = Off; // Force as feed absolute mode over arc segments.
 8013e2e:	7d13      	ldrb	r3, [r2, #20]
 8013e30:	f36f 1345 	bfc	r3, #5, #1
 8013e34:	7513      	strb	r3, [r2, #20]
        }

        float theta_per_segment = angular_travel / segments;
 8013e36:	ee07 4a90 	vmov	s15, r4
 8013e3a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8013e3e:	ee88 aa87 	vdiv.f32	s20, s17, s14
            idx--;
            if(!(idx == plane.axis_0 || idx == plane.axis_1))
                linear_per_segment[idx] = (target[idx] - position[idx]) / segments;
        } while(idx);
#else
        float linear_per_segment = (target[plane.axis_linear] - position[plane.axis_linear]) / segments;
 8013e42:	f89d 30b2 	ldrb.w	r3, [sp, #178]	; 0xb2
 8013e46:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8013e48:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8013e4c:	edd2 7a00 	vldr	s15, [r2]
 8013e50:	eb08 0b83 	add.w	fp, r8, r3, lsl #2
 8013e54:	eddb 6a00 	vldr	s13, [fp]
 8013e58:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8013e5c:	eec7 9a87 	vdiv.f32	s19, s15, s14
       a correction, the planner should have caught up to the lag caused by the initial mc_arc overhead.
       This is important when there are successive arc motions.
    */

        // Computes: cos_T = 1 - theta_per_segment^2/2, sin_T = theta_per_segment - theta_per_segment^3/6) in ~52usec
        float cos_T = 2.0f - theta_per_segment * theta_per_segment;
 8013e60:	ee2a 7a0a 	vmul.f32	s14, s20, s20
 8013e64:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 8013e68:	ee77 7ac7 	vsub.f32	s15, s15, s14
        float sin_T = theta_per_segment * 0.16666667f * (cos_T + 4.0f);
 8013e6c:	eddf 6a5e 	vldr	s13, [pc, #376]	; 8013fe8 <mc_arc+0x398>
 8013e70:	ee6a 6a26 	vmul.f32	s13, s20, s13
 8013e74:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 8013e78:	ee37 7a87 	vadd.f32	s14, s15, s14
 8013e7c:	ee26 7a87 	vmul.f32	s14, s13, s14
 8013e80:	ed8d 7a14 	vstr	s14, [sp, #80]	; 0x50
        cos_T *= 0.5f;
 8013e84:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 8013e88:	ee67 7a87 	vmul.f32	s15, s15, s14
 8013e8c:	edcd 7a16 	vstr	s15, [sp, #88]	; 0x58

        float sin_Ti;
        float cos_Ti;
        float r_axisi;
        uint_fast16_t i, count = 0;
 8013e90:	f04f 0a00 	mov.w	sl, #0

        for (i = 1; i < segments; i++) { // Increment (segments-1).
 8013e94:	f04f 0901 	mov.w	r9, #1
 8013e98:	462f      	mov	r7, r5
 8013e9a:	4646      	mov	r6, r8
 8013e9c:	46a0      	mov	r8, r4
 8013e9e:	e9dd 450a 	ldrd	r4, r5, [sp, #40]	; 0x28
 8013ea2:	e0fa      	b.n	801409a <mc_arc+0x44a>
    } else if (angular_travel <= ARC_ANGULAR_TRAVEL_EPSILON)
 8013ea4:	eddf 7a51 	vldr	s15, [pc, #324]	; 8013fec <mc_arc+0x39c>
 8013ea8:	eef4 8ae7 	vcmpe.f32	s17, s15
 8013eac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013eb0:	d888      	bhi.n	8013dc4 <mc_arc+0x174>
        angular_travel += 2.0f * M_PI;
 8013eb2:	f7f4 fa91 	bl	80083d8 <__aeabi_f2d>
 8013eb6:	a346      	add	r3, pc, #280	; (adr r3, 8013fd0 <mc_arc+0x380>)
 8013eb8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013ebc:	f7f4 f92e 	bl	800811c <__adddf3>
 8013ec0:	f7f4 fd7c 	bl	80089bc <__aeabi_d2f>
 8013ec4:	ee08 0a90 	vmov	s17, r0
 8013ec8:	e77c      	b.n	8013dc4 <mc_arc+0x174>
        uint32_t n_turns = labs(turns) - 1;
 8013eca:	3e01      	subs	r6, #1
        float arc_travel = 2.0f * M_PI * n_turns + angular_travel;
 8013ecc:	4630      	mov	r0, r6
 8013ece:	f7f4 fa61 	bl	8008394 <__aeabi_ui2d>
 8013ed2:	a33f      	add	r3, pc, #252	; (adr r3, 8013fd0 <mc_arc+0x380>)
 8013ed4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013ed8:	f7f4 fad6 	bl	8008488 <__aeabi_dmul>
 8013edc:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
 8013ee0:	ee18 0a90 	vmov	r0, s17
 8013ee4:	f7f4 fa78 	bl	80083d8 <__aeabi_f2d>
 8013ee8:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
 8013eec:	f7f4 f916 	bl	800811c <__adddf3>
 8013ef0:	f7f4 fd64 	bl	80089bc <__aeabi_d2f>
 8013ef4:	ee06 0a90 	vmov	s13, r0
        float linear_per_turn = (target[plane.axis_linear] - position[plane.axis_linear]) / arc_travel * 2.0f * M_PI;
 8013ef8:	f89d 40b2 	ldrb.w	r4, [sp, #178]	; 0xb2
 8013efc:	00a7      	lsls	r7, r4, #2
 8013efe:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8013f00:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8013f04:	edd3 7a00 	vldr	s15, [r3]
 8013f08:	eb08 0384 	add.w	r3, r8, r4, lsl #2
 8013f0c:	edd3 9a00 	vldr	s19, [r3]
 8013f10:	ee77 7ae9 	vsub.f32	s15, s15, s19
 8013f14:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 8013f18:	ee77 7a07 	vadd.f32	s15, s14, s14
 8013f1c:	ee17 0a90 	vmov	r0, s15
 8013f20:	f7f4 fa5a 	bl	80083d8 <__aeabi_f2d>
 8013f24:	a32c      	add	r3, pc, #176	; (adr r3, 8013fd8 <mc_arc+0x388>)
 8013f26:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013f2a:	f7f4 faad 	bl	8008488 <__aeabi_dmul>
 8013f2e:	f7f4 fd45 	bl	80089bc <__aeabi_d2f>
 8013f32:	ee09 0a10 	vmov	s18, r0
        memcpy(&arc_target, target, sizeof(coord_data_t));
 8013f36:	ab19      	add	r3, sp, #100	; 0x64
 8013f38:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8013f3a:	6810      	ldr	r0, [r2, #0]
 8013f3c:	6851      	ldr	r1, [r2, #4]
 8013f3e:	6892      	ldr	r2, [r2, #8]
 8013f40:	c307      	stmia	r3!, {r0, r1, r2}
        arc_target.values[plane.axis_0] = position[plane.axis_0];
 8013f42:	682b      	ldr	r3, [r5, #0]
 8013f44:	aa1c      	add	r2, sp, #112	; 0x70
 8013f46:	eb02 0a8a 	add.w	sl, r2, sl, lsl #2
 8013f4a:	f84a 3c0c 	str.w	r3, [sl, #-12]
        arc_target.values[plane.axis_1] = position[plane.axis_1];
 8013f4e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8013f50:	681b      	ldr	r3, [r3, #0]
 8013f52:	eb02 0b8b 	add.w	fp, r2, fp, lsl #2
 8013f56:	f84b 3c0c 	str.w	r3, [fp, #-12]
        arc_target.values[plane.axis_linear] = position[plane.axis_linear];
 8013f5a:	f107 0370 	add.w	r3, r7, #112	; 0x70
 8013f5e:	446b      	add	r3, sp
 8013f60:	ed43 9a03 	vstr	s19, [r3, #-12]
        while(n_turns--) {
 8013f64:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
 8013f68:	f8dd 90b4 	ldr.w	r9, [sp, #180]	; 0xb4
 8013f6c:	e019      	b.n	8013fa2 <mc_arc+0x352>
            mc_arc(arc_target.values, pl_data, position, offset, radius, plane, turns > 0 ? 1 : -1);
 8013f6e:	f04f 33ff 	mov.w	r3, #4294967295
 8013f72:	9301      	str	r3, [sp, #4]
 8013f74:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 8013f76:	f8ad 3000 	strh.w	r3, [sp]
 8013f7a:	0c1b      	lsrs	r3, r3, #16
 8013f7c:	f88d 3002 	strb.w	r3, [sp, #2]
 8013f80:	eeb0 0a48 	vmov.f32	s0, s16
 8013f84:	4653      	mov	r3, sl
 8013f86:	4642      	mov	r2, r8
 8013f88:	9905      	ldr	r1, [sp, #20]
 8013f8a:	a819      	add	r0, sp, #100	; 0x64
 8013f8c:	f7ff fe60 	bl	8013c50 <mc_arc>
            memcpy(position, arc_target.values, sizeof(coord_data_t));
 8013f90:	ab19      	add	r3, sp, #100	; 0x64
 8013f92:	cb07      	ldmia	r3!, {r0, r1, r2}
 8013f94:	f8c8 0000 	str.w	r0, [r8]
 8013f98:	f8c8 1004 	str.w	r1, [r8, #4]
 8013f9c:	f8c8 2008 	str.w	r2, [r8, #8]
        while(n_turns--) {
 8013fa0:	463e      	mov	r6, r7
 8013fa2:	1e77      	subs	r7, r6, #1
 8013fa4:	2e00      	cmp	r6, #0
 8013fa6:	f43f af14 	beq.w	8013dd2 <mc_arc+0x182>
            arc_target.values[plane.axis_linear] += linear_per_turn;
 8013faa:	ab1c      	add	r3, sp, #112	; 0x70
 8013fac:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8013fb0:	ed53 7a03 	vldr	s15, [r3, #-12]
 8013fb4:	ee77 7a89 	vadd.f32	s15, s15, s18
 8013fb8:	ed43 7a03 	vstr	s15, [r3, #-12]
            mc_arc(arc_target.values, pl_data, position, offset, radius, plane, turns > 0 ? 1 : -1);
 8013fbc:	f1b9 0f00 	cmp.w	r9, #0
 8013fc0:	ddd5      	ble.n	8013f6e <mc_arc+0x31e>
 8013fc2:	2301      	movs	r3, #1
 8013fc4:	e7d5      	b.n	8013f72 <mc_arc+0x322>
 8013fc6:	bf00      	nop
	...
 8013fd0:	54442d18 	.word	0x54442d18
 8013fd4:	401921fb 	.word	0x401921fb
 8013fd8:	54442d18 	.word	0x54442d18
 8013fdc:	400921fb 	.word	0x400921fb
 8013fe0:	b50637bd 	.word	0xb50637bd
 8013fe4:	20003b14 	.word	0x20003b14
 8013fe8:	3e2aaaab 	.word	0x3e2aaaab
 8013fec:	350637bd 	.word	0x350637bd
                r_axis1 = r_axisi;
                count++;
            } else {
                // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.
                // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
                cos_Ti = cosf(i * theta_per_segment);
 8013ff0:	ee07 9a90 	vmov	s15, r9
 8013ff4:	eeb8 8a67 	vcvt.f32.u32	s16, s15
 8013ff8:	ee28 8a0a 	vmul.f32	s16, s16, s20
 8013ffc:	eeb0 0a48 	vmov.f32	s0, s16
 8014000:	f00f fd04 	bl	8023a0c <cosf>
 8014004:	eef0 8a40 	vmov.f32	s17, s0
                sin_Ti = sinf(i * theta_per_segment);
 8014008:	eeb0 0a48 	vmov.f32	s0, s16
 801400c:	f00f fd42 	bl	8023a94 <sinf>
 8014010:	eeb0 9a40 	vmov.f32	s18, s0
                r_axis0 = -offset[plane.axis_0] * cos_Ti + offset[plane.axis_1] * sin_Ti;
 8014014:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8014016:	edd3 7a00 	vldr	s15, [r3]
 801401a:	eef1 aa67 	vneg.f32	s21, s15
 801401e:	ee67 7ae8 	vnmul.f32	s15, s15, s17
 8014022:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8014024:	ed93 8a00 	vldr	s16, [r3]
 8014028:	ee28 7a00 	vmul.f32	s14, s16, s0
 801402c:	ee77 7a87 	vadd.f32	s15, s15, s14
 8014030:	ee17 0a90 	vmov	r0, s15
 8014034:	f7f4 f9d0 	bl	80083d8 <__aeabi_f2d>
 8014038:	4604      	mov	r4, r0
 801403a:	460d      	mov	r5, r1
                r_axis1 = -offset[plane.axis_0] * sin_Ti - offset[plane.axis_1] * cos_Ti;
 801403c:	ee6a aa89 	vmul.f32	s21, s21, s18
 8014040:	ee28 8a28 	vmul.f32	s16, s16, s17
 8014044:	ee7a 7ac8 	vsub.f32	s15, s21, s16
 8014048:	ee17 0a90 	vmov	r0, s15
 801404c:	f7f4 f9c4 	bl	80083d8 <__aeabi_f2d>
 8014050:	e9cd 0102 	strd	r0, r1, [sp, #8]
                count = 0;
 8014054:	f04f 0a00 	mov.w	sl, #0
            }

            // Update arc_target location
            position[plane.axis_0] = center_axis0 + r_axis0;
 8014058:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 801405c:	4620      	mov	r0, r4
 801405e:	4629      	mov	r1, r5
 8014060:	f7f4 f85c 	bl	800811c <__adddf3>
 8014064:	f7f4 fcaa 	bl	80089bc <__aeabi_d2f>
 8014068:	6038      	str	r0, [r7, #0]
            position[plane.axis_1] = center_axis1 + r_axis1;
 801406a:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 801406e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8014072:	f7f4 f853 	bl	800811c <__adddf3>
 8014076:	f7f4 fca1 	bl	80089bc <__aeabi_d2f>
 801407a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801407c:	6018      	str	r0, [r3, #0]
                idx--;
                if(!(idx == plane.axis_0 || idx == plane.axis_1))
                    position[idx] += linear_per_segment[idx];
            } while(idx);
#else
            position[plane.axis_linear] += linear_per_segment;
 801407e:	eddb 7a00 	vldr	s15, [fp]
 8014082:	ee77 7aa9 	vadd.f32	s15, s15, s19
 8014086:	edcb 7a00 	vstr	s15, [fp]
#endif

            // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
            if(!mc_line(position, pl_data))
 801408a:	9905      	ldr	r1, [sp, #20]
 801408c:	4630      	mov	r0, r6
 801408e:	f7ff fd93 	bl	8013bb8 <mc_line>
 8014092:	2800      	cmp	r0, #0
 8014094:	d049      	beq.n	801412a <mc_arc+0x4da>
        for (i = 1; i < segments; i++) { // Increment (segments-1).
 8014096:	f109 0901 	add.w	r9, r9, #1
 801409a:	45c8      	cmp	r8, r9
 801409c:	d941      	bls.n	8014122 <mc_arc+0x4d2>
            if (count < N_ARC_CORRECTION) {
 801409e:	f1ba 0f0b 	cmp.w	sl, #11
 80140a2:	d8a5      	bhi.n	8013ff0 <mc_arc+0x3a0>
                r_axisi = r_axis0 * sin_T + r_axis1 * cos_T;
 80140a4:	9814      	ldr	r0, [sp, #80]	; 0x50
 80140a6:	f7f4 f997 	bl	80083d8 <__aeabi_f2d>
 80140aa:	4602      	mov	r2, r0
 80140ac:	460b      	mov	r3, r1
 80140ae:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
 80140b2:	4622      	mov	r2, r4
 80140b4:	462b      	mov	r3, r5
 80140b6:	f7f4 f9e7 	bl	8008488 <__aeabi_dmul>
 80140ba:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
 80140be:	9816      	ldr	r0, [sp, #88]	; 0x58
 80140c0:	f7f4 f98a 	bl	80083d8 <__aeabi_f2d>
 80140c4:	4602      	mov	r2, r0
 80140c6:	460b      	mov	r3, r1
 80140c8:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
 80140cc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80140d0:	f7f4 f9da 	bl	8008488 <__aeabi_dmul>
 80140d4:	4602      	mov	r2, r0
 80140d6:	460b      	mov	r3, r1
 80140d8:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 80140dc:	f7f4 f81e 	bl	800811c <__adddf3>
 80140e0:	f7f4 fc6c 	bl	80089bc <__aeabi_d2f>
 80140e4:	900e      	str	r0, [sp, #56]	; 0x38
                r_axis0 = r_axis0 * cos_T - r_axis1 * sin_T;
 80140e6:	4622      	mov	r2, r4
 80140e8:	462b      	mov	r3, r5
 80140ea:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 80140ee:	f7f4 f9cb 	bl	8008488 <__aeabi_dmul>
 80140f2:	4604      	mov	r4, r0
 80140f4:	460d      	mov	r5, r1
 80140f6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80140fa:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 80140fe:	f7f4 f9c3 	bl	8008488 <__aeabi_dmul>
 8014102:	4602      	mov	r2, r0
 8014104:	460b      	mov	r3, r1
 8014106:	4620      	mov	r0, r4
 8014108:	4629      	mov	r1, r5
 801410a:	f7f4 f805 	bl	8008118 <__aeabi_dsub>
 801410e:	4604      	mov	r4, r0
 8014110:	460d      	mov	r5, r1
                r_axis1 = r_axisi;
 8014112:	980e      	ldr	r0, [sp, #56]	; 0x38
 8014114:	f7f4 f960 	bl	80083d8 <__aeabi_f2d>
 8014118:	e9cd 0102 	strd	r0, r1, [sp, #8]
                count++;
 801411c:	f10a 0a01 	add.w	sl, sl, #1
 8014120:	e79a      	b.n	8014058 <mc_arc+0x408>
                return;
        }
    }

    // Ensure last segment arrives at target location.
    mc_line(target, pl_data);
 8014122:	9905      	ldr	r1, [sp, #20]
 8014124:	9811      	ldr	r0, [sp, #68]	; 0x44
 8014126:	f7ff fd47 	bl	8013bb8 <mc_line>
}
 801412a:	b01d      	add	sp, #116	; 0x74
 801412c:	ecbd 8b06 	vpop	{d8-d10}
 8014130:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08014134 <mc_cubic_b_spline>:
 * the mitigation offered by MIN_STEP and the small computational
 * power available on Arduino, I think it is not wise to implement it.
 */

void mc_cubic_b_spline (float *target, plan_line_data_t *pl_data, float *position, float *first, float *second)
{
 8014134:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8014138:	ed2d 8b04 	vpush	{d8-d9}
 801413c:	b084      	sub	sp, #16
 801413e:	4606      	mov	r6, r0
 8014140:	4688      	mov	r8, r1
 8014142:	4614      	mov	r4, r2
 8014144:	461d      	mov	r5, r3
 8014146:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    float bez_target[N_AXIS];

    memcpy(bez_target, position, sizeof(float) * N_AXIS);
 8014148:	ab01      	add	r3, sp, #4
 801414a:	6810      	ldr	r0, [r2, #0]
 801414c:	6851      	ldr	r1, [r2, #4]
 801414e:	6892      	ldr	r2, [r2, #8]
 8014150:	c307      	stmia	r3!, {r0, r1, r2}

    float t = 0.0f, step = BEZIER_MAX_STEP;
 8014152:	eddf 8aca 	vldr	s17, [pc, #808]	; 801447c <mc_cubic_b_spline+0x348>
 8014156:	eddf 4aca 	vldr	s9, [pc, #808]	; 8014480 <mc_cubic_b_spline+0x34c>

    while (t < 1.0f) {
 801415a:	e011      	b.n	8014180 <mc_cubic_b_spline+0x4c>
            new_pos1 = candidate_pos1;
            did_reduce = true;
        }

        // If we did not reduce the step, maybe we should enlarge it.
        if (!did_reduce) while (new_t - t <= BEZIER_MAX_STEP) {
 801415c:	2b00      	cmp	r3, #0
 801415e:	f000 8101 	beq.w	8014364 <mc_cubic_b_spline+0x230>
            assert(new_t - t >= (MIN_STEP) / 2.0);
            assert(new_t - t <= (MAX_STEP) * 2.0);
          }
        */

        step = new_t - t;
 8014162:	ee78 8a64 	vsub.f32	s17, s16, s9
        t = new_t;

        bez_target[X_AXIS] = new_pos0;
 8014166:	ed8d 5a01 	vstr	s10, [sp, #4]
        bez_target[Y_AXIS] = new_pos1;
 801416a:	edcd 5a02 	vstr	s11, [sp, #8]

        // Bail mid-spline on system abort. Runtime command check already performed by mc_line.
        if(!mc_line(bez_target, pl_data))
 801416e:	4641      	mov	r1, r8
 8014170:	a801      	add	r0, sp, #4
 8014172:	f7ff fd21 	bl	8013bb8 <mc_line>
 8014176:	2800      	cmp	r0, #0
 8014178:	f000 817b 	beq.w	8014472 <mc_cubic_b_spline+0x33e>
        t = new_t;
 801417c:	eef0 4a48 	vmov.f32	s9, s16
    while (t < 1.0f) {
 8014180:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8014184:	eef4 4ae7 	vcmpe.f32	s9, s15
 8014188:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801418c:	f140 8171 	bpl.w	8014472 <mc_cubic_b_spline+0x33e>
        float new_t = t + step;
 8014190:	ee34 8aa8 	vadd.f32	s16, s9, s17
        if(new_t > 1.0f)
 8014194:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8014198:	eeb4 8ae7 	vcmpe.f32	s16, s15
 801419c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80141a0:	dd01      	ble.n	80141a6 <mc_cubic_b_spline+0x72>
            new_t = 1.0f;
 80141a2:	eeb0 8a67 	vmov.f32	s16, s15
        float new_pos0 = eval_bezier(position[X_AXIS], first[X_AXIS], second[X_AXIS], target[X_AXIS], new_t),
 80141a6:	ed94 2a00 	vldr	s4, [r4]
 80141aa:	ed95 4a00 	vldr	s8, [r5]
 80141ae:	edd7 3a00 	vldr	s7, [r7]
 80141b2:	edd6 1a00 	vldr	s3, [r6]
    return (1.0f - t) * a + t * b;
 80141b6:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 80141ba:	ee75 5ac8 	vsub.f32	s11, s11, s16
 80141be:	ee22 5a25 	vmul.f32	s10, s4, s11
 80141c2:	ee64 7a08 	vmul.f32	s15, s8, s16
 80141c6:	ee35 5a27 	vadd.f32	s10, s10, s15
 80141ca:	ee64 7a25 	vmul.f32	s15, s8, s11
 80141ce:	ee23 7a88 	vmul.f32	s14, s7, s16
 80141d2:	ee77 7a87 	vadd.f32	s15, s15, s14
 80141d6:	ee23 7aa5 	vmul.f32	s14, s7, s11
 80141da:	ee61 6a88 	vmul.f32	s13, s3, s16
 80141de:	ee37 7a26 	vadd.f32	s14, s14, s13
 80141e2:	ee25 5a85 	vmul.f32	s10, s11, s10
 80141e6:	ee68 6a27 	vmul.f32	s13, s16, s15
 80141ea:	ee35 5a26 	vadd.f32	s10, s10, s13
 80141ee:	ee65 7aa7 	vmul.f32	s15, s11, s15
 80141f2:	ee28 7a07 	vmul.f32	s14, s16, s14
 80141f6:	ee77 7a87 	vadd.f32	s15, s15, s14
 80141fa:	ee25 5a85 	vmul.f32	s10, s11, s10
 80141fe:	ee68 7a27 	vmul.f32	s15, s16, s15
 8014202:	ee35 5a27 	vadd.f32	s10, s10, s15
              new_pos1 = eval_bezier(position[Y_AXIS], first[Y_AXIS], second[Y_AXIS], target[Y_AXIS], new_t);
 8014206:	ed94 1a01 	vldr	s2, [r4, #4]
 801420a:	ed95 3a01 	vldr	s6, [r5, #4]
 801420e:	edd7 2a01 	vldr	s5, [r7, #4]
 8014212:	edd6 0a01 	vldr	s1, [r6, #4]
    return (1.0f - t) * a + t * b;
 8014216:	ee21 7a25 	vmul.f32	s14, s2, s11
 801421a:	ee63 7a08 	vmul.f32	s15, s6, s16
 801421e:	ee37 7a27 	vadd.f32	s14, s14, s15
 8014222:	ee63 7a25 	vmul.f32	s15, s6, s11
 8014226:	ee62 6a88 	vmul.f32	s13, s5, s16
 801422a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 801422e:	ee62 6aa5 	vmul.f32	s13, s5, s11
 8014232:	ee20 6a88 	vmul.f32	s12, s1, s16
 8014236:	ee76 6a86 	vadd.f32	s13, s13, s12
 801423a:	ee25 7a87 	vmul.f32	s14, s11, s14
 801423e:	ee28 6a27 	vmul.f32	s12, s16, s15
 8014242:	ee37 7a06 	vadd.f32	s14, s14, s12
 8014246:	ee65 7aa7 	vmul.f32	s15, s11, s15
 801424a:	ee68 6a26 	vmul.f32	s13, s16, s13
 801424e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8014252:	ee65 5a87 	vmul.f32	s11, s11, s14
 8014256:	ee68 7a27 	vmul.f32	s15, s16, s15
 801425a:	ee75 5aa7 	vadd.f32	s11, s11, s15
        bool did_reduce = false;
 801425e:	2300      	movs	r3, #0
        while(new_t - t >= (BEZIER_MIN_STEP)) {
 8014260:	ee78 7a64 	vsub.f32	s15, s16, s9
 8014264:	ed9f 7a87 	vldr	s14, [pc, #540]	; 8014484 <mc_cubic_b_spline+0x350>
 8014268:	eef4 7ac7 	vcmpe.f32	s15, s14
 801426c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014270:	f6ff af74 	blt.w	801415c <mc_cubic_b_spline+0x28>
            const float candidate_t = 0.5f * (t + new_t),
 8014274:	ee34 7a88 	vadd.f32	s14, s9, s16
 8014278:	eef6 8a00 	vmov.f32	s17, #96	; 0x3f000000  0.5
 801427c:	ee27 7a28 	vmul.f32	s14, s14, s17
    return (1.0f - t) * a + t * b;
 8014280:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8014284:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8014288:	ee62 6a27 	vmul.f32	s13, s4, s15
 801428c:	ee24 6a07 	vmul.f32	s12, s8, s14
 8014290:	ee76 6a86 	vadd.f32	s13, s13, s12
 8014294:	ee24 6a27 	vmul.f32	s12, s8, s15
 8014298:	ee23 0a87 	vmul.f32	s0, s7, s14
 801429c:	ee36 6a00 	vadd.f32	s12, s12, s0
 80142a0:	ee23 0aa7 	vmul.f32	s0, s7, s15
 80142a4:	ee21 9a87 	vmul.f32	s18, s3, s14
 80142a8:	ee30 0a09 	vadd.f32	s0, s0, s18
 80142ac:	ee67 6aa6 	vmul.f32	s13, s15, s13
 80142b0:	ee27 9a06 	vmul.f32	s18, s14, s12
 80142b4:	ee76 6a89 	vadd.f32	s13, s13, s18
 80142b8:	ee27 6a86 	vmul.f32	s12, s15, s12
 80142bc:	ee27 0a00 	vmul.f32	s0, s14, s0
 80142c0:	ee36 6a00 	vadd.f32	s12, s12, s0
 80142c4:	ee67 6aa6 	vmul.f32	s13, s15, s13
 80142c8:	ee27 6a06 	vmul.f32	s12, s14, s12
 80142cc:	ee76 6a86 	vadd.f32	s13, s13, s12
 80142d0:	ee21 0a27 	vmul.f32	s0, s2, s15
 80142d4:	ee23 6a07 	vmul.f32	s12, s6, s14
 80142d8:	ee30 0a06 	vadd.f32	s0, s0, s12
 80142dc:	ee23 6a27 	vmul.f32	s12, s6, s15
 80142e0:	ee22 9a87 	vmul.f32	s18, s5, s14
 80142e4:	ee36 6a09 	vadd.f32	s12, s12, s18
 80142e8:	ee22 9aa7 	vmul.f32	s18, s5, s15
 80142ec:	ee60 9a87 	vmul.f32	s19, s1, s14
 80142f0:	ee39 9a29 	vadd.f32	s18, s18, s19
 80142f4:	ee27 0a80 	vmul.f32	s0, s15, s0
 80142f8:	ee67 9a06 	vmul.f32	s19, s14, s12
 80142fc:	ee30 0a29 	vadd.f32	s0, s0, s19
 8014300:	ee27 6a86 	vmul.f32	s12, s15, s12
 8014304:	ee27 9a09 	vmul.f32	s18, s14, s18
 8014308:	ee36 6a09 	vadd.f32	s12, s12, s18
 801430c:	ee67 7a80 	vmul.f32	s15, s15, s0
 8014310:	ee27 6a06 	vmul.f32	s12, s14, s12
 8014314:	ee77 7a86 	vadd.f32	s15, s15, s12
                      interp_pos0 = 0.5f * (bez_target[X_AXIS] + new_pos0),
 8014318:	ed9d 0a01 	vldr	s0, [sp, #4]
 801431c:	ee30 0a05 	vadd.f32	s0, s0, s10
 8014320:	ee20 0a28 	vmul.f32	s0, s0, s17
                      interp_pos1 = 0.5f * (bez_target[Y_AXIS] + new_pos1);
 8014324:	ed9d 6a02 	vldr	s12, [sp, #8]
 8014328:	ee36 6a25 	vadd.f32	s12, s12, s11
 801432c:	ee26 6a28 	vmul.f32	s12, s12, s17
    return fabsf(x1 - x2) + fabsf(y1 - y2);
 8014330:	ee36 0ac0 	vsub.f32	s0, s13, s0
 8014334:	eeb0 0ac0 	vabs.f32	s0, s0
 8014338:	ee37 6ac6 	vsub.f32	s12, s15, s12
 801433c:	eeb0 6ac6 	vabs.f32	s12, s12
 8014340:	ee36 6a00 	vadd.f32	s12, s12, s0
            if (dist1(candidate_pos0, candidate_pos1, interp_pos0, interp_pos1) <= (BEZIER_SIGMA))
 8014344:	ed9f 0a4d 	vldr	s0, [pc, #308]	; 801447c <mc_cubic_b_spline+0x348>
 8014348:	eeb4 6ac0 	vcmpe.f32	s12, s0
 801434c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014350:	f67f af04 	bls.w	801415c <mc_cubic_b_spline+0x28>
            new_pos1 = candidate_pos1;
 8014354:	eef0 5a67 	vmov.f32	s11, s15
            new_pos0 = candidate_pos0;
 8014358:	eeb0 5a66 	vmov.f32	s10, s13
            new_t = candidate_t;
 801435c:	eeb0 8a47 	vmov.f32	s16, s14
            did_reduce = true;
 8014360:	2301      	movs	r3, #1
 8014362:	e77d      	b.n	8014260 <mc_cubic_b_spline+0x12c>
        if (!did_reduce) while (new_t - t <= BEZIER_MAX_STEP) {
 8014364:	ee78 7a64 	vsub.f32	s15, s16, s9
 8014368:	ed9f 7a44 	vldr	s14, [pc, #272]	; 801447c <mc_cubic_b_spline+0x348>
 801436c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8014370:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014374:	f63f aef5 	bhi.w	8014162 <mc_cubic_b_spline+0x2e>
            const float candidate_t = t + 2.0f * (new_t - t);
 8014378:	ee77 7aa7 	vadd.f32	s15, s15, s15
 801437c:	ee77 7aa4 	vadd.f32	s15, s15, s9
            if (candidate_t >= 1.0f)
 8014380:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8014384:	eef4 7ac7 	vcmpe.f32	s15, s14
 8014388:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801438c:	f6bf aee9 	bge.w	8014162 <mc_cubic_b_spline+0x2e>
    return (1.0f - t) * a + t * b;
 8014390:	ee37 7a67 	vsub.f32	s14, s14, s15
 8014394:	ee62 6a07 	vmul.f32	s13, s4, s14
 8014398:	ee24 6a27 	vmul.f32	s12, s8, s15
 801439c:	ee76 6a86 	vadd.f32	s13, s13, s12
 80143a0:	ee24 6a07 	vmul.f32	s12, s8, s14
 80143a4:	ee23 0aa7 	vmul.f32	s0, s7, s15
 80143a8:	ee36 6a00 	vadd.f32	s12, s12, s0
 80143ac:	ee23 0a87 	vmul.f32	s0, s7, s14
 80143b0:	ee61 8aa7 	vmul.f32	s17, s3, s15
 80143b4:	ee30 0a28 	vadd.f32	s0, s0, s17
 80143b8:	ee67 6a26 	vmul.f32	s13, s14, s13
 80143bc:	ee67 8a86 	vmul.f32	s17, s15, s12
 80143c0:	ee76 6aa8 	vadd.f32	s13, s13, s17
 80143c4:	ee27 6a06 	vmul.f32	s12, s14, s12
 80143c8:	ee27 0a80 	vmul.f32	s0, s15, s0
 80143cc:	ee36 6a00 	vadd.f32	s12, s12, s0
 80143d0:	ee67 6a26 	vmul.f32	s13, s14, s13
 80143d4:	ee27 6a86 	vmul.f32	s12, s15, s12
 80143d8:	ee76 6a86 	vadd.f32	s13, s13, s12
 80143dc:	ee21 0a07 	vmul.f32	s0, s2, s14
 80143e0:	ee23 6a27 	vmul.f32	s12, s6, s15
 80143e4:	ee30 0a06 	vadd.f32	s0, s0, s12
 80143e8:	ee23 6a07 	vmul.f32	s12, s6, s14
 80143ec:	ee62 8aa7 	vmul.f32	s17, s5, s15
 80143f0:	ee36 6a28 	vadd.f32	s12, s12, s17
 80143f4:	ee62 8a87 	vmul.f32	s17, s5, s14
 80143f8:	ee20 9aa7 	vmul.f32	s18, s1, s15
 80143fc:	ee78 8a89 	vadd.f32	s17, s17, s18
 8014400:	ee27 0a00 	vmul.f32	s0, s14, s0
 8014404:	ee27 9a86 	vmul.f32	s18, s15, s12
 8014408:	ee30 0a09 	vadd.f32	s0, s0, s18
 801440c:	ee27 6a06 	vmul.f32	s12, s14, s12
 8014410:	ee67 8aa8 	vmul.f32	s17, s15, s17
 8014414:	ee36 6a28 	vadd.f32	s12, s12, s17
 8014418:	ee27 7a00 	vmul.f32	s14, s14, s0
 801441c:	ee27 6a86 	vmul.f32	s12, s15, s12
 8014420:	ee37 7a06 	vadd.f32	s14, s14, s12
                      interp_pos0 = 0.5f * (bez_target[X_AXIS] + candidate_pos0),
 8014424:	ed9d 6a01 	vldr	s12, [sp, #4]
 8014428:	ee36 6a26 	vadd.f32	s12, s12, s13
 801442c:	eef6 8a00 	vmov.f32	s17, #96	; 0x3f000000  0.5
 8014430:	ee26 6a28 	vmul.f32	s12, s12, s17
                      interp_pos1 = 0.5f * (bez_target[Y_AXIS] + candidate_pos1);
 8014434:	ed9d 0a02 	vldr	s0, [sp, #8]
 8014438:	ee30 0a07 	vadd.f32	s0, s0, s14
 801443c:	ee20 0a28 	vmul.f32	s0, s0, s17
    return fabsf(x1 - x2) + fabsf(y1 - y2);
 8014440:	ee35 6a46 	vsub.f32	s12, s10, s12
 8014444:	eeb0 6ac6 	vabs.f32	s12, s12
 8014448:	ee35 0ac0 	vsub.f32	s0, s11, s0
 801444c:	eeb0 0ac0 	vabs.f32	s0, s0
 8014450:	ee36 6a00 	vadd.f32	s12, s12, s0
            if (dist1(new_pos0, new_pos1, interp_pos0, interp_pos1) > (BEZIER_SIGMA))
 8014454:	ed9f 0a09 	vldr	s0, [pc, #36]	; 801447c <mc_cubic_b_spline+0x348>
 8014458:	eeb4 6ac0 	vcmpe.f32	s12, s0
 801445c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014460:	f73f ae7f 	bgt.w	8014162 <mc_cubic_b_spline+0x2e>
            new_pos1 = candidate_pos1;
 8014464:	eef0 5a47 	vmov.f32	s11, s14
            new_pos0 = candidate_pos0;
 8014468:	eeb0 5a66 	vmov.f32	s10, s13
            new_t = candidate_t;
 801446c:	eeb0 8a67 	vmov.f32	s16, s15
 8014470:	e778      	b.n	8014364 <mc_cubic_b_spline+0x230>
            return;
    }
}
 8014472:	b004      	add	sp, #16
 8014474:	ecbd 8b04 	vpop	{d8-d9}
 8014478:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801447c:	3dcccccd 	.word	0x3dcccccd
 8014480:	00000000 	.word	0x00000000
 8014484:	3b03126f 	.word	0x3b03126f

08014488 <mc_thread>:
// R - depth regression, Q - compound slide angle, H - spring passes, E - taper, L - taper end

// TODO: change pitch to follow any tapers

void mc_thread (plan_line_data_t *pl_data, float *position, gc_thread_data *thread, bool feed_hold_disabled)
{
 8014488:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801448c:	ed2d 8b08 	vpush	{d8-d11}
 8014490:	b085      	sub	sp, #20
 8014492:	4604      	mov	r4, r0
 8014494:	460f      	mov	r7, r1
 8014496:	4615      	mov	r5, r2
 8014498:	4699      	mov	r9, r3
    uint_fast16_t pass = 1, passes = 0;
    float doc = thread->initial_depth, inv_degression = 1.0f / thread->depth_degression, thread_length;
 801449a:	ed92 8a03 	vldr	s16, [r2, #12]
 801449e:	edd2 7a05 	vldr	s15, [r2, #20]
 80144a2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80144a6:	eec7 8a27 	vdiv.f32	s17, s14, s15
    float entry_taper_length = thread->end_taper_type & Taper_Entry ? thread->end_taper_length : 0.0f;
 80144aa:	f892 a02c 	ldrb.w	sl, [r2, #44]	; 0x2c
 80144ae:	f01a 0b01 	ands.w	fp, sl, #1
 80144b2:	d067      	beq.n	8014584 <mc_thread+0xfc>
 80144b4:	ed92 aa07 	vldr	s20, [r2, #28]
    float exit_taper_length = thread->end_taper_type & Taper_Exit ? thread->end_taper_length : 0.0f;
 80144b8:	f01a 0a02 	ands.w	sl, sl, #2
 80144bc:	d065      	beq.n	801458a <mc_thread+0x102>
 80144be:	edd5 aa07 	vldr	s21, [r5, #28]
    float infeed_factor = tanf(thread->infeed_angle * RADDEG);
 80144c2:	ed95 0a08 	vldr	s0, [r5, #32]
 80144c6:	eddf 7aae 	vldr	s15, [pc, #696]	; 8014780 <mc_thread+0x2f8>
 80144ca:	ee20 0a27 	vmul.f32	s0, s0, s15
 80144ce:	f00f fb27 	bl	8023b20 <tanf>
 80144d2:	eeb0 9a40 	vmov.f32	s18, s0
    float target[N_AXIS], start_z = position[Z_AXIS] + thread->depth * infeed_factor;
 80144d6:	edd7 9a02 	vldr	s19, [r7, #8]
 80144da:	ed95 ba04 	vldr	s22, [r5, #16]
 80144de:	ee6b 7a00 	vmul.f32	s15, s22, s0
 80144e2:	ee79 9aa7 	vadd.f32	s19, s19, s15

    memcpy(target, position, sizeof(float) * N_AXIS);
 80144e6:	ab01      	add	r3, sp, #4
 80144e8:	6838      	ldr	r0, [r7, #0]
 80144ea:	6879      	ldr	r1, [r7, #4]
 80144ec:	68ba      	ldr	r2, [r7, #8]
 80144ee:	c307      	stmia	r3!, {r0, r1, r2}
    uint_fast16_t pass = 1, passes = 0;
 80144f0:	f04f 0800 	mov.w	r8, #0

    // Calculate number of passes
    while(calc_thread_doc(++passes, doc, inv_degression) < thread->depth);
 80144f4:	f108 0801 	add.w	r8, r8, #1
    return cut_depth * powf((float)pass, inv_degression);
 80144f8:	eef0 0a68 	vmov.f32	s1, s17
 80144fc:	ee07 8a90 	vmov	s15, r8
 8014500:	eeb8 0a67 	vcvt.f32.u32	s0, s15
 8014504:	f00f fa0c 	bl	8023920 <powf>
 8014508:	ee28 0a00 	vmul.f32	s0, s16, s0
    while(calc_thread_doc(++passes, doc, inv_degression) < thread->depth);
 801450c:	eeb4 bac0 	vcmpe.f32	s22, s0
 8014510:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014514:	dcee      	bgt.n	80144f4 <mc_thread+0x6c>

    passes += thread->spring_passes + 1;
 8014516:	6aae      	ldr	r6, [r5, #40]	; 0x28
 8014518:	4446      	add	r6, r8
 801451a:	3601      	adds	r6, #1

    if((thread_length = thread->z_final - position[Z_AXIS]) > 0.0f) {
 801451c:	ed95 ba01 	vldr	s22, [r5, #4]
 8014520:	edd7 7a02 	vldr	s15, [r7, #8]
 8014524:	ee3b ba67 	vsub.f32	s22, s22, s15
 8014528:	eeb5 bac0 	vcmpe.f32	s22, #0.0
 801452c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014530:	dd09      	ble.n	8014546 <mc_thread+0xbe>
        if(thread->end_taper_type & Taper_Entry)
 8014532:	f1bb 0f00 	cmp.w	fp, #0
 8014536:	d001      	beq.n	801453c <mc_thread+0xb4>
            entry_taper_length = -entry_taper_length;
 8014538:	eeb1 aa4a 	vneg.f32	s20, s20
        if(thread->end_taper_type & Taper_Exit)
 801453c:	f1ba 0f00 	cmp.w	sl, #0
 8014540:	d001      	beq.n	8014546 <mc_thread+0xbe>
            exit_taper_length = - exit_taper_length;
 8014542:	eef1 aa6a 	vneg.f32	s21, s21
    }

    thread_length += entry_taper_length + exit_taper_length;
 8014546:	ee7a 7a2a 	vadd.f32	s15, s20, s21
 801454a:	ee37 ba8b 	vadd.f32	s22, s15, s22

    if(thread->main_taper_height != 0.0f)
 801454e:	ed95 7a06 	vldr	s14, [r5, #24]
 8014552:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8014556:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801455a:	d007      	beq.n	801456c <mc_thread+0xe4>
        thread->main_taper_height = thread->main_taper_height * thread_length / (thread_length - (entry_taper_length + exit_taper_length));
 801455c:	ee27 7a0b 	vmul.f32	s14, s14, s22
 8014560:	ee7b 7a67 	vsub.f32	s15, s22, s15
 8014564:	eec7 6a27 	vdiv.f32	s13, s14, s15
 8014568:	edc5 6a06 	vstr	s13, [r5, #24]

    pl_data->condition.rapid_motion = On; // Set rapid motion condition flag.
 801456c:	7d23      	ldrb	r3, [r4, #20]
 801456e:	f043 0301 	orr.w	r3, r3, #1
 8014572:	7523      	strb	r3, [r4, #20]
    float acc_distance = pl_data->feed_rate * pl_data->spindle.hal->get_data(SpindleData_RPM)->rpm / settings.acceleration[Z_AXIS];
    acc_distance = acc_distance * acc_distance * settings.acceleration[Z_AXIS] * 0.5f;
     */

    // Initial Z-move for compound slide angle offset.
    if(infeed_factor != 0.0f) {
 8014574:	eeb5 9a40 	vcmp.f32	s18, #0.0
 8014578:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801457c:	d108      	bne.n	8014590 <mc_thread+0x108>

            // Restore disable feed hold status for reposition move.
            pl_data->overrides.feed_hold_disable = feed_hold_disabled;

            // 5. Back to start, add compound slide angle offset when commanded.
            target[Z_AXIS] = start_z - (infeed_factor != 0.0f ? doc * infeed_factor : 0.0f);
 801457e:	f04f 0801 	mov.w	r8, #1
 8014582:	e04f      	b.n	8014624 <mc_thread+0x19c>
    float entry_taper_length = thread->end_taper_type & Taper_Entry ? thread->end_taper_length : 0.0f;
 8014584:	ed9f aa7f 	vldr	s20, [pc, #508]	; 8014784 <mc_thread+0x2fc>
 8014588:	e796      	b.n	80144b8 <mc_thread+0x30>
    float exit_taper_length = thread->end_taper_type & Taper_Exit ? thread->end_taper_length : 0.0f;
 801458a:	eddf aa7e 	vldr	s21, [pc, #504]	; 8014784 <mc_thread+0x2fc>
 801458e:	e798      	b.n	80144c2 <mc_thread+0x3a>
        target[Z_AXIS] = start_z - doc * infeed_factor;
 8014590:	ee68 7a09 	vmul.f32	s15, s16, s18
 8014594:	ee79 7ae7 	vsub.f32	s15, s19, s15
 8014598:	edcd 7a03 	vstr	s15, [sp, #12]
        if(!mc_line(target, pl_data))
 801459c:	4621      	mov	r1, r4
 801459e:	a801      	add	r0, sp, #4
 80145a0:	f7ff fb0a 	bl	8013bb8 <mc_line>
 80145a4:	2800      	cmp	r0, #0
 80145a6:	d1ea      	bne.n	801457e <mc_thread+0xf6>
            target[X_AXIS] = position[X_AXIS];
            if(!mc_line(target, pl_data))
                return;
        }
    }
}
 80145a8:	b005      	add	sp, #20
 80145aa:	ecbd 8b08 	vpop	{d8-d11}
 80145ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            target[X_AXIS] = position[X_AXIS] + (thread->peak + doc) * thread->cut_direction;
 80145b2:	ed97 7a00 	vldr	s14, [r7]
 80145b6:	edd5 7a02 	vldr	s15, [r5, #8]
 80145ba:	ee77 7a88 	vadd.f32	s15, s15, s16
 80145be:	edd5 6a09 	vldr	s13, [r5, #36]	; 0x24
 80145c2:	ee67 7aa6 	vmul.f32	s15, s15, s13
 80145c6:	ee77 7a27 	vadd.f32	s15, s14, s15
 80145ca:	edcd 7a01 	vstr	s15, [sp, #4]
 80145ce:	e042      	b.n	8014656 <mc_thread+0x1ce>
        if(!protocol_buffer_synchronize() && state_get() != STATE_IDLE) // Wait until any previous moves are finished.
 80145d0:	f00a f808 	bl	801e5e4 <state_get>
 80145d4:	2800      	cmp	r0, #0
 80145d6:	d048      	beq.n	801466a <mc_thread+0x1e2>
 80145d8:	e7e6      	b.n	80145a8 <mc_thread+0x120>
            target[X_AXIS] -= thread->depth * thread->cut_direction;
 80145da:	ed95 7a04 	vldr	s14, [r5, #16]
 80145de:	edd5 7a09 	vldr	s15, [r5, #36]	; 0x24
 80145e2:	ee27 7a27 	vmul.f32	s14, s14, s15
 80145e6:	eddd 7a01 	vldr	s15, [sp, #4]
 80145ea:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80145ee:	edcd 7a01 	vstr	s15, [sp, #4]
            target[Z_AXIS] -= exit_taper_length;
 80145f2:	eddd 7a03 	vldr	s15, [sp, #12]
 80145f6:	ee77 7aea 	vsub.f32	s15, s15, s21
 80145fa:	edcd 7a03 	vstr	s15, [sp, #12]
            if(!mc_line(target, pl_data))
 80145fe:	4621      	mov	r1, r4
 8014600:	a801      	add	r0, sp, #4
 8014602:	f7ff fad9 	bl	8013bb8 <mc_line>
 8014606:	2800      	cmp	r0, #0
 8014608:	d16c      	bne.n	80146e4 <mc_thread+0x25c>
 801460a:	e7cd      	b.n	80145a8 <mc_thread+0x120>
            target[Z_AXIS] = start_z - (infeed_factor != 0.0f ? doc * infeed_factor : 0.0f);
 801460c:	eddf 7a5d 	vldr	s15, [pc, #372]	; 8014784 <mc_thread+0x2fc>
 8014610:	ee79 7ae7 	vsub.f32	s15, s19, s15
 8014614:	edcd 7a03 	vstr	s15, [sp, #12]
            if(!mc_line(target, pl_data))
 8014618:	4621      	mov	r1, r4
 801461a:	a801      	add	r0, sp, #4
 801461c:	f7ff facc 	bl	8013bb8 <mc_line>
 8014620:	2800      	cmp	r0, #0
 8014622:	d0c1      	beq.n	80145a8 <mc_thread+0x120>
    while(--passes) {
 8014624:	3e01      	subs	r6, #1
 8014626:	d0bf      	beq.n	80145a8 <mc_thread+0x120>
        if(thread->end_taper_type & Taper_Entry)
 8014628:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
 801462c:	f013 0f01 	tst.w	r3, #1
 8014630:	d0bf      	beq.n	80145b2 <mc_thread+0x12a>
            target[X_AXIS] = position[X_AXIS] + (thread->peak + doc - thread->depth) * thread->cut_direction;
 8014632:	ed97 7a00 	vldr	s14, [r7]
 8014636:	edd5 7a02 	vldr	s15, [r5, #8]
 801463a:	ee77 7a88 	vadd.f32	s15, s15, s16
 801463e:	edd5 6a04 	vldr	s13, [r5, #16]
 8014642:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8014646:	edd5 6a09 	vldr	s13, [r5, #36]	; 0x24
 801464a:	ee67 7aa6 	vmul.f32	s15, s15, s13
 801464e:	ee77 7a27 	vadd.f32	s15, s14, s15
 8014652:	edcd 7a01 	vstr	s15, [sp, #4]
        if(!mc_line(target, pl_data))
 8014656:	4621      	mov	r1, r4
 8014658:	a801      	add	r0, sp, #4
 801465a:	f7ff faad 	bl	8013bb8 <mc_line>
 801465e:	2800      	cmp	r0, #0
 8014660:	d0a2      	beq.n	80145a8 <mc_thread+0x120>
        if(!protocol_buffer_synchronize() && state_get() != STATE_IDLE) // Wait until any previous moves are finished.
 8014662:	f003 fab9 	bl	8017bd8 <protocol_buffer_synchronize>
 8014666:	2800      	cmp	r0, #0
 8014668:	d0b2      	beq.n	80145d0 <mc_thread+0x148>
        pl_data->condition.rapid_motion = Off;      // Clear rapid motion condition flag,
 801466a:	7d23      	ldrb	r3, [r4, #20]
 801466c:	f36f 0300 	bfc	r3, #0, #1
 8014670:	7523      	strb	r3, [r4, #20]
        pl_data->spindle.state.synchronized = On;   // enable spindle sync for cut
 8014672:	7a23      	ldrb	r3, [r4, #8]
 8014674:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8014678:	7223      	strb	r3, [r4, #8]
        pl_data->overrides.feed_hold_disable = On;  // and disable feed hold
 801467a:	7e22      	ldrb	r2, [r4, #24]
 801467c:	f042 0202 	orr.w	r2, r2, #2
 8014680:	7622      	strb	r2, [r4, #24]
        if(thread->end_taper_type & Taper_Entry) {
 8014682:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
 8014686:	f013 0f01 	tst.w	r3, #1
 801468a:	d018      	beq.n	80146be <mc_thread+0x236>
            target[X_AXIS] += thread->depth * thread->cut_direction;
 801468c:	ed95 7a04 	vldr	s14, [r5, #16]
 8014690:	edd5 7a09 	vldr	s15, [r5, #36]	; 0x24
 8014694:	ee27 7a27 	vmul.f32	s14, s14, s15
 8014698:	eddd 7a01 	vldr	s15, [sp, #4]
 801469c:	ee77 7a87 	vadd.f32	s15, s15, s14
 80146a0:	edcd 7a01 	vstr	s15, [sp, #4]
            target[Z_AXIS] -= entry_taper_length;
 80146a4:	eddd 7a03 	vldr	s15, [sp, #12]
 80146a8:	ee77 7aca 	vsub.f32	s15, s15, s20
 80146ac:	edcd 7a03 	vstr	s15, [sp, #12]
            if(!mc_line(target, pl_data))
 80146b0:	4621      	mov	r1, r4
 80146b2:	a801      	add	r0, sp, #4
 80146b4:	f7ff fa80 	bl	8013bb8 <mc_line>
 80146b8:	2800      	cmp	r0, #0
 80146ba:	f43f af75 	beq.w	80145a8 <mc_thread+0x120>
        target[Z_AXIS] += thread_length;
 80146be:	eddd 7a03 	vldr	s15, [sp, #12]
 80146c2:	ee77 7a8b 	vadd.f32	s15, s15, s22
 80146c6:	edcd 7a03 	vstr	s15, [sp, #12]
        if(!mc_line(target, pl_data))
 80146ca:	4621      	mov	r1, r4
 80146cc:	a801      	add	r0, sp, #4
 80146ce:	f7ff fa73 	bl	8013bb8 <mc_line>
 80146d2:	2800      	cmp	r0, #0
 80146d4:	f43f af68 	beq.w	80145a8 <mc_thread+0x120>
        if(thread->end_taper_type & Taper_Exit) {
 80146d8:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
 80146dc:	f013 0f02 	tst.w	r3, #2
 80146e0:	f47f af7b 	bne.w	80145da <mc_thread+0x152>
        pl_data->condition.rapid_motion = On;       // Set rapid motion condition flag and
 80146e4:	7d23      	ldrb	r3, [r4, #20]
 80146e6:	f043 0301 	orr.w	r3, r3, #1
 80146ea:	7523      	strb	r3, [r4, #20]
        pl_data->spindle.state.synchronized = Off;  // disable spindle sync for retract & reposition
 80146ec:	7a23      	ldrb	r3, [r4, #8]
 80146ee:	f36f 13c7 	bfc	r3, #7, #1
 80146f2:	7223      	strb	r3, [r4, #8]
        if(passes > 1) {
 80146f4:	2e01      	cmp	r6, #1
 80146f6:	d936      	bls.n	8014766 <mc_thread+0x2de>
            doc = calc_thread_doc(++pass, thread->initial_depth, inv_degression);
 80146f8:	f108 0801 	add.w	r8, r8, #1
 80146fc:	ed95 8a03 	vldr	s16, [r5, #12]
    return cut_depth * powf((float)pass, inv_degression);
 8014700:	eef0 0a68 	vmov.f32	s1, s17
 8014704:	ee07 8a90 	vmov	s15, r8
 8014708:	eeb8 0a67 	vcvt.f32.u32	s0, s15
 801470c:	f00f f908 	bl	8023920 <powf>
 8014710:	ee28 8a00 	vmul.f32	s16, s16, s0
            doc = min(doc, thread->depth);
 8014714:	edd5 7a04 	vldr	s15, [r5, #16]
 8014718:	eef4 7ac8 	vcmpe.f32	s15, s16
 801471c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014720:	dc01      	bgt.n	8014726 <mc_thread+0x29e>
 8014722:	eeb0 8a67 	vmov.f32	s16, s15
            target[X_AXIS] = position[X_AXIS] + (doc - thread->depth) * thread->cut_direction;
 8014726:	ed97 7a00 	vldr	s14, [r7]
 801472a:	ee78 7a67 	vsub.f32	s15, s16, s15
 801472e:	edd5 6a09 	vldr	s13, [r5, #36]	; 0x24
 8014732:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8014736:	ee77 7a27 	vadd.f32	s15, s14, s15
 801473a:	edcd 7a01 	vstr	s15, [sp, #4]
            if(!mc_line(target, pl_data))
 801473e:	4621      	mov	r1, r4
 8014740:	a801      	add	r0, sp, #4
 8014742:	f7ff fa39 	bl	8013bb8 <mc_line>
 8014746:	2800      	cmp	r0, #0
 8014748:	f43f af2e 	beq.w	80145a8 <mc_thread+0x120>
            pl_data->overrides.feed_hold_disable = feed_hold_disabled;
 801474c:	7e23      	ldrb	r3, [r4, #24]
 801474e:	f369 0341 	bfi	r3, r9, #1, #1
 8014752:	7623      	strb	r3, [r4, #24]
            target[Z_AXIS] = start_z - (infeed_factor != 0.0f ? doc * infeed_factor : 0.0f);
 8014754:	eeb5 9a40 	vcmp.f32	s18, #0.0
 8014758:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801475c:	f43f af56 	beq.w	801460c <mc_thread+0x184>
 8014760:	ee68 7a09 	vmul.f32	s15, s16, s18
 8014764:	e754      	b.n	8014610 <mc_thread+0x188>
            doc = thread->depth;
 8014766:	ed95 8a04 	vldr	s16, [r5, #16]
            target[X_AXIS] = position[X_AXIS];
 801476a:	683b      	ldr	r3, [r7, #0]
 801476c:	9301      	str	r3, [sp, #4]
            if(!mc_line(target, pl_data))
 801476e:	4621      	mov	r1, r4
 8014770:	a801      	add	r0, sp, #4
 8014772:	f7ff fa21 	bl	8013bb8 <mc_line>
 8014776:	2800      	cmp	r0, #0
 8014778:	f47f af54 	bne.w	8014624 <mc_thread+0x19c>
 801477c:	e714      	b.n	80145a8 <mc_thread+0x120>
 801477e:	bf00      	nop
 8014780:	3c8efa35 	.word	0x3c8efa35
 8014784:	00000000 	.word	0x00000000

08014788 <mc_jog_execute>:

// Sets up valid jog motion received from g-code parser, checks for soft-limits, and executes the jog.
status_code_t mc_jog_execute (plan_line_data_t *pl_data, parser_block_t *gc_block)
{
 8014788:	b538      	push	{r3, r4, r5, lr}
 801478a:	4604      	mov	r4, r0
 801478c:	460d      	mov	r5, r1
    // Initialize planner data struct for jogging motions.
    // NOTE: Spindle and coolant are allowed to fully function with overrides during a jog.
    pl_data->feed_rate = gc_block->values.f;
 801478e:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 8014790:	6003      	str	r3, [r0, #0]
    pl_data->condition.no_feed_override = On;
 8014792:	7d03      	ldrb	r3, [r0, #20]
 8014794:	f043 0310 	orr.w	r3, r3, #16
 8014798:	7503      	strb	r3, [r0, #20]
    pl_data->condition.jog_motion = On;
 801479a:	b2db      	uxtb	r3, r3
 801479c:	f043 0304 	orr.w	r3, r3, #4
 80147a0:	7503      	strb	r3, [r0, #20]
    pl_data->line_number = gc_block->values.n;
 80147a2:	f8d1 3080 	ldr.w	r3, [r1, #128]	; 0x80
 80147a6:	61c3      	str	r3, [r0, #28]

    if(settings.limits.flags.jog_soft_limited)
 80147a8:	4b18      	ldr	r3, [pc, #96]	; (801480c <mc_jog_execute+0x84>)
 80147aa:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 80147ae:	f013 0f08 	tst.w	r3, #8
 80147b2:	d10f      	bne.n	80147d4 <mc_jog_execute+0x4c>
        system_apply_jog_limits(gc_block->values.xyz);
    else if (settings.limits.flags.soft_enabled && !system_check_travel_limits(gc_block->values.xyz))
 80147b4:	f013 0f02 	tst.w	r3, #2
 80147b8:	d111      	bne.n	80147de <mc_jog_execute+0x56>
        return Status_TravelExceeded;

    // Valid jog command. Plan, set state, and execute.
    mc_line(gc_block->values.xyz, pl_data);
 80147ba:	4621      	mov	r1, r4
 80147bc:	f105 0060 	add.w	r0, r5, #96	; 0x60
 80147c0:	f7ff f9fa 	bl	8013bb8 <mc_line>

#ifndef KINEMATICS_API // kinematics may segment long jog moves triggering auto start (RUN)...
    sys_state_t state = state_get();
 80147c4:	f009 ff0e 	bl	801e5e4 <state_get>
    if ((state == STATE_IDLE || state == STATE_TOOL_CHANGE) && plan_get_current_block() != NULL) { // Check if there is a block to execute.
 80147c8:	b188      	cbz	r0, 80147ee <mc_jog_execute+0x66>
 80147ca:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 80147ce:	d00e      	beq.n	80147ee <mc_jog_execute+0x66>
        st_prep_buffer();
        st_wake_up();  // NOTE: Manual start. No state machine required.
    }
#endif

    return Status_OK;
 80147d0:	2000      	movs	r0, #0
}
 80147d2:	bd38      	pop	{r3, r4, r5, pc}
        system_apply_jog_limits(gc_block->values.xyz);
 80147d4:	f101 0060 	add.w	r0, r1, #96	; 0x60
 80147d8:	f00c fca0 	bl	802111c <system_apply_jog_limits>
 80147dc:	e7ed      	b.n	80147ba <mc_jog_execute+0x32>
    else if (settings.limits.flags.soft_enabled && !system_check_travel_limits(gc_block->values.xyz))
 80147de:	f101 0060 	add.w	r0, r1, #96	; 0x60
 80147e2:	f00c fc51 	bl	8021088 <system_check_travel_limits>
 80147e6:	2800      	cmp	r0, #0
 80147e8:	d1e7      	bne.n	80147ba <mc_jog_execute+0x32>
        return Status_TravelExceeded;
 80147ea:	200f      	movs	r0, #15
 80147ec:	e7f1      	b.n	80147d2 <mc_jog_execute+0x4a>
    if ((state == STATE_IDLE || state == STATE_TOOL_CHANGE) && plan_get_current_block() != NULL) { // Check if there is a block to execute.
 80147ee:	f001 ff61 	bl	80166b4 <plan_get_current_block>
 80147f2:	b140      	cbz	r0, 8014806 <mc_jog_execute+0x7e>
        state_set(STATE_JOG);
 80147f4:	2020      	movs	r0, #32
 80147f6:	f009 fefb 	bl	801e5f0 <state_set>
        st_prep_buffer();
 80147fa:	f00a fde9 	bl	801f3d0 <st_prep_buffer>
        st_wake_up();  // NOTE: Manual start. No state machine required.
 80147fe:	f00a fb05 	bl	801ee0c <st_wake_up>
    return Status_OK;
 8014802:	2000      	movs	r0, #0
 8014804:	e7e5      	b.n	80147d2 <mc_jog_execute+0x4a>
 8014806:	2000      	movs	r0, #0
 8014808:	e7e3      	b.n	80147d2 <mc_jog_execute+0x4a>
 801480a:	bf00      	nop
 801480c:	20003b14 	.word	0x20003b14

08014810 <mc_dwell>:

// Execute dwell in seconds.
void mc_dwell (float seconds)
{
 8014810:	b508      	push	{r3, lr}
 8014812:	ed2d 8b02 	vpush	{d8}
 8014816:	eeb0 8a40 	vmov.f32	s16, s0
    if (state_get() != STATE_CHECK_MODE) {
 801481a:	f009 fee3 	bl	801e5e4 <state_get>
 801481e:	2802      	cmp	r0, #2
 8014820:	d102      	bne.n	8014828 <mc_dwell+0x18>
        protocol_buffer_synchronize();
        delay_sec(seconds, DelayMode_Dwell);
    }
}
 8014822:	ecbd 8b02 	vpop	{d8}
 8014826:	bd08      	pop	{r3, pc}
        protocol_buffer_synchronize();
 8014828:	f003 f9d6 	bl	8017bd8 <protocol_buffer_synchronize>
        delay_sec(seconds, DelayMode_Dwell);
 801482c:	2000      	movs	r0, #0
 801482e:	eeb0 0a48 	vmov.f32	s0, s16
 8014832:	f001 f917 	bl	8015a64 <delay_sec>
}
 8014836:	e7f4      	b.n	8014822 <mc_dwell+0x12>

08014838 <mc_canned_drill>:
{
 8014838:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801483c:	ed2d 8b02 	vpush	{d8}
 8014840:	b083      	sub	sp, #12
 8014842:	4681      	mov	r9, r0
 8014844:	468a      	mov	sl, r1
 8014846:	4614      	mov	r4, r2
 8014848:	461e      	mov	r6, r3
 801484a:	9d10      	ldr	r5, [sp, #64]	; 0x40
    pl_data->condition.rapid_motion = On; // Set rapid motion condition flag.
 801484c:	7d13      	ldrb	r3, [r2, #20]
 801484e:	f043 0301 	orr.w	r3, r3, #1
 8014852:	7513      	strb	r3, [r2, #20]
    if(position[plane.axis_linear] < canned->retract_position) {
 8014854:	f89d 803a 	ldrb.w	r8, [sp, #58]	; 0x3a
 8014858:	ea4f 0b88 	mov.w	fp, r8, lsl #2
 801485c:	eb06 0788 	add.w	r7, r6, r8, lsl #2
 8014860:	ed97 7a00 	vldr	s14, [r7]
 8014864:	edd5 7a06 	vldr	s15, [r5, #24]
 8014868:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801486c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014870:	d506      	bpl.n	8014880 <mc_canned_drill+0x48>
        position[plane.axis_linear] = canned->retract_position;
 8014872:	edc7 7a00 	vstr	s15, [r7]
        if(!mc_line(position, pl_data))
 8014876:	4611      	mov	r1, r2
 8014878:	4630      	mov	r0, r6
 801487a:	f7ff f99d 	bl	8013bb8 <mc_line>
 801487e:	b3c0      	cbz	r0, 80148f2 <mc_canned_drill+0xba>
    memcpy(position, target, sizeof(float) * N_AXIS);
 8014880:	f8da 1000 	ldr.w	r1, [sl]
 8014884:	f8da 2004 	ldr.w	r2, [sl, #4]
 8014888:	f8da 3008 	ldr.w	r3, [sl, #8]
 801488c:	6031      	str	r1, [r6, #0]
 801488e:	6072      	str	r2, [r6, #4]
 8014890:	60b3      	str	r3, [r6, #8]
    position[plane.axis_linear] = canned->prev_position > canned->retract_position ? canned->prev_position : canned->retract_position;
 8014892:	ed95 7a05 	vldr	s14, [r5, #20]
 8014896:	edd5 7a06 	vldr	s15, [r5, #24]
 801489a:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801489e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80148a2:	dd01      	ble.n	80148a8 <mc_canned_drill+0x70>
 80148a4:	eef0 7a47 	vmov.f32	s15, s14
 80148a8:	edc7 7a00 	vstr	s15, [r7]
    if(!mc_line(position, pl_data))
 80148ac:	4621      	mov	r1, r4
 80148ae:	4630      	mov	r0, r6
 80148b0:	f7ff f982 	bl	8013bb8 <mc_line>
 80148b4:	b1e8      	cbz	r0, 80148f2 <mc_canned_drill+0xba>
    if(position[plane.axis_linear] > canned->retract_position) {
 80148b6:	ed97 7a00 	vldr	s14, [r7]
 80148ba:	edd5 7a06 	vldr	s15, [r5, #24]
 80148be:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80148c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80148c6:	dc0c      	bgt.n	80148e2 <mc_canned_drill+0xaa>
    if(canned->retract_mode == CCRetractMode_RPos)
 80148c8:	7fab      	ldrb	r3, [r5, #30]
 80148ca:	2b01      	cmp	r3, #1
 80148cc:	d016      	beq.n	80148fc <mc_canned_drill+0xc4>
    while(repeats--) {
 80148ce:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80148d0:	3b01      	subs	r3, #1
 80148d2:	9301      	str	r3, [sp, #4]
 80148d4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80148d6:	2b00      	cmp	r3, #0
 80148d8:	f000 80a6 	beq.w	8014a28 <mc_canned_drill+0x1f0>
        float current_z = canned->retract_position;
 80148dc:	edd5 7a06 	vldr	s15, [r5, #24]
        while(current_z > canned->xyz[plane.axis_linear]) {
 80148e0:	e027      	b.n	8014932 <mc_canned_drill+0xfa>
        position[plane.axis_linear] = canned->retract_position;
 80148e2:	edc7 7a00 	vstr	s15, [r7]
        if(!mc_line(position, pl_data))
 80148e6:	4621      	mov	r1, r4
 80148e8:	4630      	mov	r0, r6
 80148ea:	f7ff f965 	bl	8013bb8 <mc_line>
 80148ee:	2800      	cmp	r0, #0
 80148f0:	d1ea      	bne.n	80148c8 <mc_canned_drill+0x90>
}
 80148f2:	b003      	add	sp, #12
 80148f4:	ecbd 8b02 	vpop	{d8}
 80148f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        canned->prev_position = canned->retract_position;
 80148fc:	69ab      	ldr	r3, [r5, #24]
 80148fe:	616b      	str	r3, [r5, #20]
 8014900:	e7e5      	b.n	80148ce <mc_canned_drill+0x96>
                mc_dwell(canned->dwell);
 8014902:	f7ff ff85 	bl	8014810 <mc_dwell>
 8014906:	e03b      	b.n	8014980 <mc_canned_drill+0x148>
            switch(motion) {
 8014908:	f1b9 0f49 	cmp.w	r9, #73	; 0x49
 801490c:	d043      	beq.n	8014996 <mc_canned_drill+0x15e>
                    position[plane.axis_linear] = canned->retract_position;
 801490e:	69ab      	ldr	r3, [r5, #24]
 8014910:	603b      	str	r3, [r7, #0]
            pl_data->condition.rapid_motion = canned->rapid_retract;
 8014912:	7f2a      	ldrb	r2, [r5, #28]
 8014914:	7d23      	ldrb	r3, [r4, #20]
 8014916:	f362 0300 	bfi	r3, r2, #0, #1
 801491a:	7523      	strb	r3, [r4, #20]
            if(!mc_line(position, pl_data))
 801491c:	4621      	mov	r1, r4
 801491e:	4630      	mov	r0, r6
 8014920:	f7ff f94a 	bl	8013bb8 <mc_line>
 8014924:	2800      	cmp	r0, #0
 8014926:	d0e4      	beq.n	80148f2 <mc_canned_drill+0xba>
            if(canned->spindle_off)
 8014928:	7f6b      	ldrb	r3, [r5, #29]
 801492a:	2b00      	cmp	r3, #0
 801492c:	d149      	bne.n	80149c2 <mc_canned_drill+0x18a>
            current_z -= canned->delta;
 801492e:	eef0 7a48 	vmov.f32	s15, s16
        while(current_z > canned->xyz[plane.axis_linear]) {
 8014932:	eb05 0388 	add.w	r3, r5, r8, lsl #2
 8014936:	ed93 8a00 	vldr	s16, [r3]
 801493a:	eeb4 8ae7 	vcmpe.f32	s16, s15
 801493e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014942:	d546      	bpl.n	80149d2 <mc_canned_drill+0x19a>
            current_z -= canned->delta;
 8014944:	ed95 7a03 	vldr	s14, [r5, #12]
 8014948:	ee77 7ac7 	vsub.f32	s15, s15, s14
            if(current_z < canned->xyz[plane.axis_linear])
 801494c:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8014950:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014954:	dc01      	bgt.n	801495a <mc_canned_drill+0x122>
            current_z -= canned->delta;
 8014956:	eeb0 8a67 	vmov.f32	s16, s15
            pl_data->condition.rapid_motion = Off;
 801495a:	7d23      	ldrb	r3, [r4, #20]
 801495c:	f36f 0300 	bfc	r3, #0, #1
 8014960:	7523      	strb	r3, [r4, #20]
            position[plane.axis_linear] = current_z;
 8014962:	ed87 8a00 	vstr	s16, [r7]
            if(!mc_line(position, pl_data)) // drill
 8014966:	4621      	mov	r1, r4
 8014968:	4630      	mov	r0, r6
 801496a:	f7ff f925 	bl	8013bb8 <mc_line>
 801496e:	2800      	cmp	r0, #0
 8014970:	d0bf      	beq.n	80148f2 <mc_canned_drill+0xba>
            if(canned->dwell > 0.0f)
 8014972:	ed95 0a04 	vldr	s0, [r5, #16]
 8014976:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 801497a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801497e:	dcc0      	bgt.n	8014902 <mc_canned_drill+0xca>
            if(canned->spindle_off)
 8014980:	7f6b      	ldrb	r3, [r5, #29]
 8014982:	2b00      	cmp	r3, #0
 8014984:	d0c0      	beq.n	8014908 <mc_canned_drill+0xd0>
                pl_data->spindle.hal->set_state((spindle_state_t){0}, 0.0f);
 8014986:	6923      	ldr	r3, [r4, #16]
 8014988:	69db      	ldr	r3, [r3, #28]
 801498a:	ed9f 0a3b 	vldr	s0, [pc, #236]	; 8014a78 <mc_canned_drill+0x240>
 801498e:	f04f 0000 	mov.w	r0, #0
 8014992:	4798      	blx	r3
 8014994:	e7b8      	b.n	8014908 <mc_canned_drill+0xd0>
                    position[plane.axis_linear] = position[plane.axis_linear] == canned->xyz[plane.axis_linear]
 8014996:	edd7 7a00 	vldr	s15, [r7]
 801499a:	eb05 0388 	add.w	r3, r5, r8, lsl #2
 801499e:	ed93 7a00 	vldr	s14, [r3]
                                                   : position[plane.axis_linear] + settings.g73_retract;
 80149a2:	eef4 7a47 	vcmp.f32	s15, s14
 80149a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80149aa:	d104      	bne.n	80149b6 <mc_canned_drill+0x17e>
 80149ac:	edd5 7a06 	vldr	s15, [r5, #24]
                    position[plane.axis_linear] = position[plane.axis_linear] == canned->xyz[plane.axis_linear]
 80149b0:	edc7 7a00 	vstr	s15, [r7]
                    break;
 80149b4:	e7ad      	b.n	8014912 <mc_canned_drill+0xda>
                                                   : position[plane.axis_linear] + settings.g73_retract;
 80149b6:	4b31      	ldr	r3, [pc, #196]	; (8014a7c <mc_canned_drill+0x244>)
 80149b8:	ed93 7a03 	vldr	s14, [r3, #12]
 80149bc:	ee77 7a87 	vadd.f32	s15, s15, s14
 80149c0:	e7f6      	b.n	80149b0 <mc_canned_drill+0x178>
                spindle_sync(pl_data->spindle.hal, gc_state.modal.spindle.state, pl_data->spindle.rpm);
 80149c2:	ed94 0a01 	vldr	s0, [r4, #4]
 80149c6:	4b2e      	ldr	r3, [pc, #184]	; (8014a80 <mc_canned_drill+0x248>)
 80149c8:	7e99      	ldrb	r1, [r3, #26]
 80149ca:	6920      	ldr	r0, [r4, #16]
 80149cc:	f009 f906 	bl	801dbdc <spindle_sync>
 80149d0:	e7ad      	b.n	801492e <mc_canned_drill+0xf6>
        if(repeats && gc_state.modal.distance_incremental) {
 80149d2:	9b01      	ldr	r3, [sp, #4]
 80149d4:	b113      	cbz	r3, 80149dc <mc_canned_drill+0x1a4>
 80149d6:	4b2a      	ldr	r3, [pc, #168]	; (8014a80 <mc_canned_drill+0x248>)
 80149d8:	791b      	ldrb	r3, [r3, #4]
 80149da:	b913      	cbnz	r3, 80149e2 <mc_canned_drill+0x1aa>
            current_z -= canned->delta;
 80149dc:	9b01      	ldr	r3, [sp, #4]
 80149de:	930f      	str	r3, [sp, #60]	; 0x3c
 80149e0:	e775      	b.n	80148ce <mc_canned_drill+0x96>
            position[plane.axis_0] += canned->xyz[plane.axis_0];
 80149e2:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
 80149e6:	eb06 0283 	add.w	r2, r6, r3, lsl #2
 80149ea:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 80149ee:	ed93 7a00 	vldr	s14, [r3]
 80149f2:	edd2 7a00 	vldr	s15, [r2]
 80149f6:	ee77 7a87 	vadd.f32	s15, s15, s14
 80149fa:	edc2 7a00 	vstr	s15, [r2]
            position[plane.axis_1] += canned->xyz[plane.axis_1];
 80149fe:	f89d 3039 	ldrb.w	r3, [sp, #57]	; 0x39
 8014a02:	eb06 0283 	add.w	r2, r6, r3, lsl #2
 8014a06:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8014a0a:	ed93 7a00 	vldr	s14, [r3]
 8014a0e:	edd2 7a00 	vldr	s15, [r2]
 8014a12:	ee77 7a87 	vadd.f32	s15, s15, s14
 8014a16:	edc2 7a00 	vstr	s15, [r2]
            if(!mc_line(position, pl_data))
 8014a1a:	4621      	mov	r1, r4
 8014a1c:	4630      	mov	r0, r6
 8014a1e:	f7ff f8cb 	bl	8013bb8 <mc_line>
 8014a22:	2800      	cmp	r0, #0
 8014a24:	d1da      	bne.n	80149dc <mc_canned_drill+0x1a4>
 8014a26:	e764      	b.n	80148f2 <mc_canned_drill+0xba>
    memcpy(target, position, sizeof(float) * N_AXIS);
 8014a28:	6831      	ldr	r1, [r6, #0]
 8014a2a:	6872      	ldr	r2, [r6, #4]
 8014a2c:	68b3      	ldr	r3, [r6, #8]
 8014a2e:	f8ca 1000 	str.w	r1, [sl]
 8014a32:	f8ca 2004 	str.w	r2, [sl, #4]
 8014a36:	f8ca 3008 	str.w	r3, [sl, #8]
    if(canned->retract_mode == CCRetractMode_Previous && motion != MotionMode_DrillChipBreak && target[plane.axis_linear] < canned->prev_position) {
 8014a3a:	7fab      	ldrb	r3, [r5, #30]
 8014a3c:	2b00      	cmp	r3, #0
 8014a3e:	f47f af58 	bne.w	80148f2 <mc_canned_drill+0xba>
 8014a42:	f1b9 0f49 	cmp.w	r9, #73	; 0x49
 8014a46:	f43f af54 	beq.w	80148f2 <mc_canned_drill+0xba>
 8014a4a:	44d3      	add	fp, sl
 8014a4c:	ed9b 7a00 	vldr	s14, [fp]
 8014a50:	edd5 7a05 	vldr	s15, [r5, #20]
 8014a54:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8014a58:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014a5c:	f57f af49 	bpl.w	80148f2 <mc_canned_drill+0xba>
        pl_data->condition.rapid_motion = On;
 8014a60:	7d23      	ldrb	r3, [r4, #20]
 8014a62:	f043 0301 	orr.w	r3, r3, #1
 8014a66:	7523      	strb	r3, [r4, #20]
        target[plane.axis_linear] = canned->prev_position;
 8014a68:	696b      	ldr	r3, [r5, #20]
 8014a6a:	f8cb 3000 	str.w	r3, [fp]
        if(!mc_line(target, pl_data))
 8014a6e:	4621      	mov	r1, r4
 8014a70:	4650      	mov	r0, sl
 8014a72:	f7ff f8a1 	bl	8013bb8 <mc_line>
 8014a76:	e73c      	b.n	80148f2 <mc_canned_drill+0xba>
 8014a78:	00000000 	.word	0x00000000
 8014a7c:	20003b14 	.word	0x20003b14
 8014a80:	20003344 	.word	0x20003344

08014a84 <mc_probe_cycle>:
}

// Perform tool length probe cycle. Requires probe switch.
// NOTE: Upon probe failure, the program will be stopped and placed into ALARM state.
gc_probe_t mc_probe_cycle (float *target, plan_line_data_t *pl_data, gc_parser_flags_t parser_flags)
{
 8014a84:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8014a88:	b084      	sub	sp, #16
 8014a8a:	4605      	mov	r5, r0
 8014a8c:	460f      	mov	r7, r1
 8014a8e:	4616      	mov	r6, r2
    uint_fast8_t idx = N_AXIS;

    // TODO: Need to update this cycle so it obeys a non-auto cycle start.
    if (state_get() == STATE_CHECK_MODE)
 8014a90:	f009 fda8 	bl	801e5e4 <state_get>
 8014a94:	2802      	cmp	r0, #2
 8014a96:	f000 8100 	beq.w	8014c9a <mc_probe_cycle+0x216>
    uint_fast8_t idx = N_AXIS;
 8014a9a:	2403      	movs	r4, #3
        return GCProbe_CheckMode;

    do {
        idx--;
 8014a9c:	3c01      	subs	r4, #1
        sys.probe_position[idx] = lroundf(target[idx] * settings.axis[idx].steps_per_mm);
 8014a9e:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 8014aa2:	ed93 0a00 	vldr	s0, [r3]
 8014aa6:	eb04 0284 	add.w	r2, r4, r4, lsl #2
 8014aaa:	4b7e      	ldr	r3, [pc, #504]	; (8014ca4 <mc_probe_cycle+0x220>)
 8014aac:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8014ab0:	edd3 7a0c 	vldr	s15, [r3, #48]	; 0x30
 8014ab4:	ee20 0a27 	vmul.f32	s0, s0, s15
 8014ab8:	f00f f86b 	bl	8023b92 <lroundf>
 8014abc:	f104 020e 	add.w	r2, r4, #14
 8014ac0:	4b79      	ldr	r3, [pc, #484]	; (8014ca8 <mc_probe_cycle+0x224>)
 8014ac2:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
    } while(idx);
 8014ac6:	2c00      	cmp	r4, #0
 8014ac8:	d1e8      	bne.n	8014a9c <mc_probe_cycle+0x18>

    sys.probe_coordsys_id = gc_state.modal.coord_system.id;
 8014aca:	4b78      	ldr	r3, [pc, #480]	; (8014cac <mc_probe_cycle+0x228>)
 8014acc:	7d1a      	ldrb	r2, [r3, #20]
 8014ace:	4b76      	ldr	r3, [pc, #472]	; (8014ca8 <mc_probe_cycle+0x224>)
 8014ad0:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36

    // Finish all queued commands and empty planner buffer before starting probe cycle.
    if (!protocol_buffer_synchronize())
 8014ad4:	f003 f880 	bl	8017bd8 <protocol_buffer_synchronize>
 8014ad8:	2800      	cmp	r0, #0
 8014ada:	f000 80e0 	beq.w	8014c9e <mc_probe_cycle+0x21a>
        return GCProbe_Abort; // Return if system reset has been issued.

    // Initialize probing control variables
    sys.flags.probe_succeeded = Off; // Re-initialize probe history before beginning cycle.
 8014ade:	4b72      	ldr	r3, [pc, #456]	; (8014ca8 <mc_probe_cycle+0x224>)
 8014ae0:	7d9a      	ldrb	r2, [r3, #22]
 8014ae2:	f36f 0241 	bfc	r2, #1, #1
 8014ae6:	759a      	strb	r2, [r3, #22]
    hal.probe.configure(parser_flags.probe_is_away, true);
 8014ae8:	4b71      	ldr	r3, [pc, #452]	; (8014cb0 <mc_probe_cycle+0x22c>)
 8014aea:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 8014aee:	2101      	movs	r1, #1
 8014af0:	f3c6 00c0 	ubfx	r0, r6, #3, #1
 8014af4:	4798      	blx	r3

#if COMPATIBILITY_LEVEL <= 1
    bool at_g59_3 = false, probe_fixture = grbl.on_probe_fixture != NULL && state_get() != STATE_TOOL_CHANGE && (sys.homed.mask & (X_AXIS_BIT|Y_AXIS_BIT));
 8014af6:	4b6f      	ldr	r3, [pc, #444]	; (8014cb4 <mc_probe_cycle+0x230>)
 8014af8:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8014afc:	b173      	cbz	r3, 8014b1c <mc_probe_cycle+0x98>
 8014afe:	f009 fd71 	bl	801e5e4 <state_get>
 8014b02:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8014b06:	f000 8090 	beq.w	8014c2a <mc_probe_cycle+0x1a6>
 8014b0a:	4b67      	ldr	r3, [pc, #412]	; (8014ca8 <mc_probe_cycle+0x224>)
 8014b0c:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 8014b10:	f013 0f03 	tst.w	r3, #3
 8014b14:	f000 808b 	beq.w	8014c2e <mc_probe_cycle+0x1aa>
 8014b18:	2301      	movs	r3, #1
 8014b1a:	e000      	b.n	8014b1e <mc_probe_cycle+0x9a>
 8014b1c:	2300      	movs	r3, #0

    if(probe_fixture)
 8014b1e:	4699      	mov	r9, r3
 8014b20:	2b00      	cmp	r3, #0
 8014b22:	f040 8086 	bne.w	8014c32 <mc_probe_cycle+0x1ae>
    bool at_g59_3 = false, probe_fixture = grbl.on_probe_fixture != NULL && state_get() != STATE_TOOL_CHANGE && (sys.homed.mask & (X_AXIS_BIT|Y_AXIS_BIT));
 8014b26:	4698      	mov	r8, r3
        grbl.on_probe_fixture(NULL, at_g59_3 = system_xy_at_fixture(CoordinateSystem_G59_3, TOOLSETTER_RADIUS), true);
#endif

    // After syncing, check if probe is already triggered or not connected. If so, halt and issue alarm.
    // NOTE: This probe initialization error applies to all probing cycles.
    probe_state_t probe = hal.probe.get_state();
 8014b28:	4b61      	ldr	r3, [pc, #388]	; (8014cb0 <mc_probe_cycle+0x22c>)
 8014b2a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 8014b2e:	4798      	blx	r3
    if (probe.triggered || !probe.connected) { // Check probe state.
 8014b30:	f000 0403 	and.w	r4, r0, #3
 8014b34:	2c02      	cmp	r4, #2
 8014b36:	f040 808a 	bne.w	8014c4e <mc_probe_cycle+0x1ca>
        protocol_execute_realtime();
        hal.probe.configure(false, false); // Re-initialize invert mask before returning.
        return GCProbe_FailInit; // Nothing else to do but bail.
    }

    if(grbl.on_probe_start) {
 8014b3a:	4b5e      	ldr	r3, [pc, #376]	; (8014cb4 <mc_probe_cycle+0x230>)
 8014b3c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8014b40:	b31b      	cbz	r3, 8014b8a <mc_probe_cycle+0x106>

        uint_fast8_t idx = N_AXIS;
        axes_signals_t axes = {0};
 8014b42:	f04f 0a00 	mov.w	sl, #0
        coord_data_t position;

        system_convert_array_steps_to_mpos(position.values, sys.position);
 8014b46:	495c      	ldr	r1, [pc, #368]	; (8014cb8 <mc_probe_cycle+0x234>)
 8014b48:	a801      	add	r0, sp, #4
 8014b4a:	f00c fa47 	bl	8020fdc <system_convert_array_steps_to_mpos>
        uint_fast8_t idx = N_AXIS;
 8014b4e:	2203      	movs	r2, #3

        do {
            idx--;
 8014b50:	1e53      	subs	r3, r2, #1
            if(position.values[idx] != target[idx])
 8014b52:	a904      	add	r1, sp, #16
 8014b54:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 8014b58:	ed11 7a03 	vldr	s14, [r1, #-12]
 8014b5c:	eb05 0183 	add.w	r1, r5, r3, lsl #2
 8014b60:	edd1 7a00 	vldr	s15, [r1]
 8014b64:	eeb4 7a67 	vcmp.f32	s14, s15
 8014b68:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014b6c:	d003      	beq.n	8014b76 <mc_probe_cycle+0xf2>
                bit_true(axes.mask, bit(idx));
 8014b6e:	2101      	movs	r1, #1
 8014b70:	4099      	lsls	r1, r3
 8014b72:	ea41 0a0a 	orr.w	sl, r1, sl
        } while(idx--);
 8014b76:	3a02      	subs	r2, #2
 8014b78:	2b00      	cmp	r3, #0
 8014b7a:	d1e9      	bne.n	8014b50 <mc_probe_cycle+0xcc>

        grbl.on_probe_start(axes, target, pl_data);
 8014b7c:	4b4d      	ldr	r3, [pc, #308]	; (8014cb4 <mc_probe_cycle+0x230>)
 8014b7e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8014b82:	463a      	mov	r2, r7
 8014b84:	4629      	mov	r1, r5
 8014b86:	4650      	mov	r0, sl
 8014b88:	4798      	blx	r3
    }

    // Setup and queue probing motion. Auto cycle-start should not start the cycle.
    if(!mc_line(target, pl_data))
 8014b8a:	4639      	mov	r1, r7
 8014b8c:	4628      	mov	r0, r5
 8014b8e:	f7ff f813 	bl	8013bb8 <mc_line>
 8014b92:	2800      	cmp	r0, #0
 8014b94:	d068      	beq.n	8014c68 <mc_probe_cycle+0x1e4>
        return GCProbe_Abort;

    // Activate the probing state monitor in the stepper module.
    sys.probing_state = Probing_Active;
 8014b96:	4844      	ldr	r0, [pc, #272]	; (8014ca8 <mc_probe_cycle+0x224>)
 8014b98:	2301      	movs	r3, #1
 8014b9a:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44

    // Perform probing cycle. Wait here until probe is triggered or motion completes.
    system_set_exec_state_flag(EXEC_CYCLE_START);
 8014b9e:	4b44      	ldr	r3, [pc, #272]	; (8014cb0 <mc_probe_cycle+0x22c>)
 8014ba0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8014ba2:	2102      	movs	r1, #2
 8014ba4:	3048      	adds	r0, #72	; 0x48
 8014ba6:	4798      	blx	r3
    do {
        if(!protocol_execute_realtime()) // Check for system abort
 8014ba8:	f002 fd50 	bl	801764c <protocol_execute_realtime>
 8014bac:	2800      	cmp	r0, #0
 8014bae:	d05b      	beq.n	8014c68 <mc_probe_cycle+0x1e4>
            return GCProbe_Abort;
    } while (!(state_get() == STATE_IDLE || state_get() == STATE_TOOL_CHANGE));
 8014bb0:	f009 fd18 	bl	801e5e4 <state_get>
 8014bb4:	b120      	cbz	r0, 8014bc0 <mc_probe_cycle+0x13c>
 8014bb6:	f009 fd15 	bl	801e5e4 <state_get>
 8014bba:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8014bbe:	d1f3      	bne.n	8014ba8 <mc_probe_cycle+0x124>

    // Probing cycle complete!

    // Set state variables and error out, if the probe failed and cycle with error is enabled.
    if(sys.probing_state == Probing_Active) {
 8014bc0:	4b39      	ldr	r3, [pc, #228]	; (8014ca8 <mc_probe_cycle+0x224>)
 8014bc2:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8014bc6:	b2db      	uxtb	r3, r3
 8014bc8:	2b01      	cmp	r3, #1
 8014bca:	d051      	beq.n	8014c70 <mc_probe_cycle+0x1ec>
        memcpy(sys.probe_position, sys.position, sizeof(sys.position));
        if(!parser_flags.probe_is_no_error)
            system_set_exec_alarm(Alarm_ProbeFailContact);
    } else
        sys.flags.probe_succeeded = On; // Indicate to system the probing cycle completed successfully.
 8014bcc:	4a36      	ldr	r2, [pc, #216]	; (8014ca8 <mc_probe_cycle+0x224>)
 8014bce:	7d93      	ldrb	r3, [r2, #22]
 8014bd0:	f043 0302 	orr.w	r3, r3, #2
 8014bd4:	7593      	strb	r3, [r2, #22]

    sys.probing_state = Probing_Off;    // Ensure probe state monitor is disabled.
 8014bd6:	2000      	movs	r0, #0
 8014bd8:	4b33      	ldr	r3, [pc, #204]	; (8014ca8 <mc_probe_cycle+0x224>)
 8014bda:	f883 0044 	strb.w	r0, [r3, #68]	; 0x44
    hal.probe.configure(false, false);  // Re-initialize invert mask.
 8014bde:	4b34      	ldr	r3, [pc, #208]	; (8014cb0 <mc_probe_cycle+0x22c>)
 8014be0:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 8014be4:	4601      	mov	r1, r0
 8014be6:	4798      	blx	r3
    protocol_execute_realtime();        // Check and execute run-time commands
 8014be8:	f002 fd30 	bl	801764c <protocol_execute_realtime>

#if COMPATIBILITY_LEVEL <= 1
    if(probe_fixture)
 8014bec:	f1b9 0f00 	cmp.w	r9, #0
 8014bf0:	d006      	beq.n	8014c00 <mc_probe_cycle+0x17c>
        grbl.on_probe_fixture(NULL, at_g59_3, false);
 8014bf2:	4b30      	ldr	r3, [pc, #192]	; (8014cb4 <mc_probe_cycle+0x230>)
 8014bf4:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8014bf8:	2200      	movs	r2, #0
 8014bfa:	4641      	mov	r1, r8
 8014bfc:	4610      	mov	r0, r2
 8014bfe:	4798      	blx	r3
#endif

    // Reset the stepper and planner buffers to remove the remainder of the probe motion.
    st_reset();             // Reset step segment buffer.
 8014c00:	f00a fab2 	bl	801f168 <st_reset>
    plan_reset();           // Reset planner buffer. Zero planner positions. Ensure probing motion is cleared.
 8014c04:	f001 fc72 	bl	80164ec <plan_reset>
    plan_sync_position();   // Sync planner position to current machine position.
 8014c08:	f002 f83a 	bl	8016c80 <plan_sync_position>
#if ENABLE_BACKLASH_COMPENSATION
    mc_sync_backlash_position();
#endif

    // All done! Output the probe position as message if configured.
    if(settings.status_report.probe_coordinates)
 8014c0c:	4b25      	ldr	r3, [pc, #148]	; (8014ca4 <mc_probe_cycle+0x220>)
 8014c0e:	f993 30fc 	ldrsb.w	r3, [r3, #252]	; 0xfc
 8014c12:	2b00      	cmp	r3, #0
 8014c14:	db3e      	blt.n	8014c94 <mc_probe_cycle+0x210>
        report_probe_parameters();

    if(grbl.on_probe_completed)
 8014c16:	4b27      	ldr	r3, [pc, #156]	; (8014cb4 <mc_probe_cycle+0x230>)
 8014c18:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8014c1c:	b103      	cbz	r3, 8014c20 <mc_probe_cycle+0x19c>
        grbl.on_probe_completed();
 8014c1e:	4798      	blx	r3

    // Successful probe cycle or Failed to trigger probe within travel. With or without error.
    return sys.flags.probe_succeeded ? GCProbe_Found : GCProbe_FailEnd;
 8014c20:	4b21      	ldr	r3, [pc, #132]	; (8014ca8 <mc_probe_cycle+0x224>)
 8014c22:	7d9c      	ldrb	r4, [r3, #22]
 8014c24:	f3c4 0440 	ubfx	r4, r4, #1, #1
 8014c28:	e01e      	b.n	8014c68 <mc_probe_cycle+0x1e4>
    bool at_g59_3 = false, probe_fixture = grbl.on_probe_fixture != NULL && state_get() != STATE_TOOL_CHANGE && (sys.homed.mask & (X_AXIS_BIT|Y_AXIS_BIT));
 8014c2a:	2300      	movs	r3, #0
 8014c2c:	e777      	b.n	8014b1e <mc_probe_cycle+0x9a>
 8014c2e:	2300      	movs	r3, #0
 8014c30:	e775      	b.n	8014b1e <mc_probe_cycle+0x9a>
        grbl.on_probe_fixture(NULL, at_g59_3 = system_xy_at_fixture(CoordinateSystem_G59_3, TOOLSETTER_RADIUS), true);
 8014c32:	4b20      	ldr	r3, [pc, #128]	; (8014cb4 <mc_probe_cycle+0x230>)
 8014c34:	f8d3 4080 	ldr.w	r4, [r3, #128]	; 0x80
 8014c38:	eeb1 0a04 	vmov.f32	s0, #20	; 0x40a00000  5.0
 8014c3c:	2008      	movs	r0, #8
 8014c3e:	f00c f9eb 	bl	8021018 <system_xy_at_fixture>
 8014c42:	4680      	mov	r8, r0
 8014c44:	2201      	movs	r2, #1
 8014c46:	4601      	mov	r1, r0
 8014c48:	2000      	movs	r0, #0
 8014c4a:	47a0      	blx	r4
 8014c4c:	e76c      	b.n	8014b28 <mc_probe_cycle+0xa4>
        system_set_exec_alarm(Alarm_ProbeFailInitial);
 8014c4e:	4c18      	ldr	r4, [pc, #96]	; (8014cb0 <mc_probe_cycle+0x22c>)
 8014c50:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8014c52:	2104      	movs	r1, #4
 8014c54:	4819      	ldr	r0, [pc, #100]	; (8014cbc <mc_probe_cycle+0x238>)
 8014c56:	4798      	blx	r3
        protocol_execute_realtime();
 8014c58:	f002 fcf8 	bl	801764c <protocol_execute_realtime>
        hal.probe.configure(false, false); // Re-initialize invert mask before returning.
 8014c5c:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 8014c60:	2100      	movs	r1, #0
 8014c62:	4608      	mov	r0, r1
 8014c64:	4798      	blx	r3
        return GCProbe_FailInit; // Nothing else to do but bail.
 8014c66:	2402      	movs	r4, #2
}
 8014c68:	4620      	mov	r0, r4
 8014c6a:	b004      	add	sp, #16
 8014c6c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        memcpy(sys.probe_position, sys.position, sizeof(sys.position));
 8014c70:	4b0d      	ldr	r3, [pc, #52]	; (8014ca8 <mc_probe_cycle+0x224>)
 8014c72:	f103 0438 	add.w	r4, r3, #56	; 0x38
 8014c76:	3388      	adds	r3, #136	; 0x88
 8014c78:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8014c7c:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        if(!parser_flags.probe_is_no_error)
 8014c80:	f016 0f10 	tst.w	r6, #16
 8014c84:	d1a7      	bne.n	8014bd6 <mc_probe_cycle+0x152>
            system_set_exec_alarm(Alarm_ProbeFailContact);
 8014c86:	4b0a      	ldr	r3, [pc, #40]	; (8014cb0 <mc_probe_cycle+0x22c>)
 8014c88:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8014c8a:	2105      	movs	r1, #5
 8014c8c:	f104 0014 	add.w	r0, r4, #20
 8014c90:	4798      	blx	r3
 8014c92:	e7a0      	b.n	8014bd6 <mc_probe_cycle+0x152>
        report_probe_parameters();
 8014c94:	f004 fba8 	bl	80193e8 <report_probe_parameters>
 8014c98:	e7bd      	b.n	8014c16 <mc_probe_cycle+0x192>
        return GCProbe_CheckMode;
 8014c9a:	2400      	movs	r4, #0
 8014c9c:	e7e4      	b.n	8014c68 <mc_probe_cycle+0x1e4>
        return GCProbe_Abort; // Return if system reset has been issued.
 8014c9e:	2402      	movs	r4, #2
 8014ca0:	e7e2      	b.n	8014c68 <mc_probe_cycle+0x1e4>
 8014ca2:	bf00      	nop
 8014ca4:	20003b14 	.word	0x20003b14
 8014ca8:	200036c4 	.word	0x200036c4
 8014cac:	20003344 	.word	0x20003344
 8014cb0:	2000350c 	.word	0x2000350c
 8014cb4:	2000343c 	.word	0x2000343c
 8014cb8:	2000374c 	.word	0x2000374c
 8014cbc:	20003710 	.word	0x20003710

08014cc0 <mc_parking_motion>:


// Plans and executes the single special motion case for parking. Independent of main planner buffer.
// NOTE: Uses the always free planner ring buffer head to store motion parameters for execution.
bool mc_parking_motion (float *parking_target, plan_line_data_t *pl_data)
{
 8014cc0:	b510      	push	{r4, lr}
    bool ok;

    if (sys.abort)
 8014cc2:	4b0d      	ldr	r3, [pc, #52]	; (8014cf8 <mc_parking_motion+0x38>)
 8014cc4:	781b      	ldrb	r3, [r3, #0]
 8014cc6:	b113      	cbz	r3, 8014cce <mc_parking_motion+0xe>
        return false; // Block during abort.
 8014cc8:	2400      	movs	r4, #0
        st_prep_buffer();
        st_wake_up();
    }

    return ok;
}
 8014cca:	4620      	mov	r0, r4
 8014ccc:	bd10      	pop	{r4, pc}
    if ((ok = plan_buffer_line(parking_target, pl_data))) {
 8014cce:	f001 fdb1 	bl	8016834 <plan_buffer_line>
 8014cd2:	4604      	mov	r4, r0
 8014cd4:	2800      	cmp	r0, #0
 8014cd6:	d0f8      	beq.n	8014cca <mc_parking_motion+0xa>
        sys.step_control.execute_sys_motion = On;
 8014cd8:	4b07      	ldr	r3, [pc, #28]	; (8014cf8 <mc_parking_motion+0x38>)
 8014cda:	7e1a      	ldrb	r2, [r3, #24]
 8014cdc:	f042 0204 	orr.w	r2, r2, #4
 8014ce0:	761a      	strb	r2, [r3, #24]
        sys.step_control.end_motion = Off;  // Allow parking motion to execute, if feed hold is active.
 8014ce2:	b2d2      	uxtb	r2, r2
 8014ce4:	f36f 0200 	bfc	r2, #0, #1
 8014ce8:	761a      	strb	r2, [r3, #24]
        st_parking_setup_buffer();          // Setup step segment buffer for special parking motion case.
 8014cea:	f00a faeb 	bl	801f2c4 <st_parking_setup_buffer>
        st_prep_buffer();
 8014cee:	f00a fb6f 	bl	801f3d0 <st_prep_buffer>
        st_wake_up();
 8014cf2:	f00a f88b 	bl	801ee0c <st_wake_up>
 8014cf6:	e7e8      	b.n	8014cca <mc_parking_motion+0xa>
 8014cf8:	200036c4 	.word	0x200036c4

08014cfc <mc_override_ctrl_update>:

void mc_override_ctrl_update (gc_override_flags_t override_state)
{
 8014cfc:	b510      	push	{r4, lr}
 8014cfe:	4604      	mov	r4, r0
// Finish all queued commands before altering override control state
    protocol_buffer_synchronize();
 8014d00:	f002 ff6a 	bl	8017bd8 <protocol_buffer_synchronize>
    if (!sys.abort)
 8014d04:	4b03      	ldr	r3, [pc, #12]	; (8014d14 <mc_override_ctrl_update+0x18>)
 8014d06:	781b      	ldrb	r3, [r3, #0]
 8014d08:	b913      	cbnz	r3, 8014d10 <mc_override_ctrl_update+0x14>
        sys.override.control = override_state;
 8014d0a:	4b02      	ldr	r3, [pc, #8]	; (8014d14 <mc_override_ctrl_update+0x18>)
 8014d0c:	f883 4029 	strb.w	r4, [r3, #41]	; 0x29
}
 8014d10:	bd10      	pop	{r4, pc}
 8014d12:	bf00      	nop
 8014d14:	200036c4 	.word	0x200036c4

08014d18 <mc_reset>:
// lost, since there was an abrupt uncontrolled deceleration. Called at an interrupt level by
// realtime abort command and hard limits. So, keep to a minimum.
ISR_CODE void ISR_FUNC(mc_reset)(void)
{
    // Only this function can set the system reset. Helps prevent multiple kill calls.
    if (bit_isfalse(sys.rt_exec_state, EXEC_RESET)) {
 8014d18:	4b27      	ldr	r3, [pc, #156]	; (8014db8 <mc_reset+0xa0>)
 8014d1a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8014d1c:	f013 0f20 	tst.w	r3, #32
 8014d20:	d149      	bne.n	8014db6 <mc_reset+0x9e>
{
 8014d22:	b510      	push	{r4, lr}

        system_set_exec_state_flag(EXEC_RESET);
 8014d24:	4c25      	ldr	r4, [pc, #148]	; (8014dbc <mc_reset+0xa4>)
 8014d26:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8014d28:	2120      	movs	r1, #32
 8014d2a:	4825      	ldr	r0, [pc, #148]	; (8014dc0 <mc_reset+0xa8>)
 8014d2c:	4798      	blx	r3

        if(hal.stream.suspend_read)
 8014d2e:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 8014d32:	b10b      	cbz	r3, 8014d38 <mc_reset+0x20>
            hal.stream.suspend_read(false);
 8014d34:	2000      	movs	r0, #0
 8014d36:	4798      	blx	r3

        // Kill steppers only if in any motion state, i.e. cycle, actively holding, or homing.
        // NOTE: If steppers are kept enabled via the step idle delay setting, this also keeps
        // the steppers enabled by avoiding the go_idle call altogether, unless the motion state is
        // violated, by which, all bets are off.
        if ((state_get() & (STATE_CYCLE|STATE_HOMING|STATE_JOG)) || sys.step_control.execute_hold || sys.step_control.execute_sys_motion) {
 8014d38:	f009 fc54 	bl	801e5e4 <state_get>
 8014d3c:	f010 0f2c 	tst.w	r0, #44	; 0x2c
 8014d40:	d104      	bne.n	8014d4c <mc_reset+0x34>
 8014d42:	4b1d      	ldr	r3, [pc, #116]	; (8014db8 <mc_reset+0xa0>)
 8014d44:	7e1b      	ldrb	r3, [r3, #24]
 8014d46:	f013 0f06 	tst.w	r3, #6
 8014d4a:	d00d      	beq.n	8014d68 <mc_reset+0x50>

            sys.position_lost = true;
 8014d4c:	4b1a      	ldr	r3, [pc, #104]	; (8014db8 <mc_reset+0xa0>)
 8014d4e:	2201      	movs	r2, #1
 8014d50:	70da      	strb	r2, [r3, #3]

            if (state_get() != STATE_HOMING)
 8014d52:	f009 fc47 	bl	801e5e4 <state_get>
 8014d56:	2804      	cmp	r0, #4
 8014d58:	d017      	beq.n	8014d8a <mc_reset+0x72>
                system_set_exec_alarm(Alarm_AbortCycle);
 8014d5a:	4b18      	ldr	r3, [pc, #96]	; (8014dbc <mc_reset+0xa4>)
 8014d5c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8014d5e:	2103      	movs	r1, #3
 8014d60:	4818      	ldr	r0, [pc, #96]	; (8014dc4 <mc_reset+0xac>)
 8014d62:	4798      	blx	r3
            else if (!sys.rt_exec_alarm)
                system_set_exec_alarm(Alarm_HomingFailReset);

            st_go_idle(); // Force kill steppers. Position has likely been lost.
 8014d64:	f00a f862 	bl	801ee2c <st_go_idle>
        }

        if(hal.control.get_state().e_stop)
 8014d68:	4b14      	ldr	r3, [pc, #80]	; (8014dbc <mc_reset+0xa4>)
 8014d6a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8014d6c:	4798      	blx	r3
 8014d6e:	f010 0f40 	tst.w	r0, #64	; 0x40
 8014d72:	d014      	beq.n	8014d9e <mc_reset+0x86>
            system_set_exec_alarm(Alarm_EStop);
 8014d74:	4b11      	ldr	r3, [pc, #68]	; (8014dbc <mc_reset+0xa4>)
 8014d76:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8014d78:	210a      	movs	r1, #10
 8014d7a:	4812      	ldr	r0, [pc, #72]	; (8014dc4 <mc_reset+0xac>)
 8014d7c:	4798      	blx	r3
        else if(hal.control.get_state().motor_fault)
            system_set_exec_alarm(Alarm_MotorFault);

        if(grbl.on_reset)
 8014d7e:	4b12      	ldr	r3, [pc, #72]	; (8014dc8 <mc_reset+0xb0>)
 8014d80:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 8014d84:	b103      	cbz	r3, 8014d88 <mc_reset+0x70>
            grbl.on_reset();
 8014d86:	4798      	blx	r3
    }
}
 8014d88:	bd10      	pop	{r4, pc}
            else if (!sys.rt_exec_alarm)
 8014d8a:	4b0b      	ldr	r3, [pc, #44]	; (8014db8 <mc_reset+0xa0>)
 8014d8c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8014d8e:	2b00      	cmp	r3, #0
 8014d90:	d1e8      	bne.n	8014d64 <mc_reset+0x4c>
                system_set_exec_alarm(Alarm_HomingFailReset);
 8014d92:	4b0a      	ldr	r3, [pc, #40]	; (8014dbc <mc_reset+0xa4>)
 8014d94:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8014d96:	2106      	movs	r1, #6
 8014d98:	480a      	ldr	r0, [pc, #40]	; (8014dc4 <mc_reset+0xac>)
 8014d9a:	4798      	blx	r3
 8014d9c:	e7e2      	b.n	8014d64 <mc_reset+0x4c>
        else if(hal.control.get_state().motor_fault)
 8014d9e:	4b07      	ldr	r3, [pc, #28]	; (8014dbc <mc_reset+0xa4>)
 8014da0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8014da2:	4798      	blx	r3
 8014da4:	f410 7f80 	tst.w	r0, #256	; 0x100
 8014da8:	d0e9      	beq.n	8014d7e <mc_reset+0x66>
            system_set_exec_alarm(Alarm_MotorFault);
 8014daa:	4b04      	ldr	r3, [pc, #16]	; (8014dbc <mc_reset+0xa4>)
 8014dac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8014dae:	2111      	movs	r1, #17
 8014db0:	4804      	ldr	r0, [pc, #16]	; (8014dc4 <mc_reset+0xac>)
 8014db2:	4798      	blx	r3
 8014db4:	e7e3      	b.n	8014d7e <mc_reset+0x66>
 8014db6:	4770      	bx	lr
 8014db8:	200036c4 	.word	0x200036c4
 8014dbc:	2000350c 	.word	0x2000350c
 8014dc0:	2000370c 	.word	0x2000370c
 8014dc4:	20003710 	.word	0x20003710
 8014dc8:	2000343c 	.word	0x2000343c

08014dcc <mc_homing_cycle>:
{
 8014dcc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8014dce:	b083      	sub	sp, #12
 8014dd0:	4604      	mov	r4, r0
    bool home_all = cycle.mask == 0;
 8014dd2:	b2c7      	uxtb	r7, r0
    memset(&sys.last_event.limits, 0, sizeof(limit_signals_t));
 8014dd4:	4b7a      	ldr	r3, [pc, #488]	; (8014fc0 <mc_homing_cycle+0x1f4>)
 8014dd6:	2200      	movs	r2, #0
 8014dd8:	601a      	str	r2, [r3, #0]
    if(settings.homing.flags.manual && (home_all ? sys.homing.mask : (cycle.mask & sys.homing.mask)) == 0) {
 8014dda:	4b7a      	ldr	r3, [pc, #488]	; (8014fc4 <mc_homing_cycle+0x1f8>)
 8014ddc:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 8014de0:	f013 0f10 	tst.w	r3, #16
 8014de4:	d007      	beq.n	8014df6 <mc_homing_cycle+0x2a>
 8014de6:	2f00      	cmp	r7, #0
 8014de8:	f040 808a 	bne.w	8014f00 <mc_homing_cycle+0x134>
 8014dec:	4b76      	ldr	r3, [pc, #472]	; (8014fc8 <mc_homing_cycle+0x1fc>)
 8014dee:	7e9b      	ldrb	r3, [r3, #26]
 8014df0:	2b00      	cmp	r3, #0
 8014df2:	f000 808a 	beq.w	8014f0a <mc_homing_cycle+0x13e>
        if(settings.homing.seek_rate <= 0.0f)
 8014df6:	4b73      	ldr	r3, [pc, #460]	; (8014fc4 <mc_homing_cycle+0x1f8>)
 8014df8:	edd3 7a42 	vldr	s15, [r3, #264]	; 0x108
 8014dfc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8014e00:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014e04:	f240 80d9 	bls.w	8014fba <mc_homing_cycle+0x1ee>
        if (settings.limits.flags.two_switches && hal.homing.get_state == hal.limits.get_state && limit_signals_merge(hal.limits.get_state()).value) {
 8014e08:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 8014e0c:	f013 0f10 	tst.w	r3, #16
 8014e10:	d005      	beq.n	8014e1e <mc_homing_cycle+0x52>
 8014e12:	4b6e      	ldr	r3, [pc, #440]	; (8014fcc <mc_homing_cycle+0x200>)
 8014e14:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8014e16:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8014e18:	429a      	cmp	r2, r3
 8014e1a:	f000 8089 	beq.w	8014f30 <mc_homing_cycle+0x164>
        state_set(STATE_HOMING);                                // Set homing system state.
 8014e1e:	2004      	movs	r0, #4
 8014e20:	f009 fbe6 	bl	801e5f0 <state_set>
        protocol_enqueue_realtime_command(CMD_STATUS_REPORT);   // Force a status report and
 8014e24:	2080      	movs	r0, #128	; 0x80
 8014e26:	f002 fee9 	bl	8017bfc <protocol_enqueue_realtime_command>
        delay_sec(0.1f, DelayMode_Dwell);                       // delay a bit to get it sent (or perhaps wait a bit for a request?)
 8014e2a:	2000      	movs	r0, #0
 8014e2c:	ed9f 0a68 	vldr	s0, [pc, #416]	; 8014fd0 <mc_homing_cycle+0x204>
 8014e30:	f000 fe18 	bl	8015a64 <delay_sec>
        hal.limits.enable(false, true); // Disable hard limits pin change register for cycle duration
 8014e34:	4b65      	ldr	r3, [pc, #404]	; (8014fcc <mc_homing_cycle+0x200>)
 8014e36:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8014e38:	2101      	movs	r1, #1
 8014e3a:	2000      	movs	r0, #0
 8014e3c:	4798      	blx	r3
        if(spindle_is_on())
 8014e3e:	f008 ff8d 	bl	801dd5c <spindle_is_on>
 8014e42:	2800      	cmp	r0, #0
 8014e44:	f040 8085 	bne.w	8014f52 <mc_homing_cycle+0x186>
        if(hal.coolant.get_state().mask)
 8014e48:	4b60      	ldr	r3, [pc, #384]	; (8014fcc <mc_homing_cycle+0x200>)
 8014e4a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8014e4c:	4798      	blx	r3
 8014e4e:	b2c0      	uxtb	r0, r0
 8014e50:	2800      	cmp	r0, #0
 8014e52:	f040 8081 	bne.w	8014f58 <mc_homing_cycle+0x18c>
        if (!home_all) // Perform homing cycle based on mask.
 8014e56:	2f00      	cmp	r7, #0
 8014e58:	f040 8081 	bne.w	8014f5e <mc_homing_cycle+0x192>
            sys.homed.mask &= ~sys.homing.mask;
 8014e5c:	4a5a      	ldr	r2, [pc, #360]	; (8014fc8 <mc_homing_cycle+0x1fc>)
 8014e5e:	7e93      	ldrb	r3, [r2, #26]
 8014e60:	43db      	mvns	r3, r3
 8014e62:	b25b      	sxtb	r3, r3
 8014e64:	f892 1054 	ldrb.w	r1, [r2, #84]	; 0x54
 8014e68:	400b      	ands	r3, r1
 8014e6a:	f882 3054 	strb.w	r3, [r2, #84]	; 0x54
    status_code_t homed_status = Status_OK;
 8014e6e:	463e      	mov	r6, r7
            uint_fast8_t idx = 0;
 8014e70:	2500      	movs	r5, #0
                if(settings.homing.cycle[idx].mask) {
 8014e72:	4b54      	ldr	r3, [pc, #336]	; (8014fc4 <mc_homing_cycle+0x1f8>)
 8014e74:	442b      	add	r3, r5
 8014e76:	f893 0115 	ldrb.w	r0, [r3, #277]	; 0x115
 8014e7a:	2800      	cmp	r0, #0
 8014e7c:	d174      	bne.n	8014f68 <mc_homing_cycle+0x19c>
            } while(++idx < N_AXIS);
 8014e7e:	3501      	adds	r5, #1
 8014e80:	2d02      	cmp	r5, #2
 8014e82:	d9f6      	bls.n	8014e72 <mc_homing_cycle+0xa6>
        hal.limits.enable(settings.limits.flags.hard_enabled, false);
 8014e84:	4b51      	ldr	r3, [pc, #324]	; (8014fcc <mc_homing_cycle+0x200>)
 8014e86:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8014e88:	4a4e      	ldr	r2, [pc, #312]	; (8014fc4 <mc_homing_cycle+0x1f8>)
 8014e8a:	f892 0124 	ldrb.w	r0, [r2, #292]	; 0x124
 8014e8e:	2100      	movs	r1, #0
 8014e90:	f000 0001 	and.w	r0, r0, #1
 8014e94:	4798      	blx	r3
    if(cycle.mask) {
 8014e96:	b2e4      	uxtb	r4, r4
 8014e98:	b194      	cbz	r4, 8014ec0 <mc_homing_cycle+0xf4>
        if(!protocol_execute_realtime()) {  // Check for reset and set system abort.
 8014e9a:	f002 fbd7 	bl	801764c <protocol_execute_realtime>
 8014e9e:	2800      	cmp	r0, #0
 8014ea0:	d069      	beq.n	8014f76 <mc_homing_cycle+0x1aa>
        if(homed_status != Status_OK) {
 8014ea2:	2e00      	cmp	r6, #0
 8014ea4:	d16d      	bne.n	8014f82 <mc_homing_cycle+0x1b6>
        if(home_all && settings.homing.flags.manual)
 8014ea6:	b92f      	cbnz	r7, 8014eb4 <mc_homing_cycle+0xe8>
 8014ea8:	4b46      	ldr	r3, [pc, #280]	; (8014fc4 <mc_homing_cycle+0x1f8>)
 8014eaa:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 8014eae:	f013 0f10 	tst.w	r3, #16
 8014eb2:	d175      	bne.n	8014fa0 <mc_homing_cycle+0x1d4>
        sync_position();
 8014eb4:	f001 fee4 	bl	8016c80 <plan_sync_position>
 8014eb8:	4946      	ldr	r1, [pc, #280]	; (8014fd4 <mc_homing_cycle+0x208>)
 8014eba:	4847      	ldr	r0, [pc, #284]	; (8014fd8 <mc_homing_cycle+0x20c>)
 8014ebc:	f00c f88e 	bl	8020fdc <system_convert_array_steps_to_mpos>
    system_add_rt_report(Report_Homed);
 8014ec0:	2004      	movs	r0, #4
 8014ec2:	f00c f9bd 	bl	8021240 <system_add_rt_report>
    homed_status = settings.limits.flags.hard_enabled && settings.limits.flags.check_at_init && limit_signals_merge(hal.limits.get_state()).value
 8014ec6:	4b3f      	ldr	r3, [pc, #252]	; (8014fc4 <mc_homing_cycle+0x1f8>)
 8014ec8:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 8014ecc:	f003 0305 	and.w	r3, r3, #5
                    : Status_OK;
 8014ed0:	2b05      	cmp	r3, #5
 8014ed2:	d108      	bne.n	8014ee6 <mc_homing_cycle+0x11a>
    homed_status = settings.limits.flags.hard_enabled && settings.limits.flags.check_at_init && limit_signals_merge(hal.limits.get_state()).value
 8014ed4:	4b3d      	ldr	r3, [pc, #244]	; (8014fcc <mc_homing_cycle+0x200>)
 8014ed6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8014ed8:	4798      	blx	r3
 8014eda:	9001      	str	r0, [sp, #4]
 8014edc:	f7fe fa0c 	bl	80132f8 <limit_signals_merge>
 8014ee0:	b2c0      	uxtb	r0, r0
 8014ee2:	2800      	cmp	r0, #0
 8014ee4:	d167      	bne.n	8014fb6 <mc_homing_cycle+0x1ea>
        limits_set_work_envelope();
 8014ee6:	f7fe fa37 	bl	8013358 <limits_set_work_envelope>
                    : Status_OK;
 8014eea:	2600      	movs	r6, #0
    if(grbl.on_homing_completed)
 8014eec:	4b3b      	ldr	r3, [pc, #236]	; (8014fdc <mc_homing_cycle+0x210>)
 8014eee:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8014ef0:	b11b      	cbz	r3, 8014efa <mc_homing_cycle+0x12e>
        grbl.on_homing_completed(homed_status == Status_OK);
 8014ef2:	fab6 f086 	clz	r0, r6
 8014ef6:	0940      	lsrs	r0, r0, #5
 8014ef8:	4798      	blx	r3
}
 8014efa:	4630      	mov	r0, r6
 8014efc:	b003      	add	sp, #12
 8014efe:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if(settings.homing.flags.manual && (home_all ? sys.homing.mask : (cycle.mask & sys.homing.mask)) == 0) {
 8014f00:	4b31      	ldr	r3, [pc, #196]	; (8014fc8 <mc_homing_cycle+0x1fc>)
 8014f02:	7e9b      	ldrb	r3, [r3, #26]
 8014f04:	421f      	tst	r7, r3
 8014f06:	f47f af76 	bne.w	8014df6 <mc_homing_cycle+0x2a>
        if(home_all)
 8014f0a:	b90f      	cbnz	r7, 8014f10 <mc_homing_cycle+0x144>
            cycle.mask = AXES_BITMASK;
 8014f0c:	f04f 0407 	mov.w	r4, #7
        tc_clear_tlo_reference(cycle);
 8014f10:	4620      	mov	r0, r4
 8014f12:	f00c fe27 	bl	8021b64 <tc_clear_tlo_reference>
        sys.homed.mask |= cycle.mask;
 8014f16:	b2e3      	uxtb	r3, r4
 8014f18:	4a2b      	ldr	r2, [pc, #172]	; (8014fc8 <mc_homing_cycle+0x1fc>)
 8014f1a:	f892 1054 	ldrb.w	r1, [r2, #84]	; 0x54
 8014f1e:	430b      	orrs	r3, r1
 8014f20:	f882 3054 	strb.w	r3, [r2, #84]	; 0x54
        limits_set_machine_positions(cycle, false);
 8014f24:	2100      	movs	r1, #0
 8014f26:	4620      	mov	r0, r4
 8014f28:	f7fe faa0 	bl	801346c <limits_set_machine_positions>
    status_code_t homed_status = Status_OK;
 8014f2c:	2600      	movs	r6, #0
        limits_set_machine_positions(cycle, false);
 8014f2e:	e7b2      	b.n	8014e96 <mc_homing_cycle+0xca>
        if (settings.limits.flags.two_switches && hal.homing.get_state == hal.limits.get_state && limit_signals_merge(hal.limits.get_state()).value) {
 8014f30:	4798      	blx	r3
 8014f32:	9000      	str	r0, [sp, #0]
 8014f34:	f7fe f9e0 	bl	80132f8 <limit_signals_merge>
 8014f38:	b2c0      	uxtb	r0, r0
 8014f3a:	2800      	cmp	r0, #0
 8014f3c:	f43f af6f 	beq.w	8014e1e <mc_homing_cycle+0x52>
            mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
 8014f40:	f7ff feea 	bl	8014d18 <mc_reset>
            system_set_exec_alarm(Alarm_HardLimit);
 8014f44:	4b21      	ldr	r3, [pc, #132]	; (8014fcc <mc_homing_cycle+0x200>)
 8014f46:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8014f48:	2101      	movs	r1, #1
 8014f4a:	4825      	ldr	r0, [pc, #148]	; (8014fe0 <mc_homing_cycle+0x214>)
 8014f4c:	4798      	blx	r3
            return Status_Unhandled;
 8014f4e:	2654      	movs	r6, #84	; 0x54
 8014f50:	e7d3      	b.n	8014efa <mc_homing_cycle+0x12e>
            gc_spindle_off();
 8014f52:	f7fa f97f 	bl	800f254 <gc_spindle_off>
 8014f56:	e777      	b.n	8014e48 <mc_homing_cycle+0x7c>
            gc_coolant_off();
 8014f58:	f7fa f98a 	bl	800f270 <gc_coolant_off>
 8014f5c:	e77b      	b.n	8014e56 <mc_homing_cycle+0x8a>
            homed_status = limits_go_home(cycle);
 8014f5e:	4620      	mov	r0, r4
 8014f60:	f7fe fd62 	bl	8013a28 <limits_go_home>
 8014f64:	4606      	mov	r6, r0
 8014f66:	e78d      	b.n	8014e84 <mc_homing_cycle+0xb8>
                    cycle.mask = settings.homing.cycle[idx].mask;
 8014f68:	4604      	mov	r4, r0
                    if((homed_status = limits_go_home(cycle)) != Status_OK)
 8014f6a:	f7fe fd5d 	bl	8013a28 <limits_go_home>
 8014f6e:	4606      	mov	r6, r0
 8014f70:	2800      	cmp	r0, #0
 8014f72:	d084      	beq.n	8014e7e <mc_homing_cycle+0xb2>
 8014f74:	e786      	b.n	8014e84 <mc_homing_cycle+0xb8>
            if(grbl.on_homing_completed)
 8014f76:	4b19      	ldr	r3, [pc, #100]	; (8014fdc <mc_homing_cycle+0x210>)
 8014f78:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8014f7a:	b103      	cbz	r3, 8014f7e <mc_homing_cycle+0x1b2>
                grbl.on_homing_completed(false);
 8014f7c:	4798      	blx	r3
            return Status_Unhandled;        // Did not complete. Alarm state set by mc_alarm.
 8014f7e:	2654      	movs	r6, #84	; 0x54
 8014f80:	e7bb      	b.n	8014efa <mc_homing_cycle+0x12e>
            if(state_get() == STATE_HOMING)
 8014f82:	f009 fb2f 	bl	801e5e4 <state_get>
 8014f86:	2804      	cmp	r0, #4
 8014f88:	d006      	beq.n	8014f98 <mc_homing_cycle+0x1cc>
            if(grbl.on_homing_completed)
 8014f8a:	4b14      	ldr	r3, [pc, #80]	; (8014fdc <mc_homing_cycle+0x210>)
 8014f8c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8014f8e:	2b00      	cmp	r3, #0
 8014f90:	d0b3      	beq.n	8014efa <mc_homing_cycle+0x12e>
                grbl.on_homing_completed(false);
 8014f92:	2000      	movs	r0, #0
 8014f94:	4798      	blx	r3
            return homed_status;
 8014f96:	e7b0      	b.n	8014efa <mc_homing_cycle+0x12e>
                state_set(STATE_IDLE);
 8014f98:	2000      	movs	r0, #0
 8014f9a:	f009 fb29 	bl	801e5f0 <state_set>
 8014f9e:	e7f4      	b.n	8014f8a <mc_homing_cycle+0x1be>
            cycle.mask = AXES_BITMASK & ~sys.homing.mask;
 8014fa0:	4b09      	ldr	r3, [pc, #36]	; (8014fc8 <mc_homing_cycle+0x1fc>)
 8014fa2:	7e98      	ldrb	r0, [r3, #26]
 8014fa4:	43c0      	mvns	r0, r0
            sys.homed.mask = AXES_BITMASK;
 8014fa6:	2207      	movs	r2, #7
 8014fa8:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
            limits_set_machine_positions(cycle, false);
 8014fac:	2100      	movs	r1, #0
 8014fae:	4010      	ands	r0, r2
 8014fb0:	f7fe fa5c 	bl	801346c <limits_set_machine_positions>
 8014fb4:	e77e      	b.n	8014eb4 <mc_homing_cycle+0xe8>
                    : Status_OK;
 8014fb6:	262d      	movs	r6, #45	; 0x2d
 8014fb8:	e798      	b.n	8014eec <mc_homing_cycle+0x120>
            return Status_HomingDisabled;
 8014fba:	2605      	movs	r6, #5
 8014fbc:	e79d      	b.n	8014efa <mc_homing_cycle+0x12e>
 8014fbe:	bf00      	nop
 8014fc0:	20003746 	.word	0x20003746
 8014fc4:	20003b14 	.word	0x20003b14
 8014fc8:	200036c4 	.word	0x200036c4
 8014fcc:	2000350c 	.word	0x2000350c
 8014fd0:	3dcccccd 	.word	0x3dcccccd
 8014fd4:	2000374c 	.word	0x2000374c
 8014fd8:	200033a4 	.word	0x200033a4
 8014fdc:	2000343c 	.word	0x2000343c
 8014fe0:	20003710 	.word	0x20003710

08014fe4 <my_plugin_init>:
#ifndef ADD_MY_PLUGIN

__attribute__((weak)) void my_plugin_init (void)
{
    // NOOP
}
 8014fe4:	4770      	bx	lr
	...

08014fe8 <probe_result>:
    return axis <= N_AXIS ? factors[axis - 1] : 0.0f;
}

static float probe_result (ngc_param_id_t id)
{
    return sys.flags.probe_succeeded ? 1.0f : 0.0f;
 8014fe8:	4b05      	ldr	r3, [pc, #20]	; (8015000 <probe_result+0x18>)
 8014fea:	7d9b      	ldrb	r3, [r3, #22]
 8014fec:	f013 0f02 	tst.w	r3, #2
 8014ff0:	d002      	beq.n	8014ff8 <probe_result+0x10>
 8014ff2:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8014ff6:	4770      	bx	lr
 8014ff8:	ed9f 0a02 	vldr	s0, [pc, #8]	; 8015004 <probe_result+0x1c>
}
 8014ffc:	4770      	bx	lr
 8014ffe:	bf00      	nop
 8015000:	200036c4 	.word	0x200036c4
 8015004:	00000000 	.word	0x00000000

08015008 <m66_result>:
    return axis <= N_AXIS ? sys.home_position[axis - 1] : 0.0f;
}
*/
static float m66_result (ngc_param_id_t id)
{
    return (float)sys.var5399;
 8015008:	4b02      	ldr	r3, [pc, #8]	; (8015014 <m66_result+0xc>)
 801500a:	ed93 0a14 	vldr	s0, [r3, #80]	; 0x50
}
 801500e:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 8015012:	4770      	bx	lr
 8015014:	200036c4 	.word	0x200036c4

08015018 <tool_number>:

static float tool_number (ngc_param_id_t id)
{
    return (float)gc_state.tool->tool_id;
 8015018:	4b03      	ldr	r3, [pc, #12]	; (8015028 <tool_number+0x10>)
 801501a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 801501e:	ed93 0a04 	vldr	s0, [r3, #16]
}
 8015022:	eeb8 0a40 	vcvt.f32.u32	s0, s0
 8015026:	4770      	bx	lr
 8015028:	20003344 	.word	0x20003344

0801502c <tool_offset>:

static float tool_offset (ngc_param_id_t id)
{
    uint_fast8_t axis = id % 10;
 801502c:	4b0a      	ldr	r3, [pc, #40]	; (8015058 <tool_offset+0x2c>)
 801502e:	fba3 2300 	umull	r2, r3, r3, r0
 8015032:	08db      	lsrs	r3, r3, #3
 8015034:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8015038:	eba0 0043 	sub.w	r0, r0, r3, lsl #1
 801503c:	b280      	uxth	r0, r0

    return axis <= N_AXIS ? gc_state.tool_length_offset[axis] : 0.0f;
 801503e:	2803      	cmp	r0, #3
 8015040:	d806      	bhi.n	8015050 <tool_offset+0x24>
 8015042:	3022      	adds	r0, #34	; 0x22
 8015044:	4b05      	ldr	r3, [pc, #20]	; (801505c <tool_offset+0x30>)
 8015046:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 801504a:	ed93 0a00 	vldr	s0, [r3]
 801504e:	4770      	bx	lr
 8015050:	ed9f 0a03 	vldr	s0, [pc, #12]	; 8015060 <tool_offset+0x34>
}
 8015054:	4770      	bx	lr
 8015056:	bf00      	nop
 8015058:	cccccccd 	.word	0xcccccccd
 801505c:	20003344 	.word	0x20003344
 8015060:	00000000 	.word	0x00000000

08015064 <coord_system>:
    return value;
}

static float coord_system (ngc_param_id_t id)
{
    return (float)gc_state.modal.coord_system.id + 1;
 8015064:	4b05      	ldr	r3, [pc, #20]	; (801507c <coord_system+0x18>)
 8015066:	7d1b      	ldrb	r3, [r3, #20]
 8015068:	ee00 3a10 	vmov	s0, r3
 801506c:	eeb8 0a40 	vcvt.f32.u32	s0, s0
}
 8015070:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8015074:	ee30 0a27 	vadd.f32	s0, s0, s15
 8015078:	4770      	bx	lr
 801507a:	bf00      	nop
 801507c:	20003344 	.word	0x20003344

08015080 <g92_offset_applied>:
    return value;
}

static float g92_offset_applied (ngc_param_id_t id)
{
    return (float)gc_state.g92_coord_offset_applied;
 8015080:	4b03      	ldr	r3, [pc, #12]	; (8015090 <g92_offset_applied+0x10>)
 8015082:	f893 307a 	ldrb.w	r3, [r3, #122]	; 0x7a
 8015086:	ee00 3a10 	vmov	s0, r3
}
 801508a:	eeb8 0a40 	vcvt.f32.u32	s0, s0
 801508e:	4770      	bx	lr
 8015090:	20003344 	.word	0x20003344

08015094 <g92_offset>:

static float g92_offset (ngc_param_id_t id)
{
    uint_fast8_t axis = id % 10;
 8015094:	4b0a      	ldr	r3, [pc, #40]	; (80150c0 <g92_offset+0x2c>)
 8015096:	fba3 2300 	umull	r2, r3, r3, r0
 801509a:	08db      	lsrs	r3, r3, #3
 801509c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80150a0:	eba0 0043 	sub.w	r0, r0, r3, lsl #1
 80150a4:	b280      	uxth	r0, r0

    return axis <= N_AXIS ? gc_state.g92_coord_offset [axis - 1] : 0.0f;
 80150a6:	2803      	cmp	r0, #3
 80150a8:	d806      	bhi.n	80150b8 <g92_offset+0x24>
 80150aa:	301d      	adds	r0, #29
 80150ac:	4b05      	ldr	r3, [pc, #20]	; (80150c4 <g92_offset+0x30>)
 80150ae:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 80150b2:	ed93 0a01 	vldr	s0, [r3, #4]
 80150b6:	4770      	bx	lr
 80150b8:	ed9f 0a03 	vldr	s0, [pc, #12]	; 80150c8 <g92_offset+0x34>
}
 80150bc:	4770      	bx	lr
 80150be:	bf00      	nop
 80150c0:	cccccccd 	.word	0xcccccccd
 80150c4:	20003344 	.word	0x20003344
 80150c8:	00000000 	.word	0x00000000

080150cc <_relative_pos>:
    if(axis < N_AXIS) {
 80150cc:	2802      	cmp	r0, #2
 80150ce:	d902      	bls.n	80150d6 <_relative_pos+0xa>
        value = 0.0f;
 80150d0:	ed9f 0a13 	vldr	s0, [pc, #76]	; 8015120 <_relative_pos+0x54>
}
 80150d4:	4770      	bx	lr
{
 80150d6:	b510      	push	{r4, lr}
 80150d8:	ed2d 8b02 	vpush	{d8}
        value = sys.position[axis] / settings.axis[axis].steps_per_mm - gc_get_offset(axis);
 80150dc:	f100 0222 	add.w	r2, r0, #34	; 0x22
 80150e0:	4b10      	ldr	r3, [pc, #64]	; (8015124 <_relative_pos+0x58>)
 80150e2:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80150e6:	edd3 7a00 	vldr	s15, [r3]
 80150ea:	4c0f      	ldr	r4, [pc, #60]	; (8015128 <_relative_pos+0x5c>)
 80150ec:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 80150f0:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 80150f4:	ed93 7a0c 	vldr	s14, [r3, #48]	; 0x30
 80150f8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80150fc:	ee87 8a87 	vdiv.f32	s16, s15, s14
 8015100:	f7f9 ff8c 	bl	800f01c <gc_get_offset>
 8015104:	ee38 0a40 	vsub.f32	s0, s16, s0
        if(settings.flags.report_inches)
 8015108:	f894 30fe 	ldrb.w	r3, [r4, #254]	; 0xfe
 801510c:	f013 0f01 	tst.w	r3, #1
 8015110:	d003      	beq.n	801511a <_relative_pos+0x4e>
            value *= 25.4f;
 8015112:	eddf 7a06 	vldr	s15, [pc, #24]	; 801512c <_relative_pos+0x60>
 8015116:	ee20 0a27 	vmul.f32	s0, s0, s15
}
 801511a:	ecbd 8b02 	vpop	{d8}
 801511e:	bd10      	pop	{r4, pc}
 8015120:	00000000 	.word	0x00000000
 8015124:	200036c4 	.word	0x200036c4
 8015128:	20003b14 	.word	0x20003b14
 801512c:	41cb3333 	.word	0x41cb3333

08015130 <work_position>:

static float work_position (ngc_param_id_t id)
{
 8015130:	b508      	push	{r3, lr}
    float value = 0.0f;
    uint_fast8_t axis = id % 10;
 8015132:	4b08      	ldr	r3, [pc, #32]	; (8015154 <work_position+0x24>)
 8015134:	fba3 2300 	umull	r2, r3, r3, r0
 8015138:	08db      	lsrs	r3, r3, #3
 801513a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801513e:	eba0 0043 	sub.w	r0, r0, r3, lsl #1
 8015142:	b280      	uxth	r0, r0

    if(axis < N_AXIS)
 8015144:	2802      	cmp	r0, #2
 8015146:	d902      	bls.n	801514e <work_position+0x1e>
    float value = 0.0f;
 8015148:	ed9f 0a03 	vldr	s0, [pc, #12]	; 8015158 <work_position+0x28>
        value = _relative_pos(axis);

    return value;
}
 801514c:	bd08      	pop	{r3, pc}
        value = _relative_pos(axis);
 801514e:	f7ff ffbd 	bl	80150cc <_relative_pos>
 8015152:	e7fb      	b.n	801514c <work_position+0x1c>
 8015154:	cccccccd 	.word	0xcccccccd
 8015158:	00000000 	.word	0x00000000

0801515c <coord_system_offset>:
{
 801515c:	b510      	push	{r4, lr}
 801515e:	b084      	sub	sp, #16
    uint_fast8_t axis = id % 10;
 8015160:	4b15      	ldr	r3, [pc, #84]	; (80151b8 <coord_system_offset+0x5c>)
 8015162:	fba3 2300 	umull	r2, r3, r3, r0
 8015166:	08db      	lsrs	r3, r3, #3
 8015168:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801516c:	eba0 0343 	sub.w	r3, r0, r3, lsl #1
 8015170:	b29b      	uxth	r3, r3
    id = (id - 5220 - axis - (id == 0 ? 10 : 0)) / 20;
 8015172:	1ac2      	subs	r2, r0, r3
 8015174:	b978      	cbnz	r0, 8015196 <coord_system_offset+0x3a>
 8015176:	210a      	movs	r1, #10
 8015178:	1a50      	subs	r0, r2, r1
 801517a:	f5a0 50a3 	sub.w	r0, r0, #5216	; 0x1460
 801517e:	3804      	subs	r0, #4
 8015180:	4a0d      	ldr	r2, [pc, #52]	; (80151b8 <coord_system_offset+0x5c>)
 8015182:	fba2 2000 	umull	r2, r0, r2, r0
 8015186:	0900      	lsrs	r0, r0, #4
    if (axis > 0 && axis <= N_AXIS && settings_read_coord_data((coord_system_id_t)id, &data.xyz))
 8015188:	1e5c      	subs	r4, r3, #1
 801518a:	2c02      	cmp	r4, #2
 801518c:	d905      	bls.n	801519a <coord_system_offset+0x3e>
    float value = 0.0f;
 801518e:	ed9f 0a0b 	vldr	s0, [pc, #44]	; 80151bc <coord_system_offset+0x60>
}
 8015192:	b004      	add	sp, #16
 8015194:	bd10      	pop	{r4, pc}
    id = (id - 5220 - axis - (id == 0 ? 10 : 0)) / 20;
 8015196:	2100      	movs	r1, #0
 8015198:	e7ee      	b.n	8015178 <coord_system_offset+0x1c>
    if (axis > 0 && axis <= N_AXIS && settings_read_coord_data((coord_system_id_t)id, &data.xyz))
 801519a:	4669      	mov	r1, sp
 801519c:	b2c0      	uxtb	r0, r0
 801519e:	f007 fc29 	bl	801c9f4 <settings_read_coord_data>
 80151a2:	b128      	cbz	r0, 80151b0 <coord_system_offset+0x54>
        value = data.xyz[axis - 1];
 80151a4:	ab04      	add	r3, sp, #16
 80151a6:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 80151aa:	ed13 0a04 	vldr	s0, [r3, #-16]
 80151ae:	e7f0      	b.n	8015192 <coord_system_offset+0x36>
    float value = 0.0f;
 80151b0:	ed9f 0a02 	vldr	s0, [pc, #8]	; 80151bc <coord_system_offset+0x60>
    return value;
 80151b4:	e7ed      	b.n	8015192 <coord_system_offset+0x36>
 80151b6:	bf00      	nop
 80151b8:	cccccccd 	.word	0xcccccccd
 80151bc:	00000000 	.word	0x00000000

080151c0 <g30_home>:
{
 80151c0:	b510      	push	{r4, lr}
 80151c2:	b084      	sub	sp, #16
    uint_fast8_t axis = id % 10;
 80151c4:	4b0e      	ldr	r3, [pc, #56]	; (8015200 <g30_home+0x40>)
 80151c6:	fba3 2300 	umull	r2, r3, r3, r0
 80151ca:	08db      	lsrs	r3, r3, #3
 80151cc:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80151d0:	eba0 0043 	sub.w	r0, r0, r3, lsl #1
 80151d4:	b284      	uxth	r4, r0
    if (axis <= N_AXIS && settings_read_coord_data(CoordinateSystem_G30, &data.xyz))
 80151d6:	2c03      	cmp	r4, #3
 80151d8:	d903      	bls.n	80151e2 <g30_home+0x22>
    float value = 0.0f;
 80151da:	ed9f 0a0a 	vldr	s0, [pc, #40]	; 8015204 <g30_home+0x44>
}
 80151de:	b004      	add	sp, #16
 80151e0:	bd10      	pop	{r4, pc}
    if (axis <= N_AXIS && settings_read_coord_data(CoordinateSystem_G30, &data.xyz))
 80151e2:	4669      	mov	r1, sp
 80151e4:	200a      	movs	r0, #10
 80151e6:	f007 fc05 	bl	801c9f4 <settings_read_coord_data>
 80151ea:	b130      	cbz	r0, 80151fa <g30_home+0x3a>
        value = data.xyz[axis - 1];
 80151ec:	3c01      	subs	r4, #1
 80151ee:	ab04      	add	r3, sp, #16
 80151f0:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 80151f4:	ed14 0a04 	vldr	s0, [r4, #-16]
 80151f8:	e7f1      	b.n	80151de <g30_home+0x1e>
    float value = 0.0f;
 80151fa:	ed9f 0a02 	vldr	s0, [pc, #8]	; 8015204 <g30_home+0x44>
    return value;
 80151fe:	e7ee      	b.n	80151de <g30_home+0x1e>
 8015200:	cccccccd 	.word	0xcccccccd
 8015204:	00000000 	.word	0x00000000

08015208 <g28_home>:
{
 8015208:	b510      	push	{r4, lr}
 801520a:	b084      	sub	sp, #16
    uint_fast8_t axis = id % 10;
 801520c:	4b0e      	ldr	r3, [pc, #56]	; (8015248 <g28_home+0x40>)
 801520e:	fba3 2300 	umull	r2, r3, r3, r0
 8015212:	08db      	lsrs	r3, r3, #3
 8015214:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8015218:	eba0 0043 	sub.w	r0, r0, r3, lsl #1
 801521c:	b284      	uxth	r4, r0
    if(axis <= N_AXIS && settings_read_coord_data(CoordinateSystem_G28, &data.xyz))
 801521e:	2c03      	cmp	r4, #3
 8015220:	d903      	bls.n	801522a <g28_home+0x22>
    float value = 0.0f;
 8015222:	ed9f 0a0a 	vldr	s0, [pc, #40]	; 801524c <g28_home+0x44>
}
 8015226:	b004      	add	sp, #16
 8015228:	bd10      	pop	{r4, pc}
    if(axis <= N_AXIS && settings_read_coord_data(CoordinateSystem_G28, &data.xyz))
 801522a:	4669      	mov	r1, sp
 801522c:	2009      	movs	r0, #9
 801522e:	f007 fbe1 	bl	801c9f4 <settings_read_coord_data>
 8015232:	b130      	cbz	r0, 8015242 <g28_home+0x3a>
        value = data.xyz[axis - 1];
 8015234:	3c01      	subs	r4, #1
 8015236:	ab04      	add	r3, sp, #16
 8015238:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 801523c:	ed14 0a04 	vldr	s0, [r4, #-16]
 8015240:	e7f1      	b.n	8015226 <g28_home+0x1e>
    float value = 0.0f;
 8015242:	ed9f 0a02 	vldr	s0, [pc, #8]	; 801524c <g28_home+0x44>
    return value;
 8015246:	e7ee      	b.n	8015226 <g28_home+0x1e>
 8015248:	cccccccd 	.word	0xcccccccd
 801524c:	00000000 	.word	0x00000000

08015250 <probe_coord>:
{
 8015250:	b510      	push	{r4, lr}
 8015252:	b084      	sub	sp, #16
    uint_fast8_t axis = (id % 10) - 1;
 8015254:	4b27      	ldr	r3, [pc, #156]	; (80152f4 <probe_coord+0xa4>)
 8015256:	fba3 2300 	umull	r2, r3, r3, r0
 801525a:	08db      	lsrs	r3, r3, #3
 801525c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8015260:	eba0 0443 	sub.w	r4, r0, r3, lsl #1
 8015264:	b2a4      	uxth	r4, r4
 8015266:	3c01      	subs	r4, #1
    if(axis < N_AXIS && (sys.probe_coordsys_id == gc_state.modal.coord_system.id || settings_read_coord_data(sys.probe_coordsys_id, &data.xyz))) {
 8015268:	2c02      	cmp	r4, #2
 801526a:	d83f      	bhi.n	80152ec <probe_coord+0x9c>
 801526c:	4b22      	ldr	r3, [pc, #136]	; (80152f8 <probe_coord+0xa8>)
 801526e:	f893 0036 	ldrb.w	r0, [r3, #54]	; 0x36
 8015272:	4b22      	ldr	r3, [pc, #136]	; (80152fc <probe_coord+0xac>)
 8015274:	7d1b      	ldrb	r3, [r3, #20]
 8015276:	4298      	cmp	r0, r3
 8015278:	d129      	bne.n	80152ce <probe_coord+0x7e>
        value = sys.probe_position[axis] / settings.axis[axis].steps_per_mm -
 801527a:	491f      	ldr	r1, [pc, #124]	; (80152f8 <probe_coord+0xa8>)
 801527c:	f104 030e 	add.w	r3, r4, #14
 8015280:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 8015284:	edd3 7a00 	vldr	s15, [r3]
 8015288:	eb04 0284 	add.w	r2, r4, r4, lsl #2
 801528c:	4b1c      	ldr	r3, [pc, #112]	; (8015300 <probe_coord+0xb0>)
 801528e:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8015292:	ed93 7a0c 	vldr	s14, [r3, #48]	; 0x30
 8015296:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801529a:	ee87 0a87 	vdiv.f32	s0, s15, s14
                 (sys.probe_coordsys_id == gc_state.modal.coord_system.id ? gc_state.modal.coord_system.xyz[axis] : data.xyz[axis]);
 801529e:	f891 2036 	ldrb.w	r2, [r1, #54]	; 0x36
 80152a2:	4b16      	ldr	r3, [pc, #88]	; (80152fc <probe_coord+0xac>)
 80152a4:	7d1b      	ldrb	r3, [r3, #20]
 80152a6:	429a      	cmp	r2, r3
 80152a8:	d019      	beq.n	80152de <probe_coord+0x8e>
 80152aa:	ab04      	add	r3, sp, #16
 80152ac:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 80152b0:	ed54 7a04 	vldr	s15, [r4, #-16]
        value = sys.probe_position[axis] / settings.axis[axis].steps_per_mm -
 80152b4:	ee30 0a67 	vsub.f32	s0, s0, s15
        if(settings.flags.report_inches)
 80152b8:	4b11      	ldr	r3, [pc, #68]	; (8015300 <probe_coord+0xb0>)
 80152ba:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 80152be:	f013 0f01 	tst.w	r3, #1
 80152c2:	d015      	beq.n	80152f0 <probe_coord+0xa0>
            value *= 25.4f;
 80152c4:	eddf 7a0f 	vldr	s15, [pc, #60]	; 8015304 <probe_coord+0xb4>
 80152c8:	ee20 0a27 	vmul.f32	s0, s0, s15
 80152cc:	e010      	b.n	80152f0 <probe_coord+0xa0>
    if(axis < N_AXIS && (sys.probe_coordsys_id == gc_state.modal.coord_system.id || settings_read_coord_data(sys.probe_coordsys_id, &data.xyz))) {
 80152ce:	4669      	mov	r1, sp
 80152d0:	f007 fb90 	bl	801c9f4 <settings_read_coord_data>
 80152d4:	2800      	cmp	r0, #0
 80152d6:	d1d0      	bne.n	801527a <probe_coord+0x2a>
    float value = 0.0f;
 80152d8:	ed9f 0a0b 	vldr	s0, [pc, #44]	; 8015308 <probe_coord+0xb8>
    return value;
 80152dc:	e008      	b.n	80152f0 <probe_coord+0xa0>
                 (sys.probe_coordsys_id == gc_state.modal.coord_system.id ? gc_state.modal.coord_system.xyz[axis] : data.xyz[axis]);
 80152de:	3402      	adds	r4, #2
 80152e0:	4b06      	ldr	r3, [pc, #24]	; (80152fc <probe_coord+0xac>)
 80152e2:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 80152e6:	edd3 7a00 	vldr	s15, [r3]
 80152ea:	e7e3      	b.n	80152b4 <probe_coord+0x64>
    float value = 0.0f;
 80152ec:	ed9f 0a06 	vldr	s0, [pc, #24]	; 8015308 <probe_coord+0xb8>
}
 80152f0:	b004      	add	sp, #16
 80152f2:	bd10      	pop	{r4, pc}
 80152f4:	cccccccd 	.word	0xcccccccd
 80152f8:	200036c4 	.word	0x200036c4
 80152fc:	20003344 	.word	0x20003344
 8015300:	20003b14 	.word	0x20003b14
 8015304:	41cb3333 	.word	0x41cb3333
 8015308:	00000000 	.word	0x00000000

0801530c <scaling_factors>:
{
 801530c:	b510      	push	{r4, lr}
 801530e:	4604      	mov	r4, r0
    float *factors = gc_get_scaling();
 8015310:	f7f9 fe30 	bl	800ef74 <gc_get_scaling>
    uint_fast8_t axis = id % 10;
 8015314:	4b0a      	ldr	r3, [pc, #40]	; (8015340 <scaling_factors+0x34>)
 8015316:	fba3 2304 	umull	r2, r3, r3, r4
 801531a:	08db      	lsrs	r3, r3, #3
 801531c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8015320:	eba4 0443 	sub.w	r4, r4, r3, lsl #1
 8015324:	b2a4      	uxth	r4, r4
    return axis <= N_AXIS ? factors[axis - 1] : 0.0f;
 8015326:	2c03      	cmp	r4, #3
 8015328:	d807      	bhi.n	801533a <scaling_factors+0x2e>
 801532a:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 801532e:	3c01      	subs	r4, #1
 8015330:	eb00 0084 	add.w	r0, r0, r4, lsl #2
 8015334:	ed90 0a00 	vldr	s0, [r0]
}
 8015338:	bd10      	pop	{r4, pc}
    return axis <= N_AXIS ? factors[axis - 1] : 0.0f;
 801533a:	ed9f 0a02 	vldr	s0, [pc, #8]	; 8015344 <scaling_factors+0x38>
 801533e:	e7fb      	b.n	8015338 <scaling_factors+0x2c>
 8015340:	cccccccd 	.word	0xcccccccd
 8015344:	00000000 	.word	0x00000000

08015348 <ngc_param_get>:
    { .id_min = 5401, .id_max = 5409, .get = tool_offset },        // LinuxCNC
    { .id_min = 5420, .id_max = 5428, .get = work_position }       // LinuxCNC
};

bool ngc_param_get (ngc_param_id_t id, float *value)
{
 8015348:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801534a:	460f      	mov	r7, r1
    bool found = id > 0 && id < ngc_ro_params[0].id_min;
 801534c:	4605      	mov	r5, r0
 801534e:	b128      	cbz	r0, 801535c <ngc_param_get+0x14>
 8015350:	f241 33c4 	movw	r3, #5060	; 0x13c4
 8015354:	4298      	cmp	r0, r3
 8015356:	d90e      	bls.n	8015376 <ngc_param_get+0x2e>
 8015358:	2300      	movs	r3, #0
 801535a:	e000      	b.n	801535e <ngc_param_get+0x16>
 801535c:	2300      	movs	r3, #0
    uint_fast8_t idx = sizeof(ngc_ro_params) / sizeof(ngc_ro_param_t);

    *value = 0.0f;
 801535e:	2200      	movs	r2, #0
 8015360:	603a      	str	r2, [r7, #0]

    if(found) {
 8015362:	461e      	mov	r6, r3
 8015364:	b16b      	cbz	r3, 8015382 <ngc_param_get+0x3a>
        ngc_rw_param_t *rw_param = rw_params;
 8015366:	4b17      	ldr	r3, [pc, #92]	; (80153c4 <ngc_param_get+0x7c>)
 8015368:	681b      	ldr	r3, [r3, #0]
        while(rw_param) {
 801536a:	b143      	cbz	r3, 801537e <ngc_param_get+0x36>
            if(rw_param->id == id) {
 801536c:	881a      	ldrh	r2, [r3, #0]
 801536e:	42aa      	cmp	r2, r5
 8015370:	d003      	beq.n	801537a <ngc_param_get+0x32>
                *value = rw_param->value;
                rw_param = NULL;
            } else
                rw_param = rw_param->next;
 8015372:	689b      	ldr	r3, [r3, #8]
 8015374:	e7f9      	b.n	801536a <ngc_param_get+0x22>
    bool found = id > 0 && id < ngc_ro_params[0].id_min;
 8015376:	2301      	movs	r3, #1
 8015378:	e7f1      	b.n	801535e <ngc_param_get+0x16>
                *value = rw_param->value;
 801537a:	685b      	ldr	r3, [r3, #4]
 801537c:	603b      	str	r3, [r7, #0]
        if((found = id >= ngc_ro_params[idx].id_min && id <= ngc_ro_params[idx].id_max))
            *value = ngc_ro_params[idx].get(id);
    } while(idx && !found);

    return found;
}
 801537e:	4630      	mov	r0, r6
 8015380:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    uint_fast8_t idx = sizeof(ngc_ro_params) / sizeof(ngc_ro_param_t);
 8015382:	2415      	movs	r4, #21
 8015384:	e00e      	b.n	80153a4 <ngc_param_get+0x5c>
        if((found = id >= ngc_ro_params[idx].id_min && id <= ngc_ro_params[idx].id_max))
 8015386:	2300      	movs	r3, #0
 8015388:	461e      	mov	r6, r3
 801538a:	b13b      	cbz	r3, 801539c <ngc_param_get+0x54>
            *value = ngc_ro_params[idx].get(id);
 801538c:	4b0e      	ldr	r3, [pc, #56]	; (80153c8 <ngc_param_get+0x80>)
 801538e:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 8015392:	685b      	ldr	r3, [r3, #4]
 8015394:	4628      	mov	r0, r5
 8015396:	4798      	blx	r3
 8015398:	ed87 0a00 	vstr	s0, [r7]
    } while(idx && !found);
 801539c:	2c00      	cmp	r4, #0
 801539e:	d0ee      	beq.n	801537e <ngc_param_get+0x36>
 80153a0:	2e00      	cmp	r6, #0
 80153a2:	d1ec      	bne.n	801537e <ngc_param_get+0x36>
        idx--;
 80153a4:	3c01      	subs	r4, #1
        if((found = id >= ngc_ro_params[idx].id_min && id <= ngc_ro_params[idx].id_max))
 80153a6:	4b08      	ldr	r3, [pc, #32]	; (80153c8 <ngc_param_get+0x80>)
 80153a8:	f833 3034 	ldrh.w	r3, [r3, r4, lsl #3]
 80153ac:	42ab      	cmp	r3, r5
 80153ae:	d8ea      	bhi.n	8015386 <ngc_param_get+0x3e>
 80153b0:	4b05      	ldr	r3, [pc, #20]	; (80153c8 <ngc_param_get+0x80>)
 80153b2:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 80153b6:	885b      	ldrh	r3, [r3, #2]
 80153b8:	42ab      	cmp	r3, r5
 80153ba:	d201      	bcs.n	80153c0 <ngc_param_get+0x78>
 80153bc:	2300      	movs	r3, #0
 80153be:	e7e3      	b.n	8015388 <ngc_param_get+0x40>
 80153c0:	2301      	movs	r3, #1
 80153c2:	e7e1      	b.n	8015388 <ngc_param_get+0x40>
 80153c4:	2000375c 	.word	0x2000375c
 80153c8:	08027124 	.word	0x08027124

080153cc <ngc_named_param_get_by_id>:


// Named parameters

float ngc_named_param_get_by_id (ncg_name_param_id_t id)
{
 80153cc:	b508      	push	{r3, lr}
    float value;

    switch(id) {
 80153ce:	282c      	cmp	r0, #44	; 0x2c
 80153d0:	f200 812f 	bhi.w	8015632 <ngc_named_param_get_by_id+0x266>
 80153d4:	e8df f010 	tbh	[pc, r0, lsl #1]
 80153d8:	0130002d 	.word	0x0130002d
 80153dc:	00360030 	.word	0x00360030
 80153e0:	004b0040 	.word	0x004b0040
 80153e4:	0056004e 	.word	0x0056004e
 80153e8:	0066005e 	.word	0x0066005e
 80153ec:	0078006e 	.word	0x0078006e
 80153f0:	008a0080 	.word	0x008a0080
 80153f4:	00a3009b 	.word	0x00a3009b
 80153f8:	00b500ab 	.word	0x00b500ab
 80153fc:	013000bd 	.word	0x013000bd
 8015400:	00ce00c7 	.word	0x00ce00c7
 8015404:	00dd00d5 	.word	0x00dd00d5
 8015408:	00ed00e5 	.word	0x00ed00e5
 801540c:	00fd00f5 	.word	0x00fd00f5
 8015410:	01050130 	.word	0x01050130
 8015414:	0111010d 	.word	0x0111010d
 8015418:	01150115 	.word	0x01150115
 801541c:	01150115 	.word	0x01150115
 8015420:	01150115 	.word	0x01150115
 8015424:	01150115 	.word	0x01150115
 8015428:	01190115 	.word	0x01190115
 801542c:	01210130 	.word	0x01210130
 8015430:	0130      	.short	0x0130
 8015432:	ed9f 0a9e 	vldr	s0, [pc, #632]	; 80156ac <ngc_named_param_get_by_id+0x2e0>
 8015436:	e101      	b.n	801563c <ngc_named_param_get_by_id+0x270>
        case NGCParam_vminor:
            value = 0.0f; // TODO: derive from version letter?
            break;

        case NGCParam_line:
            value = (float)gc_state.line_number;
 8015438:	4b9d      	ldr	r3, [pc, #628]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 801543a:	ed93 0a1b 	vldr	s0, [r3, #108]	; 0x6c
 801543e:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
            break;
 8015442:	e0fb      	b.n	801563c <ngc_named_param_get_by_id+0x270>

        case NGCParam_motion_mode:
            value = (float)(gc_state.modal.motion * 10); // TODO: Fix G38.x
 8015444:	4b9a      	ldr	r3, [pc, #616]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 8015446:	881b      	ldrh	r3, [r3, #0]
 8015448:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801544c:	005b      	lsls	r3, r3, #1
 801544e:	ee07 3a90 	vmov	s15, r3
 8015452:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
            break;
 8015456:	e0f1      	b.n	801563c <ngc_named_param_get_by_id+0x270>

        case NGCParam_plane:
            value = (float)(170 + gc_state.modal.plane_select * 10);
 8015458:	4b95      	ldr	r3, [pc, #596]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 801545a:	799b      	ldrb	r3, [r3, #6]
 801545c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8015460:	005b      	lsls	r3, r3, #1
 8015462:	33aa      	adds	r3, #170	; 0xaa
 8015464:	ee00 3a10 	vmov	s0, r3
 8015468:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
            break;
 801546c:	e0e6      	b.n	801563c <ngc_named_param_get_by_id+0x270>

        case NGCParam_ccomp:
            value = 400.0f;
 801546e:	ed9f 0a91 	vldr	s0, [pc, #580]	; 80156b4 <ngc_named_param_get_by_id+0x2e8>
            break;
 8015472:	e0e3      	b.n	801563c <ngc_named_param_get_by_id+0x270>

        case NGCParam_metric:
            value = gc_state.modal.units_imperial ? 0.0f : 1.0f;
 8015474:	4b8e      	ldr	r3, [pc, #568]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 8015476:	78db      	ldrb	r3, [r3, #3]
 8015478:	2b00      	cmp	r3, #0
 801547a:	f000 80e0 	beq.w	801563e <ngc_named_param_get_by_id+0x272>
 801547e:	ed9f 0a8e 	vldr	s0, [pc, #568]	; 80156b8 <ngc_named_param_get_by_id+0x2ec>
 8015482:	e0db      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            break;

        case NGCParam_imperial:
            value = gc_state.modal.units_imperial ? 1.0f : 0.0f;
 8015484:	4b8a      	ldr	r3, [pc, #552]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 8015486:	78db      	ldrb	r3, [r3, #3]
 8015488:	2b00      	cmp	r3, #0
 801548a:	f000 80db 	beq.w	8015644 <ngc_named_param_get_by_id+0x278>
 801548e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8015492:	e0d3      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            break;

        case NGCParam_absolute:
            value = gc_state.modal.distance_incremental ? 0.0f : 1.0f;
 8015494:	4b86      	ldr	r3, [pc, #536]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 8015496:	791b      	ldrb	r3, [r3, #4]
 8015498:	2b00      	cmp	r3, #0
 801549a:	f000 80d6 	beq.w	801564a <ngc_named_param_get_by_id+0x27e>
 801549e:	ed9f 0a86 	vldr	s0, [pc, #536]	; 80156b8 <ngc_named_param_get_by_id+0x2ec>
 80154a2:	e0cb      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            break;

        case NGCParam_incremental:
            value = gc_state.modal.distance_incremental ? 1.0f : 0.0f;
 80154a4:	4b82      	ldr	r3, [pc, #520]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 80154a6:	791b      	ldrb	r3, [r3, #4]
 80154a8:	2b00      	cmp	r3, #0
 80154aa:	f000 80d1 	beq.w	8015650 <ngc_named_param_get_by_id+0x284>
 80154ae:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80154b2:	e0c3      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            break;

        case NGCParam_inverse_time:
            value = gc_state.modal.feed_mode == FeedMode_InverseTime ? 1.0f : 0.0f;
 80154b4:	4b7e      	ldr	r3, [pc, #504]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 80154b6:	789b      	ldrb	r3, [r3, #2]
 80154b8:	2b01      	cmp	r3, #1
 80154ba:	d002      	beq.n	80154c2 <ngc_named_param_get_by_id+0xf6>
 80154bc:	ed9f 0a7e 	vldr	s0, [pc, #504]	; 80156b8 <ngc_named_param_get_by_id+0x2ec>
 80154c0:	e0bc      	b.n	801563c <ngc_named_param_get_by_id+0x270>
 80154c2:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80154c6:	e0b9      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            break;

        case NGCParam_units_per_minute:
            value = gc_state.modal.feed_mode == FeedMode_UnitsPerMin ? 1.0f : 0.0f;
 80154c8:	4b79      	ldr	r3, [pc, #484]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 80154ca:	789b      	ldrb	r3, [r3, #2]
 80154cc:	2b00      	cmp	r3, #0
 80154ce:	f040 80c2 	bne.w	8015656 <ngc_named_param_get_by_id+0x28a>
 80154d2:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80154d6:	e0b1      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            break;

        case NGCParam_units_per_rev:
            value = gc_state.modal.feed_mode == FeedMode_UnitsPerRev ? 1.0f : 0.0f;
 80154d8:	4b75      	ldr	r3, [pc, #468]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 80154da:	789b      	ldrb	r3, [r3, #2]
 80154dc:	2b02      	cmp	r3, #2
 80154de:	d002      	beq.n	80154e6 <ngc_named_param_get_by_id+0x11a>
 80154e0:	ed9f 0a75 	vldr	s0, [pc, #468]	; 80156b8 <ngc_named_param_get_by_id+0x2ec>
 80154e4:	e0aa      	b.n	801563c <ngc_named_param_get_by_id+0x270>
 80154e6:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80154ea:	e0a7      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            break;

        case NGCParam_coord_system:
            {
                uint_fast16_t id = gc_state.modal.coord_system.id * 10;
 80154ec:	4b70      	ldr	r3, [pc, #448]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 80154ee:	7d19      	ldrb	r1, [r3, #20]
 80154f0:	eb01 0281 	add.w	r2, r1, r1, lsl #2
 80154f4:	0052      	lsls	r2, r2, #1
 80154f6:	4613      	mov	r3, r2

                if(id > (CoordinateSystem_G59 * 10))
 80154f8:	2a32      	cmp	r2, #50	; 0x32
 80154fa:	d901      	bls.n	8015500 <ngc_named_param_get_by_id+0x134>
                    id = (CoordinateSystem_G59 * 10) + gc_state.modal.coord_system.id - CoordinateSystem_G59;
 80154fc:	f101 032d 	add.w	r3, r1, #45	; 0x2d

                value = (float)(540 + id);
 8015500:	f503 7307 	add.w	r3, r3, #540	; 0x21c
 8015504:	ee00 3a10 	vmov	s0, r3
 8015508:	eeb8 0a40 	vcvt.f32.u32	s0, s0
            }
            break;
 801550c:	e096      	b.n	801563c <ngc_named_param_get_by_id+0x270>

        case NGCParam_tool_offset:
            value = gc_state.modal.tool_offset_mode >= ToolLengthOffset_Enable ? 1.0f : 0.0f;
 801550e:	4b68      	ldr	r3, [pc, #416]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 8015510:	79db      	ldrb	r3, [r3, #7]
 8015512:	2b00      	cmp	r3, #0
 8015514:	f000 80a2 	beq.w	801565c <ngc_named_param_get_by_id+0x290>
 8015518:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 801551c:	e08e      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            break;

        case NGCParam_retract_r_plane:
            value = gc_state.modal.retract_mode == CCRetractMode_Previous ? 1.0f : 0.0f;
 801551e:	4b64      	ldr	r3, [pc, #400]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 8015520:	7f5b      	ldrb	r3, [r3, #29]
 8015522:	2b00      	cmp	r3, #0
 8015524:	f040 809d 	bne.w	8015662 <ngc_named_param_get_by_id+0x296>
 8015528:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 801552c:	e086      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            break;

        case NGCParam_retract_old_z:
            value = gc_state.modal.retract_mode == CCRetractMode_RPos ? 1.0f : 0.0f;
 801552e:	4b60      	ldr	r3, [pc, #384]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 8015530:	7f5b      	ldrb	r3, [r3, #29]
 8015532:	2b01      	cmp	r3, #1
 8015534:	d002      	beq.n	801553c <ngc_named_param_get_by_id+0x170>
 8015536:	ed9f 0a60 	vldr	s0, [pc, #384]	; 80156b8 <ngc_named_param_get_by_id+0x2ec>
 801553a:	e07f      	b.n	801563c <ngc_named_param_get_by_id+0x270>
 801553c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8015540:	e07c      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            break;

        case NGCParam_spindle_rpm_mode:
            value = gc_state.modal.spindle.rpm_mode == SpindleSpeedMode_RPM ? 1.0f : 0.0f;
 8015542:	4b5b      	ldr	r3, [pc, #364]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 8015544:	7edb      	ldrb	r3, [r3, #27]
 8015546:	2b00      	cmp	r3, #0
 8015548:	f040 808e 	bne.w	8015668 <ngc_named_param_get_by_id+0x29c>
 801554c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8015550:	e074      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            break;

        case NGCParam_spindle_css_mode:
            value = gc_state.modal.spindle.rpm_mode == SpindleSpeedMode_CSS ? 1.0f : 0.0f;
 8015552:	4b57      	ldr	r3, [pc, #348]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 8015554:	7edb      	ldrb	r3, [r3, #27]
 8015556:	2b01      	cmp	r3, #1
 8015558:	d002      	beq.n	8015560 <ngc_named_param_get_by_id+0x194>
 801555a:	ed9f 0a57 	vldr	s0, [pc, #348]	; 80156b8 <ngc_named_param_get_by_id+0x2ec>
 801555e:	e06d      	b.n	801563c <ngc_named_param_get_by_id+0x270>
 8015560:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8015564:	e06a      	b.n	801563c <ngc_named_param_get_by_id+0x270>
        case NGCParam_ijk_absolute_mode:
            value = 0.0f;
            break;

        case NGCParam_lathe_diameter_mode:
            value = gc_state.modal.diameter_mode ? 1.0f : 0.0f;
 8015566:	4b52      	ldr	r3, [pc, #328]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 8015568:	795b      	ldrb	r3, [r3, #5]
 801556a:	2b00      	cmp	r3, #0
 801556c:	d07f      	beq.n	801566e <ngc_named_param_get_by_id+0x2a2>
 801556e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8015572:	e063      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            break;

        case NGCParam_lathe_radius_mode:
            value = gc_state.modal.diameter_mode ? 0.0f : 1.0f;
 8015574:	4b4e      	ldr	r3, [pc, #312]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 8015576:	795b      	ldrb	r3, [r3, #5]
 8015578:	2b00      	cmp	r3, #0
 801557a:	d07b      	beq.n	8015674 <ngc_named_param_get_by_id+0x2a8>
 801557c:	ed9f 0a4e 	vldr	s0, [pc, #312]	; 80156b8 <ngc_named_param_get_by_id+0x2ec>
 8015580:	e05c      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            break;

        case NGCParam_spindle_on:
            value = gc_state.modal.spindle.state.on ? 1.0f : 0.0f;
 8015582:	4b4b      	ldr	r3, [pc, #300]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 8015584:	7e9b      	ldrb	r3, [r3, #26]
 8015586:	f013 0f01 	tst.w	r3, #1
 801558a:	d076      	beq.n	801567a <ngc_named_param_get_by_id+0x2ae>
 801558c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8015590:	e054      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            break;

        case NGCParam_spindle_cw:
            value = gc_state.modal.spindle.state.ccw ? 1.0f : 0.0f;
 8015592:	4b47      	ldr	r3, [pc, #284]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 8015594:	7e9b      	ldrb	r3, [r3, #26]
 8015596:	f013 0f02 	tst.w	r3, #2
 801559a:	d071      	beq.n	8015680 <ngc_named_param_get_by_id+0x2b4>
 801559c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80155a0:	e04c      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            break;

        case NGCParam_mist:
            value = gc_state.modal.coolant.mist ? 1.0f : 0.0f;
 80155a2:	4b43      	ldr	r3, [pc, #268]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 80155a4:	7e5b      	ldrb	r3, [r3, #25]
 80155a6:	f013 0f02 	tst.w	r3, #2
 80155aa:	d06c      	beq.n	8015686 <ngc_named_param_get_by_id+0x2ba>
 80155ac:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80155b0:	e044      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            break;

        case NGCParam_flood:
            value = gc_state.modal.coolant.flood ? 1.0f : 0.0f;
 80155b2:	4b3f      	ldr	r3, [pc, #252]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 80155b4:	7e5b      	ldrb	r3, [r3, #25]
 80155b6:	f013 0f01 	tst.w	r3, #1
 80155ba:	d067      	beq.n	801568c <ngc_named_param_get_by_id+0x2c0>
 80155bc:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80155c0:	e03c      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            break;

        case NGCParam_speed_override:
            value = gc_state.modal.override_ctrl.spindle_rpm_disable ? 0.0f : 1.0f;
 80155c2:	4b3b      	ldr	r3, [pc, #236]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 80155c4:	7f1b      	ldrb	r3, [r3, #28]
 80155c6:	f013 0f04 	tst.w	r3, #4
 80155ca:	d062      	beq.n	8015692 <ngc_named_param_get_by_id+0x2c6>
 80155cc:	ed9f 0a3a 	vldr	s0, [pc, #232]	; 80156b8 <ngc_named_param_get_by_id+0x2ec>
 80155d0:	e034      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            break;

        case NGCParam_feed_override:
            value = gc_state.modal.override_ctrl.feed_rate_disable ? 0.0f : 1.0f;
 80155d2:	4b37      	ldr	r3, [pc, #220]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 80155d4:	7f1b      	ldrb	r3, [r3, #28]
 80155d6:	f013 0f01 	tst.w	r3, #1
 80155da:	d05d      	beq.n	8015698 <ngc_named_param_get_by_id+0x2cc>
 80155dc:	ed9f 0a36 	vldr	s0, [pc, #216]	; 80156b8 <ngc_named_param_get_by_id+0x2ec>
 80155e0:	e02c      	b.n	801563c <ngc_named_param_get_by_id+0x270>
        case NGCParam_adaptive_feed:
            value = 0.0f;
            break;

        case NGCParam_feed_hold:
            value = gc_state.modal.override_ctrl.feed_hold_disable ? 0.0f : 1.0f;
 80155e2:	4b33      	ldr	r3, [pc, #204]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 80155e4:	7f1b      	ldrb	r3, [r3, #28]
 80155e6:	f013 0f02 	tst.w	r3, #2
 80155ea:	d058      	beq.n	801569e <ngc_named_param_get_by_id+0x2d2>
 80155ec:	ed9f 0a32 	vldr	s0, [pc, #200]	; 80156b8 <ngc_named_param_get_by_id+0x2ec>
 80155f0:	e024      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            break;

        case NGCParam_feed:
            value = gc_state.feed_rate;
 80155f2:	4b2f      	ldr	r3, [pc, #188]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 80155f4:	ed93 0a16 	vldr	s0, [r3, #88]	; 0x58
            break;
 80155f8:	e020      	b.n	801563c <ngc_named_param_get_by_id+0x270>

        case NGCParam_rpm:
            value = gc_state.spindle.rpm;
 80155fa:	4b2d      	ldr	r3, [pc, #180]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 80155fc:	ed93 0a12 	vldr	s0, [r3, #72]	; 0x48
            break;
 8015600:	e01c      	b.n	801563c <ngc_named_param_get_by_id+0x270>
        case NGCParam_u:
            //no break
        case NGCParam_v:
            //no break
        case NGCParam_w:
            value = _relative_pos(id - NGCParam_x);
 8015602:	3820      	subs	r0, #32
 8015604:	f7ff fd62 	bl	80150cc <_relative_pos>
            break;
 8015608:	e018      	b.n	801563c <ngc_named_param_get_by_id+0x270>

        case NGCParam_current_tool:
            value = (float)gc_state.tool->tool_id;
 801560a:	4b29      	ldr	r3, [pc, #164]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 801560c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8015610:	ed93 0a04 	vldr	s0, [r3, #16]
 8015614:	eeb8 0a40 	vcvt.f32.u32	s0, s0
            break;
 8015618:	e010      	b.n	801563c <ngc_named_param_get_by_id+0x270>
        case NGCParam_current_pocket:
            value = 0.0f;
            break;

        case NGCParam_selected_tool:
            value = gc_state.tool_pending != gc_state.tool->tool_id ? (float)gc_state.tool_pending : -1.0f;
 801561a:	4a25      	ldr	r2, [pc, #148]	; (80156b0 <ngc_named_param_get_by_id+0x2e4>)
 801561c:	6f13      	ldr	r3, [r2, #112]	; 0x70
 801561e:	f8d2 2094 	ldr.w	r2, [r2, #148]	; 0x94
 8015622:	6912      	ldr	r2, [r2, #16]
 8015624:	4293      	cmp	r3, r2
 8015626:	d03d      	beq.n	80156a4 <ngc_named_param_get_by_id+0x2d8>
 8015628:	ee07 3a90 	vmov	s15, r3
 801562c:	eeb8 0a67 	vcvt.f32.u32	s0, s15
 8015630:	e004      	b.n	801563c <ngc_named_param_get_by_id+0x270>
        case NGCParam_selected_pocket:
            value = 0.0f;
            break;

        default:
            value = NAN;
 8015632:	ed9f 0a22 	vldr	s0, [pc, #136]	; 80156bc <ngc_named_param_get_by_id+0x2f0>
 8015636:	e001      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            value = 0.0f; // TODO: derive from version letter?
 8015638:	ed9f 0a1f 	vldr	s0, [pc, #124]	; 80156b8 <ngc_named_param_get_by_id+0x2ec>
    }

    return value;
}
 801563c:	bd08      	pop	{r3, pc}
            value = gc_state.modal.units_imperial ? 0.0f : 1.0f;
 801563e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8015642:	e7fb      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            value = gc_state.modal.units_imperial ? 1.0f : 0.0f;
 8015644:	ed9f 0a1c 	vldr	s0, [pc, #112]	; 80156b8 <ngc_named_param_get_by_id+0x2ec>
 8015648:	e7f8      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            value = gc_state.modal.distance_incremental ? 0.0f : 1.0f;
 801564a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 801564e:	e7f5      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            value = gc_state.modal.distance_incremental ? 1.0f : 0.0f;
 8015650:	ed9f 0a19 	vldr	s0, [pc, #100]	; 80156b8 <ngc_named_param_get_by_id+0x2ec>
 8015654:	e7f2      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            value = gc_state.modal.feed_mode == FeedMode_UnitsPerMin ? 1.0f : 0.0f;
 8015656:	ed9f 0a18 	vldr	s0, [pc, #96]	; 80156b8 <ngc_named_param_get_by_id+0x2ec>
 801565a:	e7ef      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            value = gc_state.modal.tool_offset_mode >= ToolLengthOffset_Enable ? 1.0f : 0.0f;
 801565c:	ed9f 0a16 	vldr	s0, [pc, #88]	; 80156b8 <ngc_named_param_get_by_id+0x2ec>
 8015660:	e7ec      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            value = gc_state.modal.retract_mode == CCRetractMode_Previous ? 1.0f : 0.0f;
 8015662:	ed9f 0a15 	vldr	s0, [pc, #84]	; 80156b8 <ngc_named_param_get_by_id+0x2ec>
 8015666:	e7e9      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            value = gc_state.modal.spindle.rpm_mode == SpindleSpeedMode_RPM ? 1.0f : 0.0f;
 8015668:	ed9f 0a13 	vldr	s0, [pc, #76]	; 80156b8 <ngc_named_param_get_by_id+0x2ec>
 801566c:	e7e6      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            value = gc_state.modal.diameter_mode ? 1.0f : 0.0f;
 801566e:	ed9f 0a12 	vldr	s0, [pc, #72]	; 80156b8 <ngc_named_param_get_by_id+0x2ec>
 8015672:	e7e3      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            value = gc_state.modal.diameter_mode ? 0.0f : 1.0f;
 8015674:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8015678:	e7e0      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            value = gc_state.modal.spindle.state.on ? 1.0f : 0.0f;
 801567a:	ed9f 0a0f 	vldr	s0, [pc, #60]	; 80156b8 <ngc_named_param_get_by_id+0x2ec>
 801567e:	e7dd      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            value = gc_state.modal.spindle.state.ccw ? 1.0f : 0.0f;
 8015680:	ed9f 0a0d 	vldr	s0, [pc, #52]	; 80156b8 <ngc_named_param_get_by_id+0x2ec>
 8015684:	e7da      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            value = gc_state.modal.coolant.mist ? 1.0f : 0.0f;
 8015686:	ed9f 0a0c 	vldr	s0, [pc, #48]	; 80156b8 <ngc_named_param_get_by_id+0x2ec>
 801568a:	e7d7      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            value = gc_state.modal.coolant.flood ? 1.0f : 0.0f;
 801568c:	ed9f 0a0a 	vldr	s0, [pc, #40]	; 80156b8 <ngc_named_param_get_by_id+0x2ec>
 8015690:	e7d4      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            value = gc_state.modal.override_ctrl.spindle_rpm_disable ? 0.0f : 1.0f;
 8015692:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8015696:	e7d1      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            value = gc_state.modal.override_ctrl.feed_rate_disable ? 0.0f : 1.0f;
 8015698:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 801569c:	e7ce      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            value = gc_state.modal.override_ctrl.feed_hold_disable ? 0.0f : 1.0f;
 801569e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80156a2:	e7cb      	b.n	801563c <ngc_named_param_get_by_id+0x270>
            value = gc_state.tool_pending != gc_state.tool->tool_id ? (float)gc_state.tool_pending : -1.0f;
 80156a4:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
    return value;
 80156a8:	e7c8      	b.n	801563c <ngc_named_param_get_by_id+0x270>
 80156aa:	bf00      	nop
 80156ac:	3f8ccccd 	.word	0x3f8ccccd
 80156b0:	20003344 	.word	0x20003344
 80156b4:	43c80000 	.word	0x43c80000
 80156b8:	00000000 	.word	0x00000000
 80156bc:	7fc00000 	.word	0x7fc00000

080156c0 <ngc_named_param_get>:

bool ngc_named_param_get (char *name, float *value)
{
 80156c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80156c4:	4605      	mov	r5, r0
 80156c6:	460e      	mov	r6, r1
    char c, *s = name;
 80156c8:	4603      	mov	r3, r0
    bool found = false;
    uint_fast8_t idx = sizeof(ngc_named_ro_param) / sizeof(ngc_named_ro_param_t);

    // Lowercase name
    while((c = *s))
 80156ca:	e001      	b.n	80156d0 <ngc_named_param_get+0x10>
        *s++ = LCAPS(c);
 80156cc:	f803 2b01 	strb.w	r2, [r3], #1
    while((c = *s))
 80156d0:	781a      	ldrb	r2, [r3, #0]
 80156d2:	b14a      	cbz	r2, 80156e8 <ngc_named_param_get+0x28>
        *s++ = LCAPS(c);
 80156d4:	f1a2 0c41 	sub.w	ip, r2, #65	; 0x41
 80156d8:	fa5f fc8c 	uxtb.w	ip, ip
 80156dc:	f1bc 0f19 	cmp.w	ip, #25
 80156e0:	d8f4      	bhi.n	80156cc <ngc_named_param_get+0xc>
 80156e2:	f042 0220 	orr.w	r2, r2, #32
 80156e6:	e7f1      	b.n	80156cc <ngc_named_param_get+0xc>

    *value = 0.0f;
 80156e8:	2300      	movs	r3, #0
 80156ea:	6033      	str	r3, [r6, #0]

     if(*name == '_') do {
 80156ec:	782b      	ldrb	r3, [r5, #0]
 80156ee:	2b5f      	cmp	r3, #95	; 0x5f
 80156f0:	d004      	beq.n	80156fc <ngc_named_param_get+0x3c>
    bool found = false;
 80156f2:	f04f 0800 	mov.w	r8, #0
        if((found = !strcmp(name, ngc_named_ro_param[idx].name)))
            *value = ngc_named_param_get_by_id(ngc_named_ro_param[idx].id);
    } while(idx && !found);

    if(!found) {
        ngc_named_rw_param_t *rw_param = rw_global_params;
 80156f6:	4b1e      	ldr	r3, [pc, #120]	; (8015770 <ngc_named_param_get+0xb0>)
 80156f8:	681c      	ldr	r4, [r3, #0]
        while(rw_param && !found) {
 80156fa:	e025      	b.n	8015748 <ngc_named_param_get+0x88>
    uint_fast8_t idx = sizeof(ngc_named_ro_param) / sizeof(ngc_named_ro_param_t);
 80156fc:	242d      	movs	r4, #45	; 0x2d
 80156fe:	e001      	b.n	8015704 <ngc_named_param_get+0x44>
    } while(idx && !found);
 8015700:	b1dc      	cbz	r4, 801573a <ngc_named_param_get+0x7a>
 8015702:	b1d7      	cbz	r7, 801573a <ngc_named_param_get+0x7a>
        idx--;
 8015704:	3c01      	subs	r4, #1
        if((found = !strcmp(name, ngc_named_ro_param[idx].name)))
 8015706:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 801570a:	4b1a      	ldr	r3, [pc, #104]	; (8015774 <ngc_named_param_get+0xb4>)
 801570c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8015710:	4628      	mov	r0, r5
 8015712:	f7f2 fc95 	bl	8008040 <strcmp>
 8015716:	1e07      	subs	r7, r0, #0
 8015718:	bf0c      	ite	eq
 801571a:	f04f 0801 	moveq.w	r8, #1
 801571e:	f04f 0800 	movne.w	r8, #0
 8015722:	d1ed      	bne.n	8015700 <ngc_named_param_get+0x40>
            *value = ngc_named_param_get_by_id(ngc_named_ro_param[idx].id);
 8015724:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 8015728:	4b12      	ldr	r3, [pc, #72]	; (8015774 <ngc_named_param_get+0xb4>)
 801572a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 801572e:	7918      	ldrb	r0, [r3, #4]
 8015730:	f7ff fe4c 	bl	80153cc <ngc_named_param_get_by_id>
 8015734:	ed86 0a00 	vstr	s0, [r6]
 8015738:	e7e2      	b.n	8015700 <ngc_named_param_get+0x40>
    if(!found) {
 801573a:	f1b8 0f00 	cmp.w	r8, #0
 801573e:	d0da      	beq.n	80156f6 <ngc_named_param_get+0x36>
                rw_param = rw_param->next;
        }
    }

    return found;
}
 8015740:	4640      	mov	r0, r8
 8015742:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                rw_param = rw_param->next;
 8015746:	69e4      	ldr	r4, [r4, #28]
        while(rw_param && !found) {
 8015748:	2c00      	cmp	r4, #0
 801574a:	d0f9      	beq.n	8015740 <ngc_named_param_get+0x80>
 801574c:	f1b8 0f00 	cmp.w	r8, #0
 8015750:	d1f6      	bne.n	8015740 <ngc_named_param_get+0x80>
            if((found = !strcmp(rw_param->name, name)))
 8015752:	4629      	mov	r1, r5
 8015754:	4620      	mov	r0, r4
 8015756:	f7f2 fc73 	bl	8008040 <strcmp>
 801575a:	2800      	cmp	r0, #0
 801575c:	bf0c      	ite	eq
 801575e:	f04f 0801 	moveq.w	r8, #1
 8015762:	f04f 0800 	movne.w	r8, #0
 8015766:	d1ee      	bne.n	8015746 <ngc_named_param_get+0x86>
                *value = rw_param->value;
 8015768:	69a3      	ldr	r3, [r4, #24]
 801576a:	6033      	str	r3, [r6, #0]
 801576c:	e7ec      	b.n	8015748 <ngc_named_param_get+0x88>
 801576e:	bf00      	nop
 8015770:	20003758 	.word	0x20003758
 8015774:	08026f08 	.word	0x08026f08

08015778 <uitoa>:
// Converts an uint32 variable to string.
char *uitoa (uint32_t n)
{
    char *bptr = buf + sizeof(buf);

    *--bptr = '\0';
 8015778:	4b0d      	ldr	r3, [pc, #52]	; (80157b0 <uitoa+0x38>)
 801577a:	2200      	movs	r2, #0
 801577c:	739a      	strb	r2, [r3, #14]

    if (n == 0)
 801577e:	4602      	mov	r2, r0
 8015780:	b9a0      	cbnz	r0, 80157ac <uitoa+0x34>
        *--bptr = '0';
 8015782:	4618      	mov	r0, r3
 8015784:	2330      	movs	r3, #48	; 0x30
 8015786:	f800 3f0d 	strb.w	r3, [r0, #13]!
 801578a:	4770      	bx	lr
    else while (n) {
        *--bptr = '0' + (n % 10);
 801578c:	4b09      	ldr	r3, [pc, #36]	; (80157b4 <uitoa+0x3c>)
 801578e:	fba3 1302 	umull	r1, r3, r3, r2
 8015792:	08db      	lsrs	r3, r3, #3
 8015794:	4619      	mov	r1, r3
 8015796:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801579a:	eba2 0343 	sub.w	r3, r2, r3, lsl #1
 801579e:	3330      	adds	r3, #48	; 0x30
 80157a0:	f800 3d01 	strb.w	r3, [r0, #-1]!
        n /= 10;
 80157a4:	460a      	mov	r2, r1
    else while (n) {
 80157a6:	2a00      	cmp	r2, #0
 80157a8:	d1f0      	bne.n	801578c <uitoa+0x14>
    }

    return bptr;
}
 80157aa:	4770      	bx	lr
    *--bptr = '\0';
 80157ac:	4802      	ldr	r0, [pc, #8]	; (80157b8 <uitoa+0x40>)
 80157ae:	e7fa      	b.n	80157a6 <uitoa+0x2e>
 80157b0:	20003760 	.word	0x20003760
 80157b4:	cccccccd 	.word	0xcccccccd
 80157b8:	2000376e 	.word	0x2000376e

080157bc <ftoa>:

// Convert float to string by immediately converting to integers.
// Number of decimal places, which are tracked by a counter, must be set by the user.
// The integers is then efficiently converted to a string.
char *ftoa (float n, uint8_t decimal_places)
{
 80157bc:	b410      	push	{r4}
    bool isNegative;
    char *bptr = buf + sizeof(buf);

    *--bptr = '\0';
 80157be:	4b38      	ldr	r3, [pc, #224]	; (80158a0 <ftoa+0xe4>)
 80157c0:	2200      	movs	r2, #0
 80157c2:	739a      	strb	r2, [r3, #14]

    if ((isNegative = n < 0.0f))
 80157c4:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 80157c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80157cc:	d413      	bmi.n	80157f6 <ftoa+0x3a>
 80157ce:	eeb0 7a40 	vmov.f32	s14, s0
        n = -n;

    n += froundvalues[decimal_places];
 80157d2:	4b34      	ldr	r3, [pc, #208]	; (80158a4 <ftoa+0xe8>)
 80157d4:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 80157d8:	edd3 7a00 	vldr	s15, [r3]
 80157dc:	ee77 7a87 	vadd.f32	s15, s15, s14

    uint32_t a = (uint32_t)n;
 80157e0:	eebc 7ae7 	vcvt.u32.f32	s14, s15
 80157e4:	ee17 1a10 	vmov	r1, s14

    if (decimal_places) {
 80157e8:	b390      	cbz	r0, 8015850 <ftoa+0x94>

        n -= (float)a;
 80157ea:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 80157ee:	ee77 7ac7 	vsub.f32	s15, s15, s14

        uint_fast8_t decimals = decimal_places;
 80157f2:	4603      	mov	r3, r0
        while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
 80157f4:	e007      	b.n	8015806 <ftoa+0x4a>
        n = -n;
 80157f6:	eeb1 7a40 	vneg.f32	s14, s0
 80157fa:	e7ea      	b.n	80157d2 <ftoa+0x16>
            n *= 100.0f;
 80157fc:	ed9f 7a2a 	vldr	s14, [pc, #168]	; 80158a8 <ftoa+0xec>
 8015800:	ee67 7a87 	vmul.f32	s15, s15, s14
            decimals -= 2;
 8015804:	3b02      	subs	r3, #2
        while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
 8015806:	2b01      	cmp	r3, #1
 8015808:	d8f8      	bhi.n	80157fc <ftoa+0x40>
        }

        if (decimals)
 801580a:	b11b      	cbz	r3, 8015814 <ftoa+0x58>
            n *= 10.0f;
 801580c:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 8015810:	ee67 7a87 	vmul.f32	s15, s15, s14

        uint32_t b = (uint32_t)n;
 8015814:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8015818:	ee17 2a90 	vmov	r2, s15
    *--bptr = '\0';
 801581c:	4c23      	ldr	r4, [pc, #140]	; (80158ac <ftoa+0xf0>)

        while(decimal_places--) {
 801581e:	e003      	b.n	8015828 <ftoa+0x6c>
            if(b) {
                *--bptr = (b % 10) + '0'; // Get digit
                b /= 10;
            } else
                *--bptr = '0';
 8015820:	2330      	movs	r3, #48	; 0x30
 8015822:	f804 3d01 	strb.w	r3, [r4, #-1]!
 8015826:	4660      	mov	r0, ip
        while(decimal_places--) {
 8015828:	1e43      	subs	r3, r0, #1
 801582a:	fa5f fc83 	uxtb.w	ip, r3
 801582e:	b180      	cbz	r0, 8015852 <ftoa+0x96>
            if(b) {
 8015830:	2a00      	cmp	r2, #0
 8015832:	d0f5      	beq.n	8015820 <ftoa+0x64>
                *--bptr = (b % 10) + '0'; // Get digit
 8015834:	4b1e      	ldr	r3, [pc, #120]	; (80158b0 <ftoa+0xf4>)
 8015836:	fba3 0302 	umull	r0, r3, r3, r2
 801583a:	08db      	lsrs	r3, r3, #3
 801583c:	4618      	mov	r0, r3
 801583e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8015842:	eba2 0343 	sub.w	r3, r2, r3, lsl #1
 8015846:	3330      	adds	r3, #48	; 0x30
 8015848:	f804 3d01 	strb.w	r3, [r4, #-1]!
                b /= 10;
 801584c:	4602      	mov	r2, r0
 801584e:	e7ea      	b.n	8015826 <ftoa+0x6a>
    *--bptr = '\0';
 8015850:	4c16      	ldr	r4, [pc, #88]	; (80158ac <ftoa+0xf0>)
        }
    }

    *--bptr = '.'; // Always add decimal point (TODO: is this really needed?)
 8015852:	1e60      	subs	r0, r4, #1
 8015854:	232e      	movs	r3, #46	; 0x2e
 8015856:	f804 3c01 	strb.w	r3, [r4, #-1]

    if(a == 0)
 801585a:	b9c1      	cbnz	r1, 801588e <ftoa+0xd2>
        *--bptr = '0';
 801585c:	1ea0      	subs	r0, r4, #2
 801585e:	2330      	movs	r3, #48	; 0x30
 8015860:	f804 3c02 	strb.w	r3, [r4, #-2]
    else while(a) {
        *--bptr = (a % 10) + '0'; // Get digit
        a /= 10;
    }

    if(isNegative)
 8015864:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8015868:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801586c:	d412      	bmi.n	8015894 <ftoa+0xd8>
        *--bptr = '-';

    return bptr;
}
 801586e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8015872:	4770      	bx	lr
        *--bptr = (a % 10) + '0'; // Get digit
 8015874:	4b0e      	ldr	r3, [pc, #56]	; (80158b0 <ftoa+0xf4>)
 8015876:	fba3 2301 	umull	r2, r3, r3, r1
 801587a:	08db      	lsrs	r3, r3, #3
 801587c:	461a      	mov	r2, r3
 801587e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8015882:	eba1 0343 	sub.w	r3, r1, r3, lsl #1
 8015886:	3330      	adds	r3, #48	; 0x30
 8015888:	f800 3d01 	strb.w	r3, [r0, #-1]!
        a /= 10;
 801588c:	4611      	mov	r1, r2
    else while(a) {
 801588e:	2900      	cmp	r1, #0
 8015890:	d1f0      	bne.n	8015874 <ftoa+0xb8>
 8015892:	e7e7      	b.n	8015864 <ftoa+0xa8>
        *--bptr = '-';
 8015894:	232d      	movs	r3, #45	; 0x2d
 8015896:	f800 3c01 	strb.w	r3, [r0, #-1]
 801589a:	3801      	subs	r0, #1
    return bptr;
 801589c:	e7e7      	b.n	801586e <ftoa+0xb2>
 801589e:	bf00      	nop
 80158a0:	20003760 	.word	0x20003760
 80158a4:	080271d8 	.word	0x080271d8
 80158a8:	42c80000 	.word	0x42c80000
 80158ac:	2000376e 	.word	0x2000376e
 80158b0:	cccccccd 	.word	0xcccccccd

080158b4 <read_uint>:

// Extracts an unsigned integer value from a string.
status_code_t read_uint (char *line, uint_fast8_t *char_counter, uint32_t *uint_ptr)
{
 80158b4:	b570      	push	{r4, r5, r6, lr}
    char *ptr = line + *char_counter;
 80158b6:	680b      	ldr	r3, [r1, #0]
 80158b8:	18c4      	adds	r4, r0, r3
    uint_fast8_t ndigit = 0, c;
    uint32_t intval = 0;
    bool isdecimal = false, ok = false;

    // Grab first character and increment pointer. No spaces assumed in line.
    c = *ptr++;
 80158ba:	5cc3      	ldrb	r3, [r0, r3]

    if (c == '-')
 80158bc:	2b2d      	cmp	r3, #45	; 0x2d
 80158be:	d039      	beq.n	8015934 <read_uint+0x80>
 80158c0:	f104 0c01 	add.w	ip, r4, #1
        return Status_NegativeValue;

    // Skip initial sign character
    if (c == '+')
 80158c4:	2b2b      	cmp	r3, #43	; 0x2b
 80158c6:	d004      	beq.n	80158d2 <read_uint+0x1e>

    // Extract number into fast integer. Track decimal in terms of exponent value.
    while(c) {
        c -= '0';
        if (c <= 9) {
            ok = true;
 80158c8:	2600      	movs	r6, #0
 80158ca:	4634      	mov	r4, r6
 80158cc:	4635      	mov	r5, r6
 80158ce:	46b6      	mov	lr, r6
 80158d0:	e00a      	b.n	80158e8 <read_uint+0x34>
        c = *ptr++;
 80158d2:	f104 0c02 	add.w	ip, r4, #2
 80158d6:	7863      	ldrb	r3, [r4, #1]
 80158d8:	e7f6      	b.n	80158c8 <read_uint+0x14>

            if ((ndigit <= 9 || c <= 4) && intval <= 429496729) {
                intval = (((intval << 2) + intval) << 1) + c; // intval * 10 + c
            } else if (!isdecimal)
                exp++;  // Drop overflow digits
        } else if (c == (uint_fast8_t)('.' - '0') && !isdecimal)
 80158da:	f113 0f02 	cmn.w	r3, #2
 80158de:	d120      	bne.n	8015922 <read_uint+0x6e>
 80158e0:	b9fc      	cbnz	r4, 8015922 <read_uint+0x6e>
            isdecimal = true;
 80158e2:	2401      	movs	r4, #1
         else
            break;

        c = *ptr++;
 80158e4:	f81c 3b01 	ldrb.w	r3, [ip], #1
    while(c) {
 80158e8:	b1db      	cbz	r3, 8015922 <read_uint+0x6e>
        c -= '0';
 80158ea:	3b30      	subs	r3, #48	; 0x30
        if (c <= 9) {
 80158ec:	2b09      	cmp	r3, #9
 80158ee:	d8f4      	bhi.n	80158da <read_uint+0x26>
            if(!isdecimal && (c != 0 || intval))
 80158f0:	b91c      	cbnz	r4, 80158fa <read_uint+0x46>
 80158f2:	b903      	cbnz	r3, 80158f6 <read_uint+0x42>
 80158f4:	b10d      	cbz	r5, 80158fa <read_uint+0x46>
                ndigit++;
 80158f6:	f10e 0e01 	add.w	lr, lr, #1
            if (isdecimal && c != 0)
 80158fa:	b104      	cbz	r4, 80158fe <read_uint+0x4a>
 80158fc:	b9e3      	cbnz	r3, 8015938 <read_uint+0x84>
            if ((ndigit <= 9 || c <= 4) && intval <= 429496729) {
 80158fe:	f1be 0f09 	cmp.w	lr, #9
 8015902:	d901      	bls.n	8015908 <read_uint+0x54>
 8015904:	2b04      	cmp	r3, #4
 8015906:	d808      	bhi.n	801591a <read_uint+0x66>
 8015908:	4e0d      	ldr	r6, [pc, #52]	; (8015940 <read_uint+0x8c>)
 801590a:	42b5      	cmp	r5, r6
 801590c:	d807      	bhi.n	801591e <read_uint+0x6a>
                intval = (((intval << 2) + intval) << 1) + c; // intval * 10 + c
 801590e:	eb05 0585 	add.w	r5, r5, r5, lsl #2
 8015912:	eb03 0545 	add.w	r5, r3, r5, lsl #1
            ok = true;
 8015916:	2601      	movs	r6, #1
                intval = (((intval << 2) + intval) << 1) + c; // intval * 10 + c
 8015918:	e7e4      	b.n	80158e4 <read_uint+0x30>
            ok = true;
 801591a:	2601      	movs	r6, #1
 801591c:	e7e2      	b.n	80158e4 <read_uint+0x30>
 801591e:	2601      	movs	r6, #1
 8015920:	e7e0      	b.n	80158e4 <read_uint+0x30>
    }

    // Return if no digits have been read.

    if (!ok)
 8015922:	b15e      	cbz	r6, 801593c <read_uint+0x88>
        return Status_BadNumberFormat;

    *uint_ptr = intval; // Assign value.
 8015924:	6015      	str	r5, [r2, #0]
    *char_counter = ptr - line - 1; // Set char_counter to next statement
 8015926:	ebac 0c00 	sub.w	ip, ip, r0
 801592a:	f10c 33ff 	add.w	r3, ip, #4294967295
 801592e:	600b      	str	r3, [r1, #0]

    return Status_OK;
 8015930:	2000      	movs	r0, #0
}
 8015932:	bd70      	pop	{r4, r5, r6, pc}
        return Status_NegativeValue;
 8015934:	2004      	movs	r0, #4
 8015936:	e7fc      	b.n	8015932 <read_uint+0x7e>
                return Status_GcodeCommandValueNotInteger;
 8015938:	2017      	movs	r0, #23
 801593a:	e7fa      	b.n	8015932 <read_uint+0x7e>
        return Status_BadNumberFormat;
 801593c:	2002      	movs	r0, #2
 801593e:	e7f8      	b.n	8015932 <read_uint+0x7e>
 8015940:	19999999 	.word	0x19999999

08015944 <read_float>:
// CNC applications, the typical decimal value is expected to be in the range of E0 to E-4.
// Scientific notation is officially not supported by g-code, and the 'E' character may
// be a g-code word on some CNC systems. So, 'E' notation will not be recognized.
// NOTE: Thanks to Radu-Eosif Mihailescu for identifying the issues with using strtod().
bool read_float (char *line, uint_fast8_t *char_counter, float *float_ptr)
{
 8015944:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8015948:	4607      	mov	r7, r0
    char *ptr = line + *char_counter;
 801594a:	6808      	ldr	r0, [r1, #0]
 801594c:	183b      	adds	r3, r7, r0
    uint_fast8_t ndigit = 0, c;
    uint32_t intval = 0;
    bool isnegative, isdecimal = false, ok = false;

    // Grab first character and increment pointer. No spaces assumed in line.
    c = *ptr++;
 801594e:	f817 8000 	ldrb.w	r8, [r7, r0]

    // Capture initial sign character
    if ((isnegative = (c == '-')) || c == '+')
 8015952:	f1b8 0f2d 	cmp.w	r8, #45	; 0x2d
 8015956:	d006      	beq.n	8015966 <read_float+0x22>
 8015958:	f103 0c01 	add.w	ip, r3, #1
 801595c:	f1b8 0f2b 	cmp.w	r8, #43	; 0x2b
 8015960:	d001      	beq.n	8015966 <read_float+0x22>
    c = *ptr++;
 8015962:	4643      	mov	r3, r8
 8015964:	e002      	b.n	801596c <read_float+0x28>
        c = *ptr++;
 8015966:	f103 0c02 	add.w	ip, r3, #2
 801596a:	785b      	ldrb	r3, [r3, #1]
    c = *ptr++;
 801596c:	2000      	movs	r0, #0
 801596e:	4605      	mov	r5, r0
 8015970:	4604      	mov	r4, r0
 8015972:	4606      	mov	r6, r0
 8015974:	4686      	mov	lr, r0
 8015976:	e00b      	b.n	8015990 <read_float+0x4c>
                ndigit++;
            if (ndigit <= MAX_INT_DIGITS) {
                if (isdecimal)
                    exp--;
                intval = (((intval << 2) + intval) << 1) + c; // intval * 10 + c
            } else if (!isdecimal)
 8015978:	b9e5      	cbnz	r5, 80159b4 <read_float+0x70>
                exp++;  // Drop overflow digits
 801597a:	f10e 0e01 	add.w	lr, lr, #1
            ok = true;
 801597e:	2001      	movs	r0, #1
 8015980:	e004      	b.n	801598c <read_float+0x48>
        } else if (c == (uint_fast8_t)('.' - '0') && !isdecimal)
 8015982:	f113 0f02 	cmn.w	r3, #2
 8015986:	d117      	bne.n	80159b8 <read_float+0x74>
 8015988:	b9b5      	cbnz	r5, 80159b8 <read_float+0x74>
            isdecimal = true;
 801598a:	2501      	movs	r5, #1
         else
            break;

        c = *ptr++;
 801598c:	f81c 3b01 	ldrb.w	r3, [ip], #1
    while(c) {
 8015990:	b193      	cbz	r3, 80159b8 <read_float+0x74>
        c -= '0';
 8015992:	3b30      	subs	r3, #48	; 0x30
        if (c <= 9) {
 8015994:	2b09      	cmp	r3, #9
 8015996:	d8f4      	bhi.n	8015982 <read_float+0x3e>
            if(c != 0 || intval)
 8015998:	b903      	cbnz	r3, 801599c <read_float+0x58>
 801599a:	b104      	cbz	r4, 801599e <read_float+0x5a>
                ndigit++;
 801599c:	3601      	adds	r6, #1
            if (ndigit <= MAX_INT_DIGITS) {
 801599e:	2e09      	cmp	r6, #9
 80159a0:	d8ea      	bhi.n	8015978 <read_float+0x34>
                if (isdecimal)
 80159a2:	b10d      	cbz	r5, 80159a8 <read_float+0x64>
                    exp--;
 80159a4:	f10e 3eff 	add.w	lr, lr, #4294967295
                intval = (((intval << 2) + intval) << 1) + c; // intval * 10 + c
 80159a8:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 80159ac:	eb03 0444 	add.w	r4, r3, r4, lsl #1
            ok = true;
 80159b0:	2001      	movs	r0, #1
 80159b2:	e7eb      	b.n	801598c <read_float+0x48>
 80159b4:	4628      	mov	r0, r5
 80159b6:	e7e9      	b.n	801598c <read_float+0x48>
    }

    // Return if no digits have been read.
    if (!ok)
 80159b8:	b190      	cbz	r0, 80159e0 <read_float+0x9c>
        return false;

    // Convert integer into floating point.
    float fval = (float)intval;
 80159ba:	ee07 4a90 	vmov	s15, r4
 80159be:	eef8 7a67 	vcvt.f32.u32	s15, s15

    // Apply decimal. Should perform no more than two floating point multiplications for the
    // expected range of E0 to E-4.
    if (fval != 0.0f) {
 80159c2:	eef5 7a40 	vcmp.f32	s15, #0.0
 80159c6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80159ca:	d10b      	bne.n	80159e4 <read_float+0xa0>
            fval *= 10.0f;
        } while (--exp > 0);
    }

    // Assign floating point value with correct sign.
    *float_ptr = isnegative ? - fval : fval;
 80159cc:	f1b8 0f2d 	cmp.w	r8, #45	; 0x2d
 80159d0:	d027      	beq.n	8015a22 <read_float+0xde>
 80159d2:	edc2 7a00 	vstr	s15, [r2]
    *char_counter = ptr - line - 1; // Set char_counter to next statement
 80159d6:	ebac 0c07 	sub.w	ip, ip, r7
 80159da:	f10c 33ff 	add.w	r3, ip, #4294967295
 80159de:	600b      	str	r3, [r1, #0]

    return true;
}
 80159e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        while (exp <= -2) {
 80159e4:	f1be 3fff 	cmp.w	lr, #4294967295
 80159e8:	da06      	bge.n	80159f8 <read_float+0xb4>
            fval *= 0.01f;
 80159ea:	ed9f 7a0f 	vldr	s14, [pc, #60]	; 8015a28 <read_float+0xe4>
 80159ee:	ee67 7a87 	vmul.f32	s15, s15, s14
            exp += 2;
 80159f2:	f10e 0e02 	add.w	lr, lr, #2
 80159f6:	e7f5      	b.n	80159e4 <read_float+0xa0>
        if (exp < 0)
 80159f8:	f1be 0f00 	cmp.w	lr, #0
 80159fc:	db0c      	blt.n	8015a18 <read_float+0xd4>
        else if (exp > 0) do {
 80159fe:	f1be 0f00 	cmp.w	lr, #0
 8015a02:	dde3      	ble.n	80159cc <read_float+0x88>
            fval *= 10.0f;
 8015a04:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 8015a08:	ee67 7a87 	vmul.f32	s15, s15, s14
        } while (--exp > 0);
 8015a0c:	f10e 3eff 	add.w	lr, lr, #4294967295
 8015a10:	f1be 0f00 	cmp.w	lr, #0
 8015a14:	dcf6      	bgt.n	8015a04 <read_float+0xc0>
 8015a16:	e7d9      	b.n	80159cc <read_float+0x88>
            fval *= 0.1f;
 8015a18:	ed9f 7a04 	vldr	s14, [pc, #16]	; 8015a2c <read_float+0xe8>
 8015a1c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8015a20:	e7d4      	b.n	80159cc <read_float+0x88>
    *float_ptr = isnegative ? - fval : fval;
 8015a22:	eef1 7a67 	vneg.f32	s15, s15
 8015a26:	e7d4      	b.n	80159d2 <read_float+0x8e>
 8015a28:	3c23d70a 	.word	0x3c23d70a
 8015a2c:	3dcccccd 	.word	0x3dcccccd

08015a30 <isintf>:

// Returns true if float value is a whole number (integer)
bool isintf (float value)
{
 8015a30:	b508      	push	{r3, lr}
 8015a32:	ed2d 8b02 	vpush	{d8}
 8015a36:	eeb0 8a40 	vmov.f32	s16, s0
    return value != NAN && fabsf(value - truncf(value)) < 0.001f;
 8015a3a:	f00e f983 	bl	8023d44 <truncf>
 8015a3e:	ee38 8a40 	vsub.f32	s16, s16, s0
 8015a42:	eeb0 8ac8 	vabs.f32	s16, s16
 8015a46:	eddf 7a06 	vldr	s15, [pc, #24]	; 8015a60 <isintf+0x30>
 8015a4a:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8015a4e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
}
 8015a52:	bf4c      	ite	mi
 8015a54:	2001      	movmi	r0, #1
 8015a56:	2000      	movpl	r0, #0
 8015a58:	ecbd 8b02 	vpop	{d8}
 8015a5c:	bd08      	pop	{r3, pc}
 8015a5e:	bf00      	nop
 8015a60:	3a83126f 	.word	0x3a83126f

08015a64 <delay_sec>:

// Non-blocking delay function used for general operation and suspend features.
void delay_sec (float seconds, delaymode_t mode)
{
 8015a64:	b538      	push	{r3, r4, r5, lr}
 8015a66:	4605      	mov	r5, r0
    uint_fast16_t i = (uint_fast16_t)ceilf((1000.0f / DWELL_TIME_STEP) * seconds) + 1;
 8015a68:	eef3 7a04 	vmov.f32	s15, #52	; 0x41a00000  20.0
 8015a6c:	ee20 0a27 	vmul.f32	s0, s0, s15
 8015a70:	f00e f8c0 	bl	8023bf4 <ceilf>
 8015a74:	eebc 0ac0 	vcvt.u32.f32	s0, s0
 8015a78:	ee10 4a10 	vmov	r4, s0
 8015a7c:	3401      	adds	r4, #1

    while (--i && !sys.abort) {
 8015a7e:	e009      	b.n	8015a94 <delay_sec+0x30>
        if (mode == DelayMode_Dwell) {
            protocol_execute_realtime();
        } else { // DelayMode_SysSuspend
          // Execute rt_system() only to avoid nesting suspend loops.
          protocol_exec_rt_system();
 8015a80:	f001 fad6 	bl	8017030 <protocol_exec_rt_system>
          if (state_door_reopened()) // Bail, if safety door reopens.
 8015a84:	f008 fd98 	bl	801e5b8 <state_door_reopened>
 8015a88:	b970      	cbnz	r0, 8015aa8 <delay_sec+0x44>
              return;
        }
        hal.delay_ms(DWELL_TIME_STEP, 0); // Delay DWELL_TIME_STEP increment
 8015a8a:	4b08      	ldr	r3, [pc, #32]	; (8015aac <delay_sec+0x48>)
 8015a8c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8015a8e:	2100      	movs	r1, #0
 8015a90:	2032      	movs	r0, #50	; 0x32
 8015a92:	4798      	blx	r3
    while (--i && !sys.abort) {
 8015a94:	3c01      	subs	r4, #1
 8015a96:	d007      	beq.n	8015aa8 <delay_sec+0x44>
 8015a98:	4b05      	ldr	r3, [pc, #20]	; (8015ab0 <delay_sec+0x4c>)
 8015a9a:	781b      	ldrb	r3, [r3, #0]
 8015a9c:	b923      	cbnz	r3, 8015aa8 <delay_sec+0x44>
        if (mode == DelayMode_Dwell) {
 8015a9e:	2d00      	cmp	r5, #0
 8015aa0:	d1ee      	bne.n	8015a80 <delay_sec+0x1c>
            protocol_execute_realtime();
 8015aa2:	f001 fdd3 	bl	801764c <protocol_execute_realtime>
 8015aa6:	e7f0      	b.n	8015a8a <delay_sec+0x26>
    }
}
 8015aa8:	bd38      	pop	{r3, r4, r5, pc}
 8015aaa:	bf00      	nop
 8015aac:	2000350c 	.word	0x2000350c
 8015ab0:	200036c4 	.word	0x200036c4

08015ab4 <convert_delta_vector_to_unit_vector>:


float convert_delta_vector_to_unit_vector (float *vector)
{
 8015ab4:	b510      	push	{r4, lr}
 8015ab6:	4604      	mov	r4, r0
    uint_fast8_t idx = N_AXIS;
    float magnitude = 0.0f, inv_magnitude;
 8015ab8:	ed9f 0a13 	vldr	s0, [pc, #76]	; 8015b08 <convert_delta_vector_to_unit_vector+0x54>
    uint_fast8_t idx = N_AXIS;
 8015abc:	2303      	movs	r3, #3
 8015abe:	e004      	b.n	8015aca <convert_delta_vector_to_unit_vector+0x16>

    do {
        if (vector[--idx] != 0.0f)
            magnitude += vector[idx] * vector[idx];
 8015ac0:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8015ac4:	ee30 0a27 	vadd.f32	s0, s0, s15
    } while(idx);
 8015ac8:	b153      	cbz	r3, 8015ae0 <convert_delta_vector_to_unit_vector+0x2c>
        if (vector[--idx] != 0.0f)
 8015aca:	3b01      	subs	r3, #1
 8015acc:	eb04 0283 	add.w	r2, r4, r3, lsl #2
 8015ad0:	edd2 7a00 	vldr	s15, [r2]
 8015ad4:	eef5 7a40 	vcmp.f32	s15, #0.0
 8015ad8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015adc:	d0f4      	beq.n	8015ac8 <convert_delta_vector_to_unit_vector+0x14>
 8015ade:	e7ef      	b.n	8015ac0 <convert_delta_vector_to_unit_vector+0xc>

    idx = N_AXIS;
    magnitude = sqrtf(magnitude);
 8015ae0:	f00d ff76 	bl	80239d0 <sqrtf>
    inv_magnitude = 1.0f / magnitude;
 8015ae4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8015ae8:	ee87 7a80 	vdiv.f32	s14, s15, s0
    idx = N_AXIS;
 8015aec:	2303      	movs	r3, #3

    do {
        vector[--idx] *= inv_magnitude;
 8015aee:	3b01      	subs	r3, #1
 8015af0:	eb04 0283 	add.w	r2, r4, r3, lsl #2
 8015af4:	edd2 7a00 	vldr	s15, [r2]
 8015af8:	ee67 7a87 	vmul.f32	s15, s15, s14
 8015afc:	edc2 7a00 	vstr	s15, [r2]
    } while(idx);
 8015b00:	2b00      	cmp	r3, #0
 8015b02:	d1f4      	bne.n	8015aee <convert_delta_vector_to_unit_vector+0x3a>

    return magnitude;
}
 8015b04:	bd10      	pop	{r4, pc}
 8015b06:	bf00      	nop
 8015b08:	00000000 	.word	0x00000000

08015b0c <get_datetime>:

// parse ISO8601 datetime: YYYY-MM-DDTHH:MM:SSZxxx
struct tm *get_datetime (const char *s)
{
 8015b0c:	b570      	push	{r4, r5, r6, lr}
 8015b0e:	4604      	mov	r4, r0
    PROGMEM static const uint8_t mdays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

    char *s1 = (char *)s, c;
    uint_fast16_t idx = 0, value = 0;

    memset(&dt, 0, sizeof(struct tm));
 8015b10:	4d49      	ldr	r5, [pc, #292]	; (8015c38 <get_datetime+0x12c>)
 8015b12:	2224      	movs	r2, #36	; 0x24
 8015b14:	2100      	movs	r1, #0
 8015b16:	4628      	mov	r0, r5
 8015b18:	f00d f82d 	bl	8022b76 <memset>
    dt.tm_year = dt.tm_mon = dt.tm_mday = dt.tm_hour = dt.tm_min = dt.tm_sec = -1;
 8015b1c:	f04f 33ff 	mov.w	r3, #4294967295
 8015b20:	602b      	str	r3, [r5, #0]
 8015b22:	606b      	str	r3, [r5, #4]
 8015b24:	60ab      	str	r3, [r5, #8]
 8015b26:	60eb      	str	r3, [r5, #12]
 8015b28:	612b      	str	r3, [r5, #16]
 8015b2a:	616b      	str	r3, [r5, #20]
    uint_fast16_t idx = 0, value = 0;
 8015b2c:	2200      	movs	r2, #0
 8015b2e:	4611      	mov	r1, r2
 8015b30:	e005      	b.n	8015b3e <get_datetime+0x32>

    do {
        c = *s1++;

        if(isdigit(c))
            value = (value * 10) + c - '0';
 8015b32:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8015b36:	eb03 0242 	add.w	r2, r3, r2, lsl #1
 8015b3a:	3a30      	subs	r2, #48	; 0x30
                    break;
            }
            idx++;
            value = 0;
        }
    } while(c);
 8015b3c:	b1c3      	cbz	r3, 8015b70 <get_datetime+0x64>
        c = *s1++;
 8015b3e:	7823      	ldrb	r3, [r4, #0]
 8015b40:	3401      	adds	r4, #1
        if(isdigit(c))
 8015b42:	483e      	ldr	r0, [pc, #248]	; (8015c3c <get_datetime+0x130>)
 8015b44:	5cc0      	ldrb	r0, [r0, r3]
 8015b46:	f010 0f04 	tst.w	r0, #4
 8015b4a:	d1f2      	bne.n	8015b32 <get_datetime+0x26>
        else if(!(c == '-' || c == ':' || c == 'T' || c == 'Z' || c == '\0'))
 8015b4c:	2b54      	cmp	r3, #84	; 0x54
 8015b4e:	d004      	beq.n	8015b5a <get_datetime+0x4e>
 8015b50:	d80a      	bhi.n	8015b68 <get_datetime+0x5c>
 8015b52:	2b2d      	cmp	r3, #45	; 0x2d
 8015b54:	d001      	beq.n	8015b5a <get_datetime+0x4e>
 8015b56:	2b3a      	cmp	r3, #58	; 0x3a
 8015b58:	d108      	bne.n	8015b6c <get_datetime+0x60>
            switch(idx) {
 8015b5a:	2905      	cmp	r1, #5
 8015b5c:	d81a      	bhi.n	8015b94 <get_datetime+0x88>
 8015b5e:	e8df f001 	tbb	[pc, r1]
 8015b62:	2917      	.short	0x2917
 8015b64:	5f585133 	.word	0x5f585133
 8015b68:	2b5a      	cmp	r3, #90	; 0x5a
 8015b6a:	d0f6      	beq.n	8015b5a <get_datetime+0x4e>
        else if(!(c == '-' || c == ':' || c == 'T' || c == 'Z' || c == '\0'))
 8015b6c:	2b00      	cmp	r3, #0
 8015b6e:	d0f4      	beq.n	8015b5a <get_datetime+0x4e>

    return (dt.tm_year | dt.tm_mon | dt.tm_mday | dt.tm_hour | dt.tm_min | dt.tm_sec) > 0 ? &dt : NULL;
 8015b70:	4a31      	ldr	r2, [pc, #196]	; (8015c38 <get_datetime+0x12c>)
 8015b72:	6953      	ldr	r3, [r2, #20]
 8015b74:	6911      	ldr	r1, [r2, #16]
 8015b76:	430b      	orrs	r3, r1
 8015b78:	68d1      	ldr	r1, [r2, #12]
 8015b7a:	430b      	orrs	r3, r1
 8015b7c:	6891      	ldr	r1, [r2, #8]
 8015b7e:	430b      	orrs	r3, r1
 8015b80:	6851      	ldr	r1, [r2, #4]
 8015b82:	430b      	orrs	r3, r1
 8015b84:	6812      	ldr	r2, [r2, #0]
 8015b86:	4313      	orrs	r3, r2
 8015b88:	2b00      	cmp	r3, #0
 8015b8a:	dd52      	ble.n	8015c32 <get_datetime+0x126>
 8015b8c:	482a      	ldr	r0, [pc, #168]	; (8015c38 <get_datetime+0x12c>)
}
 8015b8e:	bd70      	pop	{r4, r5, r6, pc}
                    if(c == '-' && value >= 1970 && value <= 2099)
 8015b90:	2b2d      	cmp	r3, #45	; 0x2d
 8015b92:	d002      	beq.n	8015b9a <get_datetime+0x8e>
            idx++;
 8015b94:	3101      	adds	r1, #1
            value = 0;
 8015b96:	2200      	movs	r2, #0
 8015b98:	e7d0      	b.n	8015b3c <get_datetime+0x30>
                    if(c == '-' && value >= 1970 && value <= 2099)
 8015b9a:	f240 70b1 	movw	r0, #1969	; 0x7b1
 8015b9e:	4282      	cmp	r2, r0
 8015ba0:	d9f8      	bls.n	8015b94 <get_datetime+0x88>
 8015ba2:	f640 0033 	movw	r0, #2099	; 0x833
 8015ba6:	4282      	cmp	r2, r0
 8015ba8:	d8f4      	bhi.n	8015b94 <get_datetime+0x88>
                        dt.tm_year = value - 1900;
 8015baa:	f2a2 726c 	subw	r2, r2, #1900	; 0x76c
 8015bae:	4822      	ldr	r0, [pc, #136]	; (8015c38 <get_datetime+0x12c>)
 8015bb0:	6142      	str	r2, [r0, #20]
 8015bb2:	e7ef      	b.n	8015b94 <get_datetime+0x88>
                    if(c == '-' && value >= 1 && value <= 12)
 8015bb4:	2b2d      	cmp	r3, #45	; 0x2d
 8015bb6:	d1ed      	bne.n	8015b94 <get_datetime+0x88>
 8015bb8:	2a00      	cmp	r2, #0
 8015bba:	d0eb      	beq.n	8015b94 <get_datetime+0x88>
 8015bbc:	2a0c      	cmp	r2, #12
 8015bbe:	d8e9      	bhi.n	8015b94 <get_datetime+0x88>
                        dt.tm_mon = value - 1;
 8015bc0:	3a01      	subs	r2, #1
 8015bc2:	481d      	ldr	r0, [pc, #116]	; (8015c38 <get_datetime+0x12c>)
 8015bc4:	6102      	str	r2, [r0, #16]
 8015bc6:	e7e5      	b.n	8015b94 <get_datetime+0x88>
                    if(c == 'T' && value >= 1 && value <= (mdays[dt.tm_mon >= 0 ? dt.tm_mon : 0] + (dt.tm_mon == 1 && dt.tm_year != 100 && (dt.tm_year % 4) == 0 ? 1 : 0)))
 8015bc8:	2b54      	cmp	r3, #84	; 0x54
 8015bca:	d1e3      	bne.n	8015b94 <get_datetime+0x88>
 8015bcc:	2a00      	cmp	r2, #0
 8015bce:	d0e1      	beq.n	8015b94 <get_datetime+0x88>
 8015bd0:	4819      	ldr	r0, [pc, #100]	; (8015c38 <get_datetime+0x12c>)
 8015bd2:	6900      	ldr	r0, [r0, #16]
 8015bd4:	ea20 75e0 	bic.w	r5, r0, r0, asr #31
 8015bd8:	4e19      	ldr	r6, [pc, #100]	; (8015c40 <get_datetime+0x134>)
 8015bda:	5d75      	ldrb	r5, [r6, r5]
 8015bdc:	2801      	cmp	r0, #1
 8015bde:	d006      	beq.n	8015bee <get_datetime+0xe2>
 8015be0:	2000      	movs	r0, #0
 8015be2:	4428      	add	r0, r5
 8015be4:	4290      	cmp	r0, r2
 8015be6:	d3d5      	bcc.n	8015b94 <get_datetime+0x88>
                        dt.tm_mday = value;
 8015be8:	4813      	ldr	r0, [pc, #76]	; (8015c38 <get_datetime+0x12c>)
 8015bea:	60c2      	str	r2, [r0, #12]
 8015bec:	e7d2      	b.n	8015b94 <get_datetime+0x88>
                    if(c == 'T' && value >= 1 && value <= (mdays[dt.tm_mon >= 0 ? dt.tm_mon : 0] + (dt.tm_mon == 1 && dt.tm_year != 100 && (dt.tm_year % 4) == 0 ? 1 : 0)))
 8015bee:	4e12      	ldr	r6, [pc, #72]	; (8015c38 <get_datetime+0x12c>)
 8015bf0:	6976      	ldr	r6, [r6, #20]
 8015bf2:	2e64      	cmp	r6, #100	; 0x64
 8015bf4:	d004      	beq.n	8015c00 <get_datetime+0xf4>
 8015bf6:	f016 0f03 	tst.w	r6, #3
 8015bfa:	d0f2      	beq.n	8015be2 <get_datetime+0xd6>
 8015bfc:	2000      	movs	r0, #0
 8015bfe:	e7f0      	b.n	8015be2 <get_datetime+0xd6>
 8015c00:	2000      	movs	r0, #0
 8015c02:	e7ee      	b.n	8015be2 <get_datetime+0xd6>
                    if(c == ':' && value <= 23)
 8015c04:	2b3a      	cmp	r3, #58	; 0x3a
 8015c06:	d1c5      	bne.n	8015b94 <get_datetime+0x88>
 8015c08:	2a17      	cmp	r2, #23
 8015c0a:	d8c3      	bhi.n	8015b94 <get_datetime+0x88>
                        dt.tm_hour = value;
 8015c0c:	480a      	ldr	r0, [pc, #40]	; (8015c38 <get_datetime+0x12c>)
 8015c0e:	6082      	str	r2, [r0, #8]
 8015c10:	e7c0      	b.n	8015b94 <get_datetime+0x88>
                    if(c == ':' && value <= 59)
 8015c12:	2b3a      	cmp	r3, #58	; 0x3a
 8015c14:	d1be      	bne.n	8015b94 <get_datetime+0x88>
 8015c16:	2a3b      	cmp	r2, #59	; 0x3b
 8015c18:	d8bc      	bhi.n	8015b94 <get_datetime+0x88>
                        dt.tm_min = value;
 8015c1a:	4807      	ldr	r0, [pc, #28]	; (8015c38 <get_datetime+0x12c>)
 8015c1c:	6042      	str	r2, [r0, #4]
 8015c1e:	e7b9      	b.n	8015b94 <get_datetime+0x88>
                    if((c == 'Z' || c == '\0') && value <= 59)
 8015c20:	2b5a      	cmp	r3, #90	; 0x5a
 8015c22:	d001      	beq.n	8015c28 <get_datetime+0x11c>
 8015c24:	2b00      	cmp	r3, #0
 8015c26:	d1b5      	bne.n	8015b94 <get_datetime+0x88>
 8015c28:	2a3b      	cmp	r2, #59	; 0x3b
 8015c2a:	d8b3      	bhi.n	8015b94 <get_datetime+0x88>
                        dt.tm_sec = value;
 8015c2c:	4802      	ldr	r0, [pc, #8]	; (8015c38 <get_datetime+0x12c>)
 8015c2e:	6002      	str	r2, [r0, #0]
 8015c30:	e7b0      	b.n	8015b94 <get_datetime+0x88>
    return (dt.tm_year | dt.tm_mon | dt.tm_mday | dt.tm_hour | dt.tm_min | dt.tm_sec) > 0 ? &dt : NULL;
 8015c32:	2000      	movs	r0, #0
 8015c34:	e7ab      	b.n	8015b8e <get_datetime+0x82>
 8015c36:	bf00      	nop
 8015c38:	20003770 	.word	0x20003770
 8015c3c:	0802d055 	.word	0x0802d055
 8015c40:	08027204 	.word	0x08027204

08015c44 <calc_checksum>:

// calculate checksum byte for data
uint8_t calc_checksum (uint8_t *data, uint32_t size) {
 8015c44:	4603      	mov	r3, r0

    uint8_t checksum = 0;
 8015c46:	2000      	movs	r0, #0

    while(size--) {
 8015c48:	e008      	b.n	8015c5c <calc_checksum+0x18>
        checksum = (checksum << 1) | (checksum >> 7);
 8015c4a:	09c2      	lsrs	r2, r0, #7
 8015c4c:	ea42 0240 	orr.w	r2, r2, r0, lsl #1
        checksum += *(data++);
 8015c50:	f813 1b01 	ldrb.w	r1, [r3], #1
 8015c54:	fa51 f282 	uxtab	r2, r1, r2
 8015c58:	b2d0      	uxtb	r0, r2
    while(size--) {
 8015c5a:	4661      	mov	r1, ip
 8015c5c:	f101 3cff 	add.w	ip, r1, #4294967295
 8015c60:	2900      	cmp	r1, #0
 8015c62:	d1f2      	bne.n	8015c4a <calc_checksum+0x6>
    }

    return checksum;
}
 8015c64:	4770      	bx	lr

08015c66 <dummy_handler>:
}

void dummy_handler (void)
{
    // NOOP
}
 8015c66:	4770      	bx	lr

08015c68 <ram_get_byte>:
    {0, 0, 0} // list termination - do not remove
};

inline static uint8_t ram_get_byte (uint32_t addr)
{
    return nvsbuffer[addr];
 8015c68:	4b01      	ldr	r3, [pc, #4]	; (8015c70 <ram_get_byte+0x8>)
 8015c6a:	681b      	ldr	r3, [r3, #0]
}
 8015c6c:	5c18      	ldrb	r0, [r3, r0]
 8015c6e:	4770      	bx	lr
 8015c70:	2000379c 	.word	0x2000379c

08015c74 <ram_put_byte>:

inline static void ram_put_byte (uint32_t addr, uint8_t new_value)
{
    if(addr == 0)
 8015c74:	4603      	mov	r3, r0
 8015c76:	b910      	cbnz	r0, 8015c7e <ram_put_byte+0xa>
        settings_dirty.version = true;
 8015c78:	4a0c      	ldr	r2, [pc, #48]	; (8015cac <ram_put_byte+0x38>)
 8015c7a:	2001      	movs	r0, #1
 8015c7c:	7050      	strb	r0, [r2, #1]
    dirty = dirty || nvsbuffer[addr] != new_value || addr == 0;
 8015c7e:	4a0c      	ldr	r2, [pc, #48]	; (8015cb0 <ram_put_byte+0x3c>)
 8015c80:	7812      	ldrb	r2, [r2, #0]
 8015c82:	b94a      	cbnz	r2, 8015c98 <ram_put_byte+0x24>
 8015c84:	4a0b      	ldr	r2, [pc, #44]	; (8015cb4 <ram_put_byte+0x40>)
 8015c86:	6812      	ldr	r2, [r2, #0]
 8015c88:	5cd2      	ldrb	r2, [r2, r3]
 8015c8a:	428a      	cmp	r2, r1
 8015c8c:	d001      	beq.n	8015c92 <ram_put_byte+0x1e>
 8015c8e:	2001      	movs	r0, #1
 8015c90:	e003      	b.n	8015c9a <ram_put_byte+0x26>
 8015c92:	b943      	cbnz	r3, 8015ca6 <ram_put_byte+0x32>
 8015c94:	2001      	movs	r0, #1
 8015c96:	e000      	b.n	8015c9a <ram_put_byte+0x26>
 8015c98:	2001      	movs	r0, #1
 8015c9a:	4a05      	ldr	r2, [pc, #20]	; (8015cb0 <ram_put_byte+0x3c>)
 8015c9c:	7010      	strb	r0, [r2, #0]
    nvsbuffer[addr] = new_value;
 8015c9e:	4a05      	ldr	r2, [pc, #20]	; (8015cb4 <ram_put_byte+0x40>)
 8015ca0:	6812      	ldr	r2, [r2, #0]
 8015ca2:	54d1      	strb	r1, [r2, r3]
}
 8015ca4:	4770      	bx	lr
    dirty = dirty || nvsbuffer[addr] != new_value || addr == 0;
 8015ca6:	2000      	movs	r0, #0
 8015ca8:	e7f7      	b.n	8015c9a <ram_put_byte+0x26>
 8015caa:	bf00      	nop
 8015cac:	200037cc 	.word	0x200037cc
 8015cb0:	20003794 	.word	0x20003794
 8015cb4:	2000379c 	.word	0x2000379c

08015cb8 <nvs_warning>:

    return with_checksum ? (checksum == ram_get_byte(source) ? NVS_TransferResult_OK : NVS_TransferResult_Failed) : NVS_TransferResult_OK;
}

static void nvs_warning (sys_state_t state)
{
 8015cb8:	b508      	push	{r3, lr}
    report_message("Not enough heap for NVS buffer!", Message_Warning);
 8015cba:	2102      	movs	r1, #2
 8015cbc:	4801      	ldr	r0, [pc, #4]	; (8015cc4 <nvs_warning+0xc>)
 8015cbe:	f003 fab3 	bl	8019228 <report_message>
}
 8015cc2:	bd08      	pop	{r3, pc}
 8015cc4:	08027210 	.word	0x08027210

08015cc8 <memcpy_from_ram>:
{
 8015cc8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8015ccc:	4604      	mov	r4, r0
 8015cce:	460d      	mov	r5, r1
 8015cd0:	4616      	mov	r6, r2
 8015cd2:	461f      	mov	r7, r3
    if(hal.nvs.driver_area.address && source > hal.nvs.driver_area.address + hal.nvs.driver_area.size)
 8015cd4:	4b19      	ldr	r3, [pc, #100]	; (8015d3c <memcpy_from_ram+0x74>)
 8015cd6:	f8b3 3154 	ldrh.w	r3, [r3, #340]	; 0x154
 8015cda:	b12b      	cbz	r3, 8015ce8 <memcpy_from_ram+0x20>
 8015cdc:	4a17      	ldr	r2, [pc, #92]	; (8015d3c <memcpy_from_ram+0x74>)
 8015cde:	f8b2 2156 	ldrh.w	r2, [r2, #342]	; 0x156
 8015ce2:	4413      	add	r3, r2
 8015ce4:	428b      	cmp	r3, r1
 8015ce6:	d302      	bcc.n	8015cee <memcpy_from_ram+0x26>
    uint8_t checksum = with_checksum ? calc_checksum(&nvsbuffer[source], size) : 0;
 8015ce8:	b947      	cbnz	r7, 8015cfc <memcpy_from_ram+0x34>
 8015cea:	2300      	movs	r3, #0
    for(; size > 0; size--)
 8015cec:	e017      	b.n	8015d1e <memcpy_from_ram+0x56>
        return physical_nvs.memcpy_from_nvs(destination, source, size, with_checksum);
 8015cee:	4b14      	ldr	r3, [pc, #80]	; (8015d40 <memcpy_from_ram+0x78>)
 8015cf0:	f8d3 8020 	ldr.w	r8, [r3, #32]
 8015cf4:	463b      	mov	r3, r7
 8015cf6:	4632      	mov	r2, r6
 8015cf8:	47c0      	blx	r8
 8015cfa:	e019      	b.n	8015d30 <memcpy_from_ram+0x68>
    uint8_t checksum = with_checksum ? calc_checksum(&nvsbuffer[source], size) : 0;
 8015cfc:	4b11      	ldr	r3, [pc, #68]	; (8015d44 <memcpy_from_ram+0x7c>)
 8015cfe:	6818      	ldr	r0, [r3, #0]
 8015d00:	4631      	mov	r1, r6
 8015d02:	4428      	add	r0, r5
 8015d04:	f7ff ff9e 	bl	8015c44 <calc_checksum>
 8015d08:	4603      	mov	r3, r0
 8015d0a:	e008      	b.n	8015d1e <memcpy_from_ram+0x56>
        *(destination++) = ram_get_byte(source++);
 8015d0c:	4620      	mov	r0, r4
    return nvsbuffer[addr];
 8015d0e:	4a0d      	ldr	r2, [pc, #52]	; (8015d44 <memcpy_from_ram+0x7c>)
 8015d10:	6812      	ldr	r2, [r2, #0]
 8015d12:	5d52      	ldrb	r2, [r2, r5]
        *(destination++) = ram_get_byte(source++);
 8015d14:	f800 2b01 	strb.w	r2, [r0], #1
    for(; size > 0; size--)
 8015d18:	3e01      	subs	r6, #1
        *(destination++) = ram_get_byte(source++);
 8015d1a:	3501      	adds	r5, #1
 8015d1c:	4604      	mov	r4, r0
    for(; size > 0; size--)
 8015d1e:	2e00      	cmp	r6, #0
 8015d20:	d1f4      	bne.n	8015d0c <memcpy_from_ram+0x44>
    return with_checksum ? (checksum == ram_get_byte(source) ? NVS_TransferResult_OK : NVS_TransferResult_Failed) : NVS_TransferResult_OK;
 8015d22:	b14f      	cbz	r7, 8015d38 <memcpy_from_ram+0x70>
    return nvsbuffer[addr];
 8015d24:	4a07      	ldr	r2, [pc, #28]	; (8015d44 <memcpy_from_ram+0x7c>)
 8015d26:	6812      	ldr	r2, [r2, #0]
 8015d28:	5d52      	ldrb	r2, [r2, r5]
    return with_checksum ? (checksum == ram_get_byte(source) ? NVS_TransferResult_OK : NVS_TransferResult_Failed) : NVS_TransferResult_OK;
 8015d2a:	4293      	cmp	r3, r2
 8015d2c:	d002      	beq.n	8015d34 <memcpy_from_ram+0x6c>
 8015d2e:	2000      	movs	r0, #0
}
 8015d30:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return with_checksum ? (checksum == ram_get_byte(source) ? NVS_TransferResult_OK : NVS_TransferResult_Failed) : NVS_TransferResult_OK;
 8015d34:	2002      	movs	r0, #2
 8015d36:	e7fb      	b.n	8015d30 <memcpy_from_ram+0x68>
 8015d38:	2002      	movs	r0, #2
 8015d3a:	e7f9      	b.n	8015d30 <memcpy_from_ram+0x68>
 8015d3c:	2000350c 	.word	0x2000350c
 8015d40:	200037a0 	.word	0x200037a0
 8015d44:	2000379c 	.word	0x2000379c

08015d48 <memcpy_to_ram>:
{
 8015d48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8015d4c:	4607      	mov	r7, r0
 8015d4e:	460c      	mov	r4, r1
 8015d50:	4616      	mov	r6, r2
 8015d52:	4698      	mov	r8, r3
    if(hal.nvs.driver_area.address && destination > hal.nvs.driver_area.address + hal.nvs.driver_area.size)
 8015d54:	4b63      	ldr	r3, [pc, #396]	; (8015ee4 <memcpy_to_ram+0x19c>)
 8015d56:	f8b3 3154 	ldrh.w	r3, [r3, #340]	; 0x154
 8015d5a:	b12b      	cbz	r3, 8015d68 <memcpy_to_ram+0x20>
 8015d5c:	4a61      	ldr	r2, [pc, #388]	; (8015ee4 <memcpy_to_ram+0x19c>)
 8015d5e:	f8b2 2156 	ldrh.w	r2, [r2, #342]	; 0x156
 8015d62:	4413      	add	r3, r2
 8015d64:	4283      	cmp	r3, r0
 8015d66:	d308      	bcc.n	8015d7a <memcpy_to_ram+0x32>
    uint8_t checksum = with_checksum ? calc_checksum(source, size) : 0;
 8015d68:	f1b8 0f00 	cmp.w	r8, #0
 8015d6c:	d10b      	bne.n	8015d86 <memcpy_to_ram+0x3e>
 8015d6e:	2000      	movs	r0, #0
    dirty = false;
 8015d70:	4b5d      	ldr	r3, [pc, #372]	; (8015ee8 <memcpy_to_ram+0x1a0>)
 8015d72:	2200      	movs	r2, #0
 8015d74:	701a      	strb	r2, [r3, #0]
    uint32_t dest = destination;
 8015d76:	463d      	mov	r5, r7
    for(; size > 0; size--)
 8015d78:	e016      	b.n	8015da8 <memcpy_to_ram+0x60>
        return physical_nvs.memcpy_to_nvs(destination, source, size, with_checksum);
 8015d7a:	4b5c      	ldr	r3, [pc, #368]	; (8015eec <memcpy_to_ram+0x1a4>)
 8015d7c:	69dd      	ldr	r5, [r3, #28]
 8015d7e:	4643      	mov	r3, r8
 8015d80:	4632      	mov	r2, r6
 8015d82:	47a8      	blx	r5
 8015d84:	e0a6      	b.n	8015ed4 <memcpy_to_ram+0x18c>
    uint8_t checksum = with_checksum ? calc_checksum(source, size) : 0;
 8015d86:	4631      	mov	r1, r6
 8015d88:	4620      	mov	r0, r4
 8015d8a:	f7ff ff5b 	bl	8015c44 <calc_checksum>
 8015d8e:	e7ef      	b.n	8015d70 <memcpy_to_ram+0x28>
    dirty = dirty || nvsbuffer[addr] != new_value || addr == 0;
 8015d90:	b9fd      	cbnz	r5, 8015dd2 <memcpy_to_ram+0x8a>
 8015d92:	2401      	movs	r4, #1
 8015d94:	e000      	b.n	8015d98 <memcpy_to_ram+0x50>
 8015d96:	2401      	movs	r4, #1
 8015d98:	4b53      	ldr	r3, [pc, #332]	; (8015ee8 <memcpy_to_ram+0x1a0>)
 8015d9a:	701c      	strb	r4, [r3, #0]
    nvsbuffer[addr] = new_value;
 8015d9c:	4b54      	ldr	r3, [pc, #336]	; (8015ef0 <memcpy_to_ram+0x1a8>)
 8015d9e:	681b      	ldr	r3, [r3, #0]
 8015da0:	555a      	strb	r2, [r3, r5]
    for(; size > 0; size--)
 8015da2:	3e01      	subs	r6, #1
        ram_put_byte(dest++, *(source++));
 8015da4:	4665      	mov	r5, ip
 8015da6:	460c      	mov	r4, r1
    for(; size > 0; size--)
 8015da8:	b1ae      	cbz	r6, 8015dd6 <memcpy_to_ram+0x8e>
        ram_put_byte(dest++, *(source++));
 8015daa:	f105 0c01 	add.w	ip, r5, #1
 8015dae:	4621      	mov	r1, r4
 8015db0:	f811 2b01 	ldrb.w	r2, [r1], #1
    if(addr == 0)
 8015db4:	b915      	cbnz	r5, 8015dbc <memcpy_to_ram+0x74>
        settings_dirty.version = true;
 8015db6:	4b4f      	ldr	r3, [pc, #316]	; (8015ef4 <memcpy_to_ram+0x1ac>)
 8015db8:	2401      	movs	r4, #1
 8015dba:	705c      	strb	r4, [r3, #1]
    dirty = dirty || nvsbuffer[addr] != new_value || addr == 0;
 8015dbc:	4b4a      	ldr	r3, [pc, #296]	; (8015ee8 <memcpy_to_ram+0x1a0>)
 8015dbe:	781b      	ldrb	r3, [r3, #0]
 8015dc0:	2b00      	cmp	r3, #0
 8015dc2:	d1e8      	bne.n	8015d96 <memcpy_to_ram+0x4e>
 8015dc4:	4b4a      	ldr	r3, [pc, #296]	; (8015ef0 <memcpy_to_ram+0x1a8>)
 8015dc6:	681b      	ldr	r3, [r3, #0]
 8015dc8:	5d5b      	ldrb	r3, [r3, r5]
 8015dca:	429a      	cmp	r2, r3
 8015dcc:	d0e0      	beq.n	8015d90 <memcpy_to_ram+0x48>
 8015dce:	2401      	movs	r4, #1
 8015dd0:	e7e2      	b.n	8015d98 <memcpy_to_ram+0x50>
 8015dd2:	2400      	movs	r4, #0
 8015dd4:	e7e0      	b.n	8015d98 <memcpy_to_ram+0x50>
    if(with_checksum)
 8015dd6:	f1b8 0f00 	cmp.w	r8, #0
 8015dda:	d11d      	bne.n	8015e18 <memcpy_to_ram+0xd0>
    if(settings_dirty.version || source == hal.nvs.driver_area.mem_address)
 8015ddc:	4b45      	ldr	r3, [pc, #276]	; (8015ef4 <memcpy_to_ram+0x1ac>)
 8015dde:	785b      	ldrb	r3, [r3, #1]
 8015de0:	b923      	cbnz	r3, 8015dec <memcpy_to_ram+0xa4>
 8015de2:	4b40      	ldr	r3, [pc, #256]	; (8015ee4 <memcpy_to_ram+0x19c>)
 8015de4:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 8015de8:	42a3      	cmp	r3, r4
 8015dea:	d102      	bne.n	8015df2 <memcpy_to_ram+0xaa>
        dirty = true;
 8015dec:	4b3e      	ldr	r3, [pc, #248]	; (8015ee8 <memcpy_to_ram+0x1a0>)
 8015dee:	2201      	movs	r2, #1
 8015df0:	701a      	strb	r2, [r3, #0]
    if(dirty && physical_nvs.type != NVS_None) {
 8015df2:	4b3d      	ldr	r3, [pc, #244]	; (8015ee8 <memcpy_to_ram+0x1a0>)
 8015df4:	781b      	ldrb	r3, [r3, #0]
 8015df6:	2b00      	cmp	r3, #0
 8015df8:	d06b      	beq.n	8015ed2 <memcpy_to_ram+0x18a>
 8015dfa:	4b3c      	ldr	r3, [pc, #240]	; (8015eec <memcpy_to_ram+0x1a4>)
 8015dfc:	781b      	ldrb	r3, [r3, #0]
 8015dfe:	2b00      	cmp	r3, #0
 8015e00:	d06a      	beq.n	8015ed8 <memcpy_to_ram+0x190>
        settings_dirty.is_dirty = true;
 8015e02:	4b3c      	ldr	r3, [pc, #240]	; (8015ef4 <memcpy_to_ram+0x1ac>)
 8015e04:	2201      	movs	r2, #1
 8015e06:	701a      	strb	r2, [r3, #0]
        if(hal.nvs.driver_area.address && destination >= hal.nvs.driver_area.address)
 8015e08:	4b36      	ldr	r3, [pc, #216]	; (8015ee4 <memcpy_to_ram+0x19c>)
 8015e0a:	f8b3 3154 	ldrh.w	r3, [r3, #340]	; 0x154
 8015e0e:	b30b      	cbz	r3, 8015e54 <memcpy_to_ram+0x10c>
 8015e10:	42bb      	cmp	r3, r7
 8015e12:	d91b      	bls.n	8015e4c <memcpy_to_ram+0x104>
 8015e14:	2300      	movs	r3, #0
 8015e16:	e01e      	b.n	8015e56 <memcpy_to_ram+0x10e>
    if(addr == 0)
 8015e18:	b915      	cbnz	r5, 8015e20 <memcpy_to_ram+0xd8>
        settings_dirty.version = true;
 8015e1a:	4b36      	ldr	r3, [pc, #216]	; (8015ef4 <memcpy_to_ram+0x1ac>)
 8015e1c:	2201      	movs	r2, #1
 8015e1e:	705a      	strb	r2, [r3, #1]
    dirty = dirty || nvsbuffer[addr] != new_value || addr == 0;
 8015e20:	4b31      	ldr	r3, [pc, #196]	; (8015ee8 <memcpy_to_ram+0x1a0>)
 8015e22:	781b      	ldrb	r3, [r3, #0]
 8015e24:	b94b      	cbnz	r3, 8015e3a <memcpy_to_ram+0xf2>
 8015e26:	4b32      	ldr	r3, [pc, #200]	; (8015ef0 <memcpy_to_ram+0x1a8>)
 8015e28:	681b      	ldr	r3, [r3, #0]
 8015e2a:	5d5b      	ldrb	r3, [r3, r5]
 8015e2c:	4298      	cmp	r0, r3
 8015e2e:	d001      	beq.n	8015e34 <memcpy_to_ram+0xec>
 8015e30:	2201      	movs	r2, #1
 8015e32:	e003      	b.n	8015e3c <memcpy_to_ram+0xf4>
 8015e34:	b945      	cbnz	r5, 8015e48 <memcpy_to_ram+0x100>
 8015e36:	2201      	movs	r2, #1
 8015e38:	e000      	b.n	8015e3c <memcpy_to_ram+0xf4>
 8015e3a:	2201      	movs	r2, #1
 8015e3c:	4b2a      	ldr	r3, [pc, #168]	; (8015ee8 <memcpy_to_ram+0x1a0>)
 8015e3e:	701a      	strb	r2, [r3, #0]
    nvsbuffer[addr] = new_value;
 8015e40:	4b2b      	ldr	r3, [pc, #172]	; (8015ef0 <memcpy_to_ram+0x1a8>)
 8015e42:	681b      	ldr	r3, [r3, #0]
 8015e44:	5558      	strb	r0, [r3, r5]
}
 8015e46:	e7c9      	b.n	8015ddc <memcpy_to_ram+0x94>
    dirty = dirty || nvsbuffer[addr] != new_value || addr == 0;
 8015e48:	2200      	movs	r2, #0
 8015e4a:	e7f7      	b.n	8015e3c <memcpy_to_ram+0xf4>
            settings_dirty.driver_settings = true;
 8015e4c:	4b29      	ldr	r3, [pc, #164]	; (8015ef4 <memcpy_to_ram+0x1ac>)
 8015e4e:	711a      	strb	r2, [r3, #4]
    return NVS_TransferResult_OK;
 8015e50:	2002      	movs	r0, #2
            settings_dirty.driver_settings = true;
 8015e52:	e03f      	b.n	8015ed4 <memcpy_to_ram+0x18c>
 8015e54:	2300      	movs	r3, #0
                if(target[idx].addr == destination)
 8015e56:	4a28      	ldr	r2, [pc, #160]	; (8015ef8 <memcpy_to_ram+0x1b0>)
 8015e58:	f832 2023 	ldrh.w	r2, [r2, r3, lsl #2]
 8015e5c:	42ba      	cmp	r2, r7
 8015e5e:	d006      	beq.n	8015e6e <memcpy_to_ram+0x126>
            } while(target[++idx].addr);
 8015e60:	3301      	adds	r3, #1
 8015e62:	b2db      	uxtb	r3, r3
 8015e64:	4a24      	ldr	r2, [pc, #144]	; (8015ef8 <memcpy_to_ram+0x1b0>)
 8015e66:	f832 2023 	ldrh.w	r2, [r2, r3, lsl #2]
 8015e6a:	2a00      	cmp	r2, #0
 8015e6c:	d1f3      	bne.n	8015e56 <memcpy_to_ram+0x10e>
            if(target[idx].addr) switch(target[idx].type) {
 8015e6e:	4619      	mov	r1, r3
 8015e70:	4a21      	ldr	r2, [pc, #132]	; (8015ef8 <memcpy_to_ram+0x1b0>)
 8015e72:	f832 2023 	ldrh.w	r2, [r2, r3, lsl #2]
 8015e76:	2a00      	cmp	r2, #0
 8015e78:	d030      	beq.n	8015edc <memcpy_to_ram+0x194>
 8015e7a:	4a1f      	ldr	r2, [pc, #124]	; (8015ef8 <memcpy_to_ram+0x1b0>)
 8015e7c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8015e80:	7898      	ldrb	r0, [r3, #2]
 8015e82:	2804      	cmp	r0, #4
 8015e84:	d82c      	bhi.n	8015ee0 <memcpy_to_ram+0x198>
 8015e86:	e8df f000 	tbb	[pc, r0]
 8015e8a:	2b03      	.short	0x2b03
 8015e8c:	1308      	.short	0x1308
 8015e8e:	1f          	.byte	0x1f
 8015e8f:	00          	.byte	0x00
                    settings_dirty.global_settings = true;
 8015e90:	4b18      	ldr	r3, [pc, #96]	; (8015ef4 <memcpy_to_ram+0x1ac>)
 8015e92:	2201      	movs	r2, #1
 8015e94:	709a      	strb	r2, [r3, #2]
    return NVS_TransferResult_OK;
 8015e96:	2002      	movs	r0, #2
                    break;
 8015e98:	e01c      	b.n	8015ed4 <memcpy_to_ram+0x18c>
                    settings_dirty.coord_data |= (1 << target[idx].offset);
 8015e9a:	4b17      	ldr	r3, [pc, #92]	; (8015ef8 <memcpy_to_ram+0x1b0>)
 8015e9c:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8015ea0:	78da      	ldrb	r2, [r3, #3]
 8015ea2:	2301      	movs	r3, #1
 8015ea4:	4093      	lsls	r3, r2
 8015ea6:	4a13      	ldr	r2, [pc, #76]	; (8015ef4 <memcpy_to_ram+0x1ac>)
 8015ea8:	88d1      	ldrh	r1, [r2, #6]
 8015eaa:	430b      	orrs	r3, r1
 8015eac:	80d3      	strh	r3, [r2, #6]
                    break;
 8015eae:	e011      	b.n	8015ed4 <memcpy_to_ram+0x18c>
                    settings_dirty.startup_lines |= (1 << target[idx].offset);
 8015eb0:	4b11      	ldr	r3, [pc, #68]	; (8015ef8 <memcpy_to_ram+0x1b0>)
 8015eb2:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8015eb6:	78db      	ldrb	r3, [r3, #3]
 8015eb8:	2201      	movs	r2, #1
 8015eba:	409a      	lsls	r2, r3
 8015ebc:	490d      	ldr	r1, [pc, #52]	; (8015ef4 <memcpy_to_ram+0x1ac>)
 8015ebe:	794b      	ldrb	r3, [r1, #5]
 8015ec0:	4313      	orrs	r3, r2
 8015ec2:	714b      	strb	r3, [r1, #5]
    return NVS_TransferResult_OK;
 8015ec4:	2002      	movs	r0, #2
                    break;
 8015ec6:	e005      	b.n	8015ed4 <memcpy_to_ram+0x18c>
                    settings_dirty.build_info = true;
 8015ec8:	4b0a      	ldr	r3, [pc, #40]	; (8015ef4 <memcpy_to_ram+0x1ac>)
 8015eca:	2201      	movs	r2, #1
 8015ecc:	70da      	strb	r2, [r3, #3]
    return NVS_TransferResult_OK;
 8015ece:	2002      	movs	r0, #2
                    break;
 8015ed0:	e000      	b.n	8015ed4 <memcpy_to_ram+0x18c>
    return NVS_TransferResult_OK;
 8015ed2:	2002      	movs	r0, #2
}
 8015ed4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return NVS_TransferResult_OK;
 8015ed8:	2002      	movs	r0, #2
 8015eda:	e7fb      	b.n	8015ed4 <memcpy_to_ram+0x18c>
 8015edc:	2002      	movs	r0, #2
 8015ede:	e7f9      	b.n	8015ed4 <memcpy_to_ram+0x18c>
            if(target[idx].addr) switch(target[idx].type) {
 8015ee0:	2002      	movs	r0, #2
 8015ee2:	e7f7      	b.n	8015ed4 <memcpy_to_ram+0x18c>
 8015ee4:	2000350c 	.word	0x2000350c
 8015ee8:	20003794 	.word	0x20003794
 8015eec:	200037a0 	.word	0x200037a0
 8015ef0:	2000379c 	.word	0x2000379c
 8015ef4:	200037cc 	.word	0x200037cc
 8015ef8:	08027248 	.word	0x08027248

08015efc <nvs_buffer_alloc>:

// Try to allocate RAM from heap for buffer/emulation.
bool nvs_buffer_alloc (void)
{
 8015efc:	b510      	push	{r4, lr}
    assert(NVS_SIZE >= GRBL_NVS_SIZE);

    if((nvsbuffer = malloc(NVS_SIZE)))
 8015efe:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8015f02:	f00c fad5 	bl	80224b0 <malloc>
 8015f06:	4604      	mov	r4, r0
 8015f08:	4b05      	ldr	r3, [pc, #20]	; (8015f20 <nvs_buffer_alloc+0x24>)
 8015f0a:	6018      	str	r0, [r3, #0]
 8015f0c:	b120      	cbz	r0, 8015f18 <nvs_buffer_alloc+0x1c>
        memset(nvsbuffer, 0xFF, NVS_SIZE);
 8015f0e:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8015f12:	21ff      	movs	r1, #255	; 0xff
 8015f14:	f00c fe2f 	bl	8022b76 <memset>

    return nvsbuffer != NULL;
}
 8015f18:	1e20      	subs	r0, r4, #0
 8015f1a:	bf18      	it	ne
 8015f1c:	2001      	movne	r0, #1
 8015f1e:	bd10      	pop	{r4, pc}
 8015f20:	2000379c 	.word	0x2000379c

08015f24 <nvs_buffer_init>:
}
//
// Switch over to RAM based copy.
// Changes to RAM based copy will be written to physical storage when grblHAL is in IDLE state.
bool nvs_buffer_init (void)
{
 8015f24:	b570      	push	{r4, r5, r6, lr}
    hal.nvs.size = ((hal.nvs.size - 1) | 0x03) + 1; // Ensure NVS area ends on a word boundary
 8015f26:	4a3d      	ldr	r2, [pc, #244]	; (801601c <nvs_buffer_init+0xf8>)
 8015f28:	f8d2 3148 	ldr.w	r3, [r2, #328]	; 0x148
 8015f2c:	3b01      	subs	r3, #1
 8015f2e:	f043 0303 	orr.w	r3, r3, #3
 8015f32:	3301      	adds	r3, #1
 8015f34:	f8c2 3148 	str.w	r3, [r2, #328]	; 0x148

    if(nvsbuffer) {
 8015f38:	4b39      	ldr	r3, [pc, #228]	; (8016020 <nvs_buffer_init+0xfc>)
 8015f3a:	681d      	ldr	r5, [r3, #0]
 8015f3c:	2d00      	cmp	r5, #0
 8015f3e:	d069      	beq.n	8016014 <nvs_buffer_init+0xf0>

        memcpy(&physical_nvs, &hal.nvs, sizeof(nvs_io_t)); // save pointers to physical storage handler functions
 8015f40:	4e38      	ldr	r6, [pc, #224]	; (8016024 <nvs_buffer_init+0x100>)
 8015f42:	46b4      	mov	ip, r6
 8015f44:	f502 74a2 	add.w	r4, r2, #324	; 0x144
 8015f48:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8015f4a:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 8015f4e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8015f50:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 8015f54:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8015f58:	e88c 0007 	stmia.w	ip, {r0, r1, r2}

        // Copy physical storage content to RAM when available
        if(physical_nvs.type == NVS_Flash)
 8015f5c:	7833      	ldrb	r3, [r6, #0]
 8015f5e:	2b03      	cmp	r3, #3
 8015f60:	d00c      	beq.n	8015f7c <nvs_buffer_init+0x58>
            physical_nvs.memcpy_from_flash(nvsbuffer);
        else if(physical_nvs.type != NVS_None)
 8015f62:	b173      	cbz	r3, 8015f82 <nvs_buffer_init+0x5e>
            physical_nvs.memcpy_from_nvs(nvsbuffer, 0, GRBL_NVS_SIZE + hal.nvs.driver_area.size, false);
 8015f64:	4b2f      	ldr	r3, [pc, #188]	; (8016024 <nvs_buffer_init+0x100>)
 8015f66:	6a1c      	ldr	r4, [r3, #32]
 8015f68:	4b2c      	ldr	r3, [pc, #176]	; (801601c <nvs_buffer_init+0xf8>)
 8015f6a:	f8b3 2156 	ldrh.w	r2, [r3, #342]	; 0x156
 8015f6e:	2300      	movs	r3, #0
 8015f70:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8015f74:	4619      	mov	r1, r3
 8015f76:	4628      	mov	r0, r5
 8015f78:	47a0      	blx	r4
 8015f7a:	e002      	b.n	8015f82 <nvs_buffer_init+0x5e>
            physical_nvs.memcpy_from_flash(nvsbuffer);
 8015f7c:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8015f7e:	4628      	mov	r0, r5
 8015f80:	4798      	blx	r3

        // Switch hal to use RAM version of non-volatile storage data
        hal.nvs.type = NVS_Emulated;
 8015f82:	4b26      	ldr	r3, [pc, #152]	; (801601c <nvs_buffer_init+0xf8>)
 8015f84:	2204      	movs	r2, #4
 8015f86:	f883 2144 	strb.w	r2, [r3, #324]	; 0x144
        hal.nvs.get_byte = &ram_get_byte;
 8015f8a:	4a27      	ldr	r2, [pc, #156]	; (8016028 <nvs_buffer_init+0x104>)
 8015f8c:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158
        hal.nvs.put_byte = &ram_put_byte;
 8015f90:	4a26      	ldr	r2, [pc, #152]	; (801602c <nvs_buffer_init+0x108>)
 8015f92:	f8c3 215c 	str.w	r2, [r3, #348]	; 0x15c
        hal.nvs.memcpy_to_nvs = &memcpy_to_ram;
 8015f96:	4a26      	ldr	r2, [pc, #152]	; (8016030 <nvs_buffer_init+0x10c>)
 8015f98:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
        hal.nvs.memcpy_from_nvs = &memcpy_from_ram;
 8015f9c:	4a25      	ldr	r2, [pc, #148]	; (8016034 <nvs_buffer_init+0x110>)
 8015f9e:	f8c3 2164 	str.w	r2, [r3, #356]	; 0x164
        hal.nvs.memcpy_from_flash = NULL;
 8015fa2:	2200      	movs	r2, #0
 8015fa4:	f8c3 2168 	str.w	r2, [r3, #360]	; 0x168
        hal.nvs.memcpy_to_flash = NULL;
 8015fa8:	f8c3 216c 	str.w	r2, [r3, #364]	; 0x16c

        // If no physical storage available or if NVS import fails copy default settings to RAM
        // and write out to physical storage when available.
        if(physical_nvs.type == NVS_None || ram_get_byte(0) != SETTINGS_VERSION) {
 8015fac:	4b1d      	ldr	r3, [pc, #116]	; (8016024 <nvs_buffer_init+0x100>)
 8015fae:	781b      	ldrb	r3, [r3, #0]
 8015fb0:	b123      	cbz	r3, 8015fbc <nvs_buffer_init+0x98>
    return nvsbuffer[addr];
 8015fb2:	4b1b      	ldr	r3, [pc, #108]	; (8016020 <nvs_buffer_init+0xfc>)
 8015fb4:	681b      	ldr	r3, [r3, #0]
 8015fb6:	781b      	ldrb	r3, [r3, #0]
        if(physical_nvs.type == NVS_None || ram_get_byte(0) != SETTINGS_VERSION) {
 8015fb8:	2b16      	cmp	r3, #22
 8015fba:	d01b      	beq.n	8015ff4 <nvs_buffer_init+0xd0>
            settings_restore(settings_all);
 8015fbc:	4b1e      	ldr	r3, [pc, #120]	; (8016038 <nvs_buffer_init+0x114>)
 8015fbe:	7818      	ldrb	r0, [r3, #0]
 8015fc0:	f006 fdac 	bl	801cb1c <settings_restore>
            if(physical_nvs.type == NVS_Flash)
 8015fc4:	4b17      	ldr	r3, [pc, #92]	; (8016024 <nvs_buffer_init+0x100>)
 8015fc6:	781b      	ldrb	r3, [r3, #0]
 8015fc8:	2b03      	cmp	r3, #3
 8015fca:	d01d      	beq.n	8016008 <nvs_buffer_init+0xe4>
                physical_nvs.memcpy_to_flash(nvsbuffer);
            else if(physical_nvs.memcpy_to_nvs)
 8015fcc:	4b15      	ldr	r3, [pc, #84]	; (8016024 <nvs_buffer_init+0x100>)
 8015fce:	69dc      	ldr	r4, [r3, #28]
 8015fd0:	b14c      	cbz	r4, 8015fe6 <nvs_buffer_init+0xc2>
                physical_nvs.memcpy_to_nvs(0, nvsbuffer, GRBL_NVS_SIZE + hal.nvs.driver_area.size, false);
 8015fd2:	4b12      	ldr	r3, [pc, #72]	; (801601c <nvs_buffer_init+0xf8>)
 8015fd4:	f8b3 2156 	ldrh.w	r2, [r3, #342]	; 0x156
 8015fd8:	2300      	movs	r3, #0
 8015fda:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8015fde:	4910      	ldr	r1, [pc, #64]	; (8016020 <nvs_buffer_init+0xfc>)
 8015fe0:	6809      	ldr	r1, [r1, #0]
 8015fe2:	4618      	mov	r0, r3
 8015fe4:	47a0      	blx	r4
            if(physical_nvs.type != NVS_None)
 8015fe6:	4b0f      	ldr	r3, [pc, #60]	; (8016024 <nvs_buffer_init+0x100>)
 8015fe8:	781b      	ldrb	r3, [r3, #0]
 8015fea:	b11b      	cbz	r3, 8015ff4 <nvs_buffer_init+0xd0>
                grbl.report.status_message(Status_SettingReadFail);
 8015fec:	4b13      	ldr	r3, [pc, #76]	; (801603c <nvs_buffer_init+0x118>)
 8015fee:	689b      	ldr	r3, [r3, #8]
 8015ff0:	2007      	movs	r0, #7
 8015ff2:	4798      	blx	r3
        }
    } else
        protocol_enqueue_rt_command(nvs_warning);

    // Clear settings dirty flags
    memset(&settings_dirty, 0, sizeof(settings_dirty_t));
 8015ff4:	4b12      	ldr	r3, [pc, #72]	; (8016040 <nvs_buffer_init+0x11c>)
 8015ff6:	2200      	movs	r2, #0
 8015ff8:	601a      	str	r2, [r3, #0]
 8015ffa:	605a      	str	r2, [r3, #4]

    return nvsbuffer != NULL;
 8015ffc:	4b08      	ldr	r3, [pc, #32]	; (8016020 <nvs_buffer_init+0xfc>)
 8015ffe:	6818      	ldr	r0, [r3, #0]
}
 8016000:	1a80      	subs	r0, r0, r2
 8016002:	bf18      	it	ne
 8016004:	2001      	movne	r0, #1
 8016006:	bd70      	pop	{r4, r5, r6, pc}
                physical_nvs.memcpy_to_flash(nvsbuffer);
 8016008:	4b06      	ldr	r3, [pc, #24]	; (8016024 <nvs_buffer_init+0x100>)
 801600a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801600c:	4a04      	ldr	r2, [pc, #16]	; (8016020 <nvs_buffer_init+0xfc>)
 801600e:	6810      	ldr	r0, [r2, #0]
 8016010:	4798      	blx	r3
 8016012:	e7e8      	b.n	8015fe6 <nvs_buffer_init+0xc2>
        protocol_enqueue_rt_command(nvs_warning);
 8016014:	480b      	ldr	r0, [pc, #44]	; (8016044 <nvs_buffer_init+0x120>)
 8016016:	f002 f829 	bl	801806c <protocol_enqueue_rt_command>
 801601a:	e7eb      	b.n	8015ff4 <nvs_buffer_init+0xd0>
 801601c:	2000350c 	.word	0x2000350c
 8016020:	2000379c 	.word	0x2000379c
 8016024:	200037a0 	.word	0x200037a0
 8016028:	08015c69 	.word	0x08015c69
 801602c:	08015c75 	.word	0x08015c75
 8016030:	08015d49 	.word	0x08015d49
 8016034:	08015cc9 	.word	0x08015cc9
 8016038:	0802c3e4 	.word	0x0802c3e4
 801603c:	2000343c 	.word	0x2000343c
 8016040:	200037cc 	.word	0x200037cc
 8016044:	08015cb9 	.word	0x08015cb9

08016048 <nvs_alloc>:
    static uint8_t *mem_address;

    nvs_address_t addr = 0;

    // Check if already switched to emulation or buffer allocation failed, return NULL if so.
    if(hal.nvs.type == NVS_Emulated || nvsbuffer == NULL)
 8016048:	4b1e      	ldr	r3, [pc, #120]	; (80160c4 <nvs_alloc+0x7c>)
 801604a:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 801604e:	2b04      	cmp	r3, #4
 8016050:	d02f      	beq.n	80160b2 <nvs_alloc+0x6a>
 8016052:	4b1d      	ldr	r3, [pc, #116]	; (80160c8 <nvs_alloc+0x80>)
 8016054:	6819      	ldr	r1, [r3, #0]
 8016056:	b371      	cbz	r1, 80160b6 <nvs_alloc+0x6e>
{
 8016058:	b410      	push	{r4}
        return 0;

    if(hal.nvs.driver_area.address == 0) {
 801605a:	4b1a      	ldr	r3, [pc, #104]	; (80160c4 <nvs_alloc+0x7c>)
 801605c:	f8b3 3154 	ldrh.w	r3, [r3, #340]	; 0x154
 8016060:	b94b      	cbnz	r3, 8016076 <nvs_alloc+0x2e>
        hal.nvs.driver_area.address = GRBL_NVS_SIZE;
 8016062:	4b18      	ldr	r3, [pc, #96]	; (80160c4 <nvs_alloc+0x7c>)
 8016064:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8016068:	f8a3 2154 	strh.w	r2, [r3, #340]	; 0x154
        hal.nvs.driver_area.mem_address = mem_address = nvsbuffer + GRBL_NVS_SIZE;
 801606c:	188a      	adds	r2, r1, r2
 801606e:	4c17      	ldr	r4, [pc, #92]	; (80160cc <nvs_alloc+0x84>)
 8016070:	6022      	str	r2, [r4, #0]
 8016072:	f8c3 2150 	str.w	r2, [r3, #336]	; 0x150
    }

    size += NVS_CRC_BYTES; // add room for checksum.
 8016076:	1c42      	adds	r2, r0, #1
    if(hal.nvs.driver_area.size + size < (NVS_SIZE - GRBL_NVS_SIZE)) {
 8016078:	4b12      	ldr	r3, [pc, #72]	; (80160c4 <nvs_alloc+0x7c>)
 801607a:	f8b3 3156 	ldrh.w	r3, [r3, #342]	; 0x156
 801607e:	4413      	add	r3, r2
 8016080:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8016084:	d219      	bcs.n	80160ba <nvs_alloc+0x72>
        mem_address = (uint8_t *)((uint32_t)(mem_address - 1) | 0x03) + 1; // Align to word boundary
 8016086:	4c11      	ldr	r4, [pc, #68]	; (80160cc <nvs_alloc+0x84>)
 8016088:	6823      	ldr	r3, [r4, #0]
 801608a:	3b01      	subs	r3, #1
 801608c:	f043 0303 	orr.w	r3, r3, #3
 8016090:	3301      	adds	r3, #1
 8016092:	6023      	str	r3, [r4, #0]
        addr = mem_address - nvsbuffer;
 8016094:	1a58      	subs	r0, r3, r1
        mem_address += size;
 8016096:	4413      	add	r3, r2
 8016098:	6023      	str	r3, [r4, #0]
        hal.nvs.driver_area.size = mem_address - hal.nvs.driver_area.mem_address;
 801609a:	4a0a      	ldr	r2, [pc, #40]	; (80160c4 <nvs_alloc+0x7c>)
 801609c:	f8d2 1150 	ldr.w	r1, [r2, #336]	; 0x150
 80160a0:	1a5b      	subs	r3, r3, r1
 80160a2:	b29b      	uxth	r3, r3
 80160a4:	f8a2 3156 	strh.w	r3, [r2, #342]	; 0x156
        hal.nvs.size = GRBL_NVS_SIZE + hal.nvs.driver_area.size + 1;
 80160a8:	f203 4301 	addw	r3, r3, #1025	; 0x401
 80160ac:	f8c2 3148 	str.w	r3, [r2, #328]	; 0x148
 80160b0:	e004      	b.n	80160bc <nvs_alloc+0x74>
        return 0;
 80160b2:	2000      	movs	r0, #0
 80160b4:	4770      	bx	lr
 80160b6:	2000      	movs	r0, #0
    }

    return addr;
}
 80160b8:	4770      	bx	lr
    nvs_address_t addr = 0;
 80160ba:	2000      	movs	r0, #0
}
 80160bc:	f85d 4b04 	ldr.w	r4, [sp], #4
 80160c0:	4770      	bx	lr
 80160c2:	bf00      	nop
 80160c4:	2000350c 	.word	0x2000350c
 80160c8:	2000379c 	.word	0x2000379c
 80160cc:	20003798 	.word	0x20003798

080160d0 <nvs_buffer_sync_physical>:

// Write RAM changes to physical storage
void nvs_buffer_sync_physical (void)
{
    if(!settings_dirty.is_dirty)
 80160d0:	4b69      	ldr	r3, [pc, #420]	; (8016278 <nvs_buffer_sync_physical+0x1a8>)
 80160d2:	781b      	ldrb	r3, [r3, #0]
 80160d4:	2b00      	cmp	r3, #0
 80160d6:	f000 80cd 	beq.w	8016274 <nvs_buffer_sync_physical+0x1a4>
{
 80160da:	b570      	push	{r4, r5, r6, lr}
        return;

    if(physical_nvs.memcpy_to_nvs) {
 80160dc:	4b67      	ldr	r3, [pc, #412]	; (801627c <nvs_buffer_sync_physical+0x1ac>)
 80160de:	69dc      	ldr	r4, [r3, #28]
 80160e0:	2c00      	cmp	r4, #0
 80160e2:	f000 80b5 	beq.w	8016250 <nvs_buffer_sync_physical+0x180>

        if(settings_dirty.version)
 80160e6:	4b64      	ldr	r3, [pc, #400]	; (8016278 <nvs_buffer_sync_physical+0x1a8>)
 80160e8:	785b      	ldrb	r3, [r3, #1]
 80160ea:	b153      	cbz	r3, 8016102 <nvs_buffer_sync_physical+0x32>
            settings_dirty.version = physical_nvs.memcpy_to_nvs(0, nvsbuffer, 1, false) != NVS_TransferResult_OK;
 80160ec:	2300      	movs	r3, #0
 80160ee:	2201      	movs	r2, #1
 80160f0:	4963      	ldr	r1, [pc, #396]	; (8016280 <nvs_buffer_sync_physical+0x1b0>)
 80160f2:	6809      	ldr	r1, [r1, #0]
 80160f4:	4618      	mov	r0, r3
 80160f6:	47a0      	blx	r4
 80160f8:	3802      	subs	r0, #2
 80160fa:	bf18      	it	ne
 80160fc:	2001      	movne	r0, #1
 80160fe:	4b5e      	ldr	r3, [pc, #376]	; (8016278 <nvs_buffer_sync_physical+0x1a8>)
 8016100:	7058      	strb	r0, [r3, #1]

        if(settings_dirty.global_settings)
 8016102:	4b5d      	ldr	r3, [pc, #372]	; (8016278 <nvs_buffer_sync_physical+0x1a8>)
 8016104:	789b      	ldrb	r3, [r3, #2]
 8016106:	b173      	cbz	r3, 8016126 <nvs_buffer_sync_physical+0x56>
            settings_dirty.global_settings = physical_nvs.memcpy_to_nvs(NVS_ADDR_GLOBAL, (uint8_t *)(nvsbuffer + NVS_ADDR_GLOBAL), sizeof(settings_t) + NVS_CRC_BYTES, false) != NVS_TransferResult_OK;
 8016108:	4b5c      	ldr	r3, [pc, #368]	; (801627c <nvs_buffer_sync_physical+0x1ac>)
 801610a:	69dc      	ldr	r4, [r3, #28]
 801610c:	4b5c      	ldr	r3, [pc, #368]	; (8016280 <nvs_buffer_sync_physical+0x1b0>)
 801610e:	6819      	ldr	r1, [r3, #0]
 8016110:	2300      	movs	r3, #0
 8016112:	f240 126d 	movw	r2, #365	; 0x16d
 8016116:	3101      	adds	r1, #1
 8016118:	2001      	movs	r0, #1
 801611a:	47a0      	blx	r4
 801611c:	3802      	subs	r0, #2
 801611e:	bf18      	it	ne
 8016120:	2001      	movne	r0, #1
 8016122:	4b55      	ldr	r3, [pc, #340]	; (8016278 <nvs_buffer_sync_physical+0x1a8>)
 8016124:	7098      	strb	r0, [r3, #2]

        if(settings_dirty.build_info)
 8016126:	4b54      	ldr	r3, [pc, #336]	; (8016278 <nvs_buffer_sync_physical+0x1a8>)
 8016128:	78db      	ldrb	r3, [r3, #3]
 801612a:	b17b      	cbz	r3, 801614c <nvs_buffer_sync_physical+0x7c>
            settings_dirty.build_info = physical_nvs.memcpy_to_nvs(NVS_ADDR_BUILD_INFO, (uint8_t *)(nvsbuffer + NVS_ADDR_BUILD_INFO), sizeof(stored_line_t) + NVS_CRC_BYTES, false) != NVS_TransferResult_OK;
 801612c:	4b53      	ldr	r3, [pc, #332]	; (801627c <nvs_buffer_sync_physical+0x1ac>)
 801612e:	69dc      	ldr	r4, [r3, #28]
 8016130:	4b53      	ldr	r3, [pc, #332]	; (8016280 <nvs_buffer_sync_physical+0x1b0>)
 8016132:	6819      	ldr	r1, [r3, #0]
 8016134:	2300      	movs	r3, #0
 8016136:	2247      	movs	r2, #71	; 0x47
 8016138:	f201 31ae 	addw	r1, r1, #942	; 0x3ae
 801613c:	f240 30ae 	movw	r0, #942	; 0x3ae
 8016140:	47a0      	blx	r4
 8016142:	3802      	subs	r0, #2
 8016144:	bf18      	it	ne
 8016146:	2001      	movne	r0, #1
 8016148:	4b4b      	ldr	r3, [pc, #300]	; (8016278 <nvs_buffer_sync_physical+0x1a8>)
 801614a:	70d8      	strb	r0, [r3, #3]

        uint_fast8_t idx = N_STARTUP_LINE, offset;
        if(settings_dirty.startup_lines) do {
 801614c:	4b4a      	ldr	r3, [pc, #296]	; (8016278 <nvs_buffer_sync_physical+0x1a8>)
 801614e:	795b      	ldrb	r3, [r3, #5]
 8016150:	b30b      	cbz	r3, 8016196 <nvs_buffer_sync_physical+0xc6>
        uint_fast8_t idx = N_STARTUP_LINE, offset;
 8016152:	2402      	movs	r4, #2
            idx--;
 8016154:	3c01      	subs	r4, #1
            if(bit_istrue(settings_dirty.startup_lines, bit(idx))) {
 8016156:	4b48      	ldr	r3, [pc, #288]	; (8016278 <nvs_buffer_sync_physical+0x1a8>)
 8016158:	795a      	ldrb	r2, [r3, #5]
 801615a:	fa22 f304 	lsr.w	r3, r2, r4
 801615e:	f013 0f01 	tst.w	r3, #1
 8016162:	d016      	beq.n	8016192 <nvs_buffer_sync_physical+0xc2>
                bit_false(settings_dirty.startup_lines, bit(idx));
 8016164:	2301      	movs	r3, #1
 8016166:	40a3      	lsls	r3, r4
 8016168:	43db      	mvns	r3, r3
 801616a:	b2dd      	uxtb	r5, r3
 801616c:	4013      	ands	r3, r2
 801616e:	4a42      	ldr	r2, [pc, #264]	; (8016278 <nvs_buffer_sync_physical+0x1a8>)
 8016170:	7153      	strb	r3, [r2, #5]
                offset = NVS_ADDR_STARTUP_BLOCK + idx * (sizeof(stored_line_t) + NVS_CRC_BYTES);
 8016172:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 8016176:	ebc4 00c0 	rsb	r0, r4, r0, lsl #3
 801617a:	f200 301f 	addw	r0, r0, #799	; 0x31f
                if(physical_nvs.memcpy_to_nvs(offset, (uint8_t *)(nvsbuffer + offset), sizeof(stored_line_t) + NVS_CRC_BYTES, false) == NVS_TransferResult_OK)
 801617e:	4b3f      	ldr	r3, [pc, #252]	; (801627c <nvs_buffer_sync_physical+0x1ac>)
 8016180:	69de      	ldr	r6, [r3, #28]
 8016182:	4b3f      	ldr	r3, [pc, #252]	; (8016280 <nvs_buffer_sync_physical+0x1b0>)
 8016184:	6819      	ldr	r1, [r3, #0]
 8016186:	2300      	movs	r3, #0
 8016188:	2247      	movs	r2, #71	; 0x47
 801618a:	4401      	add	r1, r0
 801618c:	47b0      	blx	r6
 801618e:	2802      	cmp	r0, #2
 8016190:	d006      	beq.n	80161a0 <nvs_buffer_sync_physical+0xd0>
                    bit_false(settings_dirty.startup_lines, bit(idx));
            }
        } while(idx);
 8016192:	2c00      	cmp	r4, #0
 8016194:	d1de      	bne.n	8016154 <nvs_buffer_sync_physical+0x84>

        idx = N_CoordinateSystems;
        if(settings_dirty.coord_data) do {
 8016196:	4b38      	ldr	r3, [pc, #224]	; (8016278 <nvs_buffer_sync_physical+0x1a8>)
 8016198:	88db      	ldrh	r3, [r3, #6]
 801619a:	b33b      	cbz	r3, 80161ec <nvs_buffer_sync_physical+0x11c>
        idx = N_CoordinateSystems;
 801619c:	240c      	movs	r4, #12
 801619e:	e007      	b.n	80161b0 <nvs_buffer_sync_physical+0xe0>
                    bit_false(settings_dirty.startup_lines, bit(idx));
 80161a0:	4b35      	ldr	r3, [pc, #212]	; (8016278 <nvs_buffer_sync_physical+0x1a8>)
 80161a2:	795a      	ldrb	r2, [r3, #5]
 80161a4:	4015      	ands	r5, r2
 80161a6:	715d      	strb	r5, [r3, #5]
 80161a8:	e7f3      	b.n	8016192 <nvs_buffer_sync_physical+0xc2>
            if(bit_istrue(settings_dirty.coord_data, bit(idx))) {
                offset = NVS_ADDR_PARAMETERS + idx * (sizeof(coord_data_t) + NVS_CRC_BYTES);
                if(physical_nvs.memcpy_to_nvs(offset, (uint8_t *)(nvsbuffer + offset), sizeof(coord_data_t) + NVS_CRC_BYTES, false) == NVS_TransferResult_OK)
                    bit_false(settings_dirty.coord_data, bit(idx));
            }
        } while(idx--);
 80161aa:	1e63      	subs	r3, r4, #1
 80161ac:	b1f4      	cbz	r4, 80161ec <nvs_buffer_sync_physical+0x11c>
 80161ae:	461c      	mov	r4, r3
            if(bit_istrue(settings_dirty.coord_data, bit(idx))) {
 80161b0:	4b31      	ldr	r3, [pc, #196]	; (8016278 <nvs_buffer_sync_physical+0x1a8>)
 80161b2:	88db      	ldrh	r3, [r3, #6]
 80161b4:	40e3      	lsrs	r3, r4
 80161b6:	f013 0f01 	tst.w	r3, #1
 80161ba:	d0f6      	beq.n	80161aa <nvs_buffer_sync_physical+0xda>
                offset = NVS_ADDR_PARAMETERS + idx * (sizeof(coord_data_t) + NVS_CRC_BYTES);
 80161bc:	eb04 0044 	add.w	r0, r4, r4, lsl #1
 80161c0:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 80161c4:	f500 7000 	add.w	r0, r0, #512	; 0x200
                if(physical_nvs.memcpy_to_nvs(offset, (uint8_t *)(nvsbuffer + offset), sizeof(coord_data_t) + NVS_CRC_BYTES, false) == NVS_TransferResult_OK)
 80161c8:	4b2c      	ldr	r3, [pc, #176]	; (801627c <nvs_buffer_sync_physical+0x1ac>)
 80161ca:	69dd      	ldr	r5, [r3, #28]
 80161cc:	4b2c      	ldr	r3, [pc, #176]	; (8016280 <nvs_buffer_sync_physical+0x1b0>)
 80161ce:	6819      	ldr	r1, [r3, #0]
 80161d0:	2300      	movs	r3, #0
 80161d2:	220d      	movs	r2, #13
 80161d4:	4401      	add	r1, r0
 80161d6:	47a8      	blx	r5
 80161d8:	2802      	cmp	r0, #2
 80161da:	d1e6      	bne.n	80161aa <nvs_buffer_sync_physical+0xda>
                    bit_false(settings_dirty.coord_data, bit(idx));
 80161dc:	2201      	movs	r2, #1
 80161de:	40a2      	lsls	r2, r4
 80161e0:	4925      	ldr	r1, [pc, #148]	; (8016278 <nvs_buffer_sync_physical+0x1a8>)
 80161e2:	88cb      	ldrh	r3, [r1, #6]
 80161e4:	ea23 0302 	bic.w	r3, r3, r2
 80161e8:	80cb      	strh	r3, [r1, #6]
 80161ea:	e7de      	b.n	80161aa <nvs_buffer_sync_physical+0xda>

        if(settings_dirty.driver_settings) {
 80161ec:	4b22      	ldr	r3, [pc, #136]	; (8016278 <nvs_buffer_sync_physical+0x1a8>)
 80161ee:	791b      	ldrb	r3, [r3, #4]
 80161f0:	b193      	cbz	r3, 8016218 <nvs_buffer_sync_physical+0x148>
            if(hal.nvs.driver_area.size > 0)
 80161f2:	4b24      	ldr	r3, [pc, #144]	; (8016284 <nvs_buffer_sync_physical+0x1b4>)
 80161f4:	f8b3 2156 	ldrh.w	r2, [r3, #342]	; 0x156
 80161f8:	b1e2      	cbz	r2, 8016234 <nvs_buffer_sync_physical+0x164>
                settings_dirty.driver_settings = physical_nvs.memcpy_to_nvs(hal.nvs.driver_area.address, (uint8_t *)(nvsbuffer + hal.nvs.driver_area.address), hal.nvs.driver_area.size, false) != NVS_TransferResult_OK;
 80161fa:	4b20      	ldr	r3, [pc, #128]	; (801627c <nvs_buffer_sync_physical+0x1ac>)
 80161fc:	69dc      	ldr	r4, [r3, #28]
 80161fe:	4b21      	ldr	r3, [pc, #132]	; (8016284 <nvs_buffer_sync_physical+0x1b4>)
 8016200:	f8b3 0154 	ldrh.w	r0, [r3, #340]	; 0x154
 8016204:	4b1e      	ldr	r3, [pc, #120]	; (8016280 <nvs_buffer_sync_physical+0x1b0>)
 8016206:	6819      	ldr	r1, [r3, #0]
 8016208:	2300      	movs	r3, #0
 801620a:	4401      	add	r1, r0
 801620c:	47a0      	blx	r4
 801620e:	3802      	subs	r0, #2
 8016210:	bf18      	it	ne
 8016212:	2001      	movne	r0, #1
 8016214:	4b18      	ldr	r3, [pc, #96]	; (8016278 <nvs_buffer_sync_physical+0x1a8>)
 8016216:	7118      	strb	r0, [r3, #4]
                if(physical_nvs.memcpy_to_nvs(offset, (uint8_t *)(nvsbuffer + offset), sizeof(tool_data_t) + NVS_CRC_BYTES, false) == NVS_TransferResult_OK)
                    bit_false(settings_dirty.tool_data, bit(idx));
            }
        } while(idx);
#endif
        settings_dirty.is_dirty = settings_dirty.coord_data ||
 8016218:	4b17      	ldr	r3, [pc, #92]	; (8016278 <nvs_buffer_sync_physical+0x1a8>)
 801621a:	88db      	ldrh	r3, [r3, #6]
                                   settings_dirty.global_settings ||
                                    settings_dirty.driver_settings ||
                                     settings_dirty.startup_lines ||
 801621c:	b973      	cbnz	r3, 801623c <nvs_buffer_sync_physical+0x16c>
                                   settings_dirty.global_settings ||
 801621e:	4b16      	ldr	r3, [pc, #88]	; (8016278 <nvs_buffer_sync_physical+0x1a8>)
 8016220:	789b      	ldrb	r3, [r3, #2]
        settings_dirty.is_dirty = settings_dirty.coord_data ||
 8016222:	b97b      	cbnz	r3, 8016244 <nvs_buffer_sync_physical+0x174>
                                    settings_dirty.driver_settings ||
 8016224:	4b14      	ldr	r3, [pc, #80]	; (8016278 <nvs_buffer_sync_physical+0x1a8>)
 8016226:	889b      	ldrh	r3, [r3, #4]
 8016228:	b973      	cbnz	r3, 8016248 <nvs_buffer_sync_physical+0x178>
#if N_TOOLS
                                      settings_dirty.tool_data ||
#endif
                                       settings_dirty.build_info;
 801622a:	4b13      	ldr	r3, [pc, #76]	; (8016278 <nvs_buffer_sync_physical+0x1a8>)
 801622c:	78db      	ldrb	r3, [r3, #3]
                                     settings_dirty.startup_lines ||
 801622e:	b16b      	cbz	r3, 801624c <nvs_buffer_sync_physical+0x17c>
 8016230:	2201      	movs	r2, #1
 8016232:	e004      	b.n	801623e <nvs_buffer_sync_physical+0x16e>
                settings_dirty.driver_settings = false;
 8016234:	4b10      	ldr	r3, [pc, #64]	; (8016278 <nvs_buffer_sync_physical+0x1a8>)
 8016236:	2200      	movs	r2, #0
 8016238:	711a      	strb	r2, [r3, #4]
 801623a:	e7ed      	b.n	8016218 <nvs_buffer_sync_physical+0x148>
                                     settings_dirty.startup_lines ||
 801623c:	2201      	movs	r2, #1
        settings_dirty.is_dirty = settings_dirty.coord_data ||
 801623e:	4b0e      	ldr	r3, [pc, #56]	; (8016278 <nvs_buffer_sync_physical+0x1a8>)
 8016240:	701a      	strb	r2, [r3, #0]
    } else if(physical_nvs.memcpy_to_flash) {
        if(!physical_nvs.memcpy_to_flash(nvsbuffer))
            report_message("Settings write failed!", Message_Warning);
        memset(&settings_dirty, 0, sizeof(settings_dirty_t));
    }
}
 8016242:	bd70      	pop	{r4, r5, r6, pc}
                                     settings_dirty.startup_lines ||
 8016244:	2201      	movs	r2, #1
 8016246:	e7fa      	b.n	801623e <nvs_buffer_sync_physical+0x16e>
 8016248:	2201      	movs	r2, #1
 801624a:	e7f8      	b.n	801623e <nvs_buffer_sync_physical+0x16e>
 801624c:	2200      	movs	r2, #0
 801624e:	e7f6      	b.n	801623e <nvs_buffer_sync_physical+0x16e>
    } else if(physical_nvs.memcpy_to_flash) {
 8016250:	4b0a      	ldr	r3, [pc, #40]	; (801627c <nvs_buffer_sync_physical+0x1ac>)
 8016252:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8016254:	2b00      	cmp	r3, #0
 8016256:	d0f4      	beq.n	8016242 <nvs_buffer_sync_physical+0x172>
        if(!physical_nvs.memcpy_to_flash(nvsbuffer))
 8016258:	4a09      	ldr	r2, [pc, #36]	; (8016280 <nvs_buffer_sync_physical+0x1b0>)
 801625a:	6810      	ldr	r0, [r2, #0]
 801625c:	4798      	blx	r3
 801625e:	b120      	cbz	r0, 801626a <nvs_buffer_sync_physical+0x19a>
        memset(&settings_dirty, 0, sizeof(settings_dirty_t));
 8016260:	4b05      	ldr	r3, [pc, #20]	; (8016278 <nvs_buffer_sync_physical+0x1a8>)
 8016262:	2200      	movs	r2, #0
 8016264:	601a      	str	r2, [r3, #0]
 8016266:	605a      	str	r2, [r3, #4]
 8016268:	e7eb      	b.n	8016242 <nvs_buffer_sync_physical+0x172>
            report_message("Settings write failed!", Message_Warning);
 801626a:	2102      	movs	r1, #2
 801626c:	4806      	ldr	r0, [pc, #24]	; (8016288 <nvs_buffer_sync_physical+0x1b8>)
 801626e:	f002 ffdb 	bl	8019228 <report_message>
 8016272:	e7f5      	b.n	8016260 <nvs_buffer_sync_physical+0x190>
 8016274:	4770      	bx	lr
 8016276:	bf00      	nop
 8016278:	200037cc 	.word	0x200037cc
 801627c:	200037a0 	.word	0x200037a0
 8016280:	2000379c 	.word	0x2000379c
 8016284:	2000350c 	.word	0x2000350c
 8016288:	08027230 	.word	0x08027230

0801628c <nvs_buffer_free>:
{
 801628c:	b508      	push	{r3, lr}
    if(nvsbuffer) {
 801628e:	4b05      	ldr	r3, [pc, #20]	; (80162a4 <nvs_buffer_free+0x18>)
 8016290:	681b      	ldr	r3, [r3, #0]
 8016292:	b12b      	cbz	r3, 80162a0 <nvs_buffer_free+0x14>
        nvs_buffer_sync_physical();
 8016294:	f7ff ff1c 	bl	80160d0 <nvs_buffer_sync_physical>
        free(nvsbuffer);
 8016298:	4b02      	ldr	r3, [pc, #8]	; (80162a4 <nvs_buffer_free+0x18>)
 801629a:	6818      	ldr	r0, [r3, #0]
 801629c:	f00c f910 	bl	80224c0 <free>
}
 80162a0:	bd08      	pop	{r3, pc}
 80162a2:	bf00      	nop
 80162a4:	2000379c 	.word	0x2000379c

080162a8 <nvs_buffer_get_physical>:

nvs_io_t *nvs_buffer_get_physical (void)
{
    return hal.nvs.type == NVS_Emulated ? &physical_nvs : &hal.nvs;
 80162a8:	4b04      	ldr	r3, [pc, #16]	; (80162bc <nvs_buffer_get_physical+0x14>)
 80162aa:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 80162ae:	2b04      	cmp	r3, #4
 80162b0:	d001      	beq.n	80162b6 <nvs_buffer_get_physical+0xe>
 80162b2:	4803      	ldr	r0, [pc, #12]	; (80162c0 <nvs_buffer_get_physical+0x18>)
}
 80162b4:	4770      	bx	lr
    return hal.nvs.type == NVS_Emulated ? &physical_nvs : &hal.nvs;
 80162b6:	4803      	ldr	r0, [pc, #12]	; (80162c4 <nvs_buffer_get_physical+0x1c>)
 80162b8:	4770      	bx	lr
 80162ba:	bf00      	nop
 80162bc:	2000350c 	.word	0x2000350c
 80162c0:	20003650 	.word	0x20003650
 80162c4:	200037a0 	.word	0x200037a0

080162c8 <enqueue_feed_override>:

static override_queue_t feed = {0}, spindle = {0}, coolant = {0};

ISR_CODE void ISR_FUNC(enqueue_feed_override)(uint8_t cmd)
{
    uint_fast8_t bptr = (feed.head + 1) & (OVERRIDE_BUFSIZE - 1);    // Get next head pointer
 80162c8:	4a06      	ldr	r2, [pc, #24]	; (80162e4 <enqueue_feed_override+0x1c>)
 80162ca:	6813      	ldr	r3, [r2, #0]
 80162cc:	3301      	adds	r3, #1
 80162ce:	f003 030f 	and.w	r3, r3, #15

    if(bptr != feed.tail) {         // If not buffer full
 80162d2:	6852      	ldr	r2, [r2, #4]
 80162d4:	429a      	cmp	r2, r3
 80162d6:	d004      	beq.n	80162e2 <enqueue_feed_override+0x1a>
        feed.buf[feed.head] = cmd;  // add data to buffer
 80162d8:	4a02      	ldr	r2, [pc, #8]	; (80162e4 <enqueue_feed_override+0x1c>)
 80162da:	6811      	ldr	r1, [r2, #0]
 80162dc:	4411      	add	r1, r2
 80162de:	7208      	strb	r0, [r1, #8]
        feed.head = bptr;           // and update pointer
 80162e0:	6013      	str	r3, [r2, #0]
    }
}
 80162e2:	4770      	bx	lr
 80162e4:	200037ec 	.word	0x200037ec

080162e8 <get_feed_override>:

// Returns 0 if no commands enqueued
uint8_t get_feed_override (void)
{
    uint8_t data = 0;
    uint_fast8_t bptr = feed.tail;
 80162e8:	4a07      	ldr	r2, [pc, #28]	; (8016308 <get_feed_override+0x20>)
 80162ea:	6853      	ldr	r3, [r2, #4]

    if(bptr != feed.head) {
 80162ec:	6812      	ldr	r2, [r2, #0]
 80162ee:	429a      	cmp	r2, r3
 80162f0:	d007      	beq.n	8016302 <get_feed_override+0x1a>
        data = feed.buf[bptr++];                    // Get next character, increment tmp pointer
 80162f2:	1c5a      	adds	r2, r3, #1
 80162f4:	4904      	ldr	r1, [pc, #16]	; (8016308 <get_feed_override+0x20>)
 80162f6:	440b      	add	r3, r1
 80162f8:	7a18      	ldrb	r0, [r3, #8]
        feed.tail = bptr & (OVERRIDE_BUFSIZE - 1);  // and update pointer
 80162fa:	f002 020f 	and.w	r2, r2, #15
 80162fe:	604a      	str	r2, [r1, #4]
 8016300:	4770      	bx	lr
    uint8_t data = 0;
 8016302:	2000      	movs	r0, #0
    }

    return data;
}
 8016304:	4770      	bx	lr
 8016306:	bf00      	nop
 8016308:	200037ec 	.word	0x200037ec

0801630c <enqueue_spindle_override>:

ISR_CODE void ISR_FUNC(enqueue_spindle_override)(uint8_t cmd)
{
    uint_fast8_t bptr = (spindle.head + 1) & (OVERRIDE_BUFSIZE - 1);    // Get next head pointer
 801630c:	4a06      	ldr	r2, [pc, #24]	; (8016328 <enqueue_spindle_override+0x1c>)
 801630e:	6813      	ldr	r3, [r2, #0]
 8016310:	3301      	adds	r3, #1
 8016312:	f003 030f 	and.w	r3, r3, #15

    if(bptr != spindle.tail) {              // If not buffer full
 8016316:	6852      	ldr	r2, [r2, #4]
 8016318:	429a      	cmp	r2, r3
 801631a:	d004      	beq.n	8016326 <enqueue_spindle_override+0x1a>
        spindle.buf[spindle.head] = cmd;    // add data to buffer
 801631c:	4a02      	ldr	r2, [pc, #8]	; (8016328 <enqueue_spindle_override+0x1c>)
 801631e:	6811      	ldr	r1, [r2, #0]
 8016320:	4411      	add	r1, r2
 8016322:	7208      	strb	r0, [r1, #8]
        spindle.head = bptr;                // and update pointer
 8016324:	6013      	str	r3, [r2, #0]
    }
}
 8016326:	4770      	bx	lr
 8016328:	20003804 	.word	0x20003804

0801632c <get_spindle_override>:

// Returns 0 if no commands enqueued
uint8_t get_spindle_override (void)
{
    uint8_t data = 0;
    uint_fast8_t bptr = spindle.tail;
 801632c:	4a07      	ldr	r2, [pc, #28]	; (801634c <get_spindle_override+0x20>)
 801632e:	6853      	ldr	r3, [r2, #4]

    if(bptr != spindle.head) {
 8016330:	6812      	ldr	r2, [r2, #0]
 8016332:	429a      	cmp	r2, r3
 8016334:	d007      	beq.n	8016346 <get_spindle_override+0x1a>
        data = spindle.buf[bptr++];                     // Get next character, increment tmp pointer
 8016336:	1c5a      	adds	r2, r3, #1
 8016338:	4904      	ldr	r1, [pc, #16]	; (801634c <get_spindle_override+0x20>)
 801633a:	440b      	add	r3, r1
 801633c:	7a18      	ldrb	r0, [r3, #8]
        spindle.tail = bptr & (OVERRIDE_BUFSIZE - 1);   // and update pointer
 801633e:	f002 020f 	and.w	r2, r2, #15
 8016342:	604a      	str	r2, [r1, #4]
 8016344:	4770      	bx	lr
    uint8_t data = 0;
 8016346:	2000      	movs	r0, #0
    }

    return data;
}
 8016348:	4770      	bx	lr
 801634a:	bf00      	nop
 801634c:	20003804 	.word	0x20003804

08016350 <enqueue_coolant_override>:

ISR_CODE void ISR_FUNC(enqueue_coolant_override)(uint8_t cmd)
{
    uint_fast8_t bptr = (coolant.head + 1) & (OVERRIDE_BUFSIZE - 1);    // Get next head pointer
 8016350:	4a06      	ldr	r2, [pc, #24]	; (801636c <enqueue_coolant_override+0x1c>)
 8016352:	6813      	ldr	r3, [r2, #0]
 8016354:	3301      	adds	r3, #1
 8016356:	f003 030f 	and.w	r3, r3, #15

    if(bptr != coolant.tail) {              // If not buffer full
 801635a:	6852      	ldr	r2, [r2, #4]
 801635c:	429a      	cmp	r2, r3
 801635e:	d004      	beq.n	801636a <enqueue_coolant_override+0x1a>
        coolant.buf[coolant.head] = cmd;    // add data to buffer
 8016360:	4a02      	ldr	r2, [pc, #8]	; (801636c <enqueue_coolant_override+0x1c>)
 8016362:	6811      	ldr	r1, [r2, #0]
 8016364:	4411      	add	r1, r2
 8016366:	7208      	strb	r0, [r1, #8]
        coolant.head = bptr;                // and update pointer
 8016368:	6013      	str	r3, [r2, #0]
    }
}
 801636a:	4770      	bx	lr
 801636c:	200037d4 	.word	0x200037d4

08016370 <get_coolant_override>:

// Returns 0 if no commands enqueued
uint8_t get_coolant_override (void)
{
    uint8_t data = 0;
    uint_fast8_t bptr = coolant.tail;
 8016370:	4a07      	ldr	r2, [pc, #28]	; (8016390 <get_coolant_override+0x20>)
 8016372:	6853      	ldr	r3, [r2, #4]

    if(bptr != coolant.head) {
 8016374:	6812      	ldr	r2, [r2, #0]
 8016376:	429a      	cmp	r2, r3
 8016378:	d007      	beq.n	801638a <get_coolant_override+0x1a>
        data = coolant.buf[bptr++];                   // Get next character, increment tmp pointer
 801637a:	1c5a      	adds	r2, r3, #1
 801637c:	4904      	ldr	r1, [pc, #16]	; (8016390 <get_coolant_override+0x20>)
 801637e:	440b      	add	r3, r1
 8016380:	7a18      	ldrb	r0, [r3, #8]
        coolant.tail = bptr & (OVERRIDE_BUFSIZE - 1); // and update pointer
 8016382:	f002 020f 	and.w	r2, r2, #15
 8016386:	604a      	str	r2, [r1, #4]
 8016388:	4770      	bx	lr
    uint8_t data = 0;
 801638a:	2000      	movs	r0, #0
    }

    return data;
}
 801638c:	4770      	bx	lr
 801638e:	bf00      	nop
 8016390:	200037d4 	.word	0x200037d4

08016394 <flush_override_buffers>:

void flush_override_buffers (void)
{
    feed.head = feed.tail = spindle.head = spindle.tail = coolant.head = coolant.tail = 0;
 8016394:	4a05      	ldr	r2, [pc, #20]	; (80163ac <flush_override_buffers+0x18>)
 8016396:	2300      	movs	r3, #0
 8016398:	6053      	str	r3, [r2, #4]
 801639a:	6013      	str	r3, [r2, #0]
 801639c:	4a04      	ldr	r2, [pc, #16]	; (80163b0 <flush_override_buffers+0x1c>)
 801639e:	6053      	str	r3, [r2, #4]
 80163a0:	6013      	str	r3, [r2, #0]
 80163a2:	4a04      	ldr	r2, [pc, #16]	; (80163b4 <flush_override_buffers+0x20>)
 80163a4:	6053      	str	r3, [r2, #4]
 80163a6:	6013      	str	r3, [r2, #0]
}
 80163a8:	4770      	bx	lr
 80163aa:	bf00      	nop
 80163ac:	200037d4 	.word	0x200037d4
 80163b0:	20003804 	.word	0x20003804
 80163b4:	200037ec 	.word	0x200037ec

080163b8 <planner_warning>:
    next_buffer_head = block_buffer_head->next;             // = next block
    block_buffer_planned = block_buffer_tail;               // = block_buffer_tail
}

static void planner_warning (sys_state_t state)
{
 80163b8:	b508      	push	{r3, lr}
    report_message("Planner buffer size was reduced!", Message_Plain);
 80163ba:	2100      	movs	r1, #0
 80163bc:	4801      	ldr	r0, [pc, #4]	; (80163c4 <planner_warning+0xc>)
 80163be:	f002 ff33 	bl	8019228 <report_message>
}
 80163c2:	bd08      	pop	{r3, pc}
 80163c4:	0802728c 	.word	0x0802728c

080163c8 <planner_recalculate>:
{
 80163c8:	b570      	push	{r4, r5, r6, lr}
    plan_block_t *block = block_buffer_head->prev;
 80163ca:	4b42      	ldr	r3, [pc, #264]	; (80164d4 <planner_recalculate+0x10c>)
 80163cc:	681b      	ldr	r3, [r3, #0]
 80163ce:	6d1e      	ldr	r6, [r3, #80]	; 0x50
    if (block == block_buffer_planned)
 80163d0:	4b41      	ldr	r3, [pc, #260]	; (80164d8 <planner_recalculate+0x110>)
 80163d2:	681b      	ldr	r3, [r3, #0]
 80163d4:	42b3      	cmp	r3, r6
 80163d6:	d07b      	beq.n	80164d0 <planner_recalculate+0x108>
    current->entry_speed_sqr = min(current->max_entry_speed_sqr, 2.0f * current->acceleration * current->millimeters);
 80163d8:	ed96 7a08 	vldr	s14, [r6, #32]
 80163dc:	edd6 7a09 	vldr	s15, [r6, #36]	; 0x24
 80163e0:	ee77 7aa7 	vadd.f32	s15, s15, s15
 80163e4:	edd6 6a0a 	vldr	s13, [r6, #40]	; 0x28
 80163e8:	ee67 7aa6 	vmul.f32	s15, s15, s13
 80163ec:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80163f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80163f4:	d501      	bpl.n	80163fa <planner_recalculate+0x32>
 80163f6:	eef0 7a47 	vmov.f32	s15, s14
 80163fa:	edc6 7a07 	vstr	s15, [r6, #28]
    block = block->prev;
 80163fe:	6d34      	ldr	r4, [r6, #80]	; 0x50
    if (block == block_buffer_planned) { // Only two plannable blocks in buffer. Reverse pass complete.
 8016400:	42a3      	cmp	r3, r4
 8016402:	d111      	bne.n	8016428 <planner_recalculate+0x60>
        if (block == block_buffer_tail)
 8016404:	4b35      	ldr	r3, [pc, #212]	; (80164dc <planner_recalculate+0x114>)
 8016406:	681b      	ldr	r3, [r3, #0]
 8016408:	42a3      	cmp	r3, r4
 801640a:	d003      	beq.n	8016414 <planner_recalculate+0x4c>
    next = block_buffer_planned; // Begin at buffer planned pointer
 801640c:	4b32      	ldr	r3, [pc, #200]	; (80164d8 <planner_recalculate+0x110>)
 801640e:	681a      	ldr	r2, [r3, #0]
    block = block_buffer_planned->next;
 8016410:	6d53      	ldr	r3, [r2, #84]	; 0x54
    while (block != block_buffer_head) {
 8016412:	e03c      	b.n	801648e <planner_recalculate+0xc6>
            st_update_plan_block_parameters();
 8016414:	f008 ff40 	bl	801f298 <st_update_plan_block_parameters>
 8016418:	e7f8      	b.n	801640c <planner_recalculate+0x44>
            st_update_plan_block_parameters();
 801641a:	f008 ff3d 	bl	801f298 <st_update_plan_block_parameters>
 801641e:	e00c      	b.n	801643a <planner_recalculate+0x72>
            current->entry_speed_sqr = entry_speed_sqr < current->max_entry_speed_sqr ? entry_speed_sqr : current->max_entry_speed_sqr;
 8016420:	ed84 7a07 	vstr	s14, [r4, #28]
 8016424:	4626      	mov	r6, r4
 8016426:	462c      	mov	r4, r5
    } else while (block != block_buffer_planned) { // Three or more plan-able blocks
 8016428:	4b2b      	ldr	r3, [pc, #172]	; (80164d8 <planner_recalculate+0x110>)
 801642a:	681b      	ldr	r3, [r3, #0]
 801642c:	42a3      	cmp	r3, r4
 801642e:	d0ed      	beq.n	801640c <planner_recalculate+0x44>
        block = block->prev;
 8016430:	6d25      	ldr	r5, [r4, #80]	; 0x50
        if (block == block_buffer_tail)
 8016432:	4b2a      	ldr	r3, [pc, #168]	; (80164dc <planner_recalculate+0x114>)
 8016434:	681b      	ldr	r3, [r3, #0]
 8016436:	42ab      	cmp	r3, r5
 8016438:	d0ef      	beq.n	801641a <planner_recalculate+0x52>
        if (current->entry_speed_sqr != current->max_entry_speed_sqr) {
 801643a:	edd4 7a07 	vldr	s15, [r4, #28]
 801643e:	ed94 7a08 	vldr	s14, [r4, #32]
 8016442:	eef4 7a47 	vcmp.f32	s15, s14
 8016446:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801644a:	d0eb      	beq.n	8016424 <planner_recalculate+0x5c>
            entry_speed_sqr = next->entry_speed_sqr + 2.0f * current->acceleration * current->millimeters;
 801644c:	edd6 6a07 	vldr	s13, [r6, #28]
 8016450:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
 8016454:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8016458:	ed94 6a0a 	vldr	s12, [r4, #40]	; 0x28
 801645c:	ee67 7a86 	vmul.f32	s15, s15, s12
 8016460:	ee76 7aa7 	vadd.f32	s15, s13, s15
            current->entry_speed_sqr = entry_speed_sqr < current->max_entry_speed_sqr ? entry_speed_sqr : current->max_entry_speed_sqr;
 8016464:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8016468:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801646c:	ddd8      	ble.n	8016420 <planner_recalculate+0x58>
 801646e:	eeb0 7a67 	vmov.f32	s14, s15
 8016472:	e7d5      	b.n	8016420 <planner_recalculate+0x58>
        if (next->entry_speed_sqr == next->max_entry_speed_sqr)
 8016474:	ed93 7a07 	vldr	s14, [r3, #28]
 8016478:	edd3 7a08 	vldr	s15, [r3, #32]
 801647c:	eeb4 7a67 	vcmp.f32	s14, s15
 8016480:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016484:	d101      	bne.n	801648a <planner_recalculate+0xc2>
            block_buffer_planned = block;
 8016486:	4a14      	ldr	r2, [pc, #80]	; (80164d8 <planner_recalculate+0x110>)
 8016488:	6013      	str	r3, [r2, #0]
        next = block;
 801648a:	461a      	mov	r2, r3
        block = block->next;
 801648c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    while (block != block_buffer_head) {
 801648e:	4911      	ldr	r1, [pc, #68]	; (80164d4 <planner_recalculate+0x10c>)
 8016490:	6809      	ldr	r1, [r1, #0]
 8016492:	4299      	cmp	r1, r3
 8016494:	d01c      	beq.n	80164d0 <planner_recalculate+0x108>
        if (current->entry_speed_sqr < next->entry_speed_sqr) {
 8016496:	edd2 7a07 	vldr	s15, [r2, #28]
 801649a:	edd3 6a07 	vldr	s13, [r3, #28]
 801649e:	eef4 7ae6 	vcmpe.f32	s15, s13
 80164a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80164a6:	d5e5      	bpl.n	8016474 <planner_recalculate+0xac>
            entry_speed_sqr = current->entry_speed_sqr + 2.0f * current->acceleration * current->millimeters;
 80164a8:	ed92 7a09 	vldr	s14, [r2, #36]	; 0x24
 80164ac:	ee37 7a07 	vadd.f32	s14, s14, s14
 80164b0:	ed92 6a0a 	vldr	s12, [r2, #40]	; 0x28
 80164b4:	ee27 7a06 	vmul.f32	s14, s14, s12
 80164b8:	ee77 7a87 	vadd.f32	s15, s15, s14
            if (entry_speed_sqr < next->entry_speed_sqr) {
 80164bc:	eef4 6ae7 	vcmpe.f32	s13, s15
 80164c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80164c4:	ddd6      	ble.n	8016474 <planner_recalculate+0xac>
                next->entry_speed_sqr = entry_speed_sqr; // Always <= max_entry_speed_sqr. Backward pass sets this.
 80164c6:	edc3 7a07 	vstr	s15, [r3, #28]
                block_buffer_planned = block; // Set optimal plan pointer.
 80164ca:	4a03      	ldr	r2, [pc, #12]	; (80164d8 <planner_recalculate+0x110>)
 80164cc:	6013      	str	r3, [r2, #0]
 80164ce:	e7d1      	b.n	8016474 <planner_recalculate+0xac>
}
 80164d0:	bd70      	pop	{r4, r5, r6, pc}
 80164d2:	bf00      	nop
 80164d4:	20003820 	.word	0x20003820
 80164d8:	20003824 	.word	0x20003824
 80164dc:	2000382c 	.word	0x2000382c

080164e0 <plan_get_buffer_size>:

uint_fast16_t plan_get_buffer_size (void)
{
    return block_buffer_size;
}
 80164e0:	4b01      	ldr	r3, [pc, #4]	; (80164e8 <plan_get_buffer_size+0x8>)
 80164e2:	6818      	ldr	r0, [r3, #0]
 80164e4:	4770      	bx	lr
 80164e6:	bf00      	nop
 80164e8:	20003828 	.word	0x20003828

080164ec <plan_reset>:

bool plan_reset (void)
{
 80164ec:	b538      	push	{r3, r4, r5, lr}
    if(block_buffer == NULL) {
 80164ee:	4b50      	ldr	r3, [pc, #320]	; (8016630 <plan_reset+0x144>)
 80164f0:	681b      	ldr	r3, [r3, #0]
 80164f2:	b173      	cbz	r3, 8016512 <plan_reset+0x26>
            else
                break;
        }
    }

    if(block_buffer_size != settings.planner_buffer_blocks)
 80164f4:	4b4f      	ldr	r3, [pc, #316]	; (8016634 <plan_reset+0x148>)
 80164f6:	8ada      	ldrh	r2, [r3, #22]
 80164f8:	4b4f      	ldr	r3, [pc, #316]	; (8016638 <plan_reset+0x14c>)
 80164fa:	681b      	ldr	r3, [r3, #0]
 80164fc:	429a      	cmp	r2, r3
 80164fe:	d122      	bne.n	8016546 <plan_reset+0x5a>
        protocol_enqueue_rt_command(planner_warning);

    if(block_buffer == NULL)
 8016500:	4b4b      	ldr	r3, [pc, #300]	; (8016630 <plan_reset+0x144>)
 8016502:	681b      	ldr	r3, [r3, #0]
 8016504:	2b00      	cmp	r3, #0
 8016506:	f000 8090 	beq.w	801662a <plan_reset+0x13e>
        return false;

    if(block_buffer_tail) {
 801650a:	4b4c      	ldr	r3, [pc, #304]	; (801663c <plan_reset+0x150>)
 801650c:	681b      	ldr	r3, [r3, #0]
 801650e:	bb4b      	cbnz	r3, 8016564 <plan_reset+0x78>
 8016510:	e039      	b.n	8016586 <plan_reset+0x9a>
        block_buffer_size = settings.planner_buffer_blocks;
 8016512:	4b48      	ldr	r3, [pc, #288]	; (8016634 <plan_reset+0x148>)
 8016514:	8ada      	ldrh	r2, [r3, #22]
 8016516:	4b48      	ldr	r3, [pc, #288]	; (8016638 <plan_reset+0x14c>)
 8016518:	601a      	str	r2, [r3, #0]
        while((block_buffer = malloc((block_buffer_size + 1) * sizeof(plan_block_t))) == NULL) {
 801651a:	4b47      	ldr	r3, [pc, #284]	; (8016638 <plan_reset+0x14c>)
 801651c:	681c      	ldr	r4, [r3, #0]
 801651e:	2058      	movs	r0, #88	; 0x58
 8016520:	fb04 0000 	mla	r0, r4, r0, r0
 8016524:	f00b ffc4 	bl	80224b0 <malloc>
 8016528:	4b41      	ldr	r3, [pc, #260]	; (8016630 <plan_reset+0x144>)
 801652a:	6018      	str	r0, [r3, #0]
 801652c:	2800      	cmp	r0, #0
 801652e:	d1e1      	bne.n	80164f4 <plan_reset+0x8>
            if(block_buffer_size > 40)
 8016530:	2c28      	cmp	r4, #40	; 0x28
 8016532:	d9df      	bls.n	80164f4 <plan_reset+0x8>
                block_buffer_size -= block_buffer_size >= 250 ? 100 : 10;
 8016534:	2cf9      	cmp	r4, #249	; 0xf9
 8016536:	d904      	bls.n	8016542 <plan_reset+0x56>
 8016538:	2364      	movs	r3, #100	; 0x64
 801653a:	1ae4      	subs	r4, r4, r3
 801653c:	4b3e      	ldr	r3, [pc, #248]	; (8016638 <plan_reset+0x14c>)
 801653e:	601c      	str	r4, [r3, #0]
 8016540:	e7eb      	b.n	801651a <plan_reset+0x2e>
 8016542:	230a      	movs	r3, #10
 8016544:	e7f9      	b.n	801653a <plan_reset+0x4e>
        protocol_enqueue_rt_command(planner_warning);
 8016546:	483e      	ldr	r0, [pc, #248]	; (8016640 <plan_reset+0x154>)
 8016548:	f001 fd90 	bl	801806c <protocol_enqueue_rt_command>
 801654c:	e7d8      	b.n	8016500 <plan_reset+0x14>
        output_command_t *next = block->output_commands->next;
 801654e:	6885      	ldr	r5, [r0, #8]
        free(block->output_commands);
 8016550:	f00b ffb6 	bl	80224c0 <free>
        block->output_commands = next;
 8016554:	64e5      	str	r5, [r4, #76]	; 0x4c
    while(block->output_commands) {
 8016556:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8016558:	2800      	cmp	r0, #0
 801655a:	d1f8      	bne.n	801654e <plan_reset+0x62>
        // Free memory for any pending messages and output commands after soft reset
        while(block_buffer_tail != block_buffer_head) {
            plan_cleanup(block_buffer_tail);
            block_buffer_tail = block_buffer_tail->next;
 801655c:	4b37      	ldr	r3, [pc, #220]	; (801663c <plan_reset+0x150>)
 801655e:	681a      	ldr	r2, [r3, #0]
 8016560:	6d52      	ldr	r2, [r2, #84]	; 0x54
 8016562:	601a      	str	r2, [r3, #0]
        while(block_buffer_tail != block_buffer_head) {
 8016564:	4b35      	ldr	r3, [pc, #212]	; (801663c <plan_reset+0x150>)
 8016566:	681c      	ldr	r4, [r3, #0]
 8016568:	4b36      	ldr	r3, [pc, #216]	; (8016644 <plan_reset+0x158>)
 801656a:	681b      	ldr	r3, [r3, #0]
 801656c:	429c      	cmp	r4, r3
 801656e:	d007      	beq.n	8016580 <plan_reset+0x94>
    if(block->message) {
 8016570:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 8016572:	2800      	cmp	r0, #0
 8016574:	d0ef      	beq.n	8016556 <plan_reset+0x6a>
        free(block->message);
 8016576:	f00b ffa3 	bl	80224c0 <free>
        block->message = NULL;
 801657a:	2300      	movs	r3, #0
 801657c:	64a3      	str	r3, [r4, #72]	; 0x48
 801657e:	e7ea      	b.n	8016556 <plan_reset+0x6a>
        }
        block_buffer_tail = NULL;
 8016580:	4b2e      	ldr	r3, [pc, #184]	; (801663c <plan_reset+0x150>)
 8016582:	2200      	movs	r2, #0
 8016584:	601a      	str	r2, [r3, #0]
    }

    memset(&pl, 0, sizeof(planner_t)); // Clear planner struct
 8016586:	4a30      	ldr	r2, [pc, #192]	; (8016648 <plan_reset+0x15c>)
 8016588:	2300      	movs	r3, #0
 801658a:	6013      	str	r3, [r2, #0]
 801658c:	6053      	str	r3, [r2, #4]
 801658e:	6093      	str	r3, [r2, #8]
 8016590:	60d3      	str	r3, [r2, #12]
 8016592:	6113      	str	r3, [r2, #16]
 8016594:	6153      	str	r3, [r2, #20]
 8016596:	6193      	str	r3, [r2, #24]

    // Set up stepper block ringbuffer as circular doubly linked list
    uint_fast8_t idx;
    for(idx = 0 ; idx <= block_buffer_size ; idx++) {
 8016598:	e010      	b.n	80165bc <plan_reset+0xd0>
        block_buffer[idx].prev = &block_buffer[idx == 0 ? block_buffer_size : idx - 1];
 801659a:	2258      	movs	r2, #88	; 0x58
 801659c:	fb03 f202 	mul.w	r2, r3, r2
 80165a0:	3a58      	subs	r2, #88	; 0x58
 80165a2:	2058      	movs	r0, #88	; 0x58
 80165a4:	fb00 1003 	mla	r0, r0, r3, r1
 80165a8:	440a      	add	r2, r1
 80165aa:	6502      	str	r2, [r0, #80]	; 0x50
        block_buffer[idx].next = &block_buffer[idx == block_buffer_size ? 0 : idx + 1];
 80165ac:	429c      	cmp	r4, r3
 80165ae:	d011      	beq.n	80165d4 <plan_reset+0xe8>
 80165b0:	2258      	movs	r2, #88	; 0x58
 80165b2:	fb03 2202 	mla	r2, r3, r2, r2
 80165b6:	4411      	add	r1, r2
 80165b8:	6541      	str	r1, [r0, #84]	; 0x54
    for(idx = 0 ; idx <= block_buffer_size ; idx++) {
 80165ba:	3301      	adds	r3, #1
 80165bc:	4a1e      	ldr	r2, [pc, #120]	; (8016638 <plan_reset+0x14c>)
 80165be:	6814      	ldr	r4, [r2, #0]
 80165c0:	429c      	cmp	r4, r3
 80165c2:	d309      	bcc.n	80165d8 <plan_reset+0xec>
        block_buffer[idx].prev = &block_buffer[idx == 0 ? block_buffer_size : idx - 1];
 80165c4:	4a1a      	ldr	r2, [pc, #104]	; (8016630 <plan_reset+0x144>)
 80165c6:	6811      	ldr	r1, [r2, #0]
 80165c8:	2b00      	cmp	r3, #0
 80165ca:	d1e6      	bne.n	801659a <plan_reset+0xae>
 80165cc:	2258      	movs	r2, #88	; 0x58
 80165ce:	fb04 f202 	mul.w	r2, r4, r2
 80165d2:	e7e6      	b.n	80165a2 <plan_reset+0xb6>
        block_buffer[idx].next = &block_buffer[idx == block_buffer_size ? 0 : idx + 1];
 80165d4:	2200      	movs	r2, #0
 80165d6:	e7ee      	b.n	80165b6 <plan_reset+0xca>
    if(block_buffer_tail) {
 80165d8:	4b18      	ldr	r3, [pc, #96]	; (801663c <plan_reset+0x150>)
 80165da:	681b      	ldr	r3, [r3, #0]
 80165dc:	b9bb      	cbnz	r3, 801660e <plan_reset+0x122>
    block_buffer_tail = block_buffer_head = block_buffer;   // Empty = tail == head
 80165de:	4b14      	ldr	r3, [pc, #80]	; (8016630 <plan_reset+0x144>)
 80165e0:	681b      	ldr	r3, [r3, #0]
 80165e2:	4a18      	ldr	r2, [pc, #96]	; (8016644 <plan_reset+0x158>)
 80165e4:	6013      	str	r3, [r2, #0]
 80165e6:	4a15      	ldr	r2, [pc, #84]	; (801663c <plan_reset+0x150>)
 80165e8:	6013      	str	r3, [r2, #0]
    next_buffer_head = block_buffer_head->next;             // = next block
 80165ea:	6d59      	ldr	r1, [r3, #84]	; 0x54
 80165ec:	4a17      	ldr	r2, [pc, #92]	; (801664c <plan_reset+0x160>)
 80165ee:	6011      	str	r1, [r2, #0]
    block_buffer_planned = block_buffer_tail;               // = block_buffer_tail
 80165f0:	4a17      	ldr	r2, [pc, #92]	; (8016650 <plan_reset+0x164>)
 80165f2:	6013      	str	r3, [r2, #0]
    }

    plan_reset_buffer();

    return true;
 80165f4:	2001      	movs	r0, #1
}
 80165f6:	bd38      	pop	{r3, r4, r5, pc}
        output_command_t *next = block->output_commands->next;
 80165f8:	6885      	ldr	r5, [r0, #8]
        free(block->output_commands);
 80165fa:	f00b ff61 	bl	80224c0 <free>
        block->output_commands = next;
 80165fe:	64e5      	str	r5, [r4, #76]	; 0x4c
    while(block->output_commands) {
 8016600:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8016602:	2800      	cmp	r0, #0
 8016604:	d1f8      	bne.n	80165f8 <plan_reset+0x10c>
            block_buffer_tail = block_buffer_tail->next;
 8016606:	4b0d      	ldr	r3, [pc, #52]	; (801663c <plan_reset+0x150>)
 8016608:	681a      	ldr	r2, [r3, #0]
 801660a:	6d52      	ldr	r2, [r2, #84]	; 0x54
 801660c:	601a      	str	r2, [r3, #0]
        while(block_buffer_tail != block_buffer_head) {
 801660e:	4b0b      	ldr	r3, [pc, #44]	; (801663c <plan_reset+0x150>)
 8016610:	681c      	ldr	r4, [r3, #0]
 8016612:	4b0c      	ldr	r3, [pc, #48]	; (8016644 <plan_reset+0x158>)
 8016614:	681b      	ldr	r3, [r3, #0]
 8016616:	429c      	cmp	r4, r3
 8016618:	d0e1      	beq.n	80165de <plan_reset+0xf2>
    if(block->message) {
 801661a:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 801661c:	2800      	cmp	r0, #0
 801661e:	d0ef      	beq.n	8016600 <plan_reset+0x114>
        free(block->message);
 8016620:	f00b ff4e 	bl	80224c0 <free>
        block->message = NULL;
 8016624:	2300      	movs	r3, #0
 8016626:	64a3      	str	r3, [r4, #72]	; 0x48
 8016628:	e7ea      	b.n	8016600 <plan_reset+0x114>
        return false;
 801662a:	2000      	movs	r0, #0
 801662c:	e7e3      	b.n	80165f6 <plan_reset+0x10a>
 801662e:	bf00      	nop
 8016630:	2000381c 	.word	0x2000381c
 8016634:	20003b14 	.word	0x20003b14
 8016638:	20003828 	.word	0x20003828
 801663c:	2000382c 	.word	0x2000382c
 8016640:	080163b9 	.word	0x080163b9
 8016644:	20003820 	.word	0x20003820
 8016648:	20003834 	.word	0x20003834
 801664c:	20003830 	.word	0x20003830
 8016650:	20003824 	.word	0x20003824

08016654 <plan_discard_current_block>:


void plan_discard_current_block (void)
{
 8016654:	b538      	push	{r3, r4, r5, lr}
    if (block_buffer_tail != block_buffer_head) { // Discard non-empty buffer.
 8016656:	4b11      	ldr	r3, [pc, #68]	; (801669c <plan_discard_current_block+0x48>)
 8016658:	681c      	ldr	r4, [r3, #0]
 801665a:	4b11      	ldr	r3, [pc, #68]	; (80166a0 <plan_discard_current_block+0x4c>)
 801665c:	681b      	ldr	r3, [r3, #0]
 801665e:	429c      	cmp	r4, r3
 8016660:	d016      	beq.n	8016690 <plan_discard_current_block+0x3c>
    if(block->message) {
 8016662:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 8016664:	b140      	cbz	r0, 8016678 <plan_discard_current_block+0x24>
        free(block->message);
 8016666:	f00b ff2b 	bl	80224c0 <free>
        block->message = NULL;
 801666a:	2300      	movs	r3, #0
 801666c:	64a3      	str	r3, [r4, #72]	; 0x48
 801666e:	e003      	b.n	8016678 <plan_discard_current_block+0x24>
        output_command_t *next = block->output_commands->next;
 8016670:	6885      	ldr	r5, [r0, #8]
        free(block->output_commands);
 8016672:	f00b ff25 	bl	80224c0 <free>
        block->output_commands = next;
 8016676:	64e5      	str	r5, [r4, #76]	; 0x4c
    while(block->output_commands) {
 8016678:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 801667a:	2800      	cmp	r0, #0
 801667c:	d1f8      	bne.n	8016670 <plan_discard_current_block+0x1c>
        plan_cleanup(block_buffer_tail);
        // Push block_buffer_planned pointer, if encountered.
        if (block_buffer_tail == block_buffer_planned)
 801667e:	4b07      	ldr	r3, [pc, #28]	; (801669c <plan_discard_current_block+0x48>)
 8016680:	681b      	ldr	r3, [r3, #0]
 8016682:	4a08      	ldr	r2, [pc, #32]	; (80166a4 <plan_discard_current_block+0x50>)
 8016684:	6812      	ldr	r2, [r2, #0]
 8016686:	4293      	cmp	r3, r2
 8016688:	d003      	beq.n	8016692 <plan_discard_current_block+0x3e>
            block_buffer_planned = block_buffer_tail->next;
        block_buffer_tail = block_buffer_tail->next;
 801668a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801668c:	4b03      	ldr	r3, [pc, #12]	; (801669c <plan_discard_current_block+0x48>)
 801668e:	601a      	str	r2, [r3, #0]
    }
}
 8016690:	bd38      	pop	{r3, r4, r5, pc}
            block_buffer_planned = block_buffer_tail->next;
 8016692:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8016694:	4a03      	ldr	r2, [pc, #12]	; (80166a4 <plan_discard_current_block+0x50>)
 8016696:	6011      	str	r1, [r2, #0]
 8016698:	e7f7      	b.n	801668a <plan_discard_current_block+0x36>
 801669a:	bf00      	nop
 801669c:	2000382c 	.word	0x2000382c
 80166a0:	20003820 	.word	0x20003820
 80166a4:	20003824 	.word	0x20003824

080166a8 <plan_get_system_motion_block>:

// Returns address of planner buffer block used by system motions. Called by segment generator.
plan_block_t *plan_get_system_motion_block (void)
{
    return block_buffer_head;
}
 80166a8:	4b01      	ldr	r3, [pc, #4]	; (80166b0 <plan_get_system_motion_block+0x8>)
 80166aa:	6818      	ldr	r0, [r3, #0]
 80166ac:	4770      	bx	lr
 80166ae:	bf00      	nop
 80166b0:	20003820 	.word	0x20003820

080166b4 <plan_get_current_block>:


// Returns address of first planner block, if available. Called by various main program functions.
plan_block_t *plan_get_current_block (void)
{
    return block_buffer_head == block_buffer_tail ? NULL : block_buffer_tail;
 80166b4:	4b04      	ldr	r3, [pc, #16]	; (80166c8 <plan_get_current_block+0x14>)
 80166b6:	681b      	ldr	r3, [r3, #0]
 80166b8:	4a04      	ldr	r2, [pc, #16]	; (80166cc <plan_get_current_block+0x18>)
 80166ba:	6810      	ldr	r0, [r2, #0]
 80166bc:	4283      	cmp	r3, r0
 80166be:	d000      	beq.n	80166c2 <plan_get_current_block+0xe>
}
 80166c0:	4770      	bx	lr
    return block_buffer_head == block_buffer_tail ? NULL : block_buffer_tail;
 80166c2:	2000      	movs	r0, #0
 80166c4:	e7fc      	b.n	80166c0 <plan_get_current_block+0xc>
 80166c6:	bf00      	nop
 80166c8:	20003820 	.word	0x20003820
 80166cc:	2000382c 	.word	0x2000382c

080166d0 <plan_get_exec_block_exit_speed_sqr>:


inline float plan_get_exec_block_exit_speed_sqr (void)
{
    plan_block_t *block = block_buffer_tail->next;
 80166d0:	4b06      	ldr	r3, [pc, #24]	; (80166ec <plan_get_exec_block_exit_speed_sqr+0x1c>)
 80166d2:	681b      	ldr	r3, [r3, #0]
 80166d4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    return block == block_buffer_head ? 0.0f : block->entry_speed_sqr;
 80166d6:	4a06      	ldr	r2, [pc, #24]	; (80166f0 <plan_get_exec_block_exit_speed_sqr+0x20>)
 80166d8:	6812      	ldr	r2, [r2, #0]
 80166da:	429a      	cmp	r2, r3
 80166dc:	d002      	beq.n	80166e4 <plan_get_exec_block_exit_speed_sqr+0x14>
 80166de:	ed93 0a07 	vldr	s0, [r3, #28]
 80166e2:	4770      	bx	lr
 80166e4:	ed9f 0a03 	vldr	s0, [pc, #12]	; 80166f4 <plan_get_exec_block_exit_speed_sqr+0x24>
}
 80166e8:	4770      	bx	lr
 80166ea:	bf00      	nop
 80166ec:	2000382c 	.word	0x2000382c
 80166f0:	20003820 	.word	0x20003820
 80166f4:	00000000 	.word	0x00000000

080166f8 <plan_check_full_buffer>:


// Returns the availability status of the block ring buffer. True, if full.
bool plan_check_full_buffer (void)
{
    return block_buffer_tail == next_buffer_head;
 80166f8:	4b04      	ldr	r3, [pc, #16]	; (801670c <plan_check_full_buffer+0x14>)
 80166fa:	6818      	ldr	r0, [r3, #0]
 80166fc:	4b04      	ldr	r3, [pc, #16]	; (8016710 <plan_check_full_buffer+0x18>)
 80166fe:	681b      	ldr	r3, [r3, #0]
}
 8016700:	4298      	cmp	r0, r3
 8016702:	bf14      	ite	ne
 8016704:	2000      	movne	r0, #0
 8016706:	2001      	moveq	r0, #1
 8016708:	4770      	bx	lr
 801670a:	bf00      	nop
 801670c:	2000382c 	.word	0x2000382c
 8016710:	20003830 	.word	0x20003830

08016714 <plan_compute_profile_nominal_speed>:


// Computes and returns block nominal speed based on running condition and override values.
// NOTE: All system motion commands, such as homing/parking, are not subject to overrides.
float plan_compute_profile_nominal_speed (plan_block_t *block)
{
 8016714:	b510      	push	{r4, lr}
 8016716:	ed2d 8b02 	vpush	{d8}
 801671a:	4604      	mov	r4, r0
    float nominal_speed = block->spindle.state.synchronized ? block->programmed_rate * block->spindle.hal->get_data(SpindleData_RPM)->rpm : block->programmed_rate;
 801671c:	f990 303c 	ldrsb.w	r3, [r0, #60]	; 0x3c
 8016720:	2b00      	cmp	r3, #0
 8016722:	db1c      	blt.n	801675e <plan_compute_profile_nominal_speed+0x4a>
 8016724:	edd0 7a0d 	vldr	s15, [r0, #52]	; 0x34

    if (block->condition.rapid_motion)
 8016728:	7d23      	ldrb	r3, [r4, #20]
 801672a:	f013 0f01 	tst.w	r3, #1
 801672e:	d021      	beq.n	8016774 <plan_compute_profile_nominal_speed+0x60>
        nominal_speed *= (0.01f * (float)sys.override.rapid_rate);
 8016730:	4b1c      	ldr	r3, [pc, #112]	; (80167a4 <plan_compute_profile_nominal_speed+0x90>)
 8016732:	ed93 0a08 	vldr	s0, [r3, #32]
 8016736:	eeb8 0a40 	vcvt.f32.u32	s0, s0
 801673a:	ed9f 7a1b 	vldr	s14, [pc, #108]	; 80167a8 <plan_compute_profile_nominal_speed+0x94>
 801673e:	ee20 0a07 	vmul.f32	s0, s0, s14
 8016742:	ee20 0a27 	vmul.f32	s0, s0, s15
        if (nominal_speed > block->rapid_rate)
            nominal_speed = block->rapid_rate;
    }

// TODO: if nominal speed is outside bounds when synchronized motion is on then (?? retract and) abort, ignore overrides?
    return nominal_speed > MINIMUM_FEED_RATE ? nominal_speed : MINIMUM_FEED_RATE;
 8016746:	eddf 7a19 	vldr	s15, [pc, #100]	; 80167ac <plan_compute_profile_nominal_speed+0x98>
 801674a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 801674e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016752:	dc01      	bgt.n	8016758 <plan_compute_profile_nominal_speed+0x44>
 8016754:	eeb0 0a67 	vmov.f32	s0, s15
}
 8016758:	ecbd 8b02 	vpop	{d8}
 801675c:	bd10      	pop	{r4, pc}
    float nominal_speed = block->spindle.state.synchronized ? block->programmed_rate * block->spindle.hal->get_data(SpindleData_RPM)->rpm : block->programmed_rate;
 801675e:	ed90 8a0d 	vldr	s16, [r0, #52]	; 0x34
 8016762:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8016764:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8016766:	2001      	movs	r0, #1
 8016768:	4798      	blx	r3
 801676a:	edd0 7a00 	vldr	s15, [r0]
 801676e:	ee68 7a27 	vmul.f32	s15, s16, s15
 8016772:	e7d9      	b.n	8016728 <plan_compute_profile_nominal_speed+0x14>
        if (!block->condition.no_feed_override)
 8016774:	f013 0f10 	tst.w	r3, #16
 8016778:	d10a      	bne.n	8016790 <plan_compute_profile_nominal_speed+0x7c>
            nominal_speed *= (0.01f * (float)sys.override.feed_rate);
 801677a:	4b0a      	ldr	r3, [pc, #40]	; (80167a4 <plan_compute_profile_nominal_speed+0x90>)
 801677c:	ed93 7a07 	vldr	s14, [r3, #28]
 8016780:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 8016784:	eddf 6a08 	vldr	s13, [pc, #32]	; 80167a8 <plan_compute_profile_nominal_speed+0x94>
 8016788:	ee27 7a26 	vmul.f32	s14, s14, s13
 801678c:	ee67 7a87 	vmul.f32	s15, s15, s14
        if (nominal_speed > block->rapid_rate)
 8016790:	ed94 0a0c 	vldr	s0, [r4, #48]	; 0x30
 8016794:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8016798:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801679c:	d4d3      	bmi.n	8016746 <plan_compute_profile_nominal_speed+0x32>
 801679e:	eeb0 0a67 	vmov.f32	s0, s15
 80167a2:	e7d0      	b.n	8016746 <plan_compute_profile_nominal_speed+0x32>
 80167a4:	200036c4 	.word	0x200036c4
 80167a8:	3c23d70a 	.word	0x3c23d70a
 80167ac:	3dcccccd 	.word	0x3dcccccd

080167b0 <plan_update_velocity_profile_parameters>:
    planner_recalculate();
}

// Re-calculates buffered motions profile parameters upon a motion-based override change.
static bool plan_update_velocity_profile_parameters (void)
{
 80167b0:	b510      	push	{r4, lr}
 80167b2:	ed2d 8b02 	vpush	{d8}
    if(block_buffer_tail != block_buffer_head) {
 80167b6:	4b1b      	ldr	r3, [pc, #108]	; (8016824 <plan_update_velocity_profile_parameters+0x74>)
 80167b8:	681c      	ldr	r4, [r3, #0]
 80167ba:	4b1b      	ldr	r3, [pc, #108]	; (8016828 <plan_update_velocity_profile_parameters+0x78>)
 80167bc:	681b      	ldr	r3, [r3, #0]
 80167be:	429c      	cmp	r4, r3
 80167c0:	d025      	beq.n	801680e <plan_update_velocity_profile_parameters+0x5e>

        plan_block_t *block = block_buffer_tail;
        float prev_nominal_speed = SOME_LARGE_VALUE; // Set high for first block nominal speed calculation.
 80167c2:	ed9f 8a1a 	vldr	s16, [pc, #104]	; 801682c <plan_update_velocity_profile_parameters+0x7c>
 80167c6:	e005      	b.n	80167d4 <plan_update_velocity_profile_parameters+0x24>
    block->max_entry_speed_sqr = nominal_speed > prev_nominal_speed ? (prev_nominal_speed * prev_nominal_speed) : (nominal_speed * nominal_speed);
 80167c8:	ee20 8a00 	vmul.f32	s16, s0, s0
 80167cc:	e010      	b.n	80167f0 <plan_update_velocity_profile_parameters+0x40>

        while (block != block_buffer_head) {
            prev_nominal_speed = plan_compute_profile_parameters(block, plan_compute_profile_nominal_speed(block), prev_nominal_speed);
            block = block->next;
 80167ce:	6d64      	ldr	r4, [r4, #84]	; 0x54
            prev_nominal_speed = plan_compute_profile_parameters(block, plan_compute_profile_nominal_speed(block), prev_nominal_speed);
 80167d0:	eeb0 8a40 	vmov.f32	s16, s0
        while (block != block_buffer_head) {
 80167d4:	4b14      	ldr	r3, [pc, #80]	; (8016828 <plan_update_velocity_profile_parameters+0x78>)
 80167d6:	681b      	ldr	r3, [r3, #0]
 80167d8:	42a3      	cmp	r3, r4
 80167da:	d015      	beq.n	8016808 <plan_update_velocity_profile_parameters+0x58>
            prev_nominal_speed = plan_compute_profile_parameters(block, plan_compute_profile_nominal_speed(block), prev_nominal_speed);
 80167dc:	4620      	mov	r0, r4
 80167de:	f7ff ff99 	bl	8016714 <plan_compute_profile_nominal_speed>
    block->max_entry_speed_sqr = nominal_speed > prev_nominal_speed ? (prev_nominal_speed * prev_nominal_speed) : (nominal_speed * nominal_speed);
 80167e2:	eeb4 0ac8 	vcmpe.f32	s0, s16
 80167e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80167ea:	dded      	ble.n	80167c8 <plan_update_velocity_profile_parameters+0x18>
 80167ec:	ee28 8a08 	vmul.f32	s16, s16, s16
 80167f0:	ed84 8a08 	vstr	s16, [r4, #32]
    if (block->max_entry_speed_sqr > block->max_junction_speed_sqr)
 80167f4:	edd4 7a0b 	vldr	s15, [r4, #44]	; 0x2c
 80167f8:	eeb4 8ae7 	vcmpe.f32	s16, s15
 80167fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016800:	dde5      	ble.n	80167ce <plan_update_velocity_profile_parameters+0x1e>
        block->max_entry_speed_sqr = block->max_junction_speed_sqr;
 8016802:	edc4 7a08 	vstr	s15, [r4, #32]
 8016806:	e7e2      	b.n	80167ce <plan_update_velocity_profile_parameters+0x1e>
        }

        pl.previous_nominal_speed = prev_nominal_speed; // Update prev nominal speed for next incoming block.
 8016808:	4b09      	ldr	r3, [pc, #36]	; (8016830 <plan_update_velocity_profile_parameters+0x80>)
 801680a:	ed83 8a06 	vstr	s16, [r3, #24]
    }

    return block_buffer_tail != block_buffer_head;
 801680e:	4b05      	ldr	r3, [pc, #20]	; (8016824 <plan_update_velocity_profile_parameters+0x74>)
 8016810:	6818      	ldr	r0, [r3, #0]
 8016812:	4b05      	ldr	r3, [pc, #20]	; (8016828 <plan_update_velocity_profile_parameters+0x78>)
 8016814:	681b      	ldr	r3, [r3, #0]
}
 8016816:	1ac0      	subs	r0, r0, r3
 8016818:	bf18      	it	ne
 801681a:	2001      	movne	r0, #1
 801681c:	ecbd 8b02 	vpop	{d8}
 8016820:	bd10      	pop	{r4, pc}
 8016822:	bf00      	nop
 8016824:	2000382c 	.word	0x2000382c
 8016828:	20003820 	.word	0x20003820
 801682c:	7e967699 	.word	0x7e967699
 8016830:	20003834 	.word	0x20003834

08016834 <plan_buffer_line>:
{
 8016834:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8016838:	ed2d 8b04 	vpush	{d8-d9}
 801683c:	b08c      	sub	sp, #48	; 0x30
 801683e:	4607      	mov	r7, r0
 8016840:	460e      	mov	r6, r1
    plan_block_t *block = block_buffer_head;
 8016842:	4bc0      	ldr	r3, [pc, #768]	; (8016b44 <plan_buffer_line+0x310>)
 8016844:	681d      	ldr	r5, [r3, #0]
    memset(block, 0, sizeof(plan_block_t) - 2 * sizeof(plan_block_t *));    // Zero all block values (except linked list pointers).
 8016846:	2250      	movs	r2, #80	; 0x50
 8016848:	2100      	movs	r1, #0
 801684a:	4628      	mov	r0, r5
 801684c:	f00c f993 	bl	8022b76 <memset>
    memcpy(&block->spindle, &pl_data->spindle, sizeof(spindle_t));          // Copy spindle data (RPM etc)
 8016850:	6870      	ldr	r0, [r6, #4]
 8016852:	68b1      	ldr	r1, [r6, #8]
 8016854:	68f2      	ldr	r2, [r6, #12]
 8016856:	6933      	ldr	r3, [r6, #16]
 8016858:	63a8      	str	r0, [r5, #56]	; 0x38
 801685a:	63e9      	str	r1, [r5, #60]	; 0x3c
 801685c:	642a      	str	r2, [r5, #64]	; 0x40
 801685e:	646b      	str	r3, [r5, #68]	; 0x44
    block->condition = pl_data->condition;
 8016860:	6973      	ldr	r3, [r6, #20]
 8016862:	616b      	str	r3, [r5, #20]
    block->overrides = pl_data->overrides;
 8016864:	7e33      	ldrb	r3, [r6, #24]
 8016866:	746b      	strb	r3, [r5, #17]
    block->line_number = pl_data->line_number;
 8016868:	69f3      	ldr	r3, [r6, #28]
 801686a:	61ab      	str	r3, [r5, #24]
    block->output_commands = pl_data->output_commands;
 801686c:	6a73      	ldr	r3, [r6, #36]	; 0x24
 801686e:	64eb      	str	r3, [r5, #76]	; 0x4c
    block->message = pl_data->message;
 8016870:	6a33      	ldr	r3, [r6, #32]
 8016872:	64ab      	str	r3, [r5, #72]	; 0x48
    pl_data->message = NULL;
 8016874:	2300      	movs	r3, #0
 8016876:	6233      	str	r3, [r6, #32]
    memcpy(position_steps, block->condition.system_motion ? sys.position : pl.position, sizeof(position_steps));
 8016878:	7d2b      	ldrb	r3, [r5, #20]
 801687a:	f013 0f02 	tst.w	r3, #2
 801687e:	d006      	beq.n	801688e <plan_buffer_line+0x5a>
 8016880:	4ab1      	ldr	r2, [pc, #708]	; (8016b48 <plan_buffer_line+0x314>)
 8016882:	ab06      	add	r3, sp, #24
 8016884:	ca07      	ldmia	r2, {r0, r1, r2}
 8016886:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    idx = N_AXIS;
 801688a:	2403      	movs	r4, #3
 801688c:	e021      	b.n	80168d2 <plan_buffer_line+0x9e>
    memcpy(position_steps, block->condition.system_motion ? sys.position : pl.position, sizeof(position_steps));
 801688e:	4aaf      	ldr	r2, [pc, #700]	; (8016b4c <plan_buffer_line+0x318>)
 8016890:	e7f7      	b.n	8016882 <plan_buffer_line+0x4e>
            block->steps[idx] = labs(delta_steps);
 8016892:	ea80 73e0 	eor.w	r3, r0, r0, asr #31
 8016896:	eba3 73e0 	sub.w	r3, r3, r0, asr #31
 801689a:	f845 3024 	str.w	r3, [r5, r4, lsl #2]
            block->step_event_count = max(block->step_event_count, block->steps[idx]);
 801689e:	68ea      	ldr	r2, [r5, #12]
 80168a0:	4293      	cmp	r3, r2
 80168a2:	bf38      	it	cc
 80168a4:	4613      	movcc	r3, r2
 80168a6:	60eb      	str	r3, [r5, #12]
            unit_vec[idx] = (float)delta_steps / settings.axis[idx].steps_per_mm; // Store unit vector numerator
 80168a8:	ee07 0a90 	vmov	s15, r0
 80168ac:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80168b0:	eb04 0284 	add.w	r2, r4, r4, lsl #2
 80168b4:	4ba6      	ldr	r3, [pc, #664]	; (8016b50 <plan_buffer_line+0x31c>)
 80168b6:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80168ba:	edd3 6a0c 	vldr	s13, [r3, #48]	; 0x30
 80168be:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 80168c2:	ab0c      	add	r3, sp, #48	; 0x30
 80168c4:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 80168c8:	ed03 7a09 	vstr	s14, [r3, #-36]	; 0xffffffdc
        if (delta_steps < 0)
 80168cc:	2800      	cmp	r0, #0
 80168ce:	db25      	blt.n	801691c <plan_buffer_line+0xe8>
    } while(idx);
 80168d0:	b354      	cbz	r4, 8016928 <plan_buffer_line+0xf4>
        idx--;
 80168d2:	3c01      	subs	r4, #1
        target_steps[idx] = lroundf(target[idx] * settings.axis[idx].steps_per_mm);
 80168d4:	ea4f 0884 	mov.w	r8, r4, lsl #2
 80168d8:	eb07 0384 	add.w	r3, r7, r4, lsl #2
 80168dc:	ed93 0a00 	vldr	s0, [r3]
 80168e0:	eb04 0284 	add.w	r2, r4, r4, lsl #2
 80168e4:	4b9a      	ldr	r3, [pc, #616]	; (8016b50 <plan_buffer_line+0x31c>)
 80168e6:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80168ea:	edd3 7a0c 	vldr	s15, [r3, #48]	; 0x30
 80168ee:	ee20 0a27 	vmul.f32	s0, s0, s15
 80168f2:	f00d f94e 	bl	8023b92 <lroundf>
 80168f6:	f108 0330 	add.w	r3, r8, #48	; 0x30
 80168fa:	446b      	add	r3, sp
 80168fc:	f843 0c0c 	str.w	r0, [r3, #-12]
        if((delta_steps = target_steps[idx] - position_steps[idx])) {
 8016900:	f853 3c18 	ldr.w	r3, [r3, #-24]
 8016904:	1ac0      	subs	r0, r0, r3
 8016906:	d1c4      	bne.n	8016892 <plan_buffer_line+0x5e>
            block->steps[idx] = 0;
 8016908:	2300      	movs	r3, #0
 801690a:	f845 3024 	str.w	r3, [r5, r4, lsl #2]
            unit_vec[idx] = 0.0f; // Store unit vector numerator
 801690e:	2200      	movs	r2, #0
 8016910:	ab0c      	add	r3, sp, #48	; 0x30
 8016912:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8016916:	f843 2c24 	str.w	r2, [r3, #-36]
 801691a:	e7d7      	b.n	80168cc <plan_buffer_line+0x98>
            block->direction_bits.mask |= bit(idx);
 801691c:	2201      	movs	r2, #1
 801691e:	40a2      	lsls	r2, r4
 8016920:	7c2b      	ldrb	r3, [r5, #16]
 8016922:	4313      	orrs	r3, r2
 8016924:	742b      	strb	r3, [r5, #16]
 8016926:	e7d3      	b.n	80168d0 <plan_buffer_line+0x9c>
    if(block->spindle.css) {
 8016928:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 801692a:	2b00      	cmp	r3, #0
 801692c:	d05d      	beq.n	80169ea <plan_buffer_line+0x1b6>
        if((pos = (float)position_steps[block->spindle.css->axis] / settings.axis[block->spindle.css->axis].steps_per_mm - block->spindle.css->tool_offset) > 0.0f) {
 801692e:	695a      	ldr	r2, [r3, #20]
 8016930:	a90c      	add	r1, sp, #48	; 0x30
 8016932:	eb01 0182 	add.w	r1, r1, r2, lsl #2
 8016936:	ed11 7a06 	vldr	s14, [r1, #-24]	; 0xffffffe8
 801693a:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 801693e:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8016942:	4983      	ldr	r1, [pc, #524]	; (8016b50 <plan_buffer_line+0x31c>)
 8016944:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 8016948:	edd2 6a0c 	vldr	s13, [r2, #48]	; 0x30
 801694c:	eec7 7a26 	vdiv.f32	s15, s14, s13
 8016950:	ed93 7a04 	vldr	s14, [r3, #16]
 8016954:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8016958:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801695c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016960:	dd13      	ble.n	801698a <plan_buffer_line+0x156>
            if((block->spindle.rpm = block->spindle.css->surface_speed / (pos * (float)(2.0f * M_PI))) > block->spindle.css->max_rpm)
 8016962:	edd3 6a00 	vldr	s13, [r3]
 8016966:	ed9f 7a7b 	vldr	s14, [pc, #492]	; 8016b54 <plan_buffer_line+0x320>
 801696a:	ee67 7a87 	vmul.f32	s15, s15, s14
 801696e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8016972:	ed85 7a0e 	vstr	s14, [r5, #56]	; 0x38
 8016976:	edd3 7a03 	vldr	s15, [r3, #12]
 801697a:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801697e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016982:	dd04      	ble.n	801698e <plan_buffer_line+0x15a>
                block->spindle.rpm = block->spindle.css->max_rpm;
 8016984:	edc5 7a0e 	vstr	s15, [r5, #56]	; 0x38
 8016988:	e001      	b.n	801698e <plan_buffer_line+0x15a>
            block->spindle.rpm = block->spindle.css->max_rpm;
 801698a:	68da      	ldr	r2, [r3, #12]
 801698c:	63aa      	str	r2, [r5, #56]	; 0x38
        if((pos = target[block->spindle.css->axis] - block->spindle.css->tool_offset) > 0.0f) {
 801698e:	695a      	ldr	r2, [r3, #20]
 8016990:	eb07 0782 	add.w	r7, r7, r2, lsl #2
 8016994:	edd7 7a00 	vldr	s15, [r7]
 8016998:	ed93 7a04 	vldr	s14, [r3, #16]
 801699c:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80169a0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80169a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80169a8:	dd14      	ble.n	80169d4 <plan_buffer_line+0x1a0>
            if((block->spindle.css->target_rpm = block->spindle.css->surface_speed / (pos * (float)(2.0f * M_PI))) > block->spindle.css->max_rpm)
 80169aa:	edd3 6a00 	vldr	s13, [r3]
 80169ae:	ed9f 7a69 	vldr	s14, [pc, #420]	; 8016b54 <plan_buffer_line+0x320>
 80169b2:	ee67 7a87 	vmul.f32	s15, s15, s14
 80169b6:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 80169ba:	ed83 7a01 	vstr	s14, [r3, #4]
 80169be:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 80169c0:	edd3 7a03 	vldr	s15, [r3, #12]
 80169c4:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80169c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80169cc:	dd04      	ble.n	80169d8 <plan_buffer_line+0x1a4>
                block->spindle.css->target_rpm = block->spindle.css->max_rpm;
 80169ce:	edc3 7a01 	vstr	s15, [r3, #4]
 80169d2:	e001      	b.n	80169d8 <plan_buffer_line+0x1a4>
            block->spindle.css->target_rpm = block->spindle.css->max_rpm;
 80169d4:	68da      	ldr	r2, [r3, #12]
 80169d6:	605a      	str	r2, [r3, #4]
        block->spindle.css->delta_rpm = block->spindle.css->target_rpm - block->spindle.rpm;
 80169d8:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 80169da:	edd3 7a01 	vldr	s15, [r3, #4]
 80169de:	ed95 7a0e 	vldr	s14, [r5, #56]	; 0x38
 80169e2:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80169e6:	edc3 7a02 	vstr	s15, [r3, #8]
    if (block->step_event_count == 0)
 80169ea:	68eb      	ldr	r3, [r5, #12]
 80169ec:	b92b      	cbnz	r3, 80169fa <plan_buffer_line+0x1c6>
        return false;
 80169ee:	2000      	movs	r0, #0
}
 80169f0:	b00c      	add	sp, #48	; 0x30
 80169f2:	ecbd 8b04 	vpop	{d8-d9}
 80169f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    pl_data->message = NULL;         // Indicate message is already queued for display on execution
 80169fa:	2300      	movs	r3, #0
 80169fc:	6233      	str	r3, [r6, #32]
    pl_data->output_commands = NULL; // Indicate commands are already queued for execution
 80169fe:	6273      	str	r3, [r6, #36]	; 0x24
    block->millimeters = convert_delta_vector_to_unit_vector(unit_vec);
 8016a00:	a803      	add	r0, sp, #12
 8016a02:	f7ff f857 	bl	8015ab4 <convert_delta_vector_to_unit_vector>
 8016a06:	ed85 0a0a 	vstr	s0, [r5, #40]	; 0x28
    float limit_value = SOME_LARGE_VALUE;
 8016a0a:	eddf 6a58 	vldr	s13, [pc, #352]	; 8016b6c <plan_buffer_line+0x338>
    uint_fast8_t idx = N_AXIS;
 8016a0e:	2303      	movs	r3, #3
 8016a10:	e000      	b.n	8016a14 <plan_buffer_line+0x1e0>
    } while(idx);
 8016a12:	b1eb      	cbz	r3, 8016a50 <plan_buffer_line+0x21c>
        if (unit_vec[--idx] != 0.0f)  // Avoid divide by zero.
 8016a14:	3b01      	subs	r3, #1
 8016a16:	aa0c      	add	r2, sp, #48	; 0x30
 8016a18:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8016a1c:	ed52 7a09 	vldr	s15, [r2, #-36]	; 0xffffffdc
 8016a20:	eef5 7a40 	vcmp.f32	s15, #0.0
 8016a24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016a28:	d0f3      	beq.n	8016a12 <plan_buffer_line+0x1de>
            limit_value = min(limit_value, fabsf(settings.axis[idx].acceleration / unit_vec[idx]));
 8016a2a:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8016a2e:	4a48      	ldr	r2, [pc, #288]	; (8016b50 <plan_buffer_line+0x31c>)
 8016a30:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8016a34:	ed92 6a0e 	vldr	s12, [r2, #56]	; 0x38
 8016a38:	ee86 7a27 	vdiv.f32	s14, s12, s15
 8016a3c:	eef0 7ac7 	vabs.f32	s15, s14
 8016a40:	eef4 7ae6 	vcmpe.f32	s15, s13
 8016a44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016a48:	dce3      	bgt.n	8016a12 <plan_buffer_line+0x1de>
 8016a4a:	eef0 6a67 	vmov.f32	s13, s15
 8016a4e:	e7e0      	b.n	8016a12 <plan_buffer_line+0x1de>
    block->acceleration = limit_acceleration_by_axis_maximum(unit_vec);
 8016a50:	edc5 6a09 	vstr	s13, [r5, #36]	; 0x24
    float limit_value = SOME_LARGE_VALUE;
 8016a54:	eddf 6a45 	vldr	s13, [pc, #276]	; 8016b6c <plan_buffer_line+0x338>
    uint_fast8_t idx = N_AXIS;
 8016a58:	2303      	movs	r3, #3
 8016a5a:	e000      	b.n	8016a5e <plan_buffer_line+0x22a>
    } while(idx);
 8016a5c:	b1eb      	cbz	r3, 8016a9a <plan_buffer_line+0x266>
        if (unit_vec[--idx] != 0.0f)  // Avoid divide by zero.
 8016a5e:	3b01      	subs	r3, #1
 8016a60:	aa0c      	add	r2, sp, #48	; 0x30
 8016a62:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8016a66:	ed52 7a09 	vldr	s15, [r2, #-36]	; 0xffffffdc
 8016a6a:	eef5 7a40 	vcmp.f32	s15, #0.0
 8016a6e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016a72:	d0f3      	beq.n	8016a5c <plan_buffer_line+0x228>
            limit_value = min(limit_value, fabsf(settings.axis[idx].max_rate / unit_vec[idx]));
 8016a74:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8016a78:	4a35      	ldr	r2, [pc, #212]	; (8016b50 <plan_buffer_line+0x31c>)
 8016a7a:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8016a7e:	ed92 6a0d 	vldr	s12, [r2, #52]	; 0x34
 8016a82:	ee86 7a27 	vdiv.f32	s14, s12, s15
 8016a86:	eef0 7ac7 	vabs.f32	s15, s14
 8016a8a:	eef4 7ae6 	vcmpe.f32	s15, s13
 8016a8e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016a92:	dce3      	bgt.n	8016a5c <plan_buffer_line+0x228>
 8016a94:	eef0 6a67 	vmov.f32	s13, s15
 8016a98:	e7e0      	b.n	8016a5c <plan_buffer_line+0x228>
    block->rapid_rate = limit_max_rate_by_axis_maximum(unit_vec);
 8016a9a:	edc5 6a0c 	vstr	s13, [r5, #48]	; 0x30
    if (block->condition.rapid_motion)
 8016a9e:	7d2b      	ldrb	r3, [r5, #20]
 8016aa0:	f013 0f01 	tst.w	r3, #1
 8016aa4:	d014      	beq.n	8016ad0 <plan_buffer_line+0x29c>
        block->programmed_rate = block->rapid_rate;
 8016aa6:	edc5 6a0d 	vstr	s13, [r5, #52]	; 0x34
    if ((block_buffer_head == block_buffer_tail) || (block->condition.system_motion)) {
 8016aaa:	4a26      	ldr	r2, [pc, #152]	; (8016b44 <plan_buffer_line+0x310>)
 8016aac:	6811      	ldr	r1, [r2, #0]
 8016aae:	4a2a      	ldr	r2, [pc, #168]	; (8016b58 <plan_buffer_line+0x324>)
 8016ab0:	6812      	ldr	r2, [r2, #0]
 8016ab2:	4291      	cmp	r1, r2
 8016ab4:	d002      	beq.n	8016abc <plan_buffer_line+0x288>
 8016ab6:	f013 0f02 	tst.w	r3, #2
 8016aba:	d015      	beq.n	8016ae8 <plan_buffer_line+0x2b4>
        block->entry_speed_sqr = 0.0f;
 8016abc:	2300      	movs	r3, #0
 8016abe:	61eb      	str	r3, [r5, #28]
        block->max_junction_speed_sqr = 0.0f; // Starting from rest. Enforce start from zero velocity.
 8016ac0:	62eb      	str	r3, [r5, #44]	; 0x2c
    if (!block->condition.system_motion) {
 8016ac2:	7d2b      	ldrb	r3, [r5, #20]
 8016ac4:	f013 0f02 	tst.w	r3, #2
 8016ac8:	f000 8098 	beq.w	8016bfc <plan_buffer_line+0x3c8>
    return true;
 8016acc:	2001      	movs	r0, #1
 8016ace:	e78f      	b.n	80169f0 <plan_buffer_line+0x1bc>
        block->programmed_rate = pl_data->feed_rate;
 8016ad0:	edd6 7a00 	vldr	s15, [r6]
 8016ad4:	edc5 7a0d 	vstr	s15, [r5, #52]	; 0x34
        if (block->condition.inverse_time)
 8016ad8:	f013 0f20 	tst.w	r3, #32
 8016adc:	d0e5      	beq.n	8016aaa <plan_buffer_line+0x276>
            block->programmed_rate *= block->millimeters;
 8016ade:	ee20 0a27 	vmul.f32	s0, s0, s15
 8016ae2:	ed85 0a0d 	vstr	s0, [r5, #52]	; 0x34
 8016ae6:	e7e0      	b.n	8016aaa <plan_buffer_line+0x276>
        float junction_cos_theta = 0.0f;
 8016ae8:	ed9f 8a1c 	vldr	s16, [pc, #112]	; 8016b5c <plan_buffer_line+0x328>
        idx = N_AXIS;
 8016aec:	2303      	movs	r3, #3
            idx--;
 8016aee:	3b01      	subs	r3, #1
            junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
 8016af0:	1c99      	adds	r1, r3, #2
 8016af2:	4a16      	ldr	r2, [pc, #88]	; (8016b4c <plan_buffer_line+0x318>)
 8016af4:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8016af8:	ed92 7a01 	vldr	s14, [r2, #4]
 8016afc:	aa0c      	add	r2, sp, #48	; 0x30
 8016afe:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8016b02:	ed52 7a09 	vldr	s15, [r2, #-36]	; 0xffffffdc
 8016b06:	ee67 6a27 	vmul.f32	s13, s14, s15
 8016b0a:	ee38 8a66 	vsub.f32	s16, s16, s13
            junction_unit_vec[idx] = unit_vec[idx] - pl.previous_unit_vec[idx];
 8016b0e:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8016b12:	ed42 7a0c 	vstr	s15, [r2, #-48]	; 0xffffffd0
        } while(idx);
 8016b16:	2b00      	cmp	r3, #0
 8016b18:	d1e9      	bne.n	8016aee <plan_buffer_line+0x2ba>
        if (junction_cos_theta > 0.999999f)
 8016b1a:	eddf 7a11 	vldr	s15, [pc, #68]	; 8016b60 <plan_buffer_line+0x32c>
 8016b1e:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8016b22:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016b26:	dd02      	ble.n	8016b2e <plan_buffer_line+0x2fa>
            block->max_junction_speed_sqr = MINIMUM_JUNCTION_SPEED * MINIMUM_JUNCTION_SPEED;
 8016b28:	2300      	movs	r3, #0
 8016b2a:	62eb      	str	r3, [r5, #44]	; 0x2c
 8016b2c:	e7c9      	b.n	8016ac2 <plan_buffer_line+0x28e>
        else if (junction_cos_theta < -0.999999f) {
 8016b2e:	eddf 7a0d 	vldr	s15, [pc, #52]	; 8016b64 <plan_buffer_line+0x330>
 8016b32:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8016b36:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016b3a:	d519      	bpl.n	8016b70 <plan_buffer_line+0x33c>
            block->max_junction_speed_sqr = SOME_LARGE_VALUE;
 8016b3c:	4b0a      	ldr	r3, [pc, #40]	; (8016b68 <plan_buffer_line+0x334>)
 8016b3e:	62eb      	str	r3, [r5, #44]	; 0x2c
 8016b40:	e7bf      	b.n	8016ac2 <plan_buffer_line+0x28e>
 8016b42:	bf00      	nop
 8016b44:	20003820 	.word	0x20003820
 8016b48:	2000374c 	.word	0x2000374c
 8016b4c:	20003834 	.word	0x20003834
 8016b50:	20003b14 	.word	0x20003b14
 8016b54:	40c90fdb 	.word	0x40c90fdb
 8016b58:	2000382c 	.word	0x2000382c
 8016b5c:	00000000 	.word	0x00000000
 8016b60:	3f7fffef 	.word	0x3f7fffef
 8016b64:	bf7fffef 	.word	0xbf7fffef
 8016b68:	7e967699 	.word	0x7e967699
 8016b6c:	7e967699 	.word	0x7e967699
            convert_delta_vector_to_unit_vector(junction_unit_vec);
 8016b70:	4668      	mov	r0, sp
 8016b72:	f7fe ff9f 	bl	8015ab4 <convert_delta_vector_to_unit_vector>
    float limit_value = SOME_LARGE_VALUE;
 8016b76:	ed1f 9a03 	vldr	s18, [pc, #-12]	; 8016b6c <plan_buffer_line+0x338>
    uint_fast8_t idx = N_AXIS;
 8016b7a:	2303      	movs	r3, #3
 8016b7c:	e000      	b.n	8016b80 <plan_buffer_line+0x34c>
    } while(idx);
 8016b7e:	b1eb      	cbz	r3, 8016bbc <plan_buffer_line+0x388>
        if (unit_vec[--idx] != 0.0f)  // Avoid divide by zero.
 8016b80:	3b01      	subs	r3, #1
 8016b82:	aa0c      	add	r2, sp, #48	; 0x30
 8016b84:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8016b88:	ed52 7a0c 	vldr	s15, [r2, #-48]	; 0xffffffd0
 8016b8c:	eef5 7a40 	vcmp.f32	s15, #0.0
 8016b90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016b94:	d0f3      	beq.n	8016b7e <plan_buffer_line+0x34a>
            limit_value = min(limit_value, fabsf(settings.axis[idx].acceleration / unit_vec[idx]));
 8016b96:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8016b9a:	4a34      	ldr	r2, [pc, #208]	; (8016c6c <plan_buffer_line+0x438>)
 8016b9c:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8016ba0:	edd2 6a0e 	vldr	s13, [r2, #56]	; 0x38
 8016ba4:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8016ba8:	eef0 7ac7 	vabs.f32	s15, s14
 8016bac:	eef4 7ac9 	vcmpe.f32	s15, s18
 8016bb0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016bb4:	dce3      	bgt.n	8016b7e <plan_buffer_line+0x34a>
 8016bb6:	eeb0 9a67 	vmov.f32	s18, s15
 8016bba:	e7e0      	b.n	8016b7e <plan_buffer_line+0x34a>
            float sin_theta_d2 = sqrtf(0.5f * (1.0f - junction_cos_theta)); // Trig half angle identity. Always positive.
 8016bbc:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
 8016bc0:	ee38 8ac8 	vsub.f32	s16, s17, s16
 8016bc4:	eeb6 0a00 	vmov.f32	s0, #96	; 0x3f000000  0.5
 8016bc8:	ee28 0a00 	vmul.f32	s0, s16, s0
 8016bcc:	f00c ff00 	bl	80239d0 <sqrtf>
            block->max_junction_speed_sqr = max(MINIMUM_JUNCTION_SPEED * MINIMUM_JUNCTION_SPEED,
 8016bd0:	4b26      	ldr	r3, [pc, #152]	; (8016c6c <plan_buffer_line+0x438>)
 8016bd2:	edd3 7a01 	vldr	s15, [r3, #4]
 8016bd6:	ee67 7a89 	vmul.f32	s15, s15, s18
 8016bda:	ee67 7a80 	vmul.f32	s15, s15, s0
 8016bde:	ee78 8ac0 	vsub.f32	s17, s17, s0
 8016be2:	ee87 7aa8 	vdiv.f32	s14, s15, s17
 8016be6:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
 8016bea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016bee:	d402      	bmi.n	8016bf6 <plan_buffer_line+0x3c2>
 8016bf0:	ed85 7a0b 	vstr	s14, [r5, #44]	; 0x2c
 8016bf4:	e765      	b.n	8016ac2 <plan_buffer_line+0x28e>
 8016bf6:	ed9f 7a1e 	vldr	s14, [pc, #120]	; 8016c70 <plan_buffer_line+0x43c>
 8016bfa:	e7f9      	b.n	8016bf0 <plan_buffer_line+0x3bc>
        pl.previous_nominal_speed = plan_compute_profile_parameters(block, plan_compute_profile_nominal_speed(block), pl.previous_nominal_speed);
 8016bfc:	4628      	mov	r0, r5
 8016bfe:	f7ff fd89 	bl	8016714 <plan_compute_profile_nominal_speed>
 8016c02:	4b1c      	ldr	r3, [pc, #112]	; (8016c74 <plan_buffer_line+0x440>)
 8016c04:	edd3 7a06 	vldr	s15, [r3, #24]
    block->max_entry_speed_sqr = nominal_speed > prev_nominal_speed ? (prev_nominal_speed * prev_nominal_speed) : (nominal_speed * nominal_speed);
 8016c08:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8016c0c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016c10:	dd29      	ble.n	8016c66 <plan_buffer_line+0x432>
 8016c12:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8016c16:	edc5 7a08 	vstr	s15, [r5, #32]
    if (block->max_entry_speed_sqr > block->max_junction_speed_sqr)
 8016c1a:	ed95 7a0b 	vldr	s14, [r5, #44]	; 0x2c
 8016c1e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8016c22:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016c26:	dd01      	ble.n	8016c2c <plan_buffer_line+0x3f8>
        block->max_entry_speed_sqr = block->max_junction_speed_sqr;
 8016c28:	ed85 7a08 	vstr	s14, [r5, #32]
        pl.previous_nominal_speed = plan_compute_profile_parameters(block, plan_compute_profile_nominal_speed(block), pl.previous_nominal_speed);
 8016c2c:	4b11      	ldr	r3, [pc, #68]	; (8016c74 <plan_buffer_line+0x440>)
 8016c2e:	ed83 0a06 	vstr	s0, [r3, #24]
        if(!block->condition.backlash_motion) {
 8016c32:	7d2b      	ldrb	r3, [r5, #20]
 8016c34:	f013 0f08 	tst.w	r3, #8
 8016c38:	d10b      	bne.n	8016c52 <plan_buffer_line+0x41e>
            memcpy(pl.previous_unit_vec, unit_vec, sizeof(unit_vec)); // pl.previous_unit_vec[] = unit_vec[]
 8016c3a:	4b0e      	ldr	r3, [pc, #56]	; (8016c74 <plan_buffer_line+0x440>)
 8016c3c:	f103 040c 	add.w	r4, r3, #12
 8016c40:	aa03      	add	r2, sp, #12
 8016c42:	ca07      	ldmia	r2, {r0, r1, r2}
 8016c44:	e884 0007 	stmia.w	r4, {r0, r1, r2}
            memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]
 8016c48:	aa0c      	add	r2, sp, #48	; 0x30
 8016c4a:	e912 0007 	ldmdb	r2, {r0, r1, r2}
 8016c4e:	e883 0007 	stmia.w	r3, {r0, r1, r2}
        block_buffer_head = next_buffer_head;
 8016c52:	4b09      	ldr	r3, [pc, #36]	; (8016c78 <plan_buffer_line+0x444>)
 8016c54:	681a      	ldr	r2, [r3, #0]
 8016c56:	4909      	ldr	r1, [pc, #36]	; (8016c7c <plan_buffer_line+0x448>)
 8016c58:	600a      	str	r2, [r1, #0]
        next_buffer_head = block_buffer_head->next;
 8016c5a:	6d52      	ldr	r2, [r2, #84]	; 0x54
 8016c5c:	601a      	str	r2, [r3, #0]
        planner_recalculate();
 8016c5e:	f7ff fbb3 	bl	80163c8 <planner_recalculate>
    return true;
 8016c62:	2001      	movs	r0, #1
 8016c64:	e6c4      	b.n	80169f0 <plan_buffer_line+0x1bc>
    block->max_entry_speed_sqr = nominal_speed > prev_nominal_speed ? (prev_nominal_speed * prev_nominal_speed) : (nominal_speed * nominal_speed);
 8016c66:	ee60 7a00 	vmul.f32	s15, s0, s0
 8016c6a:	e7d4      	b.n	8016c16 <plan_buffer_line+0x3e2>
 8016c6c:	20003b14 	.word	0x20003b14
 8016c70:	00000000 	.word	0x00000000
 8016c74:	20003834 	.word	0x20003834
 8016c78:	20003830 	.word	0x20003830
 8016c7c:	20003820 	.word	0x20003820

08016c80 <plan_sync_position>:
    memcpy(pl.position, sys.position, sizeof(pl.position));
 8016c80:	4b02      	ldr	r3, [pc, #8]	; (8016c8c <plan_sync_position+0xc>)
 8016c82:	4a03      	ldr	r2, [pc, #12]	; (8016c90 <plan_sync_position+0x10>)
 8016c84:	ca07      	ldmia	r2, {r0, r1, r2}
 8016c86:	e883 0007 	stmia.w	r3, {r0, r1, r2}
}
 8016c8a:	4770      	bx	lr
 8016c8c:	20003834 	.word	0x20003834
 8016c90:	2000374c 	.word	0x2000374c

08016c94 <plan_get_block_buffer_available>:
    return (uint_fast16_t)(block_buffer_head >= block_buffer_tail
 8016c94:	4b0a      	ldr	r3, [pc, #40]	; (8016cc0 <plan_get_block_buffer_available+0x2c>)
 8016c96:	681a      	ldr	r2, [r3, #0]
 8016c98:	4b0a      	ldr	r3, [pc, #40]	; (8016cc4 <plan_get_block_buffer_available+0x30>)
 8016c9a:	6818      	ldr	r0, [r3, #0]
 8016c9c:	4282      	cmp	r2, r0
 8016c9e:	d307      	bcc.n	8016cb0 <plan_get_block_buffer_available+0x1c>
                            ? (block_buffer_size - (block_buffer_head - block_buffer_tail))
 8016ca0:	4909      	ldr	r1, [pc, #36]	; (8016cc8 <plan_get_block_buffer_available+0x34>)
 8016ca2:	6809      	ldr	r1, [r1, #0]
 8016ca4:	1a12      	subs	r2, r2, r0
 8016ca6:	10d2      	asrs	r2, r2, #3
    return (uint_fast16_t)(block_buffer_head >= block_buffer_tail
 8016ca8:	4808      	ldr	r0, [pc, #32]	; (8016ccc <plan_get_block_buffer_available+0x38>)
 8016caa:	fb00 1012 	mls	r0, r0, r2, r1
 8016cae:	4770      	bx	lr
                            : ((block_buffer_tail - block_buffer_head) - 1));
 8016cb0:	1a80      	subs	r0, r0, r2
 8016cb2:	10c0      	asrs	r0, r0, #3
 8016cb4:	4b05      	ldr	r3, [pc, #20]	; (8016ccc <plan_get_block_buffer_available+0x38>)
 8016cb6:	fb03 f000 	mul.w	r0, r3, r0
 8016cba:	3801      	subs	r0, #1
}
 8016cbc:	4770      	bx	lr
 8016cbe:	bf00      	nop
 8016cc0:	20003820 	.word	0x20003820
 8016cc4:	2000382c 	.word	0x2000382c
 8016cc8:	20003828 	.word	0x20003828
 8016ccc:	ba2e8ba3 	.word	0xba2e8ba3

08016cd0 <plan_cycle_reinitialize>:
{
 8016cd0:	b508      	push	{r3, lr}
    st_update_plan_block_parameters();
 8016cd2:	f008 fae1 	bl	801f298 <st_update_plan_block_parameters>
    block_buffer_planned = block_buffer_tail;
 8016cd6:	4b03      	ldr	r3, [pc, #12]	; (8016ce4 <plan_cycle_reinitialize+0x14>)
 8016cd8:	681a      	ldr	r2, [r3, #0]
 8016cda:	4b03      	ldr	r3, [pc, #12]	; (8016ce8 <plan_cycle_reinitialize+0x18>)
 8016cdc:	601a      	str	r2, [r3, #0]
    planner_recalculate();
 8016cde:	f7ff fb73 	bl	80163c8 <planner_recalculate>
}
 8016ce2:	bd08      	pop	{r3, pc}
 8016ce4:	2000382c 	.word	0x2000382c
 8016ce8:	20003824 	.word	0x20003824

08016cec <plan_feed_override>:
// Set feed overrides
void plan_feed_override (override_t feed_override, override_t rapid_override)
{
    bool feedrate_changed = false, rapidrate_changed = false;

    if(sys.override.control.feed_rate_disable)
 8016cec:	4b1a      	ldr	r3, [pc, #104]	; (8016d58 <plan_feed_override+0x6c>)
 8016cee:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8016cf2:	f013 0f01 	tst.w	r3, #1
 8016cf6:	d12d      	bne.n	8016d54 <plan_feed_override+0x68>
{
 8016cf8:	b570      	push	{r4, r5, r6, lr}
        return;

    feed_override = constrain(feed_override, MIN_FEED_RATE_OVERRIDE, MAX_FEED_RATE_OVERRIDE);
 8016cfa:	2809      	cmp	r0, #9
 8016cfc:	d904      	bls.n	8016d08 <plan_feed_override+0x1c>
 8016cfe:	28c8      	cmp	r0, #200	; 0xc8
 8016d00:	bf28      	it	cs
 8016d02:	20c8      	movcs	r0, #200	; 0xc8
 8016d04:	4604      	mov	r4, r0
 8016d06:	e000      	b.n	8016d0a <plan_feed_override+0x1e>
 8016d08:	240a      	movs	r4, #10

    if((feedrate_changed = feed_override != sys.override.feed_rate) ||
 8016d0a:	4b13      	ldr	r3, [pc, #76]	; (8016d58 <plan_feed_override+0x6c>)
 8016d0c:	69dd      	ldr	r5, [r3, #28]
 8016d0e:	42a5      	cmp	r5, r4
 8016d10:	d106      	bne.n	8016d20 <plan_feed_override+0x34>
         (rapidrate_changed = rapid_override != sys.override.rapid_rate)) {
 8016d12:	6a1b      	ldr	r3, [r3, #32]
 8016d14:	428b      	cmp	r3, r1
 8016d16:	bf14      	ite	ne
 8016d18:	2601      	movne	r6, #1
 8016d1a:	2600      	moveq	r6, #0
    if((feedrate_changed = feed_override != sys.override.feed_rate) ||
 8016d1c:	d101      	bne.n	8016d22 <plan_feed_override+0x36>
 8016d1e:	e015      	b.n	8016d4c <plan_feed_override+0x60>
    bool feedrate_changed = false, rapidrate_changed = false;
 8016d20:	2600      	movs	r6, #0
        sys.override.feed_rate = feed_override;
 8016d22:	4b0d      	ldr	r3, [pc, #52]	; (8016d58 <plan_feed_override+0x6c>)
 8016d24:	61dc      	str	r4, [r3, #28]
        sys.override.rapid_rate = rapid_override;
 8016d26:	6219      	str	r1, [r3, #32]
        system_add_rt_report(Report_Overrides); // Set to report change immediately
 8016d28:	2040      	movs	r0, #64	; 0x40
 8016d2a:	f00a fa89 	bl	8021240 <system_add_rt_report>
        if(plan_update_velocity_profile_parameters())
 8016d2e:	f7ff fd3f 	bl	80167b0 <plan_update_velocity_profile_parameters>
 8016d32:	b960      	cbnz	r0, 8016d4e <plan_feed_override+0x62>
            plan_cycle_reinitialize();
        if(grbl.on_override_changed) {
 8016d34:	4b09      	ldr	r3, [pc, #36]	; (8016d5c <plan_feed_override+0x70>)
 8016d36:	6a1b      	ldr	r3, [r3, #32]
 8016d38:	b143      	cbz	r3, 8016d4c <plan_feed_override+0x60>
            if(feedrate_changed)
 8016d3a:	42a5      	cmp	r5, r4
 8016d3c:	d001      	beq.n	8016d42 <plan_feed_override+0x56>
                grbl.on_override_changed(OverrideChanged_FeedRate);
 8016d3e:	2000      	movs	r0, #0
 8016d40:	4798      	blx	r3
            if(rapidrate_changed)
 8016d42:	b11e      	cbz	r6, 8016d4c <plan_feed_override+0x60>
                grbl.on_override_changed(OverrideChanged_RapidRate);
 8016d44:	4b05      	ldr	r3, [pc, #20]	; (8016d5c <plan_feed_override+0x70>)
 8016d46:	6a1b      	ldr	r3, [r3, #32]
 8016d48:	2000      	movs	r0, #0
 8016d4a:	4798      	blx	r3
        }
    }
}
 8016d4c:	bd70      	pop	{r4, r5, r6, pc}
            plan_cycle_reinitialize();
 8016d4e:	f7ff ffbf 	bl	8016cd0 <plan_cycle_reinitialize>
 8016d52:	e7ef      	b.n	8016d34 <plan_feed_override+0x48>
 8016d54:	4770      	bx	lr
 8016d56:	bf00      	nop
 8016d58:	200036c4 	.word	0x200036c4
 8016d5c:	2000343c 	.word	0x2000343c

08016d60 <plan_data_init>:

void plan_data_init (plan_line_data_t *plan_data)
{
 8016d60:	b510      	push	{r4, lr}
 8016d62:	4604      	mov	r4, r0
    memset(plan_data, 0, sizeof(plan_line_data_t));
 8016d64:	2228      	movs	r2, #40	; 0x28
 8016d66:	2100      	movs	r1, #0
 8016d68:	f00b ff05 	bl	8022b76 <memset>
    plan_data->spindle.hal = gc_state.spindle.hal ? gc_state.spindle.hal : spindle_get(0);
 8016d6c:	4b03      	ldr	r3, [pc, #12]	; (8016d7c <plan_data_init+0x1c>)
 8016d6e:	6d58      	ldr	r0, [r3, #84]	; 0x54
 8016d70:	b108      	cbz	r0, 8016d76 <plan_data_init+0x16>
 8016d72:	6120      	str	r0, [r4, #16]
#ifdef KINEMATICS_API
    plan_data->rate_multiplier = 1.0;
#endif
}
 8016d74:	bd10      	pop	{r4, pc}
    plan_data->spindle.hal = gc_state.spindle.hal ? gc_state.spindle.hal : spindle_get(0);
 8016d76:	f006 fded 	bl	801d954 <spindle_get>
 8016d7a:	e7fa      	b.n	8016d72 <plan_data_init+0x12>
 8016d7c:	20003344 	.word	0x20003344

08016d80 <recheck_line>:

static bool recheck_line (char *line, line_flags_t *flags)
{
    bool keep_rt_commands = false, first_char = true;

    flags->value = 0;
 8016d80:	2300      	movs	r3, #0
 8016d82:	700b      	strb	r3, [r1, #0]

    if(*line != '\0') do {
 8016d84:	7803      	ldrb	r3, [r0, #0]
 8016d86:	2b00      	cmp	r3, #0
 8016d88:	d075      	beq.n	8016e76 <recheck_line+0xf6>
{
 8016d8a:	b410      	push	{r4}
 8016d8c:	4602      	mov	r2, r0
    bool keep_rt_commands = false, first_char = true;
 8016d8e:	2401      	movs	r4, #1
 8016d90:	2000      	movs	r0, #0
 8016d92:	e008      	b.n	8016da6 <recheck_line+0x26>

        switch(*line) {
 8016d94:	2b5b      	cmp	r3, #91	; 0x5b
 8016d96:	d101      	bne.n	8016d9c <recheck_line+0x1c>

            case '$':
            case '[':
                if(first_char)
 8016d98:	2c00      	cmp	r4, #0
 8016d9a:	d16a      	bne.n	8016e72 <recheck_line+0xf2>
                break;
        }

        first_char = false;

    } while(*++line != '\0');
 8016d9c:	f812 3f01 	ldrb.w	r3, [r2, #1]!
        first_char = false;
 8016da0:	2400      	movs	r4, #0
    } while(*++line != '\0');
 8016da2:	2b00      	cmp	r3, #0
 8016da4:	d069      	beq.n	8016e7a <recheck_line+0xfa>
        switch(*line) {
 8016da6:	7813      	ldrb	r3, [r2, #0]
 8016da8:	2b3b      	cmp	r3, #59	; 0x3b
 8016daa:	d8f3      	bhi.n	8016d94 <recheck_line+0x14>
 8016dac:	2b24      	cmp	r3, #36	; 0x24
 8016dae:	d3f5      	bcc.n	8016d9c <recheck_line+0x1c>
 8016db0:	3b24      	subs	r3, #36	; 0x24
 8016db2:	2b17      	cmp	r3, #23
 8016db4:	d8f2      	bhi.n	8016d9c <recheck_line+0x1c>
 8016db6:	f20f 0c08 	addw	ip, pc, #8
 8016dba:	f85c f023 	ldr.w	pc, [ip, r3, lsl #2]
 8016dbe:	bf00      	nop
 8016dc0:	08016d99 	.word	0x08016d99
 8016dc4:	08016d9d 	.word	0x08016d9d
 8016dc8:	08016d9d 	.word	0x08016d9d
 8016dcc:	08016d9d 	.word	0x08016d9d
 8016dd0:	08016e21 	.word	0x08016e21
 8016dd4:	08016e4d 	.word	0x08016e4d
 8016dd8:	08016d9d 	.word	0x08016d9d
 8016ddc:	08016d9d 	.word	0x08016d9d
 8016de0:	08016d9d 	.word	0x08016d9d
 8016de4:	08016d9d 	.word	0x08016d9d
 8016de8:	08016d9d 	.word	0x08016d9d
 8016dec:	08016d9d 	.word	0x08016d9d
 8016df0:	08016d9d 	.word	0x08016d9d
 8016df4:	08016d9d 	.word	0x08016d9d
 8016df8:	08016d9d 	.word	0x08016d9d
 8016dfc:	08016d9d 	.word	0x08016d9d
 8016e00:	08016d9d 	.word	0x08016d9d
 8016e04:	08016d9d 	.word	0x08016d9d
 8016e08:	08016d9d 	.word	0x08016d9d
 8016e0c:	08016d9d 	.word	0x08016d9d
 8016e10:	08016d9d 	.word	0x08016d9d
 8016e14:	08016d9d 	.word	0x08016d9d
 8016e18:	08016d9d 	.word	0x08016d9d
 8016e1c:	08016e61 	.word	0x08016e61
                if(!keep_rt_commands && (flags->comment_parentheses = !flags->comment_semicolon))
 8016e20:	2800      	cmp	r0, #0
 8016e22:	d1bb      	bne.n	8016d9c <recheck_line+0x1c>
 8016e24:	780c      	ldrb	r4, [r1, #0]
 8016e26:	08a3      	lsrs	r3, r4, #2
 8016e28:	f083 0301 	eor.w	r3, r3, #1
 8016e2c:	f003 0301 	and.w	r3, r3, #1
 8016e30:	f363 0441 	bfi	r4, r3, #1, #1
 8016e34:	700c      	strb	r4, [r1, #0]
 8016e36:	2b00      	cmp	r3, #0
 8016e38:	d0b0      	beq.n	8016d9c <recheck_line+0x1c>
                    keep_rt_commands = !hal.driver_cap.no_gcode_message_handling; // Suspend real-time processing of printable command characters.
 8016e3a:	4b11      	ldr	r3, [pc, #68]	; (8016e80 <recheck_line+0x100>)
 8016e3c:	f893 31a6 	ldrb.w	r3, [r3, #422]	; 0x1a6
 8016e40:	f013 0f02 	tst.w	r3, #2
 8016e44:	bf0c      	ite	eq
 8016e46:	2001      	moveq	r0, #1
 8016e48:	2000      	movne	r0, #0
 8016e4a:	e7a7      	b.n	8016d9c <recheck_line+0x1c>
                if(!flags->comment_semicolon)
 8016e4c:	780b      	ldrb	r3, [r1, #0]
 8016e4e:	f013 0f04 	tst.w	r3, #4
 8016e52:	d1a3      	bne.n	8016d9c <recheck_line+0x1c>
                    flags->comment_parentheses = keep_rt_commands = false;
 8016e54:	780b      	ldrb	r3, [r1, #0]
 8016e56:	f36f 0341 	bfc	r3, #1, #1
 8016e5a:	700b      	strb	r3, [r1, #0]
 8016e5c:	2000      	movs	r0, #0
 8016e5e:	e79d      	b.n	8016d9c <recheck_line+0x1c>
                if(!flags->comment_parentheses) {
 8016e60:	780b      	ldrb	r3, [r1, #0]
 8016e62:	f013 0f02 	tst.w	r3, #2
 8016e66:	d199      	bne.n	8016d9c <recheck_line+0x1c>
                    flags->comment_semicolon = On;
 8016e68:	f043 0304 	orr.w	r3, r3, #4
 8016e6c:	700b      	strb	r3, [r1, #0]
                    keep_rt_commands = false;
 8016e6e:	2000      	movs	r0, #0
 8016e70:	e794      	b.n	8016d9c <recheck_line+0x1c>
                    keep_rt_commands = true;
 8016e72:	4620      	mov	r0, r4
 8016e74:	e792      	b.n	8016d9c <recheck_line+0x1c>
    bool keep_rt_commands = false, first_char = true;
 8016e76:	2000      	movs	r0, #0

    return keep_rt_commands;
}
 8016e78:	4770      	bx	lr
 8016e7a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8016e7e:	4770      	bx	lr
 8016e80:	2000350c 	.word	0x2000350c

08016e84 <protocol_execute_rt_commands>:
    return ok;
}

// Execute enqueued functions.
static void protocol_execute_rt_commands (void)
{
 8016e84:	b538      	push	{r3, r4, r5, lr}
    while(realtime_queue.tail != realtime_queue.head) {
 8016e86:	e004      	b.n	8016e92 <protocol_execute_rt_commands+0xe>
        on_execute_realtime_ptr call;
        if((call = realtime_queue.fn[bptr])) {
            realtime_queue.fn[bptr] = NULL;
            call(state_get());
        }
        realtime_queue.tail = (bptr + 1) & (RT_QUEUE_SIZE - 1);
 8016e88:	3401      	adds	r4, #1
 8016e8a:	f004 0407 	and.w	r4, r4, #7
 8016e8e:	4b0e      	ldr	r3, [pc, #56]	; (8016ec8 <protocol_execute_rt_commands+0x44>)
 8016e90:	605c      	str	r4, [r3, #4]
    while(realtime_queue.tail != realtime_queue.head) {
 8016e92:	4b0d      	ldr	r3, [pc, #52]	; (8016ec8 <protocol_execute_rt_commands+0x44>)
 8016e94:	685a      	ldr	r2, [r3, #4]
 8016e96:	681b      	ldr	r3, [r3, #0]
 8016e98:	429a      	cmp	r2, r3
 8016e9a:	d00f      	beq.n	8016ebc <protocol_execute_rt_commands+0x38>
        uint_fast8_t bptr = realtime_queue.tail;
 8016e9c:	4b0a      	ldr	r3, [pc, #40]	; (8016ec8 <protocol_execute_rt_commands+0x44>)
 8016e9e:	685c      	ldr	r4, [r3, #4]
        if((call = realtime_queue.fn[bptr])) {
 8016ea0:	1ca2      	adds	r2, r4, #2
 8016ea2:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 8016ea6:	2d00      	cmp	r5, #0
 8016ea8:	d0ee      	beq.n	8016e88 <protocol_execute_rt_commands+0x4>
            realtime_queue.fn[bptr] = NULL;
 8016eaa:	4613      	mov	r3, r2
 8016eac:	4a06      	ldr	r2, [pc, #24]	; (8016ec8 <protocol_execute_rt_commands+0x44>)
 8016eae:	2100      	movs	r1, #0
 8016eb0:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
            call(state_get());
 8016eb4:	f007 fb96 	bl	801e5e4 <state_get>
 8016eb8:	47a8      	blx	r5
 8016eba:	e7e5      	b.n	8016e88 <protocol_execute_rt_commands+0x4>
    }

    if(!sys.driver_started)
 8016ebc:	4b03      	ldr	r3, [pc, #12]	; (8016ecc <protocol_execute_rt_commands+0x48>)
 8016ebe:	f893 307e 	ldrb.w	r3, [r3, #126]	; 0x7e
 8016ec2:	b903      	cbnz	r3, 8016ec6 <protocol_execute_rt_commands+0x42>
        while(true);
 8016ec4:	e7fe      	b.n	8016ec4 <protocol_execute_rt_commands+0x40>
}
 8016ec6:	bd38      	pop	{r3, r4, r5, pc}
 8016ec8:	2000395c 	.word	0x2000395c
 8016ecc:	200036c4 	.word	0x200036c4

08016ed0 <protocol_poll_cmd>:
{
 8016ed0:	b508      	push	{r3, lr}
    if((c = hal.stream.read()) != SERIAL_NO_DATA) {
 8016ed2:	4b2b      	ldr	r3, [pc, #172]	; (8016f80 <protocol_poll_cmd+0xb0>)
 8016ed4:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 8016ed8:	4798      	blx	r3
 8016eda:	f1b0 3fff 	cmp.w	r0, #4294967295
 8016ede:	d04b      	beq.n	8016f78 <protocol_poll_cmd+0xa8>
        if ((c == '\n') || (c == '\r')) { // End of line reached
 8016ee0:	280a      	cmp	r0, #10
 8016ee2:	d014      	beq.n	8016f0e <protocol_poll_cmd+0x3e>
 8016ee4:	280d      	cmp	r0, #13
 8016ee6:	d012      	beq.n	8016f0e <protocol_poll_cmd+0x3e>
        } else if(c == ASCII_DEL || c == ASCII_BS) {
 8016ee8:	287f      	cmp	r0, #127	; 0x7f
 8016eea:	d032      	beq.n	8016f52 <protocol_poll_cmd+0x82>
 8016eec:	2808      	cmp	r0, #8
 8016eee:	d030      	beq.n	8016f52 <protocol_poll_cmd+0x82>
        } else if(char_counter == 0 ? c != ' ' : char_counter < (LINE_BUFFER_SIZE - 1))
 8016ef0:	4b24      	ldr	r3, [pc, #144]	; (8016f84 <protocol_poll_cmd+0xb4>)
 8016ef2:	681b      	ldr	r3, [r3, #0]
 8016ef4:	2b00      	cmp	r3, #0
 8016ef6:	d137      	bne.n	8016f68 <protocol_poll_cmd+0x98>
 8016ef8:	f1b0 0220 	subs.w	r2, r0, #32
 8016efc:	bf18      	it	ne
 8016efe:	2201      	movne	r2, #1
 8016f00:	b1d2      	cbz	r2, 8016f38 <protocol_poll_cmd+0x68>
            line[char_counter++] = c;
 8016f02:	1c59      	adds	r1, r3, #1
 8016f04:	4a1f      	ldr	r2, [pc, #124]	; (8016f84 <protocol_poll_cmd+0xb4>)
 8016f06:	6011      	str	r1, [r2, #0]
 8016f08:	4a1f      	ldr	r2, [pc, #124]	; (8016f88 <protocol_poll_cmd+0xb8>)
 8016f0a:	54d0      	strb	r0, [r2, r3]
 8016f0c:	e014      	b.n	8016f38 <protocol_poll_cmd+0x68>
            line[char_counter] = '\0';
 8016f0e:	4b1d      	ldr	r3, [pc, #116]	; (8016f84 <protocol_poll_cmd+0xb4>)
 8016f10:	681a      	ldr	r2, [r3, #0]
 8016f12:	4b1d      	ldr	r3, [pc, #116]	; (8016f88 <protocol_poll_cmd+0xb8>)
 8016f14:	2100      	movs	r1, #0
 8016f16:	5499      	strb	r1, [r3, r2]
            gc_state.last_error = *line == '\0' ? Status_OK : (*line == '$' ? system_execute_line(line) : Status_SystemGClock);
 8016f18:	7818      	ldrb	r0, [r3, #0]
 8016f1a:	b110      	cbz	r0, 8016f22 <protocol_poll_cmd+0x52>
 8016f1c:	2824      	cmp	r0, #36	; 0x24
 8016f1e:	d014      	beq.n	8016f4a <protocol_poll_cmd+0x7a>
 8016f20:	2009      	movs	r0, #9
 8016f22:	4b1a      	ldr	r3, [pc, #104]	; (8016f8c <protocol_poll_cmd+0xbc>)
 8016f24:	f883 0079 	strb.w	r0, [r3, #121]	; 0x79
            char_counter = 0;
 8016f28:	2300      	movs	r3, #0
 8016f2a:	4a16      	ldr	r2, [pc, #88]	; (8016f84 <protocol_poll_cmd+0xb4>)
 8016f2c:	6013      	str	r3, [r2, #0]
            *line = '\0';
 8016f2e:	4a16      	ldr	r2, [pc, #88]	; (8016f88 <protocol_poll_cmd+0xb8>)
 8016f30:	7013      	strb	r3, [r2, #0]
            grbl.report.status_message(gc_state.last_error);
 8016f32:	4b17      	ldr	r3, [pc, #92]	; (8016f90 <protocol_poll_cmd+0xc0>)
 8016f34:	689b      	ldr	r3, [r3, #8]
 8016f36:	4798      	blx	r3
        keep_rt_commands = char_counter > 0 && *line == '$';
 8016f38:	4b12      	ldr	r3, [pc, #72]	; (8016f84 <protocol_poll_cmd+0xb4>)
 8016f3a:	681b      	ldr	r3, [r3, #0]
 8016f3c:	b1cb      	cbz	r3, 8016f72 <protocol_poll_cmd+0xa2>
 8016f3e:	4b12      	ldr	r3, [pc, #72]	; (8016f88 <protocol_poll_cmd+0xb8>)
 8016f40:	781b      	ldrb	r3, [r3, #0]
 8016f42:	2b24      	cmp	r3, #36	; 0x24
 8016f44:	d019      	beq.n	8016f7a <protocol_poll_cmd+0xaa>
 8016f46:	2200      	movs	r2, #0
 8016f48:	e014      	b.n	8016f74 <protocol_poll_cmd+0xa4>
            gc_state.last_error = *line == '\0' ? Status_OK : (*line == '$' ? system_execute_line(line) : Status_SystemGClock);
 8016f4a:	4618      	mov	r0, r3
 8016f4c:	f009 ff66 	bl	8020e1c <system_execute_line>
 8016f50:	e7e7      	b.n	8016f22 <protocol_poll_cmd+0x52>
            if(char_counter)
 8016f52:	4b0c      	ldr	r3, [pc, #48]	; (8016f84 <protocol_poll_cmd+0xb4>)
 8016f54:	681b      	ldr	r3, [r3, #0]
 8016f56:	2b00      	cmp	r3, #0
 8016f58:	d0ee      	beq.n	8016f38 <protocol_poll_cmd+0x68>
                line[--char_counter] = '\0';
 8016f5a:	3b01      	subs	r3, #1
 8016f5c:	4a09      	ldr	r2, [pc, #36]	; (8016f84 <protocol_poll_cmd+0xb4>)
 8016f5e:	6013      	str	r3, [r2, #0]
 8016f60:	4a09      	ldr	r2, [pc, #36]	; (8016f88 <protocol_poll_cmd+0xb8>)
 8016f62:	2100      	movs	r1, #0
 8016f64:	54d1      	strb	r1, [r2, r3]
 8016f66:	e7e7      	b.n	8016f38 <protocol_poll_cmd+0x68>
        } else if(char_counter == 0 ? c != ' ' : char_counter < (LINE_BUFFER_SIZE - 1))
 8016f68:	2bff      	cmp	r3, #255	; 0xff
 8016f6a:	bf8c      	ite	hi
 8016f6c:	2200      	movhi	r2, #0
 8016f6e:	2201      	movls	r2, #1
 8016f70:	e7c6      	b.n	8016f00 <protocol_poll_cmd+0x30>
        keep_rt_commands = char_counter > 0 && *line == '$';
 8016f72:	2200      	movs	r2, #0
 8016f74:	4b07      	ldr	r3, [pc, #28]	; (8016f94 <protocol_poll_cmd+0xc4>)
 8016f76:	701a      	strb	r2, [r3, #0]
}
 8016f78:	bd08      	pop	{r3, pc}
        keep_rt_commands = char_counter > 0 && *line == '$';
 8016f7a:	2201      	movs	r2, #1
 8016f7c:	e7fa      	b.n	8016f74 <protocol_poll_cmd+0xa4>
 8016f7e:	bf00      	nop
 8016f80:	2000350c 	.word	0x2000350c
 8016f84:	20003850 	.word	0x20003850
 8016f88:	20003858 	.word	0x20003858
 8016f8c:	20003344 	.word	0x20003344
 8016f90:	2000343c 	.word	0x2000343c
 8016f94:	20003855 	.word	0x20003855

08016f98 <protocol_enqueue_gcode>:
{
 8016f98:	b538      	push	{r3, r4, r5, lr}
 8016f9a:	4605      	mov	r5, r0
    bool ok = xcommand[0] == '\0' &&
 8016f9c:	4b19      	ldr	r3, [pc, #100]	; (8017004 <protocol_enqueue_gcode+0x6c>)
 8016f9e:	781b      	ldrb	r3, [r3, #0]
               (state_get() == STATE_IDLE || (state_get() & (STATE_JOG|STATE_TOOL_CHANGE))) &&
 8016fa0:	b193      	cbz	r3, 8016fc8 <protocol_enqueue_gcode+0x30>
 8016fa2:	2300      	movs	r3, #0
    if(ok && gc_state.file_run)
 8016fa4:	461c      	mov	r4, r3
 8016fa6:	b32b      	cbz	r3, 8016ff4 <protocol_enqueue_gcode+0x5c>
 8016fa8:	4b17      	ldr	r3, [pc, #92]	; (8017008 <protocol_enqueue_gcode+0x70>)
 8016faa:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
 8016fae:	b30b      	cbz	r3, 8016ff4 <protocol_enqueue_gcode+0x5c>
        ok = gc_state.modal.program_flow != ProgramFlow_Running || strncmp((char *)gcode, "$J=", 3);
 8016fb0:	4b15      	ldr	r3, [pc, #84]	; (8017008 <protocol_enqueue_gcode+0x70>)
 8016fb2:	7e1b      	ldrb	r3, [r3, #24]
 8016fb4:	b9db      	cbnz	r3, 8016fee <protocol_enqueue_gcode+0x56>
 8016fb6:	2203      	movs	r2, #3
 8016fb8:	4914      	ldr	r1, [pc, #80]	; (801700c <protocol_enqueue_gcode+0x74>)
 8016fba:	4628      	mov	r0, r5
 8016fbc:	f00b fdff 	bl	8022bbe <strncmp>
 8016fc0:	4604      	mov	r4, r0
 8016fc2:	b1a8      	cbz	r0, 8016ff0 <protocol_enqueue_gcode+0x58>
 8016fc4:	2401      	movs	r4, #1
 8016fc6:	e013      	b.n	8016ff0 <protocol_enqueue_gcode+0x58>
               (state_get() == STATE_IDLE || (state_get() & (STATE_JOG|STATE_TOOL_CHANGE))) &&
 8016fc8:	f007 fb0c 	bl	801e5e4 <state_get>
    bool ok = xcommand[0] == '\0' &&
 8016fcc:	b930      	cbnz	r0, 8016fdc <protocol_enqueue_gcode+0x44>
                 bit_isfalse(sys.rt_exec_state, EXEC_MOTION_CANCEL);
 8016fce:	4b10      	ldr	r3, [pc, #64]	; (8017010 <protocol_enqueue_gcode+0x78>)
 8016fd0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
               (state_get() == STATE_IDLE || (state_get() & (STATE_JOG|STATE_TOOL_CHANGE))) &&
 8016fd2:	f013 0f80 	tst.w	r3, #128	; 0x80
 8016fd6:	d108      	bne.n	8016fea <protocol_enqueue_gcode+0x52>
 8016fd8:	2301      	movs	r3, #1
 8016fda:	e7e3      	b.n	8016fa4 <protocol_enqueue_gcode+0xc>
 8016fdc:	f007 fb02 	bl	801e5e4 <state_get>
 8016fe0:	f410 7f08 	tst.w	r0, #544	; 0x220
 8016fe4:	d1f3      	bne.n	8016fce <protocol_enqueue_gcode+0x36>
 8016fe6:	2300      	movs	r3, #0
 8016fe8:	e7dc      	b.n	8016fa4 <protocol_enqueue_gcode+0xc>
 8016fea:	2300      	movs	r3, #0
 8016fec:	e7da      	b.n	8016fa4 <protocol_enqueue_gcode+0xc>
        ok = gc_state.modal.program_flow != ProgramFlow_Running || strncmp((char *)gcode, "$J=", 3);
 8016fee:	2401      	movs	r4, #1
 8016ff0:	f004 0401 	and.w	r4, r4, #1
    if(ok)
 8016ff4:	b90c      	cbnz	r4, 8016ffa <protocol_enqueue_gcode+0x62>
}
 8016ff6:	4620      	mov	r0, r4
 8016ff8:	bd38      	pop	{r3, r4, r5, pc}
        strcpy(xcommand, gcode);
 8016ffa:	4629      	mov	r1, r5
 8016ffc:	4801      	ldr	r0, [pc, #4]	; (8017004 <protocol_enqueue_gcode+0x6c>)
 8016ffe:	f00b ff0f 	bl	8022e20 <strcpy>
 8017002:	e7f8      	b.n	8016ff6 <protocol_enqueue_gcode+0x5e>
 8017004:	20003984 	.word	0x20003984
 8017008:	20003344 	.word	0x20003344
 801700c:	080272b0 	.word	0x080272b0
 8017010:	200036c4 	.word	0x200036c4

08017014 <protocol_auto_cycle_start>:
{
 8017014:	b508      	push	{r3, lr}
    if (plan_get_current_block() != NULL) // Check if there are any blocks in the buffer.
 8017016:	f7ff fb4d 	bl	80166b4 <plan_get_current_block>
 801701a:	b120      	cbz	r0, 8017026 <protocol_auto_cycle_start+0x12>
        system_set_exec_state_flag(EXEC_CYCLE_START); // If so, execute them!
 801701c:	4b02      	ldr	r3, [pc, #8]	; (8017028 <protocol_auto_cycle_start+0x14>)
 801701e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8017020:	2102      	movs	r1, #2
 8017022:	4802      	ldr	r0, [pc, #8]	; (801702c <protocol_auto_cycle_start+0x18>)
 8017024:	4798      	blx	r3
}
 8017026:	bd08      	pop	{r3, pc}
 8017028:	2000350c 	.word	0x2000350c
 801702c:	2000370c 	.word	0x2000370c

08017030 <protocol_exec_rt_system>:
{
 8017030:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (sys.rt_exec_alarm && (rt_exec = system_clear_exec_alarm())) { // Enter only if any bit flag is true
 8017032:	4b9e      	ldr	r3, [pc, #632]	; (80172ac <protocol_exec_rt_system+0x27c>)
 8017034:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8017036:	2b00      	cmp	r3, #0
 8017038:	d078      	beq.n	801712c <protocol_exec_rt_system+0xfc>
 801703a:	4b9d      	ldr	r3, [pc, #628]	; (80172b0 <protocol_exec_rt_system+0x280>)
 801703c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801703e:	2100      	movs	r1, #0
 8017040:	489c      	ldr	r0, [pc, #624]	; (80172b4 <protocol_exec_rt_system+0x284>)
 8017042:	4798      	blx	r3
 8017044:	4604      	mov	r4, r0
 8017046:	2800      	cmp	r0, #0
 8017048:	f000 812e 	beq.w	80172a8 <protocol_exec_rt_system+0x278>
        if((sys.reset_pending = !!(sys.rt_exec_state & EXEC_RESET))) {
 801704c:	4b97      	ldr	r3, [pc, #604]	; (80172ac <protocol_exec_rt_system+0x27c>)
 801704e:	6c9d      	ldr	r5, [r3, #72]	; 0x48
 8017050:	f3c5 1540 	ubfx	r5, r5, #5, #1
 8017054:	711d      	strb	r5, [r3, #4]
 8017056:	b995      	cbnz	r5, 801707e <protocol_exec_rt_system+0x4e>
        system_raise_alarm((alarm_code_t)rt_exec);
 8017058:	b2e6      	uxtb	r6, r4
 801705a:	4630      	mov	r0, r6
 801705c:	f00a f8a2 	bl	80211a4 <system_raise_alarm>
        if(killed) // Tell driver/plugins about reset.
 8017060:	b11d      	cbz	r5, 801706a <protocol_exec_rt_system+0x3a>
            hal.driver_reset();
 8017062:	4b93      	ldr	r3, [pc, #588]	; (80172b0 <protocol_exec_rt_system+0x280>)
 8017064:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 8017068:	4798      	blx	r3
        if((sys.blocking_event = (alarm_code_t)rt_exec == Alarm_HardLimit ||
 801706a:	1e73      	subs	r3, r6, #1
 801706c:	b2db      	uxtb	r3, r3
                                   (alarm_code_t)rt_exec == Alarm_EStop ||
 801706e:	2b01      	cmp	r3, #1
 8017070:	d90f      	bls.n	8017092 <protocol_exec_rt_system+0x62>
                                  (alarm_code_t)rt_exec == Alarm_SoftLimit ||
 8017072:	2e0a      	cmp	r6, #10
 8017074:	d022      	beq.n	80170bc <protocol_exec_rt_system+0x8c>
                                   (alarm_code_t)rt_exec == Alarm_EStop ||
 8017076:	2e11      	cmp	r6, #17
 8017078:	d009      	beq.n	801708e <protocol_exec_rt_system+0x5e>
 801707a:	2300      	movs	r3, #0
 801707c:	e00a      	b.n	8017094 <protocol_exec_rt_system+0x64>
            spindle_all_off();
 801707e:	f006 fe57 	bl	801dd30 <spindle_all_off>
            hal.coolant.set_state((coolant_state_t){0});
 8017082:	4b8b      	ldr	r3, [pc, #556]	; (80172b0 <protocol_exec_rt_system+0x280>)
 8017084:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8017086:	f04f 0000 	mov.w	r0, #0
 801708a:	4798      	blx	r3
 801708c:	e7e4      	b.n	8017058 <protocol_exec_rt_system+0x28>
                                   (alarm_code_t)rt_exec == Alarm_EStop ||
 801708e:	2301      	movs	r3, #1
 8017090:	e000      	b.n	8017094 <protocol_exec_rt_system+0x64>
 8017092:	2301      	movs	r3, #1
        if((sys.blocking_event = (alarm_code_t)rt_exec == Alarm_HardLimit ||
 8017094:	4a85      	ldr	r2, [pc, #532]	; (80172ac <protocol_exec_rt_system+0x27c>)
 8017096:	7153      	strb	r3, [r2, #5]
 8017098:	2b00      	cmp	r3, #0
 801709a:	d048      	beq.n	801712e <protocol_exec_rt_system+0xfe>
            system_set_exec_alarm(rt_exec);
 801709c:	4b84      	ldr	r3, [pc, #528]	; (80172b0 <protocol_exec_rt_system+0x280>)
 801709e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80170a0:	4621      	mov	r1, r4
 80170a2:	f102 004c 	add.w	r0, r2, #76	; 0x4c
 80170a6:	4798      	blx	r3
            switch((alarm_code_t)rt_exec) {
 80170a8:	b2e4      	uxtb	r4, r4
 80170aa:	2c0a      	cmp	r4, #10
 80170ac:	d008      	beq.n	80170c0 <protocol_exec_rt_system+0x90>
 80170ae:	2c11      	cmp	r4, #17
 80170b0:	d018      	beq.n	80170e4 <protocol_exec_rt_system+0xb4>
                    grbl.report.feedback_message(Message_CriticalEvent);
 80170b2:	4b81      	ldr	r3, [pc, #516]	; (80172b8 <protocol_exec_rt_system+0x288>)
 80170b4:	68db      	ldr	r3, [r3, #12]
 80170b6:	2001      	movs	r0, #1
 80170b8:	4798      	blx	r3
                    break;
 80170ba:	e005      	b.n	80170c8 <protocol_exec_rt_system+0x98>
                                   (alarm_code_t)rt_exec == Alarm_EStop ||
 80170bc:	2301      	movs	r3, #1
 80170be:	e7e9      	b.n	8017094 <protocol_exec_rt_system+0x64>
                    grbl.report.feedback_message(Message_EStop);
 80170c0:	4b7d      	ldr	r3, [pc, #500]	; (80172b8 <protocol_exec_rt_system+0x288>)
 80170c2:	68db      	ldr	r3, [r3, #12]
 80170c4:	200c      	movs	r0, #12
 80170c6:	4798      	blx	r3
            system_clear_exec_state_flag(EXEC_RESET); // Disable any existing reset
 80170c8:	4c79      	ldr	r4, [pc, #484]	; (80172b0 <protocol_exec_rt_system+0x280>)
 80170ca:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80170cc:	2120      	movs	r1, #32
 80170ce:	487b      	ldr	r0, [pc, #492]	; (80172bc <protocol_exec_rt_system+0x28c>)
 80170d0:	4798      	blx	r3
            *line = '\0';
 80170d2:	2300      	movs	r3, #0
 80170d4:	4a7a      	ldr	r2, [pc, #488]	; (80172c0 <protocol_exec_rt_system+0x290>)
 80170d6:	7013      	strb	r3, [r2, #0]
            char_counter = 0;
 80170d8:	4a7a      	ldr	r2, [pc, #488]	; (80172c4 <protocol_exec_rt_system+0x294>)
 80170da:	6013      	str	r3, [r2, #0]
            hal.stream.reset_read_buffer();
 80170dc:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 80170e0:	4798      	blx	r3
            while (bit_isfalse(sys.rt_exec_state, EXEC_RESET)) {
 80170e2:	e00b      	b.n	80170fc <protocol_exec_rt_system+0xcc>
                    grbl.report.feedback_message(Message_MotorFault);
 80170e4:	4b74      	ldr	r3, [pc, #464]	; (80172b8 <protocol_exec_rt_system+0x288>)
 80170e6:	68db      	ldr	r3, [r3, #12]
 80170e8:	2010      	movs	r0, #16
 80170ea:	4798      	blx	r3
                    break;
 80170ec:	e7ec      	b.n	80170c8 <protocol_exec_rt_system+0x98>
                protocol_poll_cmd();
 80170ee:	f7ff feef 	bl	8016ed0 <protocol_poll_cmd>
                grbl.on_execute_realtime(STATE_ESTOP);
 80170f2:	4b71      	ldr	r3, [pc, #452]	; (80172b8 <protocol_exec_rt_system+0x288>)
 80170f4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80170f6:	f44f 7080 	mov.w	r0, #256	; 0x100
 80170fa:	4798      	blx	r3
            while (bit_isfalse(sys.rt_exec_state, EXEC_RESET)) {
 80170fc:	4b6b      	ldr	r3, [pc, #428]	; (80172ac <protocol_exec_rt_system+0x27c>)
 80170fe:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8017100:	f013 0f20 	tst.w	r3, #32
 8017104:	d10c      	bne.n	8017120 <protocol_exec_rt_system+0xf0>
                if(bit_istrue(sys.rt_exec_state, EXEC_STATUS_REPORT)) {
 8017106:	4b69      	ldr	r3, [pc, #420]	; (80172ac <protocol_exec_rt_system+0x27c>)
 8017108:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801710a:	f013 0f01 	tst.w	r3, #1
 801710e:	d0ee      	beq.n	80170ee <protocol_exec_rt_system+0xbe>
                    system_clear_exec_state_flag(EXEC_STATUS_REPORT);
 8017110:	4b67      	ldr	r3, [pc, #412]	; (80172b0 <protocol_exec_rt_system+0x280>)
 8017112:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8017114:	2101      	movs	r1, #1
 8017116:	4869      	ldr	r0, [pc, #420]	; (80172bc <protocol_exec_rt_system+0x28c>)
 8017118:	4798      	blx	r3
                    report_realtime_status();
 801711a:	f003 f907 	bl	801a32c <report_realtime_status>
 801711e:	e7e6      	b.n	80170ee <protocol_exec_rt_system+0xbe>
            system_clear_exec_alarm(); // Clear alarm
 8017120:	4b63      	ldr	r3, [pc, #396]	; (80172b0 <protocol_exec_rt_system+0x280>)
 8017122:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8017124:	2100      	movs	r1, #0
 8017126:	4863      	ldr	r0, [pc, #396]	; (80172b4 <protocol_exec_rt_system+0x284>)
 8017128:	4798      	blx	r3
 801712a:	e000      	b.n	801712e <protocol_exec_rt_system+0xfe>
    bool killed = false;
 801712c:	2500      	movs	r5, #0
    if (sys.rt_exec_state && (rt_exec = system_clear_exec_states())) { // Get and clear volatile sys.rt_exec_state atomically.
 801712e:	4b5f      	ldr	r3, [pc, #380]	; (80172ac <protocol_exec_rt_system+0x27c>)
 8017130:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8017132:	2b00      	cmp	r3, #0
 8017134:	f000 808c 	beq.w	8017250 <protocol_exec_rt_system+0x220>
 8017138:	4b5d      	ldr	r3, [pc, #372]	; (80172b0 <protocol_exec_rt_system+0x280>)
 801713a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801713c:	2100      	movs	r1, #0
 801713e:	485f      	ldr	r0, [pc, #380]	; (80172bc <protocol_exec_rt_system+0x28c>)
 8017140:	4798      	blx	r3
 8017142:	4604      	mov	r4, r0
 8017144:	2800      	cmp	r0, #0
 8017146:	f000 8083 	beq.w	8017250 <protocol_exec_rt_system+0x220>
        if((sys.reset_pending = !!(rt_exec & EXEC_RESET))) {
 801714a:	f3c0 1340 	ubfx	r3, r0, #5, #1
 801714e:	4a57      	ldr	r2, [pc, #348]	; (80172ac <protocol_exec_rt_system+0x27c>)
 8017150:	7113      	strb	r3, [r2, #4]
 8017152:	2b00      	cmp	r3, #0
 8017154:	f040 80bc 	bne.w	80172d0 <protocol_exec_rt_system+0x2a0>
        if(rt_exec & EXEC_STOP) { // Experimental for now, must be verified. Do NOT move to interrupt context!
 8017158:	f010 0f10 	tst.w	r0, #16
 801715c:	d04f      	beq.n	80171fe <protocol_exec_rt_system+0x1ce>
            sys.cancel = true;
 801715e:	4b53      	ldr	r3, [pc, #332]	; (80172ac <protocol_exec_rt_system+0x27c>)
 8017160:	2201      	movs	r2, #1
 8017162:	705a      	strb	r2, [r3, #1]
            sys.step_control.flags = 0;
 8017164:	2200      	movs	r2, #0
 8017166:	761a      	strb	r2, [r3, #24]
            sys.flags.feed_hold_pending = Off;
 8017168:	7d99      	ldrb	r1, [r3, #22]
 801716a:	f362 1145 	bfi	r1, r2, #5, #1
 801716e:	7599      	strb	r1, [r3, #22]
            sys.override_delay.flags = 0;
 8017170:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
            if(sys.override.control.sync)
 8017174:	f993 3029 	ldrsb.w	r3, [r3, #41]	; 0x29
 8017178:	4293      	cmp	r3, r2
 801717a:	f2c0 80e8 	blt.w	801734e <protocol_exec_rt_system+0x31e>
            gc_state.tool_change = false;
 801717e:	4b52      	ldr	r3, [pc, #328]	; (80172c8 <protocol_exec_rt_system+0x298>)
 8017180:	2200      	movs	r2, #0
 8017182:	f883 2077 	strb.w	r2, [r3, #119]	; 0x77
            gc_state.modal.spindle.rpm_mode = SpindleSpeedMode_RPM;
 8017186:	76da      	strb	r2, [r3, #27]
            hal.driver_reset();
 8017188:	4b49      	ldr	r3, [pc, #292]	; (80172b0 <protocol_exec_rt_system+0x280>)
 801718a:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 801718e:	4798      	blx	r3
            if(!sys.flags.keep_input && hal.stream.suspend_read && hal.stream.suspend_read(false))
 8017190:	4b46      	ldr	r3, [pc, #280]	; (80172ac <protocol_exec_rt_system+0x27c>)
 8017192:	7ddb      	ldrb	r3, [r3, #23]
 8017194:	f013 0f01 	tst.w	r3, #1
 8017198:	d10a      	bne.n	80171b0 <protocol_exec_rt_system+0x180>
 801719a:	4b45      	ldr	r3, [pc, #276]	; (80172b0 <protocol_exec_rt_system+0x280>)
 801719c:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 80171a0:	b133      	cbz	r3, 80171b0 <protocol_exec_rt_system+0x180>
 80171a2:	2000      	movs	r0, #0
 80171a4:	4798      	blx	r3
 80171a6:	b118      	cbz	r0, 80171b0 <protocol_exec_rt_system+0x180>
                hal.stream.cancel_read_buffer(); // flush pending blocks (after M6)
 80171a8:	4b41      	ldr	r3, [pc, #260]	; (80172b0 <protocol_exec_rt_system+0x280>)
 80171aa:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 80171ae:	4798      	blx	r3
            sys.flags.keep_input = Off;
 80171b0:	4d3e      	ldr	r5, [pc, #248]	; (80172ac <protocol_exec_rt_system+0x27c>)
 80171b2:	7deb      	ldrb	r3, [r5, #23]
 80171b4:	f36f 0300 	bfc	r3, #0, #1
 80171b8:	75eb      	strb	r3, [r5, #23]
            gc_init();
 80171ba:	f7f7 ffb9 	bl	800f130 <gc_init>
            plan_reset();
 80171be:	f7ff f995 	bl	80164ec <plan_reset>
            st_reset();
 80171c2:	f007 ffd1 	bl	801f168 <st_reset>
            sync_position();
 80171c6:	f7ff fd5b 	bl	8016c80 <plan_sync_position>
 80171ca:	f105 0188 	add.w	r1, r5, #136	; 0x88
 80171ce:	483f      	ldr	r0, [pc, #252]	; (80172cc <protocol_exec_rt_system+0x29c>)
 80171d0:	f009 ff04 	bl	8020fdc <system_convert_array_steps_to_mpos>
            gc_spindle_off();
 80171d4:	f7f8 f83e 	bl	800f254 <gc_spindle_off>
            gc_coolant_off();
 80171d8:	f7f8 f84a 	bl	800f270 <gc_coolant_off>
            flush_override_buffers();
 80171dc:	f7ff f8da 	bl	8016394 <flush_override_buffers>
            if(!((state_get() == STATE_ALARM) && (sys.alarm == Alarm_LimitsEngaged || sys.alarm == Alarm_HomingRequired)))
 80171e0:	f007 fa00 	bl	801e5e4 <state_get>
 80171e4:	2801      	cmp	r0, #1
 80171e6:	f000 80b8 	beq.w	801735a <protocol_exec_rt_system+0x32a>
                state_set(hal.control.get_state().safety_door_ajar ? STATE_SAFETY_DOOR : STATE_IDLE);
 80171ea:	4b31      	ldr	r3, [pc, #196]	; (80172b0 <protocol_exec_rt_system+0x280>)
 80171ec:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80171ee:	4798      	blx	r3
 80171f0:	f010 0f08 	tst.w	r0, #8
 80171f4:	f000 80b9 	beq.w	801736a <protocol_exec_rt_system+0x33a>
 80171f8:	2040      	movs	r0, #64	; 0x40
 80171fa:	f007 f9f9 	bl	801e5f0 <state_set>
        if (rt_exec & EXEC_STATUS_REPORT)
 80171fe:	f014 0f01 	tst.w	r4, #1
 8017202:	f040 80b4 	bne.w	801736e <protocol_exec_rt_system+0x33e>
        if(rt_exec & EXEC_GCODE_REPORT)
 8017206:	f414 6f00 	tst.w	r4, #2048	; 0x800
 801720a:	f040 80b3 	bne.w	8017374 <protocol_exec_rt_system+0x344>
        if(rt_exec & EXEC_TLO_REPORT)
 801720e:	f414 5f80 	tst.w	r4, #4096	; 0x1000
 8017212:	f040 80b2 	bne.w	801737a <protocol_exec_rt_system+0x34a>
        if (rt_exec & EXEC_PID_REPORT)
 8017216:	f414 6f80 	tst.w	r4, #1024	; 0x400
 801721a:	f040 80b1 	bne.w	8017380 <protocol_exec_rt_system+0x350>
        if(rt_exec & EXEC_RT_COMMAND)
 801721e:	f414 5f00 	tst.w	r4, #8192	; 0x2000
 8017222:	f040 80b0 	bne.w	8017386 <protocol_exec_rt_system+0x356>
        rt_exec &= ~(EXEC_STOP|EXEC_STATUS_REPORT|EXEC_GCODE_REPORT|EXEC_PID_REPORT|EXEC_TLO_REPORT|EXEC_RT_COMMAND); // clear requests already processed
 8017226:	f424 5070 	bic.w	r0, r4, #15360	; 0x3c00
 801722a:	f020 0011 	bic.w	r0, r0, #17
        if(sys.flags.feed_hold_pending) {
 801722e:	4b1f      	ldr	r3, [pc, #124]	; (80172ac <protocol_exec_rt_system+0x27c>)
 8017230:	7d9b      	ldrb	r3, [r3, #22]
 8017232:	f013 0f20 	tst.w	r3, #32
 8017236:	d008      	beq.n	801724a <protocol_exec_rt_system+0x21a>
            if(rt_exec & EXEC_CYCLE_START)
 8017238:	f014 0f02 	tst.w	r4, #2
 801723c:	f000 80a6 	beq.w	801738c <protocol_exec_rt_system+0x35c>
                sys.flags.feed_hold_pending = Off;
 8017240:	4b1a      	ldr	r3, [pc, #104]	; (80172ac <protocol_exec_rt_system+0x27c>)
 8017242:	7d9a      	ldrb	r2, [r3, #22]
 8017244:	f36f 1245 	bfc	r2, #5, #1
 8017248:	759a      	strb	r2, [r3, #22]
        if(rt_exec)
 801724a:	2800      	cmp	r0, #0
 801724c:	f040 80a8 	bne.w	80173a0 <protocol_exec_rt_system+0x370>
    grbl.on_execute_realtime(state_get());
 8017250:	4b19      	ldr	r3, [pc, #100]	; (80172b8 <protocol_exec_rt_system+0x288>)
 8017252:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 8017254:	f007 f9c6 	bl	801e5e4 <state_get>
 8017258:	47a0      	blx	r4
    if(!sys.override_delay.feedrate && (rt_exec = get_feed_override())) {
 801725a:	4b14      	ldr	r3, [pc, #80]	; (80172ac <protocol_exec_rt_system+0x27c>)
 801725c:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8017260:	f013 0f01 	tst.w	r3, #1
 8017264:	f000 809f 	beq.w	80173a6 <protocol_exec_rt_system+0x376>
    if(!sys.override_delay.spindle && (rt_exec = get_spindle_override())) {
 8017268:	4b10      	ldr	r3, [pc, #64]	; (80172ac <protocol_exec_rt_system+0x27c>)
 801726a:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 801726e:	f013 0f04 	tst.w	r3, #4
 8017272:	f000 80d8 	beq.w	8017426 <protocol_exec_rt_system+0x3f6>
    if(!sys.override_delay.coolant && (rt_exec = get_coolant_override())) {
 8017276:	4b0d      	ldr	r3, [pc, #52]	; (80172ac <protocol_exec_rt_system+0x27c>)
 8017278:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 801727c:	f013 0f02 	tst.w	r3, #2
 8017280:	f000 8138 	beq.w	80174f4 <protocol_exec_rt_system+0x4c4>
    if (state_get() & (STATE_CYCLE | STATE_HOLD | STATE_SAFETY_DOOR | STATE_HOMING | STATE_SLEEP| STATE_JOG))
 8017284:	f007 f9ae 	bl	801e5e4 <state_get>
 8017288:	f010 0ffc 	tst.w	r0, #252	; 0xfc
 801728c:	f040 8189 	bne.w	80175a2 <protocol_exec_rt_system+0x572>
    return !ABORTED;
 8017290:	4b06      	ldr	r3, [pc, #24]	; (80172ac <protocol_exec_rt_system+0x27c>)
 8017292:	781b      	ldrb	r3, [r3, #0]
 8017294:	2b00      	cmp	r3, #0
 8017296:	f040 8187 	bne.w	80175a8 <protocol_exec_rt_system+0x578>
 801729a:	4b04      	ldr	r3, [pc, #16]	; (80172ac <protocol_exec_rt_system+0x27c>)
 801729c:	785b      	ldrb	r3, [r3, #1]
 801729e:	2b00      	cmp	r3, #0
 80172a0:	f000 8184 	beq.w	80175ac <protocol_exec_rt_system+0x57c>
 80172a4:	2000      	movs	r0, #0
 80172a6:	e180      	b.n	80175aa <protocol_exec_rt_system+0x57a>
    bool killed = false;
 80172a8:	2500      	movs	r5, #0
 80172aa:	e740      	b.n	801712e <protocol_exec_rt_system+0xfe>
 80172ac:	200036c4 	.word	0x200036c4
 80172b0:	2000350c 	.word	0x2000350c
 80172b4:	20003710 	.word	0x20003710
 80172b8:	2000343c 	.word	0x2000343c
 80172bc:	2000370c 	.word	0x2000370c
 80172c0:	20003858 	.word	0x20003858
 80172c4:	20003850 	.word	0x20003850
 80172c8:	20003344 	.word	0x20003344
 80172cc:	200033a4 	.word	0x200033a4
            if(!killed) {
 80172d0:	b305      	cbz	r5, 8017314 <protocol_exec_rt_system+0x2e4>
            if(!(sys.abort = !hal.control.get_state().e_stop)) {
 80172d2:	4ba6      	ldr	r3, [pc, #664]	; (801756c <protocol_exec_rt_system+0x53c>)
 80172d4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80172d6:	4798      	blx	r3
 80172d8:	f3c0 1381 	ubfx	r3, r0, #6, #2
 80172dc:	f083 0301 	eor.w	r3, r3, #1
 80172e0:	f003 0301 	and.w	r3, r3, #1
 80172e4:	4aa2      	ldr	r2, [pc, #648]	; (8017570 <protocol_exec_rt_system+0x540>)
 80172e6:	7013      	strb	r3, [r2, #0]
 80172e8:	b9e3      	cbnz	r3, 8017324 <protocol_exec_rt_system+0x2f4>
                hal.stream.reset_read_buffer();
 80172ea:	4ba0      	ldr	r3, [pc, #640]	; (801756c <protocol_exec_rt_system+0x53c>)
 80172ec:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 80172f0:	4798      	blx	r3
                system_raise_alarm(Alarm_EStop);
 80172f2:	200a      	movs	r0, #10
 80172f4:	f009 ff56 	bl	80211a4 <system_raise_alarm>
                grbl.report.feedback_message(Message_EStop);
 80172f8:	4b9e      	ldr	r3, [pc, #632]	; (8017574 <protocol_exec_rt_system+0x544>)
 80172fa:	68db      	ldr	r3, [r3, #12]
 80172fc:	200c      	movs	r0, #12
 80172fe:	4798      	blx	r3
            if(!killed) // Tell driver/plugins about reset.
 8017300:	b91d      	cbnz	r5, 801730a <protocol_exec_rt_system+0x2da>
                hal.driver_reset();
 8017302:	4b9a      	ldr	r3, [pc, #616]	; (801756c <protocol_exec_rt_system+0x53c>)
 8017304:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 8017308:	4798      	blx	r3
            return !sys.abort; // Nothing else to do but exit.
 801730a:	4b99      	ldr	r3, [pc, #612]	; (8017570 <protocol_exec_rt_system+0x540>)
 801730c:	7818      	ldrb	r0, [r3, #0]
 801730e:	f080 0001 	eor.w	r0, r0, #1
 8017312:	e14a      	b.n	80175aa <protocol_exec_rt_system+0x57a>
                spindle_all_off();
 8017314:	f006 fd0c 	bl	801dd30 <spindle_all_off>
                hal.coolant.set_state((coolant_state_t){0});
 8017318:	4b94      	ldr	r3, [pc, #592]	; (801756c <protocol_exec_rt_system+0x53c>)
 801731a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801731c:	f04f 0000 	mov.w	r0, #0
 8017320:	4798      	blx	r3
 8017322:	e7d6      	b.n	80172d2 <protocol_exec_rt_system+0x2a2>
            } else if(hal.control.get_state().motor_fault) {
 8017324:	4b91      	ldr	r3, [pc, #580]	; (801756c <protocol_exec_rt_system+0x53c>)
 8017326:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8017328:	4798      	blx	r3
 801732a:	f410 7f80 	tst.w	r0, #256	; 0x100
 801732e:	d0e7      	beq.n	8017300 <protocol_exec_rt_system+0x2d0>
                sys.abort = false;
 8017330:	4b8f      	ldr	r3, [pc, #572]	; (8017570 <protocol_exec_rt_system+0x540>)
 8017332:	2200      	movs	r2, #0
 8017334:	701a      	strb	r2, [r3, #0]
                hal.stream.reset_read_buffer();
 8017336:	4b8d      	ldr	r3, [pc, #564]	; (801756c <protocol_exec_rt_system+0x53c>)
 8017338:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 801733c:	4798      	blx	r3
                system_raise_alarm(Alarm_MotorFault);
 801733e:	2011      	movs	r0, #17
 8017340:	f009 ff30 	bl	80211a4 <system_raise_alarm>
                grbl.report.feedback_message(Message_MotorFault);
 8017344:	4b8b      	ldr	r3, [pc, #556]	; (8017574 <protocol_exec_rt_system+0x544>)
 8017346:	68db      	ldr	r3, [r3, #12]
 8017348:	2010      	movs	r0, #16
 801734a:	4798      	blx	r3
 801734c:	e7d8      	b.n	8017300 <protocol_exec_rt_system+0x2d0>
                sys.override.control = gc_state.modal.override_ctrl;
 801734e:	4b8a      	ldr	r3, [pc, #552]	; (8017578 <protocol_exec_rt_system+0x548>)
 8017350:	7f1a      	ldrb	r2, [r3, #28]
 8017352:	4b87      	ldr	r3, [pc, #540]	; (8017570 <protocol_exec_rt_system+0x540>)
 8017354:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
 8017358:	e711      	b.n	801717e <protocol_exec_rt_system+0x14e>
            if(!((state_get() == STATE_ALARM) && (sys.alarm == Alarm_LimitsEngaged || sys.alarm == Alarm_HomingRequired)))
 801735a:	f895 307c 	ldrb.w	r3, [r5, #124]	; 0x7c
 801735e:	3b0b      	subs	r3, #11
 8017360:	b2db      	uxtb	r3, r3
 8017362:	2b01      	cmp	r3, #1
 8017364:	f63f af41 	bhi.w	80171ea <protocol_exec_rt_system+0x1ba>
 8017368:	e749      	b.n	80171fe <protocol_exec_rt_system+0x1ce>
                state_set(hal.control.get_state().safety_door_ajar ? STATE_SAFETY_DOOR : STATE_IDLE);
 801736a:	2000      	movs	r0, #0
 801736c:	e745      	b.n	80171fa <protocol_exec_rt_system+0x1ca>
            report_realtime_status();
 801736e:	f002 ffdd 	bl	801a32c <report_realtime_status>
 8017372:	e748      	b.n	8017206 <protocol_exec_rt_system+0x1d6>
            report_gcode_modes();
 8017374:	f002 f9e2 	bl	801973c <report_gcode_modes>
 8017378:	e749      	b.n	801720e <protocol_exec_rt_system+0x1de>
            report_tool_offsets();
 801737a:	f002 f893 	bl	80194a4 <report_tool_offsets>
 801737e:	e74a      	b.n	8017216 <protocol_exec_rt_system+0x1e6>
            report_pid_log();
 8017380:	f004 f918 	bl	801b5b4 <report_pid_log>
 8017384:	e74b      	b.n	801721e <protocol_exec_rt_system+0x1ee>
            protocol_execute_rt_commands();
 8017386:	f7ff fd7d 	bl	8016e84 <protocol_execute_rt_commands>
 801738a:	e74c      	b.n	8017226 <protocol_exec_rt_system+0x1f6>
            else if(!sys.override.control.feed_hold_disable)
 801738c:	4b78      	ldr	r3, [pc, #480]	; (8017570 <protocol_exec_rt_system+0x540>)
 801738e:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8017392:	f013 0f02 	tst.w	r3, #2
 8017396:	f47f af58 	bne.w	801724a <protocol_exec_rt_system+0x21a>
                rt_exec |= EXEC_FEED_HOLD;
 801739a:	f040 0008 	orr.w	r0, r0, #8
 801739e:	e754      	b.n	801724a <protocol_exec_rt_system+0x21a>
            state_update(rt_exec);
 80173a0:	f007 fa7e 	bl	801e8a0 <state_update>
 80173a4:	e754      	b.n	8017250 <protocol_exec_rt_system+0x220>
    if(!sys.override_delay.feedrate && (rt_exec = get_feed_override())) {
 80173a6:	f7fe ff9f 	bl	80162e8 <get_feed_override>
 80173aa:	4603      	mov	r3, r0
 80173ac:	2800      	cmp	r0, #0
 80173ae:	f43f af5b 	beq.w	8017268 <protocol_exec_rt_system+0x238>
        override_t new_f_override = sys.override.feed_rate;
 80173b2:	4a6f      	ldr	r2, [pc, #444]	; (8017570 <protocol_exec_rt_system+0x540>)
 80173b4:	69d4      	ldr	r4, [r2, #28]
        override_t new_r_override = sys.override.rapid_rate;
 80173b6:	6a15      	ldr	r5, [r2, #32]
 80173b8:	e015      	b.n	80173e6 <protocol_exec_rt_system+0x3b6>
                    new_f_override += FEED_OVERRIDE_COARSE_INCREMENT;
 80173ba:	340a      	adds	r4, #10
                    break;
 80173bc:	e00a      	b.n	80173d4 <protocol_exec_rt_system+0x3a4>
                    new_f_override -= FEED_OVERRIDE_COARSE_INCREMENT;
 80173be:	3c0a      	subs	r4, #10
                    break;
 80173c0:	e008      	b.n	80173d4 <protocol_exec_rt_system+0x3a4>
                    new_f_override += FEED_OVERRIDE_FINE_INCREMENT;
 80173c2:	3401      	adds	r4, #1
                    break;
 80173c4:	e006      	b.n	80173d4 <protocol_exec_rt_system+0x3a4>
                    new_f_override -= FEED_OVERRIDE_FINE_INCREMENT;
 80173c6:	3c01      	subs	r4, #1
                    break;
 80173c8:	e004      	b.n	80173d4 <protocol_exec_rt_system+0x3a4>
                    new_r_override = RAPID_OVERRIDE_MEDIUM;
 80173ca:	2532      	movs	r5, #50	; 0x32
                    break;
 80173cc:	e002      	b.n	80173d4 <protocol_exec_rt_system+0x3a4>
                    new_r_override = RAPID_OVERRIDE_LOW;
 80173ce:	2519      	movs	r5, #25
                    break;
 80173d0:	e000      	b.n	80173d4 <protocol_exec_rt_system+0x3a4>
                    new_r_override = DEFAULT_RAPID_OVERRIDE;
 80173d2:	2564      	movs	r5, #100	; 0x64
            new_f_override = constrain(new_f_override, MIN_FEED_RATE_OVERRIDE, MAX_FEED_RATE_OVERRIDE);
 80173d4:	2c09      	cmp	r4, #9
 80173d6:	d91f      	bls.n	8017418 <protocol_exec_rt_system+0x3e8>
 80173d8:	2cc8      	cmp	r4, #200	; 0xc8
 80173da:	bf28      	it	cs
 80173dc:	24c8      	movcs	r4, #200	; 0xc8
        } while((rt_exec = get_feed_override()));
 80173de:	f7fe ff83 	bl	80162e8 <get_feed_override>
 80173e2:	4603      	mov	r3, r0
 80173e4:	b1d0      	cbz	r0, 801741c <protocol_exec_rt_system+0x3ec>
            switch(rt_exec) {
 80173e6:	3b90      	subs	r3, #144	; 0x90
 80173e8:	2b07      	cmp	r3, #7
 80173ea:	d8f3      	bhi.n	80173d4 <protocol_exec_rt_system+0x3a4>
 80173ec:	a201      	add	r2, pc, #4	; (adr r2, 80173f4 <protocol_exec_rt_system+0x3c4>)
 80173ee:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80173f2:	bf00      	nop
 80173f4:	08017415 	.word	0x08017415
 80173f8:	080173bb 	.word	0x080173bb
 80173fc:	080173bf 	.word	0x080173bf
 8017400:	080173c3 	.word	0x080173c3
 8017404:	080173c7 	.word	0x080173c7
 8017408:	080173d3 	.word	0x080173d3
 801740c:	080173cb 	.word	0x080173cb
 8017410:	080173cf 	.word	0x080173cf
 8017414:	2464      	movs	r4, #100	; 0x64
 8017416:	e7df      	b.n	80173d8 <protocol_exec_rt_system+0x3a8>
            new_f_override = constrain(new_f_override, MIN_FEED_RATE_OVERRIDE, MAX_FEED_RATE_OVERRIDE);
 8017418:	240a      	movs	r4, #10
 801741a:	e7e0      	b.n	80173de <protocol_exec_rt_system+0x3ae>
        plan_feed_override(new_f_override, new_r_override);
 801741c:	4629      	mov	r1, r5
 801741e:	4620      	mov	r0, r4
 8017420:	f7ff fc64 	bl	8016cec <plan_feed_override>
 8017424:	e720      	b.n	8017268 <protocol_exec_rt_system+0x238>
    if(!sys.override_delay.spindle && (rt_exec = get_spindle_override())) {
 8017426:	f7fe ff81 	bl	801632c <get_spindle_override>
 801742a:	4605      	mov	r5, r0
 801742c:	2800      	cmp	r0, #0
 801742e:	f43f af22 	beq.w	8017276 <protocol_exec_rt_system+0x246>
        spindle_ptrs_t *spindle = gc_spindle_get();
 8017432:	f7f7 ff2d 	bl	800f290 <gc_spindle_get>
 8017436:	4606      	mov	r6, r0
        override_t last_s_override = spindle->param->override_pct;
 8017438:	6843      	ldr	r3, [r0, #4]
 801743a:	68dc      	ldr	r4, [r3, #12]
        bool spindle_stop = false;
 801743c:	2700      	movs	r7, #0
 801743e:	e009      	b.n	8017454 <protocol_exec_rt_system+0x424>
                    last_s_override += SPINDLE_OVERRIDE_COARSE_INCREMENT;
 8017440:	340a      	adds	r4, #10
            last_s_override = constrain(last_s_override, MIN_SPINDLE_RPM_OVERRIDE, MAX_SPINDLE_RPM_OVERRIDE);
 8017442:	2c09      	cmp	r4, #9
 8017444:	d92c      	bls.n	80174a0 <protocol_exec_rt_system+0x470>
 8017446:	2cc8      	cmp	r4, #200	; 0xc8
 8017448:	bf28      	it	cs
 801744a:	24c8      	movcs	r4, #200	; 0xc8
        } while((rt_exec = get_spindle_override()));
 801744c:	f7fe ff6e 	bl	801632c <get_spindle_override>
 8017450:	4605      	mov	r5, r0
 8017452:	b338      	cbz	r0, 80174a4 <protocol_exec_rt_system+0x474>
            switch(rt_exec) {
 8017454:	f1a5 0399 	sub.w	r3, r5, #153	; 0x99
 8017458:	2b05      	cmp	r3, #5
 801745a:	d818      	bhi.n	801748e <protocol_exec_rt_system+0x45e>
 801745c:	a201      	add	r2, pc, #4	; (adr r2, 8017464 <protocol_exec_rt_system+0x434>)
 801745e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8017462:	bf00      	nop
 8017464:	0801749d 	.word	0x0801749d
 8017468:	08017441 	.word	0x08017441
 801746c:	0801747d 	.word	0x0801747d
 8017470:	08017481 	.word	0x08017481
 8017474:	08017485 	.word	0x08017485
 8017478:	08017489 	.word	0x08017489
                    last_s_override -= SPINDLE_OVERRIDE_COARSE_INCREMENT;
 801747c:	3c0a      	subs	r4, #10
                    break;
 801747e:	e7e0      	b.n	8017442 <protocol_exec_rt_system+0x412>
                    last_s_override += SPINDLE_OVERRIDE_FINE_INCREMENT;
 8017480:	3401      	adds	r4, #1
                    break;
 8017482:	e7de      	b.n	8017442 <protocol_exec_rt_system+0x412>
                    last_s_override -= SPINDLE_OVERRIDE_FINE_INCREMENT;
 8017484:	3c01      	subs	r4, #1
                    break;
 8017486:	e7dc      	b.n	8017442 <protocol_exec_rt_system+0x412>
                    spindle_stop = !spindle_stop;
 8017488:	f087 0701 	eor.w	r7, r7, #1
                    break;
 801748c:	e7d9      	b.n	8017442 <protocol_exec_rt_system+0x412>
                    if(grbl.on_unknown_accessory_override)
 801748e:	4b39      	ldr	r3, [pc, #228]	; (8017574 <protocol_exec_rt_system+0x544>)
 8017490:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8017492:	2b00      	cmp	r3, #0
 8017494:	d0d5      	beq.n	8017442 <protocol_exec_rt_system+0x412>
                        grbl.on_unknown_accessory_override(rt_exec);
 8017496:	b2e8      	uxtb	r0, r5
 8017498:	4798      	blx	r3
 801749a:	e7d2      	b.n	8017442 <protocol_exec_rt_system+0x412>
            switch(rt_exec) {
 801749c:	2464      	movs	r4, #100	; 0x64
 801749e:	e7d2      	b.n	8017446 <protocol_exec_rt_system+0x416>
            last_s_override = constrain(last_s_override, MIN_SPINDLE_RPM_OVERRIDE, MAX_SPINDLE_RPM_OVERRIDE);
 80174a0:	240a      	movs	r4, #10
 80174a2:	e7d3      	b.n	801744c <protocol_exec_rt_system+0x41c>
        spindle_set_override(spindle, last_s_override);
 80174a4:	4621      	mov	r1, r4
 80174a6:	4630      	mov	r0, r6
 80174a8:	f006 fbfc 	bl	801dca4 <spindle_set_override>
        if (spindle_stop && state_get() == STATE_HOLD && gc_state.modal.spindle.state.on) {
 80174ac:	2f00      	cmp	r7, #0
 80174ae:	f43f aee2 	beq.w	8017276 <protocol_exec_rt_system+0x246>
 80174b2:	f007 f897 	bl	801e5e4 <state_get>
 80174b6:	2810      	cmp	r0, #16
 80174b8:	f47f aedd 	bne.w	8017276 <protocol_exec_rt_system+0x246>
 80174bc:	4b2e      	ldr	r3, [pc, #184]	; (8017578 <protocol_exec_rt_system+0x548>)
 80174be:	7e9b      	ldrb	r3, [r3, #26]
 80174c0:	f013 0f01 	tst.w	r3, #1
 80174c4:	f43f aed7 	beq.w	8017276 <protocol_exec_rt_system+0x246>
            if (!sys.override.spindle_stop.value)
 80174c8:	4b29      	ldr	r3, [pc, #164]	; (8017570 <protocol_exec_rt_system+0x540>)
 80174ca:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 80174ce:	b92b      	cbnz	r3, 80174dc <protocol_exec_rt_system+0x4ac>
                sys.override.spindle_stop.initiate = On;
 80174d0:	4a27      	ldr	r2, [pc, #156]	; (8017570 <protocol_exec_rt_system+0x540>)
 80174d2:	f043 0302 	orr.w	r3, r3, #2
 80174d6:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
 80174da:	e6cc      	b.n	8017276 <protocol_exec_rt_system+0x246>
            else if (sys.override.spindle_stop.enabled)
 80174dc:	f013 0f01 	tst.w	r3, #1
 80174e0:	f43f aec9 	beq.w	8017276 <protocol_exec_rt_system+0x246>
                sys.override.spindle_stop.restore = On;
 80174e4:	4a22      	ldr	r2, [pc, #136]	; (8017570 <protocol_exec_rt_system+0x540>)
 80174e6:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 80174ea:	f043 0304 	orr.w	r3, r3, #4
 80174ee:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
 80174f2:	e6c0      	b.n	8017276 <protocol_exec_rt_system+0x246>
    if(!sys.override_delay.coolant && (rt_exec = get_coolant_override())) {
 80174f4:	f7fe ff3c 	bl	8016370 <get_coolant_override>
 80174f8:	4603      	mov	r3, r0
 80174fa:	2800      	cmp	r0, #0
 80174fc:	f43f aec2 	beq.w	8017284 <protocol_exec_rt_system+0x254>
        coolant_state_t coolant_state = gc_state.modal.coolant;
 8017500:	4a1d      	ldr	r2, [pc, #116]	; (8017578 <protocol_exec_rt_system+0x548>)
 8017502:	7e54      	ldrb	r4, [r2, #25]
 8017504:	e010      	b.n	8017528 <protocol_exec_rt_system+0x4f8>
                    if (hal.driver_cap.mist_control && ((state_get() == STATE_IDLE) || (state_get() & (STATE_CYCLE | STATE_HOLD)))) {
 8017506:	f007 f86d 	bl	801e5e4 <state_get>
 801750a:	f010 0f18 	tst.w	r0, #24
 801750e:	d007      	beq.n	8017520 <protocol_exec_rt_system+0x4f0>
 8017510:	e018      	b.n	8017544 <protocol_exec_rt_system+0x514>
                    if ((state_get() == STATE_IDLE) || (state_get() & (STATE_CYCLE | STATE_HOLD))) {
 8017512:	f007 f867 	bl	801e5e4 <state_get>
 8017516:	b9e0      	cbnz	r0, 8017552 <protocol_exec_rt_system+0x522>
                        coolant_state.flood = !coolant_state.flood;
 8017518:	f084 0301 	eor.w	r3, r4, #1
 801751c:	f363 0400 	bfi	r4, r3, #0, #1
        } while((rt_exec = get_coolant_override()));
 8017520:	f7fe ff26 	bl	8016370 <get_coolant_override>
 8017524:	4603      	mov	r3, r0
 8017526:	b348      	cbz	r0, 801757c <protocol_exec_rt_system+0x54c>
            switch(rt_exec) {
 8017528:	2ba0      	cmp	r3, #160	; 0xa0
 801752a:	d0f2      	beq.n	8017512 <protocol_exec_rt_system+0x4e2>
 801752c:	2ba1      	cmp	r3, #161	; 0xa1
 801752e:	d116      	bne.n	801755e <protocol_exec_rt_system+0x52e>
                    if (hal.driver_cap.mist_control && ((state_get() == STATE_IDLE) || (state_get() & (STATE_CYCLE | STATE_HOLD)))) {
 8017530:	4b0e      	ldr	r3, [pc, #56]	; (801756c <protocol_exec_rt_system+0x53c>)
 8017532:	f893 31a4 	ldrb.w	r3, [r3, #420]	; 0x1a4
 8017536:	f013 0f01 	tst.w	r3, #1
 801753a:	d0f1      	beq.n	8017520 <protocol_exec_rt_system+0x4f0>
 801753c:	f007 f852 	bl	801e5e4 <state_get>
 8017540:	2800      	cmp	r0, #0
 8017542:	d1e0      	bne.n	8017506 <protocol_exec_rt_system+0x4d6>
                        coolant_state.mist = !coolant_state.mist;
 8017544:	f3c4 0346 	ubfx	r3, r4, #1, #7
 8017548:	f083 0301 	eor.w	r3, r3, #1
 801754c:	f363 0441 	bfi	r4, r3, #1, #1
 8017550:	e7e6      	b.n	8017520 <protocol_exec_rt_system+0x4f0>
                    if ((state_get() == STATE_IDLE) || (state_get() & (STATE_CYCLE | STATE_HOLD))) {
 8017552:	f007 f847 	bl	801e5e4 <state_get>
 8017556:	f010 0f18 	tst.w	r0, #24
 801755a:	d0e1      	beq.n	8017520 <protocol_exec_rt_system+0x4f0>
 801755c:	e7dc      	b.n	8017518 <protocol_exec_rt_system+0x4e8>
                    if(grbl.on_unknown_accessory_override)
 801755e:	4a05      	ldr	r2, [pc, #20]	; (8017574 <protocol_exec_rt_system+0x544>)
 8017560:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 8017562:	2a00      	cmp	r2, #0
 8017564:	d0dc      	beq.n	8017520 <protocol_exec_rt_system+0x4f0>
                        grbl.on_unknown_accessory_override(rt_exec);
 8017566:	b2d8      	uxtb	r0, r3
 8017568:	4790      	blx	r2
 801756a:	e7d9      	b.n	8017520 <protocol_exec_rt_system+0x4f0>
 801756c:	2000350c 	.word	0x2000350c
 8017570:	200036c4 	.word	0x200036c4
 8017574:	2000343c 	.word	0x2000343c
 8017578:	20003344 	.word	0x20003344
        if(coolant_state.value != gc_state.modal.coolant.value) {
 801757c:	b2e3      	uxtb	r3, r4
 801757e:	4a0c      	ldr	r2, [pc, #48]	; (80175b0 <protocol_exec_rt_system+0x580>)
 8017580:	7e52      	ldrb	r2, [r2, #25]
 8017582:	4293      	cmp	r3, r2
 8017584:	f43f ae7e 	beq.w	8017284 <protocol_exec_rt_system+0x254>
            coolant_set_state(coolant_state); // Report flag set in coolant_set_state().
 8017588:	4620      	mov	r0, r4
 801758a:	f7f7 fc27 	bl	800eddc <coolant_set_state>
            gc_state.modal.coolant = coolant_state;
 801758e:	4b08      	ldr	r3, [pc, #32]	; (80175b0 <protocol_exec_rt_system+0x580>)
 8017590:	765c      	strb	r4, [r3, #25]
            if(grbl.on_override_changed)
 8017592:	4b08      	ldr	r3, [pc, #32]	; (80175b4 <protocol_exec_rt_system+0x584>)
 8017594:	6a1b      	ldr	r3, [r3, #32]
 8017596:	2b00      	cmp	r3, #0
 8017598:	f43f ae74 	beq.w	8017284 <protocol_exec_rt_system+0x254>
                grbl.on_override_changed(OverrideChanged_CoolantState);
 801759c:	2000      	movs	r0, #0
 801759e:	4798      	blx	r3
 80175a0:	e670      	b.n	8017284 <protocol_exec_rt_system+0x254>
        st_prep_buffer();
 80175a2:	f007 ff15 	bl	801f3d0 <st_prep_buffer>
 80175a6:	e673      	b.n	8017290 <protocol_exec_rt_system+0x260>
    return !ABORTED;
 80175a8:	2000      	movs	r0, #0
}
 80175aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return !ABORTED;
 80175ac:	2001      	movs	r0, #1
 80175ae:	e7fc      	b.n	80175aa <protocol_exec_rt_system+0x57a>
 80175b0:	20003344 	.word	0x20003344
 80175b4:	2000343c 	.word	0x2000343c

080175b8 <protocol_exec_rt_suspend>:
{
 80175b8:	b508      	push	{r3, lr}
    if((sys.blocking_event = state == STATE_SLEEP)) {
 80175ba:	2880      	cmp	r0, #128	; 0x80
 80175bc:	bf14      	ite	ne
 80175be:	2000      	movne	r0, #0
 80175c0:	2001      	moveq	r0, #1
 80175c2:	4b1c      	ldr	r3, [pc, #112]	; (8017634 <protocol_exec_rt_suspend+0x7c>)
 80175c4:	7158      	strb	r0, [r3, #5]
 80175c6:	b1a0      	cbz	r0, 80175f2 <protocol_exec_rt_suspend+0x3a>
        *line = '\0';
 80175c8:	2300      	movs	r3, #0
 80175ca:	4a1b      	ldr	r2, [pc, #108]	; (8017638 <protocol_exec_rt_suspend+0x80>)
 80175cc:	7013      	strb	r3, [r2, #0]
        char_counter = 0;
 80175ce:	4a1b      	ldr	r2, [pc, #108]	; (801763c <protocol_exec_rt_suspend+0x84>)
 80175d0:	6013      	str	r3, [r2, #0]
        hal.stream.reset_read_buffer();
 80175d2:	4b1b      	ldr	r3, [pc, #108]	; (8017640 <protocol_exec_rt_suspend+0x88>)
 80175d4:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 80175d8:	4798      	blx	r3
 80175da:	e00a      	b.n	80175f2 <protocol_exec_rt_suspend+0x3a>
            protocol_poll_cmd();
 80175dc:	f7ff fc78 	bl	8016ed0 <protocol_poll_cmd>
 80175e0:	e011      	b.n	8017606 <protocol_exec_rt_suspend+0x4e>
        if(settings.flags.sleep_enable)
 80175e2:	4b18      	ldr	r3, [pc, #96]	; (8017644 <protocol_exec_rt_suspend+0x8c>)
 80175e4:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 80175e8:	f013 0f08 	tst.w	r3, #8
 80175ec:	d11e      	bne.n	801762c <protocol_exec_rt_suspend+0x74>
        protocol_exec_rt_system();
 80175ee:	f7ff fd1f 	bl	8017030 <protocol_exec_rt_system>
    while(sys.suspend) {
 80175f2:	4b10      	ldr	r3, [pc, #64]	; (8017634 <protocol_exec_rt_suspend+0x7c>)
 80175f4:	789b      	ldrb	r3, [r3, #2]
 80175f6:	b1e3      	cbz	r3, 8017632 <protocol_exec_rt_suspend+0x7a>
        if(sys.abort)
 80175f8:	4b0e      	ldr	r3, [pc, #56]	; (8017634 <protocol_exec_rt_suspend+0x7c>)
 80175fa:	781b      	ldrb	r3, [r3, #0]
 80175fc:	b9cb      	cbnz	r3, 8017632 <protocol_exec_rt_suspend+0x7a>
        if(sys.blocking_event)
 80175fe:	4b0d      	ldr	r3, [pc, #52]	; (8017634 <protocol_exec_rt_suspend+0x7c>)
 8017600:	795b      	ldrb	r3, [r3, #5]
 8017602:	2b00      	cmp	r3, #0
 8017604:	d1ea      	bne.n	80175dc <protocol_exec_rt_suspend+0x24>
        state_suspend_manager();
 8017606:	f007 fb4b 	bl	801eca0 <state_suspend_manager>
        if(state_get() == STATE_SAFETY_DOOR && !hal.control.get_state().safety_door_ajar)
 801760a:	f006 ffeb 	bl	801e5e4 <state_get>
 801760e:	2840      	cmp	r0, #64	; 0x40
 8017610:	d1e7      	bne.n	80175e2 <protocol_exec_rt_suspend+0x2a>
 8017612:	4b0b      	ldr	r3, [pc, #44]	; (8017640 <protocol_exec_rt_suspend+0x88>)
 8017614:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8017616:	4798      	blx	r3
 8017618:	f010 0f08 	tst.w	r0, #8
 801761c:	d1e1      	bne.n	80175e2 <protocol_exec_rt_suspend+0x2a>
            system_set_exec_state_flag(EXEC_DOOR_CLOSED);
 801761e:	4b08      	ldr	r3, [pc, #32]	; (8017640 <protocol_exec_rt_suspend+0x88>)
 8017620:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8017622:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8017626:	4808      	ldr	r0, [pc, #32]	; (8017648 <protocol_exec_rt_suspend+0x90>)
 8017628:	4798      	blx	r3
 801762a:	e7da      	b.n	80175e2 <protocol_exec_rt_suspend+0x2a>
            sleep_check();
 801762c:	f005 feb2 	bl	801d394 <sleep_check>
 8017630:	e7dd      	b.n	80175ee <protocol_exec_rt_suspend+0x36>
}
 8017632:	bd08      	pop	{r3, pc}
 8017634:	200036c4 	.word	0x200036c4
 8017638:	20003858 	.word	0x20003858
 801763c:	20003850 	.word	0x20003850
 8017640:	2000350c 	.word	0x2000350c
 8017644:	20003b14 	.word	0x20003b14
 8017648:	2000370c 	.word	0x2000370c

0801764c <protocol_execute_realtime>:
{
 801764c:	b510      	push	{r4, lr}
    if(protocol_exec_rt_system()) {
 801764e:	f7ff fcef 	bl	8017030 <protocol_exec_rt_system>
 8017652:	b938      	cbnz	r0, 8017664 <protocol_execute_realtime+0x18>
    return !ABORTED;
 8017654:	4b12      	ldr	r3, [pc, #72]	; (80176a0 <protocol_execute_realtime+0x54>)
 8017656:	781b      	ldrb	r3, [r3, #0]
 8017658:	b9f3      	cbnz	r3, 8017698 <protocol_execute_realtime+0x4c>
 801765a:	4b11      	ldr	r3, [pc, #68]	; (80176a0 <protocol_execute_realtime+0x54>)
 801765c:	785b      	ldrb	r3, [r3, #1]
 801765e:	b1eb      	cbz	r3, 801769c <protocol_execute_realtime+0x50>
 8017660:	2000      	movs	r0, #0
 8017662:	e01a      	b.n	801769a <protocol_execute_realtime+0x4e>
        sys_state_t state = state_get();
 8017664:	f006 ffbe 	bl	801e5e4 <state_get>
 8017668:	4604      	mov	r4, r0
        if(sys.suspend)
 801766a:	4b0d      	ldr	r3, [pc, #52]	; (80176a0 <protocol_execute_realtime+0x54>)
 801766c:	789b      	ldrb	r3, [r3, #2]
 801766e:	b983      	cbnz	r3, 8017692 <protocol_execute_realtime+0x46>
        if((state == STATE_IDLE || (state & (STATE_ALARM|STATE_ESTOP))) && settings_dirty.is_dirty && !gc_state.file_run)
 8017670:	b11c      	cbz	r4, 801767a <protocol_execute_realtime+0x2e>
 8017672:	f240 1301 	movw	r3, #257	; 0x101
 8017676:	421c      	tst	r4, r3
 8017678:	d0ec      	beq.n	8017654 <protocol_execute_realtime+0x8>
 801767a:	4b0a      	ldr	r3, [pc, #40]	; (80176a4 <protocol_execute_realtime+0x58>)
 801767c:	781b      	ldrb	r3, [r3, #0]
 801767e:	2b00      	cmp	r3, #0
 8017680:	d0e8      	beq.n	8017654 <protocol_execute_realtime+0x8>
 8017682:	4b09      	ldr	r3, [pc, #36]	; (80176a8 <protocol_execute_realtime+0x5c>)
 8017684:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
 8017688:	2b00      	cmp	r3, #0
 801768a:	d1e3      	bne.n	8017654 <protocol_execute_realtime+0x8>
            nvs_buffer_sync_physical();
 801768c:	f7fe fd20 	bl	80160d0 <nvs_buffer_sync_physical>
 8017690:	e7e0      	b.n	8017654 <protocol_execute_realtime+0x8>
            protocol_exec_rt_suspend(state);
 8017692:	f7ff ff91 	bl	80175b8 <protocol_exec_rt_suspend>
 8017696:	e7eb      	b.n	8017670 <protocol_execute_realtime+0x24>
    return !ABORTED;
 8017698:	2000      	movs	r0, #0
}
 801769a:	bd10      	pop	{r4, pc}
    return !ABORTED;
 801769c:	2001      	movs	r0, #1
 801769e:	e7fc      	b.n	801769a <protocol_execute_realtime+0x4e>
 80176a0:	200036c4 	.word	0x200036c4
 80176a4:	200037cc 	.word	0x200037cc
 80176a8:	20003344 	.word	0x20003344

080176ac <protocol_main_loop>:
{
 80176ac:	b510      	push	{r4, lr}
 80176ae:	b082      	sub	sp, #8
    if(sys.alarm == Alarm_SelftestFailed) {
 80176b0:	4b9f      	ldr	r3, [pc, #636]	; (8017930 <protocol_main_loop+0x284>)
 80176b2:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 80176b6:	2b10      	cmp	r3, #16
 80176b8:	d03c      	beq.n	8017734 <protocol_main_loop+0x88>
    } else if (hal.control.get_state().e_stop) {
 80176ba:	4b9e      	ldr	r3, [pc, #632]	; (8017934 <protocol_main_loop+0x288>)
 80176bc:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80176be:	4798      	blx	r3
 80176c0:	f010 0f40 	tst.w	r0, #64	; 0x40
 80176c4:	d13e      	bne.n	8017744 <protocol_main_loop+0x98>
    } else if(hal.control.get_state().motor_fault) {
 80176c6:	4b9b      	ldr	r3, [pc, #620]	; (8017934 <protocol_main_loop+0x288>)
 80176c8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80176ca:	4798      	blx	r3
 80176cc:	f410 7f80 	tst.w	r0, #256	; 0x100
 80176d0:	d165      	bne.n	801779e <protocol_main_loop+0xf2>
    } else if(settings.probe.enable_protection && hal.control.get_state().probe_triggered) {
 80176d2:	4b99      	ldr	r3, [pc, #612]	; (8017938 <protocol_main_loop+0x28c>)
 80176d4:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
 80176d8:	f013 0f20 	tst.w	r3, #32
 80176dc:	d005      	beq.n	80176ea <protocol_main_loop+0x3e>
 80176de:	4b95      	ldr	r3, [pc, #596]	; (8017934 <protocol_main_loop+0x288>)
 80176e0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80176e2:	4798      	blx	r3
 80176e4:	f410 4f80 	tst.w	r0, #16384	; 0x4000
 80176e8:	d161      	bne.n	80177ae <protocol_main_loop+0x102>
    } else if (limits_homing_required()) {
 80176ea:	f7fc fa2d 	bl	8013b48 <limits_homing_required>
 80176ee:	2800      	cmp	r0, #0
 80176f0:	d165      	bne.n	80177be <protocol_main_loop+0x112>
    } else if (settings.limits.flags.hard_enabled && settings.limits.flags.check_at_init && limit_signals_merge(hal.limits.get_state()).value) {
 80176f2:	4b91      	ldr	r3, [pc, #580]	; (8017938 <protocol_main_loop+0x28c>)
 80176f4:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 80176f8:	f003 0305 	and.w	r3, r3, #5
 80176fc:	2b05      	cmp	r3, #5
 80176fe:	d066      	beq.n	80177ce <protocol_main_loop+0x122>
    } else if(sys.cold_start && (settings.flags.force_initialization_alarm || hal.control.get_state().reset)) {
 8017700:	4b8b      	ldr	r3, [pc, #556]	; (8017930 <protocol_main_loop+0x284>)
 8017702:	f893 307d 	ldrb.w	r3, [r3, #125]	; 0x7d
 8017706:	2b00      	cmp	r3, #0
 8017708:	f000 8081 	beq.w	801780e <protocol_main_loop+0x162>
 801770c:	4b8a      	ldr	r3, [pc, #552]	; (8017938 <protocol_main_loop+0x28c>)
 801770e:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 8017712:	f013 0f20 	tst.w	r3, #32
 8017716:	d105      	bne.n	8017724 <protocol_main_loop+0x78>
 8017718:	4b86      	ldr	r3, [pc, #536]	; (8017934 <protocol_main_loop+0x288>)
 801771a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801771c:	4798      	blx	r3
 801771e:	f010 0f01 	tst.w	r0, #1
 8017722:	d074      	beq.n	801780e <protocol_main_loop+0x162>
        state_set(STATE_ALARM); // Ensure alarm state is set.
 8017724:	2001      	movs	r0, #1
 8017726:	f006 ff63 	bl	801e5f0 <state_set>
        grbl.report.feedback_message(Message_AlarmLock);
 801772a:	4b84      	ldr	r3, [pc, #528]	; (801793c <protocol_main_loop+0x290>)
 801772c:	68db      	ldr	r3, [r3, #12]
 801772e:	2002      	movs	r0, #2
 8017730:	4798      	blx	r3
 8017732:	e00e      	b.n	8017752 <protocol_main_loop+0xa6>
        sys.alarm = Alarm_None;
 8017734:	4b7e      	ldr	r3, [pc, #504]	; (8017930 <protocol_main_loop+0x284>)
 8017736:	2200      	movs	r2, #0
 8017738:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c
        system_raise_alarm(Alarm_SelftestFailed);
 801773c:	2010      	movs	r0, #16
 801773e:	f009 fd31 	bl	80211a4 <system_raise_alarm>
 8017742:	e006      	b.n	8017752 <protocol_main_loop+0xa6>
        system_raise_alarm(Alarm_EStop);
 8017744:	200a      	movs	r0, #10
 8017746:	f009 fd2d 	bl	80211a4 <system_raise_alarm>
        grbl.report.feedback_message(Message_EStop);
 801774a:	4b7c      	ldr	r3, [pc, #496]	; (801793c <protocol_main_loop+0x290>)
 801774c:	68db      	ldr	r3, [r3, #12]
 801774e:	200c      	movs	r0, #12
 8017750:	4798      	blx	r3
    if(sys.cold_start) {
 8017752:	4b77      	ldr	r3, [pc, #476]	; (8017930 <protocol_main_loop+0x284>)
 8017754:	f893 307d 	ldrb.w	r3, [r3, #125]	; 0x7d
 8017758:	2b00      	cmp	r3, #0
 801775a:	f000 808e 	beq.w	801787a <protocol_main_loop+0x1ce>
        spindle_all_off();
 801775e:	f006 fae7 	bl	801dd30 <spindle_all_off>
        hal.coolant.set_state((coolant_state_t){0});
 8017762:	4b74      	ldr	r3, [pc, #464]	; (8017934 <protocol_main_loop+0x288>)
 8017764:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8017766:	f04f 0000 	mov.w	r0, #0
 801776a:	4798      	blx	r3
        if(realtime_queue.head != realtime_queue.tail)
 801776c:	4b74      	ldr	r3, [pc, #464]	; (8017940 <protocol_main_loop+0x294>)
 801776e:	681a      	ldr	r2, [r3, #0]
 8017770:	685b      	ldr	r3, [r3, #4]
 8017772:	429a      	cmp	r2, r3
 8017774:	d005      	beq.n	8017782 <protocol_main_loop+0xd6>
            system_set_exec_state_flag(EXEC_RT_COMMAND);  // execute any boot up commands
 8017776:	4b6f      	ldr	r3, [pc, #444]	; (8017934 <protocol_main_loop+0x288>)
 8017778:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801777a:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 801777e:	4871      	ldr	r0, [pc, #452]	; (8017944 <protocol_main_loop+0x298>)
 8017780:	4798      	blx	r3
        sys.cold_start = false;
 8017782:	4b6b      	ldr	r3, [pc, #428]	; (8017930 <protocol_main_loop+0x284>)
 8017784:	2200      	movs	r2, #0
 8017786:	f883 207d 	strb.w	r2, [r3, #125]	; 0x7d
    line_flags_t line_flags = {0};
 801778a:	2400      	movs	r4, #0
 801778c:	f88d 4000 	strb.w	r4, [sp]
    xcommand[0] = '\0';
 8017790:	4b6d      	ldr	r3, [pc, #436]	; (8017948 <protocol_main_loop+0x29c>)
 8017792:	701c      	strb	r4, [r3, #0]
    char_counter = 0;
 8017794:	4b6d      	ldr	r3, [pc, #436]	; (801794c <protocol_main_loop+0x2a0>)
 8017796:	601c      	str	r4, [r3, #0]
    keep_rt_commands = false;
 8017798:	4b6d      	ldr	r3, [pc, #436]	; (8017950 <protocol_main_loop+0x2a4>)
 801779a:	701c      	strb	r4, [r3, #0]
 801779c:	e1c5      	b.n	8017b2a <protocol_main_loop+0x47e>
        system_raise_alarm(Alarm_MotorFault);
 801779e:	2011      	movs	r0, #17
 80177a0:	f009 fd00 	bl	80211a4 <system_raise_alarm>
        grbl.report.feedback_message(Message_MotorFault);
 80177a4:	4b65      	ldr	r3, [pc, #404]	; (801793c <protocol_main_loop+0x290>)
 80177a6:	68db      	ldr	r3, [r3, #12]
 80177a8:	2010      	movs	r0, #16
 80177aa:	4798      	blx	r3
 80177ac:	e7d1      	b.n	8017752 <protocol_main_loop+0xa6>
        system_raise_alarm(Alarm_ProbeProtect);
 80177ae:	200d      	movs	r0, #13
 80177b0:	f009 fcf8 	bl	80211a4 <system_raise_alarm>
        grbl.report.feedback_message(Message_ProbeProtected);
 80177b4:	4b61      	ldr	r3, [pc, #388]	; (801793c <protocol_main_loop+0x290>)
 80177b6:	68db      	ldr	r3, [r3, #12]
 80177b8:	2015      	movs	r0, #21
 80177ba:	4798      	blx	r3
 80177bc:	e7c9      	b.n	8017752 <protocol_main_loop+0xa6>
        system_raise_alarm(Alarm_HomingRequired);
 80177be:	200b      	movs	r0, #11
 80177c0:	f009 fcf0 	bl	80211a4 <system_raise_alarm>
        grbl.report.feedback_message(Message_HomingCycleRequired);
 80177c4:	4b5d      	ldr	r3, [pc, #372]	; (801793c <protocol_main_loop+0x290>)
 80177c6:	68db      	ldr	r3, [r3, #12]
 80177c8:	200d      	movs	r0, #13
 80177ca:	4798      	blx	r3
 80177cc:	e7c1      	b.n	8017752 <protocol_main_loop+0xa6>
    } else if (settings.limits.flags.hard_enabled && settings.limits.flags.check_at_init && limit_signals_merge(hal.limits.get_state()).value) {
 80177ce:	4b59      	ldr	r3, [pc, #356]	; (8017934 <protocol_main_loop+0x288>)
 80177d0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80177d2:	4798      	blx	r3
 80177d4:	9001      	str	r0, [sp, #4]
 80177d6:	f7fb fd8f 	bl	80132f8 <limit_signals_merge>
 80177da:	b2c0      	uxtb	r0, r0
 80177dc:	2800      	cmp	r0, #0
 80177de:	d08f      	beq.n	8017700 <protocol_main_loop+0x54>
        if(sys.alarm == Alarm_LimitsEngaged && hal.control.get_state().limits_override)
 80177e0:	4b53      	ldr	r3, [pc, #332]	; (8017930 <protocol_main_loop+0x284>)
 80177e2:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 80177e6:	2b0c      	cmp	r3, #12
 80177e8:	d105      	bne.n	80177f6 <protocol_main_loop+0x14a>
 80177ea:	4b52      	ldr	r3, [pc, #328]	; (8017934 <protocol_main_loop+0x288>)
 80177ec:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80177ee:	4798      	blx	r3
 80177f0:	f410 6f80 	tst.w	r0, #1024	; 0x400
 80177f4:	d107      	bne.n	8017806 <protocol_main_loop+0x15a>
            system_raise_alarm(Alarm_LimitsEngaged);
 80177f6:	200c      	movs	r0, #12
 80177f8:	f009 fcd4 	bl	80211a4 <system_raise_alarm>
            grbl.report.feedback_message(Message_CheckLimits);
 80177fc:	4b4f      	ldr	r3, [pc, #316]	; (801793c <protocol_main_loop+0x290>)
 80177fe:	68db      	ldr	r3, [r3, #12]
 8017800:	2007      	movs	r0, #7
 8017802:	4798      	blx	r3
 8017804:	e7a5      	b.n	8017752 <protocol_main_loop+0xa6>
            state_set(STATE_IDLE); // Clear alarm state to enable limit switch pulloff.
 8017806:	2000      	movs	r0, #0
 8017808:	f006 fef2 	bl	801e5f0 <state_set>
 801780c:	e7a1      	b.n	8017752 <protocol_main_loop+0xa6>
    } else if (state_get() & (STATE_ALARM|STATE_SLEEP)) {
 801780e:	f006 fee9 	bl	801e5e4 <state_get>
 8017812:	f010 0f81 	tst.w	r0, #129	; 0x81
 8017816:	d011      	beq.n	801783c <protocol_main_loop+0x190>
        if(sys.alarm == Alarm_HomingRequired)
 8017818:	4b45      	ldr	r3, [pc, #276]	; (8017930 <protocol_main_loop+0x284>)
 801781a:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 801781e:	2b0b      	cmp	r3, #11
 8017820:	d007      	beq.n	8017832 <protocol_main_loop+0x186>
        state_set(STATE_ALARM); // Ensure alarm state is set.
 8017822:	2001      	movs	r0, #1
 8017824:	f006 fee4 	bl	801e5f0 <state_set>
        grbl.report.feedback_message(Message_AlarmLock);
 8017828:	4b44      	ldr	r3, [pc, #272]	; (801793c <protocol_main_loop+0x290>)
 801782a:	68db      	ldr	r3, [r3, #12]
 801782c:	2002      	movs	r0, #2
 801782e:	4798      	blx	r3
 8017830:	e78f      	b.n	8017752 <protocol_main_loop+0xa6>
            sys.alarm = Alarm_None; // Clear Alarm_HomingRequired as the lock has been overridden by a soft reset.
 8017832:	4b3f      	ldr	r3, [pc, #252]	; (8017930 <protocol_main_loop+0x284>)
 8017834:	2200      	movs	r2, #0
 8017836:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c
 801783a:	e7f2      	b.n	8017822 <protocol_main_loop+0x176>
        state_set(STATE_IDLE);
 801783c:	2000      	movs	r0, #0
 801783e:	f006 fed7 	bl	801e5f0 <state_set>
        if (hal.signals_cap.safety_door_ajar && !settings.safety_door.flags.ignore_when_idle && hal.control.get_state().safety_door_ajar) {
 8017842:	4b3c      	ldr	r3, [pc, #240]	; (8017934 <protocol_main_loop+0x288>)
 8017844:	f893 31a8 	ldrb.w	r3, [r3, #424]	; 0x1a8
 8017848:	f013 0f08 	tst.w	r3, #8
 801784c:	d012      	beq.n	8017874 <protocol_main_loop+0x1c8>
 801784e:	4b3a      	ldr	r3, [pc, #232]	; (8017938 <protocol_main_loop+0x28c>)
 8017850:	f893 313c 	ldrb.w	r3, [r3, #316]	; 0x13c
 8017854:	f013 0f01 	tst.w	r3, #1
 8017858:	d10c      	bne.n	8017874 <protocol_main_loop+0x1c8>
 801785a:	4b36      	ldr	r3, [pc, #216]	; (8017934 <protocol_main_loop+0x288>)
 801785c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801785e:	4798      	blx	r3
 8017860:	f010 0f08 	tst.w	r0, #8
 8017864:	d006      	beq.n	8017874 <protocol_main_loop+0x1c8>
            system_set_exec_state_flag(EXEC_SAFETY_DOOR);
 8017866:	4b33      	ldr	r3, [pc, #204]	; (8017934 <protocol_main_loop+0x288>)
 8017868:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801786a:	2140      	movs	r1, #64	; 0x40
 801786c:	4835      	ldr	r0, [pc, #212]	; (8017944 <protocol_main_loop+0x298>)
 801786e:	4798      	blx	r3
            protocol_execute_realtime(); // Enter safety door mode. Should return as IDLE state.
 8017870:	f7ff feec 	bl	801764c <protocol_execute_realtime>
        system_execute_startup(); // Execute startup script.
 8017874:	f009 f85e 	bl	8020934 <system_execute_startup>
 8017878:	e76b      	b.n	8017752 <protocol_main_loop+0xa6>
        memset(&realtime_queue, 0, sizeof(realtime_queue_t));
 801787a:	2228      	movs	r2, #40	; 0x28
 801787c:	2100      	movs	r1, #0
 801787e:	4830      	ldr	r0, [pc, #192]	; (8017940 <protocol_main_loop+0x294>)
 8017880:	f00b f979 	bl	8022b76 <memset>
 8017884:	e781      	b.n	801778a <protocol_main_loop+0xde>
                eol = xcommand[0] = '\0';
 8017886:	2300      	movs	r3, #0
 8017888:	4a2f      	ldr	r2, [pc, #188]	; (8017948 <protocol_main_loop+0x29c>)
 801788a:	7013      	strb	r3, [r2, #0]
                keep_rt_commands = false;
 801788c:	4a30      	ldr	r2, [pc, #192]	; (8017950 <protocol_main_loop+0x2a4>)
 801788e:	7013      	strb	r3, [r2, #0]
                char_counter = line_flags.value = 0;
 8017890:	f88d 3000 	strb.w	r3, [sp]
 8017894:	4a2d      	ldr	r2, [pc, #180]	; (801794c <protocol_main_loop+0x2a0>)
 8017896:	6013      	str	r3, [r2, #0]
                gc_state.last_error = Status_OK;
 8017898:	4a2e      	ldr	r2, [pc, #184]	; (8017954 <protocol_main_loop+0x2a8>)
 801789a:	f882 3079 	strb.w	r3, [r2, #121]	; 0x79
                if (state_get() == STATE_JOG) // Block all other states from invoking motion cancel.
 801789e:	f006 fea1 	bl	801e5e4 <state_get>
 80178a2:	2820      	cmp	r0, #32
 80178a4:	d001      	beq.n	80178aa <protocol_main_loop+0x1fe>
                eol = xcommand[0] = '\0';
 80178a6:	2400      	movs	r4, #0
 80178a8:	e13f      	b.n	8017b2a <protocol_main_loop+0x47e>
                    system_set_exec_state_flag(EXEC_MOTION_CANCEL);
 80178aa:	4b22      	ldr	r3, [pc, #136]	; (8017934 <protocol_main_loop+0x288>)
 80178ac:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80178ae:	2180      	movs	r1, #128	; 0x80
 80178b0:	4824      	ldr	r0, [pc, #144]	; (8017944 <protocol_main_loop+0x298>)
 80178b2:	4798      	blx	r3
                eol = xcommand[0] = '\0';
 80178b4:	2400      	movs	r4, #0
 80178b6:	e138      	b.n	8017b2a <protocol_main_loop+0x47e>
                if(char_counter == 0 && eol && eol != c) {
 80178b8:	4b24      	ldr	r3, [pc, #144]	; (801794c <protocol_main_loop+0x2a0>)
 80178ba:	681b      	ldr	r3, [r3, #0]
 80178bc:	b91b      	cbnz	r3, 80178c6 <protocol_main_loop+0x21a>
 80178be:	b114      	cbz	r4, 80178c6 <protocol_main_loop+0x21a>
 80178c0:	4284      	cmp	r4, r0
 80178c2:	f040 810c 	bne.w	8017ade <protocol_main_loop+0x432>
                    eol = (char)c;
 80178c6:	b2c4      	uxtb	r4, r0
                if(!protocol_execute_realtime()) // Runtime command check point.
 80178c8:	f7ff fec0 	bl	801764c <protocol_execute_realtime>
 80178cc:	b300      	cbz	r0, 8017910 <protocol_main_loop+0x264>
                line[char_counter] = '\0'; // Set string termination character.
 80178ce:	4b1f      	ldr	r3, [pc, #124]	; (801794c <protocol_main_loop+0x2a0>)
 80178d0:	681b      	ldr	r3, [r3, #0]
 80178d2:	4a21      	ldr	r2, [pc, #132]	; (8017958 <protocol_main_loop+0x2ac>)
 80178d4:	2100      	movs	r1, #0
 80178d6:	54d1      	strb	r1, [r2, r3]
                if (line_flags.overflow) // Report line overflow error.
 80178d8:	f89d 3000 	ldrb.w	r3, [sp]
 80178dc:	f013 0f01 	tst.w	r3, #1
 80178e0:	d01e      	beq.n	8017920 <protocol_main_loop+0x274>
                    gc_state.last_error = Status_Overflow;
 80178e2:	4b1c      	ldr	r3, [pc, #112]	; (8017954 <protocol_main_loop+0x2a8>)
 80178e4:	220b      	movs	r2, #11
 80178e6:	f883 2079 	strb.w	r2, [r3, #121]	; 0x79
                if(ABORTED)
 80178ea:	4b11      	ldr	r3, [pc, #68]	; (8017930 <protocol_main_loop+0x284>)
 80178ec:	881b      	ldrh	r3, [r3, #0]
 80178ee:	2b00      	cmp	r3, #0
 80178f0:	f040 80f7 	bne.w	8017ae2 <protocol_main_loop+0x436>
                    grbl.report.status_message(gc_state.last_error);
 80178f4:	4b11      	ldr	r3, [pc, #68]	; (801793c <protocol_main_loop+0x290>)
 80178f6:	689b      	ldr	r3, [r3, #8]
 80178f8:	4a16      	ldr	r2, [pc, #88]	; (8017954 <protocol_main_loop+0x2a8>)
 80178fa:	f892 0079 	ldrb.w	r0, [r2, #121]	; 0x79
 80178fe:	4798      	blx	r3
                keep_rt_commands = false;
 8017900:	2300      	movs	r3, #0
 8017902:	4a13      	ldr	r2, [pc, #76]	; (8017950 <protocol_main_loop+0x2a4>)
 8017904:	7013      	strb	r3, [r2, #0]
                char_counter = line_flags.value = 0;
 8017906:	f88d 3000 	strb.w	r3, [sp]
 801790a:	4a10      	ldr	r2, [pc, #64]	; (801794c <protocol_main_loop+0x2a0>)
 801790c:	6013      	str	r3, [r2, #0]
 801790e:	e10c      	b.n	8017b2a <protocol_main_loop+0x47e>
                    return !sys.flags.exit;      // Bail to calling function upon system abort
 8017910:	4b07      	ldr	r3, [pc, #28]	; (8017930 <protocol_main_loop+0x284>)
 8017912:	7d98      	ldrb	r0, [r3, #22]
 8017914:	08c0      	lsrs	r0, r0, #3
 8017916:	f080 0001 	eor.w	r0, r0, #1
 801791a:	f000 0001 	and.w	r0, r0, #1
 801791e:	e144      	b.n	8017baa <protocol_main_loop+0x4fe>
                else if(*line == '\0') // Empty line. For syncing purposes.
 8017920:	4b0d      	ldr	r3, [pc, #52]	; (8017958 <protocol_main_loop+0x2ac>)
 8017922:	781b      	ldrb	r3, [r3, #0]
 8017924:	b9d3      	cbnz	r3, 801795c <protocol_main_loop+0x2b0>
                    gc_state.last_error = Status_OK;
 8017926:	4b0b      	ldr	r3, [pc, #44]	; (8017954 <protocol_main_loop+0x2a8>)
 8017928:	2200      	movs	r2, #0
 801792a:	f883 2079 	strb.w	r2, [r3, #121]	; 0x79
 801792e:	e7dc      	b.n	80178ea <protocol_main_loop+0x23e>
 8017930:	200036c4 	.word	0x200036c4
 8017934:	2000350c 	.word	0x2000350c
 8017938:	20003b14 	.word	0x20003b14
 801793c:	2000343c 	.word	0x2000343c
 8017940:	2000395c 	.word	0x2000395c
 8017944:	2000370c 	.word	0x2000370c
 8017948:	20003984 	.word	0x20003984
 801794c:	20003850 	.word	0x20003850
 8017950:	20003855 	.word	0x20003855
 8017954:	20003344 	.word	0x20003344
 8017958:	20003858 	.word	0x20003858
                else if(*line == '$') {// Grbl '$' system command
 801795c:	2b24      	cmp	r3, #36	; 0x24
 801795e:	d00a      	beq.n	8017976 <protocol_main_loop+0x2ca>
                } else if(*line == '[' && grbl.on_user_command)
 8017960:	2b5b      	cmp	r3, #91	; 0x5b
 8017962:	d118      	bne.n	8017996 <protocol_main_loop+0x2ea>
 8017964:	4b93      	ldr	r3, [pc, #588]	; (8017bb4 <protocol_main_loop+0x508>)
 8017966:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8017968:	b1ab      	cbz	r3, 8017996 <protocol_main_loop+0x2ea>
                    gc_state.last_error = grbl.on_user_command(line);
 801796a:	4893      	ldr	r0, [pc, #588]	; (8017bb8 <protocol_main_loop+0x50c>)
 801796c:	4798      	blx	r3
 801796e:	4b93      	ldr	r3, [pc, #588]	; (8017bbc <protocol_main_loop+0x510>)
 8017970:	f883 0079 	strb.w	r0, [r3, #121]	; 0x79
 8017974:	e7b9      	b.n	80178ea <protocol_main_loop+0x23e>
                    if((gc_state.last_error = system_execute_line(line)) == Status_LimitsEngaged) {
 8017976:	4890      	ldr	r0, [pc, #576]	; (8017bb8 <protocol_main_loop+0x50c>)
 8017978:	f009 fa50 	bl	8020e1c <system_execute_line>
 801797c:	4b8f      	ldr	r3, [pc, #572]	; (8017bbc <protocol_main_loop+0x510>)
 801797e:	f883 0079 	strb.w	r0, [r3, #121]	; 0x79
 8017982:	282d      	cmp	r0, #45	; 0x2d
 8017984:	d1b1      	bne.n	80178ea <protocol_main_loop+0x23e>
                        system_raise_alarm(Alarm_LimitsEngaged);
 8017986:	200c      	movs	r0, #12
 8017988:	f009 fc0c 	bl	80211a4 <system_raise_alarm>
                        grbl.report.feedback_message(Message_CheckLimits);
 801798c:	4b89      	ldr	r3, [pc, #548]	; (8017bb4 <protocol_main_loop+0x508>)
 801798e:	68db      	ldr	r3, [r3, #12]
 8017990:	2007      	movs	r0, #7
 8017992:	4798      	blx	r3
 8017994:	e7a9      	b.n	80178ea <protocol_main_loop+0x23e>
                else if (state_get() & (STATE_ALARM|STATE_ESTOP|STATE_JOG)) // Everything else is gcode. Block if in alarm, eStop or jog mode.
 8017996:	f006 fe25 	bl	801e5e4 <state_get>
 801799a:	f240 1321 	movw	r3, #289	; 0x121
 801799e:	4218      	tst	r0, r3
 80179a0:	d004      	beq.n	80179ac <protocol_main_loop+0x300>
                    gc_state.last_error = Status_SystemGClock;
 80179a2:	4b86      	ldr	r3, [pc, #536]	; (8017bbc <protocol_main_loop+0x510>)
 80179a4:	2209      	movs	r2, #9
 80179a6:	f883 2079 	strb.w	r2, [r3, #121]	; 0x79
 80179aa:	e79e      	b.n	80178ea <protocol_main_loop+0x23e>
                else if(gc_state.last_error == Status_OK || gc_state.last_error == Status_GcodeToolChangePending) { // Parse and execute g-code block.
 80179ac:	4b83      	ldr	r3, [pc, #524]	; (8017bbc <protocol_main_loop+0x510>)
 80179ae:	f893 3079 	ldrb.w	r3, [r3, #121]	; 0x79
 80179b2:	b10b      	cbz	r3, 80179b8 <protocol_main_loop+0x30c>
 80179b4:	2b28      	cmp	r3, #40	; 0x28
 80179b6:	d198      	bne.n	80178ea <protocol_main_loop+0x23e>
                    gc_state.last_error = gc_execute_block(line);
 80179b8:	487f      	ldr	r0, [pc, #508]	; (8017bb8 <protocol_main_loop+0x50c>)
 80179ba:	f7f7 fd11 	bl	800f3e0 <gc_execute_block>
 80179be:	4b7f      	ldr	r3, [pc, #508]	; (8017bbc <protocol_main_loop+0x510>)
 80179c0:	f883 0079 	strb.w	r0, [r3, #121]	; 0x79
 80179c4:	e791      	b.n	80178ea <protocol_main_loop+0x23e>
            } else if (c != ASCII_BS && c <= (char_counter > 0 ? ' ' - 1 : ' '))
 80179c6:	4b7e      	ldr	r3, [pc, #504]	; (8017bc0 <protocol_main_loop+0x514>)
 80179c8:	681b      	ldr	r3, [r3, #0]
 80179ca:	b1cb      	cbz	r3, 8017a00 <protocol_main_loop+0x354>
 80179cc:	231f      	movs	r3, #31
 80179ce:	4298      	cmp	r0, r3
 80179d0:	f340 80ab 	ble.w	8017b2a <protocol_main_loop+0x47e>
                switch(c) {
 80179d4:	283b      	cmp	r0, #59	; 0x3b
 80179d6:	dc2c      	bgt.n	8017a32 <protocol_main_loop+0x386>
 80179d8:	2824      	cmp	r0, #36	; 0x24
 80179da:	db13      	blt.n	8017a04 <protocol_main_loop+0x358>
 80179dc:	f1a0 0324 	sub.w	r3, r0, #36	; 0x24
 80179e0:	2b17      	cmp	r3, #23
 80179e2:	d811      	bhi.n	8017a08 <protocol_main_loop+0x35c>
 80179e4:	e8df f003 	tbb	[pc, r3]
 80179e8:	10101039 	.word	0x10101039
 80179ec:	10105d41 	.word	0x10105d41
 80179f0:	10101010 	.word	0x10101010
 80179f4:	10101010 	.word	0x10101010
 80179f8:	10101010 	.word	0x10101010
 80179fc:	6c101010 	.word	0x6c101010
            } else if (c != ASCII_BS && c <= (char_counter > 0 ? ' ' - 1 : ' '))
 8017a00:	2320      	movs	r3, #32
 8017a02:	e7e4      	b.n	80179ce <protocol_main_loop+0x322>
                switch(c) {
 8017a04:	2808      	cmp	r0, #8
 8017a06:	d018      	beq.n	8017a3a <protocol_main_loop+0x38e>
                if(!(line_flags.overflow = char_counter >= (LINE_BUFFER_SIZE - 1)))
 8017a08:	4b6d      	ldr	r3, [pc, #436]	; (8017bc0 <protocol_main_loop+0x514>)
 8017a0a:	6819      	ldr	r1, [r3, #0]
 8017a0c:	29ff      	cmp	r1, #255	; 0xff
 8017a0e:	bf94      	ite	ls
 8017a10:	2300      	movls	r3, #0
 8017a12:	2301      	movhi	r3, #1
 8017a14:	f89d 2000 	ldrb.w	r2, [sp]
 8017a18:	f363 0200 	bfi	r2, r3, #0, #1
 8017a1c:	f88d 2000 	strb.w	r2, [sp]
 8017a20:	2b00      	cmp	r3, #0
 8017a22:	f040 8082 	bne.w	8017b2a <protocol_main_loop+0x47e>
                    line[char_counter++] = c;
 8017a26:	1c4a      	adds	r2, r1, #1
 8017a28:	4b65      	ldr	r3, [pc, #404]	; (8017bc0 <protocol_main_loop+0x514>)
 8017a2a:	601a      	str	r2, [r3, #0]
 8017a2c:	4b62      	ldr	r3, [pc, #392]	; (8017bb8 <protocol_main_loop+0x50c>)
 8017a2e:	5458      	strb	r0, [r3, r1]
 8017a30:	e07b      	b.n	8017b2a <protocol_main_loop+0x47e>
                switch(c) {
 8017a32:	285b      	cmp	r0, #91	; 0x5b
 8017a34:	d011      	beq.n	8017a5a <protocol_main_loop+0x3ae>
 8017a36:	287f      	cmp	r0, #127	; 0x7f
 8017a38:	d1e6      	bne.n	8017a08 <protocol_main_loop+0x35c>
                        if(char_counter) {
 8017a3a:	4b61      	ldr	r3, [pc, #388]	; (8017bc0 <protocol_main_loop+0x514>)
 8017a3c:	681b      	ldr	r3, [r3, #0]
 8017a3e:	2b00      	cmp	r3, #0
 8017a40:	d073      	beq.n	8017b2a <protocol_main_loop+0x47e>
                            line[--char_counter] = '\0';
 8017a42:	3b01      	subs	r3, #1
 8017a44:	4a5e      	ldr	r2, [pc, #376]	; (8017bc0 <protocol_main_loop+0x514>)
 8017a46:	6013      	str	r3, [r2, #0]
 8017a48:	485b      	ldr	r0, [pc, #364]	; (8017bb8 <protocol_main_loop+0x50c>)
 8017a4a:	2200      	movs	r2, #0
 8017a4c:	54c2      	strb	r2, [r0, r3]
                            keep_rt_commands = recheck_line(line, &line_flags);
 8017a4e:	4669      	mov	r1, sp
 8017a50:	f7ff f996 	bl	8016d80 <recheck_line>
 8017a54:	4b5b      	ldr	r3, [pc, #364]	; (8017bc4 <protocol_main_loop+0x518>)
 8017a56:	7018      	strb	r0, [r3, #0]
                        continue;
 8017a58:	e067      	b.n	8017b2a <protocol_main_loop+0x47e>
                        if(char_counter == 0)
 8017a5a:	4b59      	ldr	r3, [pc, #356]	; (8017bc0 <protocol_main_loop+0x514>)
 8017a5c:	681b      	ldr	r3, [r3, #0]
 8017a5e:	2b00      	cmp	r3, #0
 8017a60:	d1d2      	bne.n	8017a08 <protocol_main_loop+0x35c>
                            keep_rt_commands = true;
 8017a62:	4b58      	ldr	r3, [pc, #352]	; (8017bc4 <protocol_main_loop+0x518>)
 8017a64:	2201      	movs	r2, #1
 8017a66:	701a      	strb	r2, [r3, #0]
 8017a68:	e7ce      	b.n	8017a08 <protocol_main_loop+0x35c>
                        if(!keep_rt_commands && (line_flags.comment_parentheses = !line_flags.comment_semicolon))
 8017a6a:	4b56      	ldr	r3, [pc, #344]	; (8017bc4 <protocol_main_loop+0x518>)
 8017a6c:	781b      	ldrb	r3, [r3, #0]
 8017a6e:	2b00      	cmp	r3, #0
 8017a70:	d1ca      	bne.n	8017a08 <protocol_main_loop+0x35c>
 8017a72:	f89d 2000 	ldrb.w	r2, [sp]
 8017a76:	0893      	lsrs	r3, r2, #2
 8017a78:	f083 0301 	eor.w	r3, r3, #1
 8017a7c:	f003 0301 	and.w	r3, r3, #1
 8017a80:	f363 0241 	bfi	r2, r3, #1, #1
 8017a84:	f88d 2000 	strb.w	r2, [sp]
 8017a88:	2b00      	cmp	r3, #0
 8017a8a:	d0bd      	beq.n	8017a08 <protocol_main_loop+0x35c>
                            keep_rt_commands = !hal.driver_cap.no_gcode_message_handling; // Suspend real-time processing of printable command characters.
 8017a8c:	4b4e      	ldr	r3, [pc, #312]	; (8017bc8 <protocol_main_loop+0x51c>)
 8017a8e:	f893 31a6 	ldrb.w	r3, [r3, #422]	; 0x1a6
 8017a92:	085b      	lsrs	r3, r3, #1
 8017a94:	f083 0301 	eor.w	r3, r3, #1
 8017a98:	f003 0301 	and.w	r3, r3, #1
 8017a9c:	4a49      	ldr	r2, [pc, #292]	; (8017bc4 <protocol_main_loop+0x518>)
 8017a9e:	7013      	strb	r3, [r2, #0]
 8017aa0:	e7b2      	b.n	8017a08 <protocol_main_loop+0x35c>
                        if(!line_flags.comment_semicolon)
 8017aa2:	f89d 3000 	ldrb.w	r3, [sp]
 8017aa6:	f013 0f04 	tst.w	r3, #4
 8017aaa:	d1ad      	bne.n	8017a08 <protocol_main_loop+0x35c>
                            line_flags.comment_parentheses = keep_rt_commands = false;
 8017aac:	2200      	movs	r2, #0
 8017aae:	4b45      	ldr	r3, [pc, #276]	; (8017bc4 <protocol_main_loop+0x518>)
 8017ab0:	701a      	strb	r2, [r3, #0]
 8017ab2:	f89d 3000 	ldrb.w	r3, [sp]
 8017ab6:	f362 0341 	bfi	r3, r2, #1, #1
 8017aba:	f88d 3000 	strb.w	r3, [sp]
 8017abe:	e7a3      	b.n	8017a08 <protocol_main_loop+0x35c>
                        if(!line_flags.comment_parentheses) {
 8017ac0:	f89d 3000 	ldrb.w	r3, [sp]
 8017ac4:	f013 0f02 	tst.w	r3, #2
 8017ac8:	d19e      	bne.n	8017a08 <protocol_main_loop+0x35c>
                            keep_rt_commands = false;
 8017aca:	4b3e      	ldr	r3, [pc, #248]	; (8017bc4 <protocol_main_loop+0x518>)
 8017acc:	2200      	movs	r2, #0
 8017ace:	701a      	strb	r2, [r3, #0]
                            line_flags.comment_semicolon = On;
 8017ad0:	f89d 3000 	ldrb.w	r3, [sp]
 8017ad4:	f043 0304 	orr.w	r3, r3, #4
 8017ad8:	f88d 3000 	strb.w	r3, [sp]
 8017adc:	e794      	b.n	8017a08 <protocol_main_loop+0x35c>
                    eol = '\0';
 8017ade:	2400      	movs	r4, #0
 8017ae0:	e023      	b.n	8017b2a <protocol_main_loop+0x47e>
        if(xcommand[0] != '\0') {
 8017ae2:	4b3a      	ldr	r3, [pc, #232]	; (8017bcc <protocol_main_loop+0x520>)
 8017ae4:	781b      	ldrb	r3, [r3, #0]
 8017ae6:	b173      	cbz	r3, 8017b06 <protocol_main_loop+0x45a>
            if (xcommand[0] == '$') // Grbl '$' system command
 8017ae8:	2b24      	cmp	r3, #36	; 0x24
 8017aea:	d04f      	beq.n	8017b8c <protocol_main_loop+0x4e0>
            else if (state_get() & (STATE_ALARM|STATE_ESTOP|STATE_JOG)) // Everything else is gcode. Block if in alarm, eStop or jog state.
 8017aec:	f006 fd7a 	bl	801e5e4 <state_get>
 8017af0:	f240 1321 	movw	r3, #289	; 0x121
 8017af4:	4218      	tst	r0, r3
 8017af6:	d04d      	beq.n	8017b94 <protocol_main_loop+0x4e8>
                grbl.report.status_message(Status_SystemGClock);
 8017af8:	4b2e      	ldr	r3, [pc, #184]	; (8017bb4 <protocol_main_loop+0x508>)
 8017afa:	689b      	ldr	r3, [r3, #8]
 8017afc:	2009      	movs	r0, #9
 8017afe:	4798      	blx	r3
            xcommand[0] = '\0';
 8017b00:	4b32      	ldr	r3, [pc, #200]	; (8017bcc <protocol_main_loop+0x520>)
 8017b02:	2200      	movs	r2, #0
 8017b04:	701a      	strb	r2, [r3, #0]
        protocol_auto_cycle_start();
 8017b06:	f7ff fa85 	bl	8017014 <protocol_auto_cycle_start>
        if(!protocol_execute_realtime() && sys.abort) // Runtime command check point.
 8017b0a:	f7ff fd9f 	bl	801764c <protocol_execute_realtime>
 8017b0e:	b918      	cbnz	r0, 8017b18 <protocol_main_loop+0x46c>
 8017b10:	4b2f      	ldr	r3, [pc, #188]	; (8017bd0 <protocol_main_loop+0x524>)
 8017b12:	781b      	ldrb	r3, [r3, #0]
 8017b14:	2b00      	cmp	r3, #0
 8017b16:	d141      	bne.n	8017b9c <protocol_main_loop+0x4f0>
        sys.cancel = false;
 8017b18:	4b2d      	ldr	r3, [pc, #180]	; (8017bd0 <protocol_main_loop+0x524>)
 8017b1a:	2200      	movs	r2, #0
 8017b1c:	705a      	strb	r2, [r3, #1]
        if(settings.flags.sleep_enable)
 8017b1e:	4b2d      	ldr	r3, [pc, #180]	; (8017bd4 <protocol_main_loop+0x528>)
 8017b20:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 8017b24:	f013 0f08 	tst.w	r3, #8
 8017b28:	d141      	bne.n	8017bae <protocol_main_loop+0x502>
        while((c = hal.stream.read()) != SERIAL_NO_DATA) {
 8017b2a:	4b27      	ldr	r3, [pc, #156]	; (8017bc8 <protocol_main_loop+0x51c>)
 8017b2c:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 8017b30:	4798      	blx	r3
 8017b32:	f1b0 3fff 	cmp.w	r0, #4294967295
 8017b36:	d0d4      	beq.n	8017ae2 <protocol_main_loop+0x436>
            if(c == ASCII_CAN) {
 8017b38:	f1a0 0308 	sub.w	r3, r0, #8
 8017b3c:	2b10      	cmp	r3, #16
 8017b3e:	f63f af42 	bhi.w	80179c6 <protocol_main_loop+0x31a>
 8017b42:	a201      	add	r2, pc, #4	; (adr r2, 8017b48 <protocol_main_loop+0x49c>)
 8017b44:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8017b48:	080179d5 	.word	0x080179d5
 8017b4c:	080179c7 	.word	0x080179c7
 8017b50:	080178b9 	.word	0x080178b9
 8017b54:	080179c7 	.word	0x080179c7
 8017b58:	080179c7 	.word	0x080179c7
 8017b5c:	080178b9 	.word	0x080178b9
 8017b60:	080179c7 	.word	0x080179c7
 8017b64:	080179c7 	.word	0x080179c7
 8017b68:	080179c7 	.word	0x080179c7
 8017b6c:	080179c7 	.word	0x080179c7
 8017b70:	080179c7 	.word	0x080179c7
 8017b74:	080179c7 	.word	0x080179c7
 8017b78:	080179c7 	.word	0x080179c7
 8017b7c:	080179c7 	.word	0x080179c7
 8017b80:	080179c7 	.word	0x080179c7
 8017b84:	080179c7 	.word	0x080179c7
 8017b88:	08017887 	.word	0x08017887
                system_execute_line(xcommand);
 8017b8c:	480f      	ldr	r0, [pc, #60]	; (8017bcc <protocol_main_loop+0x520>)
 8017b8e:	f009 f945 	bl	8020e1c <system_execute_line>
 8017b92:	e7b5      	b.n	8017b00 <protocol_main_loop+0x454>
                gc_execute_block(xcommand);
 8017b94:	480d      	ldr	r0, [pc, #52]	; (8017bcc <protocol_main_loop+0x520>)
 8017b96:	f7f7 fc23 	bl	800f3e0 <gc_execute_block>
 8017b9a:	e7b1      	b.n	8017b00 <protocol_main_loop+0x454>
            return !sys.flags.exit;                   // Bail to main() program loop to reset system.
 8017b9c:	4b0c      	ldr	r3, [pc, #48]	; (8017bd0 <protocol_main_loop+0x524>)
 8017b9e:	7d98      	ldrb	r0, [r3, #22]
 8017ba0:	08c0      	lsrs	r0, r0, #3
 8017ba2:	f080 0001 	eor.w	r0, r0, #1
 8017ba6:	f000 0001 	and.w	r0, r0, #1
}
 8017baa:	b002      	add	sp, #8
 8017bac:	bd10      	pop	{r4, pc}
            sleep_check();
 8017bae:	f005 fbf1 	bl	801d394 <sleep_check>
 8017bb2:	e7ba      	b.n	8017b2a <protocol_main_loop+0x47e>
 8017bb4:	2000343c 	.word	0x2000343c
 8017bb8:	20003858 	.word	0x20003858
 8017bbc:	20003344 	.word	0x20003344
 8017bc0:	20003850 	.word	0x20003850
 8017bc4:	20003855 	.word	0x20003855
 8017bc8:	2000350c 	.word	0x2000350c
 8017bcc:	20003984 	.word	0x20003984
 8017bd0:	200036c4 	.word	0x200036c4
 8017bd4:	20003b14 	.word	0x20003b14

08017bd8 <protocol_buffer_synchronize>:
{
 8017bd8:	b510      	push	{r4, lr}
    protocol_auto_cycle_start();
 8017bda:	f7ff fa1b 	bl	8017014 <protocol_auto_cycle_start>
    while ((ok = protocol_execute_realtime()) && (plan_get_current_block() || state_get() == STATE_CYCLE));
 8017bde:	f7ff fd35 	bl	801764c <protocol_execute_realtime>
 8017be2:	4604      	mov	r4, r0
 8017be4:	b138      	cbz	r0, 8017bf6 <protocol_buffer_synchronize+0x1e>
 8017be6:	f7fe fd65 	bl	80166b4 <plan_get_current_block>
 8017bea:	2800      	cmp	r0, #0
 8017bec:	d1f7      	bne.n	8017bde <protocol_buffer_synchronize+0x6>
 8017bee:	f006 fcf9 	bl	801e5e4 <state_get>
 8017bf2:	2808      	cmp	r0, #8
 8017bf4:	d0f3      	beq.n	8017bde <protocol_buffer_synchronize+0x6>
}
 8017bf6:	4620      	mov	r0, r4
 8017bf8:	bd10      	pop	{r4, pc}
	...

08017bfc <protocol_enqueue_realtime_command>:
{
 8017bfc:	b538      	push	{r3, r4, r5, lr}
 8017bfe:	4604      	mov	r4, r0
    switch ((unsigned char)c) {
 8017c00:	1ec3      	subs	r3, r0, #3
 8017c02:	2ba1      	cmp	r3, #161	; 0xa1
 8017c04:	f200 81aa 	bhi.w	8017f5c <protocol_enqueue_realtime_command+0x360>
 8017c08:	e8df f013 	tbh	[pc, r3, lsl #1]
 8017c0c:	01a800cc 	.word	0x01a800cc
 8017c10:	01a800ef 	.word	0x01a800ef
 8017c14:	01a801a8 	.word	0x01a801a8
 8017c18:	01be01a8 	.word	0x01be01a8
 8017c1c:	01a801a8 	.word	0x01a801a8
 8017c20:	01a801be 	.word	0x01a801be
 8017c24:	01a801a8 	.word	0x01a801a8
 8017c28:	01a801a8 	.word	0x01a801a8
 8017c2c:	019d01a8 	.word	0x019d01a8
 8017c30:	01a801a8 	.word	0x01a801a8
 8017c34:	00c001a8 	.word	0x00c001a8
 8017c38:	01a800b3 	.word	0x01a800b3
 8017c3c:	01a801a8 	.word	0x01a801a8
 8017c40:	01a801a8 	.word	0x01a801a8
 8017c44:	01a801a8 	.word	0x01a801a8
 8017c48:	01a801a8 	.word	0x01a801a8
 8017c4c:	00a201a8 	.word	0x00a201a8
 8017c50:	01a801a8 	.word	0x01a801a8
 8017c54:	01a801a8 	.word	0x01a801a8
 8017c58:	01a801a8 	.word	0x01a801a8
 8017c5c:	01a801a8 	.word	0x01a801a8
 8017c60:	01a801a8 	.word	0x01a801a8
 8017c64:	01a801a8 	.word	0x01a801a8
 8017c68:	01a801a8 	.word	0x01a801a8
 8017c6c:	01a801a8 	.word	0x01a801a8
 8017c70:	01a801a8 	.word	0x01a801a8
 8017c74:	01a801a8 	.word	0x01a801a8
 8017c78:	01a801a8 	.word	0x01a801a8
 8017c7c:	01a801a8 	.word	0x01a801a8
 8017c80:	01a801a8 	.word	0x01a801a8
 8017c84:	01a801a8 	.word	0x01a801a8
 8017c88:	01a801a8 	.word	0x01a801a8
 8017c8c:	01a801a8 	.word	0x01a801a8
 8017c90:	01a801a8 	.word	0x01a801a8
 8017c94:	01a801a8 	.word	0x01a801a8
 8017c98:	01a801a8 	.word	0x01a801a8
 8017c9c:	01a801a8 	.word	0x01a801a8
 8017ca0:	01a801a8 	.word	0x01a801a8
 8017ca4:	01a801a8 	.word	0x01a801a8
 8017ca8:	01a801a8 	.word	0x01a801a8
 8017cac:	01a801a8 	.word	0x01a801a8
 8017cb0:	01a801a8 	.word	0x01a801a8
 8017cb4:	01a801a8 	.word	0x01a801a8
 8017cb8:	01a801a8 	.word	0x01a801a8
 8017cbc:	01a801a8 	.word	0x01a801a8
 8017cc0:	01a801a8 	.word	0x01a801a8
 8017cc4:	01a801a8 	.word	0x01a801a8
 8017cc8:	01a801a8 	.word	0x01a801a8
 8017ccc:	01a801a8 	.word	0x01a801a8
 8017cd0:	01a801a8 	.word	0x01a801a8
 8017cd4:	01a801a8 	.word	0x01a801a8
 8017cd8:	01a801a8 	.word	0x01a801a8
 8017cdc:	01a801a8 	.word	0x01a801a8
 8017ce0:	01a801a8 	.word	0x01a801a8
 8017ce4:	01a801a8 	.word	0x01a801a8
 8017ce8:	01a801a8 	.word	0x01a801a8
 8017cec:	01a801a8 	.word	0x01a801a8
 8017cf0:	01a801a8 	.word	0x01a801a8
 8017cf4:	01a801a8 	.word	0x01a801a8
 8017cf8:	01a801a8 	.word	0x01a801a8
 8017cfc:	01a801a8 	.word	0x01a801a8
 8017d00:	01a801a8 	.word	0x01a801a8
 8017d04:	00ef01a8 	.word	0x00ef01a8
 8017d08:	010700fc 	.word	0x010700fc
 8017d0c:	010e012c 	.word	0x010e012c
 8017d10:	01a8011a 	.word	0x01a8011a
 8017d14:	013d00d5 	.word	0x013d00d5
 8017d18:	0199014e 	.word	0x0199014e
 8017d1c:	01830166 	.word	0x01830166
 8017d20:	01a801a8 	.word	0x01a801a8
 8017d24:	019101a8 	.word	0x019101a8
 8017d28:	01910191 	.word	0x01910191
 8017d2c:	01910191 	.word	0x01910191
 8017d30:	01910191 	.word	0x01910191
 8017d34:	01a80191 	.word	0x01a80191
 8017d38:	01950195 	.word	0x01950195
 8017d3c:	01950195 	.word	0x01950195
 8017d40:	01950195 	.word	0x01950195
 8017d44:	019901a8 	.word	0x019901a8
 8017d48:	015e0199 	.word	0x015e0199
 8017d4c:	013401a8 	.word	0x013401a8
            if(char_counter == 0)
 8017d50:	4ba1      	ldr	r3, [pc, #644]	; (8017fd8 <protocol_enqueue_realtime_command+0x3dc>)
 8017d52:	681b      	ldr	r3, [r3, #0]
 8017d54:	2b00      	cmp	r3, #0
 8017d56:	f040 8119 	bne.w	8017f8c <protocol_enqueue_realtime_command+0x390>
                keep_rt_commands = !settings.flags.legacy_rt_commands;
 8017d5a:	4ba0      	ldr	r3, [pc, #640]	; (8017fdc <protocol_enqueue_realtime_command+0x3e0>)
 8017d5c:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 8017d60:	099b      	lsrs	r3, r3, #6
 8017d62:	f083 0301 	eor.w	r3, r3, #1
 8017d66:	f003 0301 	and.w	r3, r3, #1
 8017d6a:	4a9d      	ldr	r2, [pc, #628]	; (8017fe0 <protocol_enqueue_realtime_command+0x3e4>)
 8017d6c:	7013      	strb	r3, [r2, #0]
    bool drop = false;
 8017d6e:	2000      	movs	r0, #0
 8017d70:	e0b8      	b.n	8017ee4 <protocol_enqueue_realtime_command+0x2e8>
            system_set_exec_state_flag(EXEC_STOP);
 8017d72:	4d9c      	ldr	r5, [pc, #624]	; (8017fe4 <protocol_enqueue_realtime_command+0x3e8>)
 8017d74:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8017d76:	2110      	movs	r1, #16
 8017d78:	489b      	ldr	r0, [pc, #620]	; (8017fe8 <protocol_enqueue_realtime_command+0x3ec>)
 8017d7a:	4798      	blx	r3
            char_counter = 0;
 8017d7c:	4b96      	ldr	r3, [pc, #600]	; (8017fd8 <protocol_enqueue_realtime_command+0x3dc>)
 8017d7e:	2200      	movs	r2, #0
 8017d80:	601a      	str	r2, [r3, #0]
            hal.stream.cancel_read_buffer();
 8017d82:	f8d5 30cc 	ldr.w	r3, [r5, #204]	; 0xcc
 8017d86:	4798      	blx	r3
            drop = true;
 8017d88:	2001      	movs	r0, #1
 8017d8a:	e11e      	b.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
            if(!hal.control.get_state().e_stop)
 8017d8c:	4b95      	ldr	r3, [pc, #596]	; (8017fe4 <protocol_enqueue_realtime_command+0x3e8>)
 8017d8e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8017d90:	4798      	blx	r3
 8017d92:	f010 0f40 	tst.w	r0, #64	; 0x40
 8017d96:	d001      	beq.n	8017d9c <protocol_enqueue_realtime_command+0x1a0>
            drop = true;
 8017d98:	2001      	movs	r0, #1
 8017d9a:	e116      	b.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
                mc_reset();
 8017d9c:	f7fc ffbc 	bl	8014d18 <mc_reset>
            drop = true;
 8017da0:	2001      	movs	r0, #1
 8017da2:	e112      	b.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
            mc_reset();
 8017da4:	f7fc ffb8 	bl	8014d18 <mc_reset>
            sys.flags.exit = On;
 8017da8:	4a90      	ldr	r2, [pc, #576]	; (8017fec <protocol_enqueue_realtime_command+0x3f0>)
 8017daa:	7d93      	ldrb	r3, [r2, #22]
 8017dac:	f043 0308 	orr.w	r3, r3, #8
 8017db0:	7593      	strb	r3, [r2, #22]
            drop = true;
 8017db2:	2001      	movs	r0, #1
 8017db4:	e109      	b.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
                report.value = (uint32_t)Report_All;
 8017db6:	488e      	ldr	r0, [pc, #568]	; (8017ff0 <protocol_enqueue_realtime_command+0x3f4>)
                report.tool_offset = sys.report.tool_offset;
 8017db8:	4d8c      	ldr	r5, [pc, #560]	; (8017fec <protocol_enqueue_realtime_command+0x3f0>)
 8017dba:	f895 3031 	ldrb.w	r3, [r5, #49]	; 0x31
 8017dbe:	f3c3 0380 	ubfx	r3, r3, #2, #1
 8017dc2:	f363 208a 	bfi	r0, r3, #10, #1
                report.m66result = sys.var5399 > -2;
 8017dc6:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 8017dc8:	f1b3 3fff 	cmp.w	r3, #4294967295
 8017dcc:	bfb4      	ite	lt
 8017dce:	2300      	movlt	r3, #0
 8017dd0:	2301      	movge	r3, #1
 8017dd2:	f363 20cb 	bfi	r0, r3, #11, #1
                system_add_rt_report((report_tracking_t)report.value);
 8017dd6:	f009 fa33 	bl	8021240 <system_add_rt_report>
            system_set_exec_state_flag(EXEC_STATUS_REPORT);
 8017dda:	4b82      	ldr	r3, [pc, #520]	; (8017fe4 <protocol_enqueue_realtime_command+0x3e8>)
 8017ddc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8017dde:	2101      	movs	r1, #1
 8017de0:	f105 0048 	add.w	r0, r5, #72	; 0x48
 8017de4:	4798      	blx	r3
            drop = true;
 8017de6:	2001      	movs	r0, #1
 8017de8:	e0ef      	b.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
            if(!sys.flags.auto_reporting)
 8017dea:	4b80      	ldr	r3, [pc, #512]	; (8017fec <protocol_enqueue_realtime_command+0x3f0>)
 8017dec:	7ddb      	ldrb	r3, [r3, #23]
 8017dee:	f013 0f02 	tst.w	r3, #2
 8017df2:	f040 812d 	bne.w	8018050 <protocol_enqueue_realtime_command+0x454>
                system_set_exec_state_flag(EXEC_STATUS_REPORT);
 8017df6:	4b7b      	ldr	r3, [pc, #492]	; (8017fe4 <protocol_enqueue_realtime_command+0x3e8>)
 8017df8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8017dfa:	2101      	movs	r1, #1
 8017dfc:	487a      	ldr	r0, [pc, #488]	; (8017fe8 <protocol_enqueue_realtime_command+0x3ec>)
 8017dfe:	4798      	blx	r3
            drop = true;
 8017e00:	2001      	movs	r0, #1
 8017e02:	e0e2      	b.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
            system_set_exec_state_flag(EXEC_CYCLE_START);
 8017e04:	4b77      	ldr	r3, [pc, #476]	; (8017fe4 <protocol_enqueue_realtime_command+0x3e8>)
 8017e06:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8017e08:	2102      	movs	r1, #2
 8017e0a:	4877      	ldr	r0, [pc, #476]	; (8017fe8 <protocol_enqueue_realtime_command+0x3ec>)
 8017e0c:	4798      	blx	r3
            gc_state.tool_change = false;
 8017e0e:	4b79      	ldr	r3, [pc, #484]	; (8017ff4 <protocol_enqueue_realtime_command+0x3f8>)
 8017e10:	2200      	movs	r2, #0
 8017e12:	f883 2077 	strb.w	r2, [r3, #119]	; 0x77
            drop = true;
 8017e16:	2001      	movs	r0, #1
 8017e18:	e0d7      	b.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
            system_set_exec_state_flag(EXEC_FEED_HOLD);
 8017e1a:	4b72      	ldr	r3, [pc, #456]	; (8017fe4 <protocol_enqueue_realtime_command+0x3e8>)
 8017e1c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8017e1e:	2108      	movs	r1, #8
 8017e20:	4871      	ldr	r0, [pc, #452]	; (8017fe8 <protocol_enqueue_realtime_command+0x3ec>)
 8017e22:	4798      	blx	r3
            drop = true;
 8017e24:	2001      	movs	r0, #1
 8017e26:	e0d0      	b.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
            if(state_get() != STATE_SAFETY_DOOR) {
 8017e28:	f006 fbdc 	bl	801e5e4 <state_get>
 8017e2c:	2840      	cmp	r0, #64	; 0x40
 8017e2e:	f000 80af 	beq.w	8017f90 <protocol_enqueue_realtime_command+0x394>
                system_set_exec_state_flag(EXEC_SAFETY_DOOR);
 8017e32:	4b6c      	ldr	r3, [pc, #432]	; (8017fe4 <protocol_enqueue_realtime_command+0x3e8>)
 8017e34:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8017e36:	2140      	movs	r1, #64	; 0x40
 8017e38:	486b      	ldr	r0, [pc, #428]	; (8017fe8 <protocol_enqueue_realtime_command+0x3ec>)
 8017e3a:	4798      	blx	r3
                drop = true;
 8017e3c:	2001      	movs	r0, #1
 8017e3e:	e0c4      	b.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
            char_counter = 0;
 8017e40:	4b65      	ldr	r3, [pc, #404]	; (8017fd8 <protocol_enqueue_realtime_command+0x3dc>)
 8017e42:	2200      	movs	r2, #0
 8017e44:	601a      	str	r2, [r3, #0]
            hal.stream.cancel_read_buffer();
 8017e46:	4b67      	ldr	r3, [pc, #412]	; (8017fe4 <protocol_enqueue_realtime_command+0x3e8>)
 8017e48:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 8017e4c:	4798      	blx	r3
            if(grbl.on_jog_cancel)
 8017e4e:	4b6a      	ldr	r3, [pc, #424]	; (8017ff8 <protocol_enqueue_realtime_command+0x3fc>)
 8017e50:	f8d3 50a0 	ldr.w	r5, [r3, #160]	; 0xa0
 8017e54:	2d00      	cmp	r5, #0
 8017e56:	f000 80fd 	beq.w	8018054 <protocol_enqueue_realtime_command+0x458>
                grbl.on_jog_cancel(state_get());
 8017e5a:	f006 fbc3 	bl	801e5e4 <state_get>
 8017e5e:	47a8      	blx	r5
            drop = true;
 8017e60:	2001      	movs	r0, #1
 8017e62:	e0b2      	b.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
            system_set_exec_state_flag(EXEC_GCODE_REPORT);
 8017e64:	4b5f      	ldr	r3, [pc, #380]	; (8017fe4 <protocol_enqueue_realtime_command+0x3e8>)
 8017e66:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8017e68:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8017e6c:	485e      	ldr	r0, [pc, #376]	; (8017fe8 <protocol_enqueue_realtime_command+0x3ec>)
 8017e6e:	4798      	blx	r3
            drop = true;
 8017e70:	2001      	movs	r0, #1
 8017e72:	e0aa      	b.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
            if(hal.probe.connected_toggle)
 8017e74:	4b5b      	ldr	r3, [pc, #364]	; (8017fe4 <protocol_enqueue_realtime_command+0x3e8>)
 8017e76:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8017e7a:	2b00      	cmp	r3, #0
 8017e7c:	f000 808a 	beq.w	8017f94 <protocol_enqueue_realtime_command+0x398>
                hal.probe.connected_toggle();
 8017e80:	4798      	blx	r3
    bool drop = false;
 8017e82:	2000      	movs	r0, #0
 8017e84:	e02e      	b.n	8017ee4 <protocol_enqueue_realtime_command+0x2e8>
            if(!hal.signals_cap.stop_disable) // Not available as realtime command if HAL supports physical switch
 8017e86:	4b57      	ldr	r3, [pc, #348]	; (8017fe4 <protocol_enqueue_realtime_command+0x3e8>)
 8017e88:	f893 31a8 	ldrb.w	r3, [r3, #424]	; 0x1a8
 8017e8c:	f013 0f20 	tst.w	r3, #32
 8017e90:	f040 8082 	bne.w	8017f98 <protocol_enqueue_realtime_command+0x39c>
                sys.flags.optional_stop_disable = !sys.flags.optional_stop_disable;
 8017e94:	4955      	ldr	r1, [pc, #340]	; (8017fec <protocol_enqueue_realtime_command+0x3f0>)
 8017e96:	7d8b      	ldrb	r3, [r1, #22]
 8017e98:	099a      	lsrs	r2, r3, #6
 8017e9a:	f082 0201 	eor.w	r2, r2, #1
 8017e9e:	f362 1386 	bfi	r3, r2, #6, #1
 8017ea2:	758b      	strb	r3, [r1, #22]
    bool drop = false;
 8017ea4:	2000      	movs	r0, #0
 8017ea6:	e01d      	b.n	8017ee4 <protocol_enqueue_realtime_command+0x2e8>
            if(!hal.signals_cap.single_block) // Not available as realtime command if HAL supports physical switch
 8017ea8:	4b4e      	ldr	r3, [pc, #312]	; (8017fe4 <protocol_enqueue_realtime_command+0x3e8>)
 8017eaa:	f893 31a9 	ldrb.w	r3, [r3, #425]	; 0x1a9
 8017eae:	f013 0f08 	tst.w	r3, #8
 8017eb2:	d173      	bne.n	8017f9c <protocol_enqueue_realtime_command+0x3a0>
                sys.flags.single_block = !sys.flags.single_block;
 8017eb4:	494d      	ldr	r1, [pc, #308]	; (8017fec <protocol_enqueue_realtime_command+0x3f0>)
 8017eb6:	7d8b      	ldrb	r3, [r1, #22]
 8017eb8:	43da      	mvns	r2, r3
 8017eba:	f3c2 12c0 	ubfx	r2, r2, #7, #1
 8017ebe:	f362 13c7 	bfi	r3, r2, #7, #1
 8017ec2:	758b      	strb	r3, [r1, #22]
    bool drop = false;
 8017ec4:	2000      	movs	r0, #0
 8017ec6:	e00d      	b.n	8017ee4 <protocol_enqueue_realtime_command+0x2e8>
            system_set_exec_state_flag(EXEC_PID_REPORT);
 8017ec8:	4b46      	ldr	r3, [pc, #280]	; (8017fe4 <protocol_enqueue_realtime_command+0x3e8>)
 8017eca:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8017ecc:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8017ed0:	4845      	ldr	r0, [pc, #276]	; (8017fe8 <protocol_enqueue_realtime_command+0x3ec>)
 8017ed2:	4798      	blx	r3
            drop = true;
 8017ed4:	2001      	movs	r0, #1
 8017ed6:	e078      	b.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
            if(hal.stream.type == StreamType_MPG)
 8017ed8:	4b42      	ldr	r3, [pc, #264]	; (8017fe4 <protocol_enqueue_realtime_command+0x3e8>)
 8017eda:	f893 30a8 	ldrb.w	r3, [r3, #168]	; 0xa8
 8017ede:	2b01      	cmp	r3, #1
 8017ee0:	d012      	beq.n	8017f08 <protocol_enqueue_realtime_command+0x30c>
    bool drop = false;
 8017ee2:	2000      	movs	r0, #0
    if(!drop) switch ((unsigned char)c) {
 8017ee4:	2c3f      	cmp	r4, #63	; 0x3f
 8017ee6:	d061      	beq.n	8017fac <protocol_enqueue_realtime_command+0x3b0>
 8017ee8:	2c7e      	cmp	r4, #126	; 0x7e
 8017eea:	f000 8089 	beq.w	8018000 <protocol_enqueue_realtime_command+0x404>
 8017eee:	2c21      	cmp	r4, #33	; 0x21
 8017ef0:	f000 809a 	beq.w	8018028 <protocol_enqueue_realtime_command+0x42c>
            drop = !(keep_rt_commands || (unsigned char)c < 0x7F);
 8017ef4:	4b3a      	ldr	r3, [pc, #232]	; (8017fe0 <protocol_enqueue_realtime_command+0x3e4>)
 8017ef6:	781b      	ldrb	r3, [r3, #0]
 8017ef8:	2b00      	cmp	r3, #0
 8017efa:	f040 80a5 	bne.w	8018048 <protocol_enqueue_realtime_command+0x44c>
 8017efe:	2c7e      	cmp	r4, #126	; 0x7e
 8017f00:	f200 80a4 	bhi.w	801804c <protocol_enqueue_realtime_command+0x450>
 8017f04:	2000      	movs	r0, #0
 8017f06:	e060      	b.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
                stream_mpg_enable(false);
 8017f08:	2000      	movs	r0, #0
 8017f0a:	f008 f9c1 	bl	8020290 <stream_mpg_enable>
    bool drop = false;
 8017f0e:	2000      	movs	r0, #0
 8017f10:	e7e8      	b.n	8017ee4 <protocol_enqueue_realtime_command+0x2e8>
            if(settings.report_interval)
 8017f12:	4b32      	ldr	r3, [pc, #200]	; (8017fdc <protocol_enqueue_realtime_command+0x3e0>)
 8017f14:	8a9b      	ldrh	r3, [r3, #20]
 8017f16:	2b00      	cmp	r3, #0
 8017f18:	d042      	beq.n	8017fa0 <protocol_enqueue_realtime_command+0x3a4>
                sys.flags.auto_reporting = !sys.flags.auto_reporting;
 8017f1a:	4934      	ldr	r1, [pc, #208]	; (8017fec <protocol_enqueue_realtime_command+0x3f0>)
 8017f1c:	7dcb      	ldrb	r3, [r1, #23]
 8017f1e:	085a      	lsrs	r2, r3, #1
 8017f20:	f082 0201 	eor.w	r2, r2, #1
 8017f24:	f362 0341 	bfi	r3, r2, #1, #1
 8017f28:	75cb      	strb	r3, [r1, #23]
    bool drop = false;
 8017f2a:	2000      	movs	r0, #0
 8017f2c:	e7da      	b.n	8017ee4 <protocol_enqueue_realtime_command+0x2e8>
            enqueue_feed_override(c);
 8017f2e:	f7fe f9cb 	bl	80162c8 <enqueue_feed_override>
            drop = true;
 8017f32:	2001      	movs	r0, #1
 8017f34:	e049      	b.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
            enqueue_spindle_override((uint8_t)c);
 8017f36:	f7fe f9e9 	bl	801630c <enqueue_spindle_override>
            drop = true;
 8017f3a:	2001      	movs	r0, #1
 8017f3c:	e045      	b.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
            enqueue_coolant_override((uint8_t)c);
 8017f3e:	f7fe fa07 	bl	8016350 <enqueue_coolant_override>
            drop = true;
 8017f42:	2001      	movs	r0, #1
 8017f44:	e041      	b.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
            if(esc && hal.reboot)
 8017f46:	4b2d      	ldr	r3, [pc, #180]	; (8017ffc <protocol_enqueue_realtime_command+0x400>)
 8017f48:	7818      	ldrb	r0, [r3, #0]
 8017f4a:	2800      	cmp	r0, #0
 8017f4c:	d0ca      	beq.n	8017ee4 <protocol_enqueue_realtime_command+0x2e8>
 8017f4e:	4b25      	ldr	r3, [pc, #148]	; (8017fe4 <protocol_enqueue_realtime_command+0x3e8>)
 8017f50:	f8d3 3180 	ldr.w	r3, [r3, #384]	; 0x180
 8017f54:	b333      	cbz	r3, 8017fa4 <protocol_enqueue_realtime_command+0x3a8>
                hal.reboot(); // Force MCU reboot. This call should never return.
 8017f56:	4798      	blx	r3
    bool drop = false;
 8017f58:	2000      	movs	r0, #0
 8017f5a:	e7c3      	b.n	8017ee4 <protocol_enqueue_realtime_command+0x2e8>
            if((c < ' ' && c != ASCII_BS) || (c > ASCII_DEL && c <= 0xBF))
 8017f5c:	281f      	cmp	r0, #31
 8017f5e:	d801      	bhi.n	8017f64 <protocol_enqueue_realtime_command+0x368>
 8017f60:	2808      	cmp	r0, #8
 8017f62:	d103      	bne.n	8017f6c <protocol_enqueue_realtime_command+0x370>
 8017f64:	f084 0380 	eor.w	r3, r4, #128	; 0x80
 8017f68:	2b3f      	cmp	r3, #63	; 0x3f
 8017f6a:	d81d      	bhi.n	8017fa8 <protocol_enqueue_realtime_command+0x3ac>
                drop = grbl.on_unknown_realtime_cmd == NULL || grbl.on_unknown_realtime_cmd(c);
 8017f6c:	4b22      	ldr	r3, [pc, #136]	; (8017ff8 <protocol_enqueue_realtime_command+0x3fc>)
 8017f6e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8017f70:	b133      	cbz	r3, 8017f80 <protocol_enqueue_realtime_command+0x384>
 8017f72:	4620      	mov	r0, r4
 8017f74:	4798      	blx	r3
 8017f76:	b928      	cbnz	r0, 8017f84 <protocol_enqueue_realtime_command+0x388>
 8017f78:	2300      	movs	r3, #0
    if(!drop) switch ((unsigned char)c) {
 8017f7a:	4618      	mov	r0, r3
 8017f7c:	bb2b      	cbnz	r3, 8017fca <protocol_enqueue_realtime_command+0x3ce>
 8017f7e:	e7b1      	b.n	8017ee4 <protocol_enqueue_realtime_command+0x2e8>
                drop = grbl.on_unknown_realtime_cmd == NULL || grbl.on_unknown_realtime_cmd(c);
 8017f80:	2301      	movs	r3, #1
 8017f82:	e7fa      	b.n	8017f7a <protocol_enqueue_realtime_command+0x37e>
 8017f84:	2301      	movs	r3, #1
 8017f86:	e7f8      	b.n	8017f7a <protocol_enqueue_realtime_command+0x37e>
    switch ((unsigned char)c) {
 8017f88:	2000      	movs	r0, #0
 8017f8a:	e7ab      	b.n	8017ee4 <protocol_enqueue_realtime_command+0x2e8>
    bool drop = false;
 8017f8c:	2000      	movs	r0, #0
 8017f8e:	e7a9      	b.n	8017ee4 <protocol_enqueue_realtime_command+0x2e8>
 8017f90:	2000      	movs	r0, #0
 8017f92:	e7a7      	b.n	8017ee4 <protocol_enqueue_realtime_command+0x2e8>
 8017f94:	2000      	movs	r0, #0
 8017f96:	e7a5      	b.n	8017ee4 <protocol_enqueue_realtime_command+0x2e8>
 8017f98:	2000      	movs	r0, #0
 8017f9a:	e7a3      	b.n	8017ee4 <protocol_enqueue_realtime_command+0x2e8>
 8017f9c:	2000      	movs	r0, #0
 8017f9e:	e7a1      	b.n	8017ee4 <protocol_enqueue_realtime_command+0x2e8>
 8017fa0:	2000      	movs	r0, #0
 8017fa2:	e79f      	b.n	8017ee4 <protocol_enqueue_realtime_command+0x2e8>
 8017fa4:	2000      	movs	r0, #0
 8017fa6:	e79d      	b.n	8017ee4 <protocol_enqueue_realtime_command+0x2e8>
 8017fa8:	2000      	movs	r0, #0
 8017faa:	e79b      	b.n	8017ee4 <protocol_enqueue_realtime_command+0x2e8>
            if(!keep_rt_commands || settings.flags.legacy_rt_commands) {
 8017fac:	4b0c      	ldr	r3, [pc, #48]	; (8017fe0 <protocol_enqueue_realtime_command+0x3e4>)
 8017fae:	781b      	ldrb	r3, [r3, #0]
 8017fb0:	b12b      	cbz	r3, 8017fbe <protocol_enqueue_realtime_command+0x3c2>
 8017fb2:	4b0a      	ldr	r3, [pc, #40]	; (8017fdc <protocol_enqueue_realtime_command+0x3e0>)
 8017fb4:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 8017fb8:	f013 0f40 	tst.w	r3, #64	; 0x40
 8017fbc:	d005      	beq.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
                system_set_exec_state_flag(EXEC_STATUS_REPORT);
 8017fbe:	4b09      	ldr	r3, [pc, #36]	; (8017fe4 <protocol_enqueue_realtime_command+0x3e8>)
 8017fc0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8017fc2:	2101      	movs	r1, #1
 8017fc4:	4808      	ldr	r0, [pc, #32]	; (8017fe8 <protocol_enqueue_realtime_command+0x3ec>)
 8017fc6:	4798      	blx	r3
                drop = true;
 8017fc8:	2001      	movs	r0, #1
    esc = c == ASCII_ESC;
 8017fca:	2c1b      	cmp	r4, #27
 8017fcc:	bf14      	ite	ne
 8017fce:	2400      	movne	r4, #0
 8017fd0:	2401      	moveq	r4, #1
 8017fd2:	4b0a      	ldr	r3, [pc, #40]	; (8017ffc <protocol_enqueue_realtime_command+0x400>)
 8017fd4:	701c      	strb	r4, [r3, #0]
}
 8017fd6:	bd38      	pop	{r3, r4, r5, pc}
 8017fd8:	20003850 	.word	0x20003850
 8017fdc:	20003b14 	.word	0x20003b14
 8017fe0:	20003855 	.word	0x20003855
 8017fe4:	2000350c 	.word	0x2000350c
 8017fe8:	2000370c 	.word	0x2000370c
 8017fec:	200036c4 	.word	0x200036c4
 8017ff0:	8001ffff 	.word	0x8001ffff
 8017ff4:	20003344 	.word	0x20003344
 8017ff8:	2000343c 	.word	0x2000343c
 8017ffc:	20003854 	.word	0x20003854
            if(!keep_rt_commands || settings.flags.legacy_rt_commands) {
 8018000:	4b15      	ldr	r3, [pc, #84]	; (8018058 <protocol_enqueue_realtime_command+0x45c>)
 8018002:	781b      	ldrb	r3, [r3, #0]
 8018004:	b12b      	cbz	r3, 8018012 <protocol_enqueue_realtime_command+0x416>
 8018006:	4b15      	ldr	r3, [pc, #84]	; (801805c <protocol_enqueue_realtime_command+0x460>)
 8018008:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 801800c:	f013 0f40 	tst.w	r3, #64	; 0x40
 8018010:	d0db      	beq.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
                system_set_exec_state_flag(EXEC_CYCLE_START);
 8018012:	4b13      	ldr	r3, [pc, #76]	; (8018060 <protocol_enqueue_realtime_command+0x464>)
 8018014:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8018016:	2102      	movs	r1, #2
 8018018:	4812      	ldr	r0, [pc, #72]	; (8018064 <protocol_enqueue_realtime_command+0x468>)
 801801a:	4798      	blx	r3
                gc_state.tool_change = false;
 801801c:	4b12      	ldr	r3, [pc, #72]	; (8018068 <protocol_enqueue_realtime_command+0x46c>)
 801801e:	2200      	movs	r2, #0
 8018020:	f883 2077 	strb.w	r2, [r3, #119]	; 0x77
                drop = true;
 8018024:	2001      	movs	r0, #1
 8018026:	e7d0      	b.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
            if(!keep_rt_commands || settings.flags.legacy_rt_commands) {
 8018028:	4b0b      	ldr	r3, [pc, #44]	; (8018058 <protocol_enqueue_realtime_command+0x45c>)
 801802a:	781b      	ldrb	r3, [r3, #0]
 801802c:	b12b      	cbz	r3, 801803a <protocol_enqueue_realtime_command+0x43e>
 801802e:	4b0b      	ldr	r3, [pc, #44]	; (801805c <protocol_enqueue_realtime_command+0x460>)
 8018030:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 8018034:	f013 0f40 	tst.w	r3, #64	; 0x40
 8018038:	d0c7      	beq.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
                system_set_exec_state_flag(EXEC_FEED_HOLD);
 801803a:	4b09      	ldr	r3, [pc, #36]	; (8018060 <protocol_enqueue_realtime_command+0x464>)
 801803c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801803e:	2108      	movs	r1, #8
 8018040:	4808      	ldr	r0, [pc, #32]	; (8018064 <protocol_enqueue_realtime_command+0x468>)
 8018042:	4798      	blx	r3
                drop = true;
 8018044:	2001      	movs	r0, #1
 8018046:	e7c0      	b.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
            drop = !(keep_rt_commands || (unsigned char)c < 0x7F);
 8018048:	2000      	movs	r0, #0
 801804a:	e7be      	b.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
 801804c:	2001      	movs	r0, #1
            break;
 801804e:	e7bc      	b.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
            drop = true;
 8018050:	2001      	movs	r0, #1
 8018052:	e7ba      	b.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
            drop = true;
 8018054:	2001      	movs	r0, #1
 8018056:	e7b8      	b.n	8017fca <protocol_enqueue_realtime_command+0x3ce>
 8018058:	20003855 	.word	0x20003855
 801805c:	20003b14 	.word	0x20003b14
 8018060:	2000350c 	.word	0x2000350c
 8018064:	2000370c 	.word	0x2000370c
 8018068:	20003344 	.word	0x20003344

0801806c <protocol_enqueue_rt_command>:
{
 801806c:	b510      	push	{r4, lr}
    uint_fast8_t bptr = (realtime_queue.head + 1) & (RT_QUEUE_SIZE - 1);    // Get next head pointer
 801806e:	4a0c      	ldr	r2, [pc, #48]	; (80180a0 <protocol_enqueue_rt_command+0x34>)
 8018070:	6813      	ldr	r3, [r2, #0]
 8018072:	3301      	adds	r3, #1
 8018074:	f003 0307 	and.w	r3, r3, #7
    if((ok = bptr != realtime_queue.tail)) {          // If not buffer full
 8018078:	6852      	ldr	r2, [r2, #4]
 801807a:	429a      	cmp	r2, r3
 801807c:	bf14      	ite	ne
 801807e:	2401      	movne	r4, #1
 8018080:	2400      	moveq	r4, #0
 8018082:	d00b      	beq.n	801809c <protocol_enqueue_rt_command+0x30>
        realtime_queue.fn[realtime_queue.head] = fn;  // add function pointer to buffer,
 8018084:	4a06      	ldr	r2, [pc, #24]	; (80180a0 <protocol_enqueue_rt_command+0x34>)
 8018086:	6811      	ldr	r1, [r2, #0]
 8018088:	3102      	adds	r1, #2
 801808a:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
        realtime_queue.head = bptr;                   // update pointer and
 801808e:	6013      	str	r3, [r2, #0]
        system_set_exec_state_flag(EXEC_RT_COMMAND);  // flag it for execute
 8018090:	4b04      	ldr	r3, [pc, #16]	; (80180a4 <protocol_enqueue_rt_command+0x38>)
 8018092:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8018094:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8018098:	4803      	ldr	r0, [pc, #12]	; (80180a8 <protocol_enqueue_rt_command+0x3c>)
 801809a:	4798      	blx	r3
}
 801809c:	4620      	mov	r0, r4
 801809e:	bd10      	pop	{r4, pc}
 80180a0:	2000395c 	.word	0x2000395c
 80180a4:	2000350c 	.word	0x2000350c
 80180a8:	2000370c 	.word	0x2000370c

080180ac <protocol_execute_noop>:

void protocol_execute_noop (sys_state_t state)
{
    (void)state;
}
 80180ac:	4770      	bx	lr

080180ae <matchstar>:
    return 0;
}

/* matchstar: search for c*regexp at beginning of text */
int matchstar(int c, char *regexp, char *text)
{
 80180ae:	b570      	push	{r4, r5, r6, lr}
 80180b0:	4605      	mov	r5, r0
 80180b2:	460e      	mov	r6, r1
 80180b4:	4614      	mov	r4, r2
    do {    /* a * matches zero or more instances */
        if (matchhere(regexp, text))
 80180b6:	4621      	mov	r1, r4
 80180b8:	4630      	mov	r0, r6
 80180ba:	f000 f80d 	bl	80180d8 <matchhere>
 80180be:	4602      	mov	r2, r0
 80180c0:	b938      	cbnz	r0, 80180d2 <matchstar+0x24>
            return 1;
    } while (*text != '\0' && (*text++ == c || c == '.'));
 80180c2:	7823      	ldrb	r3, [r4, #0]
 80180c4:	b133      	cbz	r3, 80180d4 <matchstar+0x26>
 80180c6:	3401      	adds	r4, #1
 80180c8:	42ab      	cmp	r3, r5
 80180ca:	d0f4      	beq.n	80180b6 <matchstar+0x8>
 80180cc:	2d2e      	cmp	r5, #46	; 0x2e
 80180ce:	d0f2      	beq.n	80180b6 <matchstar+0x8>
 80180d0:	e000      	b.n	80180d4 <matchstar+0x26>
            return 1;
 80180d2:	2201      	movs	r2, #1
    return 0;
}
 80180d4:	4610      	mov	r0, r2
 80180d6:	bd70      	pop	{r4, r5, r6, pc}

080180d8 <matchhere>:
{
 80180d8:	b508      	push	{r3, lr}
    if (regexp[0] == '\0')
 80180da:	7803      	ldrb	r3, [r0, #0]
 80180dc:	b1f3      	cbz	r3, 801811c <matchhere+0x44>
    if (regexp[1] == '*')
 80180de:	7842      	ldrb	r2, [r0, #1]
 80180e0:	2a2a      	cmp	r2, #42	; 0x2a
 80180e2:	d009      	beq.n	80180f8 <matchhere+0x20>
    if (regexp[0] == '$' && regexp[1] == '\0')
 80180e4:	2b24      	cmp	r3, #36	; 0x24
 80180e6:	d00d      	beq.n	8018104 <matchhere+0x2c>
    if (*text!='\0' && (regexp[0]=='.' || regexp[0]==*text))
 80180e8:	780a      	ldrb	r2, [r1, #0]
 80180ea:	b1ca      	cbz	r2, 8018120 <matchhere+0x48>
 80180ec:	2b2e      	cmp	r3, #46	; 0x2e
 80180ee:	d010      	beq.n	8018112 <matchhere+0x3a>
 80180f0:	4293      	cmp	r3, r2
 80180f2:	d00e      	beq.n	8018112 <matchhere+0x3a>
    return 0;
 80180f4:	2000      	movs	r0, #0
 80180f6:	e012      	b.n	801811e <matchhere+0x46>
        return matchstar(regexp[0], regexp+2, text);
 80180f8:	460a      	mov	r2, r1
 80180fa:	1c81      	adds	r1, r0, #2
 80180fc:	4618      	mov	r0, r3
 80180fe:	f7ff ffd6 	bl	80180ae <matchstar>
 8018102:	e00c      	b.n	801811e <matchhere+0x46>
    if (regexp[0] == '$' && regexp[1] == '\0')
 8018104:	2a00      	cmp	r2, #0
 8018106:	d1ef      	bne.n	80180e8 <matchhere+0x10>
        return *text == '\0';
 8018108:	7808      	ldrb	r0, [r1, #0]
 801810a:	fab0 f080 	clz	r0, r0
 801810e:	0940      	lsrs	r0, r0, #5
 8018110:	e005      	b.n	801811e <matchhere+0x46>
        return matchhere(regexp+1, text+1);
 8018112:	3101      	adds	r1, #1
 8018114:	3001      	adds	r0, #1
 8018116:	f7ff ffdf 	bl	80180d8 <matchhere>
 801811a:	e000      	b.n	801811e <matchhere+0x46>
        return 1;
 801811c:	2001      	movs	r0, #1
}
 801811e:	bd08      	pop	{r3, pc}
    return 0;
 8018120:	2000      	movs	r0, #0
 8018122:	e7fc      	b.n	801811e <matchhere+0x46>

08018124 <report_init_message>:
    return id;
}

// Welcome message
static void report_init_message (void)
{
 8018124:	b508      	push	{r3, lr}
    override_counter = wco_counter = 0;
 8018126:	2300      	movs	r3, #0
 8018128:	4a04      	ldr	r2, [pc, #16]	; (801813c <report_init_message+0x18>)
 801812a:	7013      	strb	r3, [r2, #0]
 801812c:	4a04      	ldr	r2, [pc, #16]	; (8018140 <report_init_message+0x1c>)
 801812e:	7013      	strb	r3, [r2, #0]
#if COMPATIBILITY_LEVEL == 0
    hal.stream.write_all(ASCII_EOL "GrblHAL " GRBL_VERSION " ['$' or '$HELP' for help]" ASCII_EOL);
 8018130:	4b04      	ldr	r3, [pc, #16]	; (8018144 <report_init_message+0x20>)
 8018132:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 8018136:	4804      	ldr	r0, [pc, #16]	; (8018148 <report_init_message+0x24>)
 8018138:	4798      	blx	r3
#else
    hal.stream.write_all(ASCII_EOL "Grbl " GRBL_VERSION " ['$' for help]" ASCII_EOL);
#endif
}
 801813a:	bd08      	pop	{r3, pc}
 801813c:	20003b00 	.word	0x20003b00
 8018140:	20003af4 	.word	0x20003af4
 8018144:	2000350c 	.word	0x2000350c
 8018148:	080272b4 	.word	0x080272b4

0801814c <report_help_message>:

// grblHAL help message
static void report_help_message (void)
{
 801814c:	b508      	push	{r3, lr}
    hal.stream.write("[HLP:$$ $# $G $I $N $x=val $Nx=line $J=line $SLP $C $X $H $B ~ ! ? ctrl-x]" ASCII_EOL);
 801814e:	4b03      	ldr	r3, [pc, #12]	; (801815c <report_help_message+0x10>)
 8018150:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018154:	4802      	ldr	r0, [pc, #8]	; (8018160 <report_help_message+0x14>)
 8018156:	4798      	blx	r3
}
 8018158:	bd08      	pop	{r3, pc}
 801815a:	bf00      	nop
 801815c:	2000350c 	.word	0x2000350c
 8018160:	080272e0 	.word	0x080272e0

08018164 <cmp_settings>:

// Grbl settings print out.

static int cmp_settings (const void *a, const void *b)
{
  return (*(setting_detail_t **)(a))->id - (*(setting_detail_t **)(b))->id;
 8018164:	6803      	ldr	r3, [r0, #0]
 8018166:	8818      	ldrh	r0, [r3, #0]
 8018168:	680b      	ldr	r3, [r1, #0]
 801816a:	881b      	ldrh	r3, [r3, #0]
}
 801816c:	1ac0      	subs	r0, r0, r3
 801816e:	4770      	bx	lr

08018170 <write_quoted>:
        free(s);
    }
}

static void write_quoted (const char *s, const char *sep)
{
 8018170:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8018172:	4606      	mov	r6, r0
 8018174:	460c      	mov	r4, r1
    hal.stream.write("\"");
 8018176:	4d0a      	ldr	r5, [pc, #40]	; (80181a0 <write_quoted+0x30>)
 8018178:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 801817c:	4f09      	ldr	r7, [pc, #36]	; (80181a4 <write_quoted+0x34>)
 801817e:	4638      	mov	r0, r7
 8018180:	4798      	blx	r3
    hal.stream.write(s); // TODO: escape double quoutes
 8018182:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8018186:	4630      	mov	r0, r6
 8018188:	4798      	blx	r3
    hal.stream.write("\"");
 801818a:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 801818e:	4638      	mov	r0, r7
 8018190:	4798      	blx	r3
    if(sep)
 8018192:	b11c      	cbz	r4, 801819c <write_quoted+0x2c>
        hal.stream.write(sep);
 8018194:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8018198:	4620      	mov	r0, r4
 801819a:	4798      	blx	r3
}
 801819c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801819e:	bf00      	nop
 80181a0:	2000350c 	.word	0x2000350c
 80181a4:	08027330 	.word	0x08027330

080181a8 <cmp_alarms>:

#endif

static int cmp_alarms (const void *a, const void *b)
{
  return (*(alarm_detail_t **)(a))->id - (*(alarm_detail_t **)(b))->id;
 80181a8:	6803      	ldr	r3, [r0, #0]
 80181aa:	7818      	ldrb	r0, [r3, #0]
 80181ac:	680b      	ldr	r3, [r1, #0]
 80181ae:	781b      	ldrb	r3, [r3, #0]
}
 80181b0:	1ac0      	subs	r0, r0, r3
 80181b2:	4770      	bx	lr

080181b4 <cmp_errors>:
    return Status_OK;
}

static int cmp_errors (const void *a, const void *b)
{
  return (*(status_detail_t **)(a))->id - (*(status_detail_t **)(b))->id;
 80181b4:	6803      	ldr	r3, [r0, #0]
 80181b6:	7818      	ldrb	r0, [r3, #0]
 80181b8:	680b      	ldr	r3, [r1, #0]
 80181ba:	781b      	ldrb	r3, [r3, #0]
}
 80181bc:	1ac0      	subs	r0, r0, r3
 80181be:	4770      	bx	lr

080181c0 <cmp_setting_group_id>:
    }
}

static int cmp_setting_group_id (const void *a, const void *b)
{
    return (*(setting_group_detail_t **)(a))->id - (*(setting_group_detail_t **)(b))->id;
 80181c0:	6803      	ldr	r3, [r0, #0]
 80181c2:	7858      	ldrb	r0, [r3, #1]
 80181c4:	680b      	ldr	r3, [r1, #0]
 80181c6:	785b      	ldrb	r3, [r3, #1]
}
 80181c8:	1ac0      	subs	r0, r0, r3
 80181ca:	4770      	bx	lr

080181cc <group_is_dup>:
    return strcmp((*(setting_group_detail_t **)(a))->name, (*(setting_group_detail_t **)(b))->name);
}

static bool group_is_dup (setting_group_detail_t **groups, setting_group_t group)
{
    while(*groups) {
 80181cc:	e000      	b.n	80181d0 <group_is_dup+0x4>
        if((*groups)->id == group)
            return true;
        groups++;
 80181ce:	3004      	adds	r0, #4
    while(*groups) {
 80181d0:	6803      	ldr	r3, [r0, #0]
 80181d2:	b123      	cbz	r3, 80181de <group_is_dup+0x12>
        if((*groups)->id == group)
 80181d4:	785b      	ldrb	r3, [r3, #1]
 80181d6:	428b      	cmp	r3, r1
 80181d8:	d1f9      	bne.n	80181ce <group_is_dup+0x2>
            return true;
 80181da:	2001      	movs	r0, #1
    }

    return false;
}
 80181dc:	4770      	bx	lr
    return false;
 80181de:	2000      	movs	r0, #0
 80181e0:	4770      	bx	lr
	...

080181e4 <get_pinname>:

    return spindle->get_data ? Status_OK : Status_InvalidStatement;
}

static const char *get_pinname (pin_function_t function)
{
 80181e4:	4601      	mov	r1, r0
    const char *name = NULL;
    uint_fast8_t idx = sizeof(pin_names) / sizeof(pin_name_t);
 80181e6:	2372      	movs	r3, #114	; 0x72
    const char *name = NULL;
 80181e8:	2000      	movs	r0, #0
 80181ea:	e001      	b.n	80181f0 <get_pinname+0xc>

    do {
        if(pin_names[--idx].function == function)
            name = pin_names[idx].name;
    } while(idx && !name);
 80181ec:	b15b      	cbz	r3, 8018206 <get_pinname+0x22>
 80181ee:	b950      	cbnz	r0, 8018206 <get_pinname+0x22>
        if(pin_names[--idx].function == function)
 80181f0:	3b01      	subs	r3, #1
 80181f2:	4a07      	ldr	r2, [pc, #28]	; (8018210 <get_pinname+0x2c>)
 80181f4:	f812 2033 	ldrb.w	r2, [r2, r3, lsl #3]
 80181f8:	428a      	cmp	r2, r1
 80181fa:	d1f7      	bne.n	80181ec <get_pinname+0x8>
            name = pin_names[idx].name;
 80181fc:	4a04      	ldr	r2, [pc, #16]	; (8018210 <get_pinname+0x2c>)
 80181fe:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 8018202:	6850      	ldr	r0, [r2, #4]
 8018204:	e7f2      	b.n	80181ec <get_pinname+0x8>

    return name ? name : "N/A";
 8018206:	b100      	cbz	r0, 801820a <get_pinname+0x26>
}
 8018208:	4770      	bx	lr
    return name ? name : "N/A";
 801820a:	4802      	ldr	r0, [pc, #8]	; (8018214 <get_pinname+0x30>)
 801820c:	e7fc      	b.n	8018208 <get_pinname+0x24>
 801820e:	bf00      	nop
 8018210:	0802802c 	.word	0x0802802c
 8018214:	08027334 	.word	0x08027334

08018218 <get_rate_value_mm>:
{
 8018218:	b508      	push	{r3, lr}
    return uitoa((uint32_t)value);
 801821a:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 801821e:	ee17 0a90 	vmov	r0, s15
 8018222:	f7fd faa9 	bl	8015778 <uitoa>
}
 8018226:	bd08      	pop	{r3, pc}

08018228 <get_rate_value_inch>:
{
 8018228:	b508      	push	{r3, lr}
    return uitoa((uint32_t)(value * INCH_PER_MM));
 801822a:	eddf 7a05 	vldr	s15, [pc, #20]	; 8018240 <get_rate_value_inch+0x18>
 801822e:	ee20 0a27 	vmul.f32	s0, s0, s15
 8018232:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8018236:	ee17 0a90 	vmov	r0, s15
 801823a:	f7fd fa9d 	bl	8015778 <uitoa>
}
 801823e:	bd08      	pop	{r3, pc}
 8018240:	3d21428b 	.word	0x3d21428b

08018244 <print_setting>:
{
 8018244:	b570      	push	{r4, r5, r6, lr}
 8018246:	4604      	mov	r4, r0
    if(setting->value != NULL)
 8018248:	6a03      	ldr	r3, [r0, #32]
 801824a:	b123      	cbz	r3, 8018256 <print_setting+0x12>
        grbl.report.setting(setting, offset, data);
 801824c:	4b0a      	ldr	r3, [pc, #40]	; (8018278 <print_setting+0x34>)
 801824e:	695b      	ldr	r3, [r3, #20]
 8018250:	4798      	blx	r3
}
 8018252:	2001      	movs	r0, #1
 8018254:	bd70      	pop	{r4, r5, r6, pc}
        hal.stream.write("$");
 8018256:	4d09      	ldr	r5, [pc, #36]	; (801827c <print_setting+0x38>)
 8018258:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 801825c:	4808      	ldr	r0, [pc, #32]	; (8018280 <print_setting+0x3c>)
 801825e:	4798      	blx	r3
        hal.stream.write(uitoa(setting->id));
 8018260:	f8d5 60b4 	ldr.w	r6, [r5, #180]	; 0xb4
 8018264:	8820      	ldrh	r0, [r4, #0]
 8018266:	f7fd fa87 	bl	8015778 <uitoa>
 801826a:	47b0      	blx	r6
        hal.stream.write("=N/A" ASCII_EOL);
 801826c:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8018270:	4804      	ldr	r0, [pc, #16]	; (8018284 <print_setting+0x40>)
 8018272:	4798      	blx	r3
 8018274:	e7ed      	b.n	8018252 <print_setting+0xe>
 8018276:	bf00      	nop
 8018278:	2000343c 	.word	0x2000343c
 801827c:	2000350c 	.word	0x2000350c
 8018280:	08027338 	.word	0x08027338
 8018284:	0802733c 	.word	0x0802733c

08018288 <print_alarm>:
{
 8018288:	b570      	push	{r4, r5, r6, lr}
 801828a:	4604      	mov	r4, r0
    if(grbl_format) {
 801828c:	b9f1      	cbnz	r1, 80182cc <print_alarm+0x44>
        hal.stream.write("[ALARMCODE:");
 801828e:	4d1b      	ldr	r5, [pc, #108]	; (80182fc <print_alarm+0x74>)
 8018290:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8018294:	481a      	ldr	r0, [pc, #104]	; (8018300 <print_alarm+0x78>)
 8018296:	4798      	blx	r3
        hal.stream.write(uitoa(alarm->id));
 8018298:	f8d5 60b4 	ldr.w	r6, [r5, #180]	; 0xb4
 801829c:	7820      	ldrb	r0, [r4, #0]
 801829e:	f7fd fa6b 	bl	8015778 <uitoa>
 80182a2:	47b0      	blx	r6
        hal.stream.write(vbar);
 80182a4:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 80182a8:	4e16      	ldr	r6, [pc, #88]	; (8018304 <print_alarm+0x7c>)
 80182aa:	4630      	mov	r0, r6
 80182ac:	4798      	blx	r3
        hal.stream.write(vbar);
 80182ae:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 80182b2:	4630      	mov	r0, r6
 80182b4:	4798      	blx	r3
        if(alarm->description)
 80182b6:	6860      	ldr	r0, [r4, #4]
 80182b8:	b110      	cbz	r0, 80182c0 <print_alarm+0x38>
            hal.stream.write(alarm->description);
 80182ba:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 80182be:	4798      	blx	r3
        hal.stream.write("]" ASCII_EOL);
 80182c0:	4b0e      	ldr	r3, [pc, #56]	; (80182fc <print_alarm+0x74>)
 80182c2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80182c6:	4810      	ldr	r0, [pc, #64]	; (8018308 <print_alarm+0x80>)
 80182c8:	4798      	blx	r3
}
 80182ca:	bd70      	pop	{r4, r5, r6, pc}
        write_quoted(uitoa(alarm->id), ",");
 80182cc:	7800      	ldrb	r0, [r0, #0]
 80182ce:	f7fd fa53 	bl	8015778 <uitoa>
 80182d2:	4d0e      	ldr	r5, [pc, #56]	; (801830c <print_alarm+0x84>)
 80182d4:	4629      	mov	r1, r5
 80182d6:	f7ff ff4b 	bl	8018170 <write_quoted>
        write_quoted("N/A", ",");
 80182da:	4629      	mov	r1, r5
 80182dc:	480c      	ldr	r0, [pc, #48]	; (8018310 <print_alarm+0x88>)
 80182de:	f7ff ff47 	bl	8018170 <write_quoted>
        write_quoted(alarm->description ? alarm->description : "", NULL);
 80182e2:	6860      	ldr	r0, [r4, #4]
 80182e4:	b140      	cbz	r0, 80182f8 <print_alarm+0x70>
 80182e6:	2100      	movs	r1, #0
 80182e8:	f7ff ff42 	bl	8018170 <write_quoted>
        hal.stream.write(ASCII_EOL);
 80182ec:	4b03      	ldr	r3, [pc, #12]	; (80182fc <print_alarm+0x74>)
 80182ee:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80182f2:	4808      	ldr	r0, [pc, #32]	; (8018314 <print_alarm+0x8c>)
 80182f4:	4798      	blx	r3
 80182f6:	e7e8      	b.n	80182ca <print_alarm+0x42>
        write_quoted(alarm->description ? alarm->description : "", NULL);
 80182f8:	4807      	ldr	r0, [pc, #28]	; (8018318 <print_alarm+0x90>)
 80182fa:	e7f4      	b.n	80182e6 <print_alarm+0x5e>
 80182fc:	2000350c 	.word	0x2000350c
 8018300:	08027344 	.word	0x08027344
 8018304:	080283e8 	.word	0x080283e8
 8018308:	0802cde0 	.word	0x0802cde0
 801830c:	08027758 	.word	0x08027758
 8018310:	08027334 	.word	0x08027334
 8018314:	080279c0 	.word	0x080279c0
 8018318:	080274a0 	.word	0x080274a0

0801831c <print_error>:
{
 801831c:	b570      	push	{r4, r5, r6, lr}
 801831e:	4604      	mov	r4, r0
    if(grbl_format) {
 8018320:	b9f1      	cbnz	r1, 8018360 <print_error+0x44>
        hal.stream.write("[ERRORCODE:");
 8018322:	4d1b      	ldr	r5, [pc, #108]	; (8018390 <print_error+0x74>)
 8018324:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8018328:	481a      	ldr	r0, [pc, #104]	; (8018394 <print_error+0x78>)
 801832a:	4798      	blx	r3
        hal.stream.write(uitoa(error->id));
 801832c:	f8d5 60b4 	ldr.w	r6, [r5, #180]	; 0xb4
 8018330:	7820      	ldrb	r0, [r4, #0]
 8018332:	f7fd fa21 	bl	8015778 <uitoa>
 8018336:	47b0      	blx	r6
        hal.stream.write(vbar);
 8018338:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 801833c:	4e16      	ldr	r6, [pc, #88]	; (8018398 <print_error+0x7c>)
 801833e:	4630      	mov	r0, r6
 8018340:	4798      	blx	r3
        hal.stream.write(vbar);
 8018342:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8018346:	4630      	mov	r0, r6
 8018348:	4798      	blx	r3
        if(error->description)
 801834a:	6860      	ldr	r0, [r4, #4]
 801834c:	b110      	cbz	r0, 8018354 <print_error+0x38>
            hal.stream.write(error->description);
 801834e:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8018352:	4798      	blx	r3
        hal.stream.write("]" ASCII_EOL);
 8018354:	4b0e      	ldr	r3, [pc, #56]	; (8018390 <print_error+0x74>)
 8018356:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801835a:	4810      	ldr	r0, [pc, #64]	; (801839c <print_error+0x80>)
 801835c:	4798      	blx	r3
}
 801835e:	bd70      	pop	{r4, r5, r6, pc}
        write_quoted(uitoa(error->id), ",");
 8018360:	7800      	ldrb	r0, [r0, #0]
 8018362:	f7fd fa09 	bl	8015778 <uitoa>
 8018366:	4d0e      	ldr	r5, [pc, #56]	; (80183a0 <print_error+0x84>)
 8018368:	4629      	mov	r1, r5
 801836a:	f7ff ff01 	bl	8018170 <write_quoted>
        write_quoted("N/A", ",");
 801836e:	4629      	mov	r1, r5
 8018370:	480c      	ldr	r0, [pc, #48]	; (80183a4 <print_error+0x88>)
 8018372:	f7ff fefd 	bl	8018170 <write_quoted>
        write_quoted(error->description ? error->description : "", NULL);
 8018376:	6860      	ldr	r0, [r4, #4]
 8018378:	b140      	cbz	r0, 801838c <print_error+0x70>
 801837a:	2100      	movs	r1, #0
 801837c:	f7ff fef8 	bl	8018170 <write_quoted>
        hal.stream.write(ASCII_EOL);
 8018380:	4b03      	ldr	r3, [pc, #12]	; (8018390 <print_error+0x74>)
 8018382:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018386:	4808      	ldr	r0, [pc, #32]	; (80183a8 <print_error+0x8c>)
 8018388:	4798      	blx	r3
 801838a:	e7e8      	b.n	801835e <print_error+0x42>
        write_quoted(error->description ? error->description : "", NULL);
 801838c:	4807      	ldr	r0, [pc, #28]	; (80183ac <print_error+0x90>)
 801838e:	e7f4      	b.n	801837a <print_error+0x5e>
 8018390:	2000350c 	.word	0x2000350c
 8018394:	08027350 	.word	0x08027350
 8018398:	080283e8 	.word	0x080283e8
 801839c:	0802cde0 	.word	0x0802cde0
 80183a0:	08027758 	.word	0x08027758
 80183a4:	08027334 	.word	0x08027334
 80183a8:	080279c0 	.word	0x080279c0
 80183ac:	080274a0 	.word	0x080274a0

080183b0 <report_pin>:

static void report_pin (xbar_t *pin, void *data)
{
 80183b0:	b570      	push	{r4, r5, r6, lr}
 80183b2:	4604      	mov	r4, r0
    hal.stream.write("[PIN:");
 80183b4:	4b16      	ldr	r3, [pc, #88]	; (8018410 <report_pin+0x60>)
 80183b6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80183ba:	4816      	ldr	r0, [pc, #88]	; (8018414 <report_pin+0x64>)
 80183bc:	4798      	blx	r3
    if(pin->port)
 80183be:	68a0      	ldr	r0, [r4, #8]
 80183c0:	b118      	cbz	r0, 80183ca <report_pin+0x1a>
        hal.stream.write((char *)pin->port);
 80183c2:	4b13      	ldr	r3, [pc, #76]	; (8018410 <report_pin+0x60>)
 80183c4:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80183c8:	4798      	blx	r3
    hal.stream.write(uitoa(pin->pin));
 80183ca:	4d11      	ldr	r5, [pc, #68]	; (8018410 <report_pin+0x60>)
 80183cc:	f8d5 60b4 	ldr.w	r6, [r5, #180]	; 0xb4
 80183d0:	6920      	ldr	r0, [r4, #16]
 80183d2:	f7fd f9d1 	bl	8015778 <uitoa>
 80183d6:	47b0      	blx	r6
    hal.stream.write(",");
 80183d8:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 80183dc:	480e      	ldr	r0, [pc, #56]	; (8018418 <report_pin+0x68>)
 80183de:	4798      	blx	r3
    hal.stream.write(get_pinname(pin->function));
 80183e0:	f8d5 50b4 	ldr.w	r5, [r5, #180]	; 0xb4
 80183e4:	7820      	ldrb	r0, [r4, #0]
 80183e6:	f7ff fefd 	bl	80181e4 <get_pinname>
 80183ea:	47a8      	blx	r5
    if(pin->description) {
 80183ec:	68e3      	ldr	r3, [r4, #12]
 80183ee:	b143      	cbz	r3, 8018402 <report_pin+0x52>
        hal.stream.write(",");
 80183f0:	4d07      	ldr	r5, [pc, #28]	; (8018410 <report_pin+0x60>)
 80183f2:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 80183f6:	4808      	ldr	r0, [pc, #32]	; (8018418 <report_pin+0x68>)
 80183f8:	4798      	blx	r3
        hal.stream.write(pin->description);
 80183fa:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 80183fe:	68e0      	ldr	r0, [r4, #12]
 8018400:	4798      	blx	r3
    }
    hal.stream.write("]" ASCII_EOL);
 8018402:	4b03      	ldr	r3, [pc, #12]	; (8018410 <report_pin+0x60>)
 8018404:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018408:	4804      	ldr	r0, [pc, #16]	; (801841c <report_pin+0x6c>)
 801840a:	4798      	blx	r3
}
 801840c:	bd70      	pop	{r4, r5, r6, pc}
 801840e:	bf00      	nop
 8018410:	2000350c 	.word	0x2000350c
 8018414:	0802735c 	.word	0x0802735c
 8018418:	08027758 	.word	0x08027758
 801841c:	0802cde0 	.word	0x0802cde0

08018420 <print_uito2a>:

    return Status_OK;
}

static void print_uito2a (char *prefix, uint32_t v)
{
 8018420:	b538      	push	{r3, r4, r5, lr}
 8018422:	460c      	mov	r4, r1
    hal.stream.write(prefix);
 8018424:	4b09      	ldr	r3, [pc, #36]	; (801844c <print_uito2a+0x2c>)
 8018426:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801842a:	4798      	blx	r3
    if(v < 10)
 801842c:	2c09      	cmp	r4, #9
 801842e:	d804      	bhi.n	801843a <print_uito2a+0x1a>
        hal.stream.write("0");
 8018430:	4b06      	ldr	r3, [pc, #24]	; (801844c <print_uito2a+0x2c>)
 8018432:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018436:	4806      	ldr	r0, [pc, #24]	; (8018450 <print_uito2a+0x30>)
 8018438:	4798      	blx	r3
    hal.stream.write(uitoa(v));
 801843a:	4b04      	ldr	r3, [pc, #16]	; (801844c <print_uito2a+0x2c>)
 801843c:	f8d3 50b4 	ldr.w	r5, [r3, #180]	; 0xb4
 8018440:	4620      	mov	r0, r4
 8018442:	f7fd f999 	bl	8015778 <uitoa>
 8018446:	47a8      	blx	r5
}
 8018448:	bd38      	pop	{r3, r4, r5, pc}
 801844a:	bf00      	nop
 801844c:	2000350c 	.word	0x2000350c
 8018450:	08027ef0 	.word	0x08027ef0

08018454 <report_spindle>:

    return ok ? Status_OK : Status_InvalidStatement;
}

static void report_spindle (spindle_info_t *spindle, void *data)
{
 8018454:	b570      	push	{r4, r5, r6, lr}
 8018456:	4604      	mov	r4, r0
    hal.stream.write(uitoa(spindle->id));
 8018458:	4d0d      	ldr	r5, [pc, #52]	; (8018490 <report_spindle+0x3c>)
 801845a:	f8d5 60b4 	ldr.w	r6, [r5, #180]	; 0xb4
 801845e:	f990 0000 	ldrsb.w	r0, [r0]
 8018462:	f7fd f989 	bl	8015778 <uitoa>
 8018466:	47b0      	blx	r6
    hal.stream.write(" - ");
 8018468:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 801846c:	4809      	ldr	r0, [pc, #36]	; (8018494 <report_spindle+0x40>)
 801846e:	4798      	blx	r3
    hal.stream.write(spindle->name);
 8018470:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8018474:	6860      	ldr	r0, [r4, #4]
 8018476:	4798      	blx	r3
    if(spindle->enabled) {
 8018478:	7a23      	ldrb	r3, [r4, #8]
 801847a:	b11b      	cbz	r3, 8018484 <report_spindle+0x30>
#if N_SPINDLE > 1
        hal.stream.write(", enabled as spindle ");
        hal.stream.write(uitoa(spindle->num));
#else
        hal.stream.write(", active");
 801847c:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8018480:	4805      	ldr	r0, [pc, #20]	; (8018498 <report_spindle+0x44>)
 8018482:	4798      	blx	r3
#endif
    }
    hal.stream.write(ASCII_EOL);
 8018484:	4b02      	ldr	r3, [pc, #8]	; (8018490 <report_spindle+0x3c>)
 8018486:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801848a:	4804      	ldr	r0, [pc, #16]	; (801849c <report_spindle+0x48>)
 801848c:	4798      	blx	r3
}
 801848e:	bd70      	pop	{r4, r5, r6, pc}
 8018490:	2000350c 	.word	0x2000350c
 8018494:	08027364 	.word	0x08027364
 8018498:	08027368 	.word	0x08027368
 801849c:	080279c0 	.word	0x080279c0

080184a0 <get_axis_values_mm>:
{
 80184a0:	b570      	push	{r4, r5, r6, lr}
 80184a2:	4605      	mov	r5, r0
    buf[0] = '\0';
 80184a4:	2400      	movs	r4, #0
 80184a6:	4b18      	ldr	r3, [pc, #96]	; (8018508 <get_axis_values_mm+0x68>)
 80184a8:	701c      	strb	r4, [r3, #0]
    for (idx = 0; idx < N_AXIS; idx++) {
 80184aa:	e014      	b.n	80184d6 <get_axis_values_mm+0x36>
            strcat(buf, ftoa(axis_values[idx], N_DECIMAL_COORDVALUE_MM));
 80184ac:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 80184b0:	2003      	movs	r0, #3
 80184b2:	ed93 0a00 	vldr	s0, [r3]
 80184b6:	f7fd f981 	bl	80157bc <ftoa>
 80184ba:	4601      	mov	r1, r0
 80184bc:	4812      	ldr	r0, [pc, #72]	; (8018508 <get_axis_values_mm+0x68>)
 80184be:	f00a fb62 	bl	8022b86 <strcat>
        if (idx < (N_AXIS - 1))
 80184c2:	2c01      	cmp	r4, #1
 80184c4:	d806      	bhi.n	80184d4 <get_axis_values_mm+0x34>
            strcat(buf, ",");
 80184c6:	4e10      	ldr	r6, [pc, #64]	; (8018508 <get_axis_values_mm+0x68>)
 80184c8:	4630      	mov	r0, r6
 80184ca:	f7ef fdc3 	bl	8008054 <strlen>
 80184ce:	4b0f      	ldr	r3, [pc, #60]	; (801850c <get_axis_values_mm+0x6c>)
 80184d0:	881b      	ldrh	r3, [r3, #0]
 80184d2:	5233      	strh	r3, [r6, r0]
    for (idx = 0; idx < N_AXIS; idx++) {
 80184d4:	3401      	adds	r4, #1
 80184d6:	2c02      	cmp	r4, #2
 80184d8:	d813      	bhi.n	8018502 <get_axis_values_mm+0x62>
        if(idx == X_AXIS && gc_state.modal.diameter_mode)
 80184da:	2c00      	cmp	r4, #0
 80184dc:	d1e6      	bne.n	80184ac <get_axis_values_mm+0xc>
 80184de:	4b0c      	ldr	r3, [pc, #48]	; (8018510 <get_axis_values_mm+0x70>)
 80184e0:	795b      	ldrb	r3, [r3, #5]
 80184e2:	2b00      	cmp	r3, #0
 80184e4:	d0e2      	beq.n	80184ac <get_axis_values_mm+0xc>
            strcat(buf, ftoa(axis_values[idx] * 2.0f, N_DECIMAL_COORDVALUE_MM));
 80184e6:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 80184ea:	ed93 0a00 	vldr	s0, [r3]
 80184ee:	2003      	movs	r0, #3
 80184f0:	ee30 0a00 	vadd.f32	s0, s0, s0
 80184f4:	f7fd f962 	bl	80157bc <ftoa>
 80184f8:	4601      	mov	r1, r0
 80184fa:	4803      	ldr	r0, [pc, #12]	; (8018508 <get_axis_values_mm+0x68>)
 80184fc:	f00a fb43 	bl	8022b86 <strcat>
 8018500:	e7df      	b.n	80184c2 <get_axis_values_mm+0x22>
}
 8018502:	4801      	ldr	r0, [pc, #4]	; (8018508 <get_axis_values_mm+0x68>)
 8018504:	bd70      	pop	{r4, r5, r6, pc}
 8018506:	bf00      	nop
 8018508:	20003a88 	.word	0x20003a88
 801850c:	08027758 	.word	0x08027758
 8018510:	20003344 	.word	0x20003344

08018514 <get_axis_values_inches>:
{
 8018514:	b570      	push	{r4, r5, r6, lr}
 8018516:	4605      	mov	r5, r0
    buf[0] = '\0';
 8018518:	2400      	movs	r4, #0
 801851a:	4b1c      	ldr	r3, [pc, #112]	; (801858c <get_axis_values_inches+0x78>)
 801851c:	701c      	strb	r4, [r3, #0]
    for (idx = 0; idx < N_AXIS; idx++) {
 801851e:	e018      	b.n	8018552 <get_axis_values_inches+0x3e>
             strcat(buf, ftoa(axis_values[idx] * INCH_PER_MM, N_DECIMAL_COORDVALUE_INCH));
 8018520:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 8018524:	ed93 0a00 	vldr	s0, [r3]
 8018528:	2004      	movs	r0, #4
 801852a:	eddf 7a19 	vldr	s15, [pc, #100]	; 8018590 <get_axis_values_inches+0x7c>
 801852e:	ee20 0a27 	vmul.f32	s0, s0, s15
 8018532:	f7fd f943 	bl	80157bc <ftoa>
 8018536:	4601      	mov	r1, r0
 8018538:	4814      	ldr	r0, [pc, #80]	; (801858c <get_axis_values_inches+0x78>)
 801853a:	f00a fb24 	bl	8022b86 <strcat>
        if (idx < (N_AXIS - 1))
 801853e:	2c01      	cmp	r4, #1
 8018540:	d806      	bhi.n	8018550 <get_axis_values_inches+0x3c>
            strcat(buf, ",");
 8018542:	4e12      	ldr	r6, [pc, #72]	; (801858c <get_axis_values_inches+0x78>)
 8018544:	4630      	mov	r0, r6
 8018546:	f7ef fd85 	bl	8008054 <strlen>
 801854a:	4b12      	ldr	r3, [pc, #72]	; (8018594 <get_axis_values_inches+0x80>)
 801854c:	881b      	ldrh	r3, [r3, #0]
 801854e:	5233      	strh	r3, [r6, r0]
    for (idx = 0; idx < N_AXIS; idx++) {
 8018550:	3401      	adds	r4, #1
 8018552:	2c02      	cmp	r4, #2
 8018554:	d817      	bhi.n	8018586 <get_axis_values_inches+0x72>
        if(idx == X_AXIS && gc_state.modal.diameter_mode)
 8018556:	2c00      	cmp	r4, #0
 8018558:	d1e2      	bne.n	8018520 <get_axis_values_inches+0xc>
 801855a:	4b0f      	ldr	r3, [pc, #60]	; (8018598 <get_axis_values_inches+0x84>)
 801855c:	795b      	ldrb	r3, [r3, #5]
 801855e:	2b00      	cmp	r3, #0
 8018560:	d0de      	beq.n	8018520 <get_axis_values_inches+0xc>
            strcat(buf, ftoa(axis_values[idx] * INCH_PER_MM * 2.0f, N_DECIMAL_COORDVALUE_INCH));
 8018562:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 8018566:	ed93 0a00 	vldr	s0, [r3]
 801856a:	eddf 7a09 	vldr	s15, [pc, #36]	; 8018590 <get_axis_values_inches+0x7c>
 801856e:	ee20 0a27 	vmul.f32	s0, s0, s15
 8018572:	2004      	movs	r0, #4
 8018574:	ee30 0a00 	vadd.f32	s0, s0, s0
 8018578:	f7fd f920 	bl	80157bc <ftoa>
 801857c:	4601      	mov	r1, r0
 801857e:	4803      	ldr	r0, [pc, #12]	; (801858c <get_axis_values_inches+0x78>)
 8018580:	f00a fb01 	bl	8022b86 <strcat>
 8018584:	e7db      	b.n	801853e <get_axis_values_inches+0x2a>
}
 8018586:	4801      	ldr	r0, [pc, #4]	; (801858c <get_axis_values_inches+0x78>)
 8018588:	bd70      	pop	{r4, r5, r6, pc}
 801858a:	bf00      	nop
 801858c:	20003a88 	.word	0x20003a88
 8018590:	3d21428b 	.word	0x3d21428b
 8018594:	08027758 	.word	0x08027758
 8018598:	20003344 	.word	0x20003344

0801859c <get_axis_value_mm>:
{
 801859c:	b508      	push	{r3, lr}
    return strcpy(buf, ftoa(value, N_DECIMAL_COORDVALUE_MM));
 801859e:	2003      	movs	r0, #3
 80185a0:	f7fd f90c 	bl	80157bc <ftoa>
 80185a4:	4601      	mov	r1, r0
 80185a6:	4802      	ldr	r0, [pc, #8]	; (80185b0 <get_axis_value_mm+0x14>)
 80185a8:	f00a fc3a 	bl	8022e20 <strcpy>
}
 80185ac:	bd08      	pop	{r3, pc}
 80185ae:	bf00      	nop
 80185b0:	20003a88 	.word	0x20003a88

080185b4 <get_axis_value_inches>:
{
 80185b4:	b508      	push	{r3, lr}
    return strcpy(buf, ftoa(value * INCH_PER_MM, N_DECIMAL_COORDVALUE_INCH));
 80185b6:	2004      	movs	r0, #4
 80185b8:	eddf 7a05 	vldr	s15, [pc, #20]	; 80185d0 <get_axis_value_inches+0x1c>
 80185bc:	ee20 0a27 	vmul.f32	s0, s0, s15
 80185c0:	f7fd f8fc 	bl	80157bc <ftoa>
 80185c4:	4601      	mov	r1, r0
 80185c6:	4803      	ldr	r0, [pc, #12]	; (80185d4 <get_axis_value_inches+0x20>)
 80185c8:	f00a fc2a 	bl	8022e20 <strcpy>
}
 80185cc:	bd08      	pop	{r3, pc}
 80185ce:	bf00      	nop
 80185d0:	3d21428b 	.word	0x3d21428b
 80185d4:	20003a88 	.word	0x20003a88

080185d8 <map_coord_system>:
{
 80185d8:	b538      	push	{r3, r4, r5, lr}
    uint8_t g5x = id + 54;
 80185da:	f100 0436 	add.w	r4, r0, #54	; 0x36
 80185de:	b2e4      	uxtb	r4, r4
    strcpy(buf, uitoa((uint32_t)(g5x > 59 ? 59 : g5x)));
 80185e0:	4620      	mov	r0, r4
 80185e2:	2c3b      	cmp	r4, #59	; 0x3b
 80185e4:	bf28      	it	cs
 80185e6:	203b      	movcs	r0, #59	; 0x3b
 80185e8:	f7fd f8c6 	bl	8015778 <uitoa>
 80185ec:	4601      	mov	r1, r0
 80185ee:	480b      	ldr	r0, [pc, #44]	; (801861c <map_coord_system+0x44>)
 80185f0:	f00a fc16 	bl	8022e20 <strcpy>
    if(g5x > 59) {
 80185f4:	2c3b      	cmp	r4, #59	; 0x3b
 80185f6:	d801      	bhi.n	80185fc <map_coord_system+0x24>
}
 80185f8:	4808      	ldr	r0, [pc, #32]	; (801861c <map_coord_system+0x44>)
 80185fa:	bd38      	pop	{r3, r4, r5, pc}
        strcat(buf, ".");
 80185fc:	4d07      	ldr	r5, [pc, #28]	; (801861c <map_coord_system+0x44>)
 80185fe:	4628      	mov	r0, r5
 8018600:	f7ef fd28 	bl	8008054 <strlen>
 8018604:	4b06      	ldr	r3, [pc, #24]	; (8018620 <map_coord_system+0x48>)
 8018606:	881b      	ldrh	r3, [r3, #0]
 8018608:	522b      	strh	r3, [r5, r0]
        strcat(buf, uitoa((uint32_t)(g5x - 59)));
 801860a:	f1a4 003b 	sub.w	r0, r4, #59	; 0x3b
 801860e:	f7fd f8b3 	bl	8015778 <uitoa>
 8018612:	4601      	mov	r1, r0
 8018614:	4628      	mov	r0, r5
 8018616:	f00a fab6 	bl	8022b86 <strcat>
 801861a:	e7ed      	b.n	80185f8 <map_coord_system+0x20>
 801861c:	20003a88 	.word	0x20003a88
 8018620:	08025884 	.word	0x08025884

08018624 <appendbuf>:
{
 8018624:	b40f      	push	{r0, r1, r2, r3}
 8018626:	b410      	push	{r4}
 8018628:	b083      	sub	sp, #12
 801862a:	ab04      	add	r3, sp, #16
 801862c:	f853 4b04 	ldr.w	r4, [r3], #4
    va_start(list, argc);
 8018630:	9301      	str	r3, [sp, #4]
    char c, *s = buf, *arg;
 8018632:	480c      	ldr	r0, [pc, #48]	; (8018664 <appendbuf+0x40>)
    while(argc--) {
 8018634:	e00b      	b.n	801864e <appendbuf+0x2a>
        arg = va_arg(list, char *);
 8018636:	9b01      	ldr	r3, [sp, #4]
 8018638:	1d1a      	adds	r2, r3, #4
 801863a:	9201      	str	r2, [sp, #4]
 801863c:	6819      	ldr	r1, [r3, #0]
 801863e:	4602      	mov	r2, r0
            c = *s++ = *arg++;
 8018640:	4610      	mov	r0, r2
 8018642:	3201      	adds	r2, #1
 8018644:	780b      	ldrb	r3, [r1, #0]
 8018646:	3101      	adds	r1, #1
 8018648:	7003      	strb	r3, [r0, #0]
        } while(c);
 801864a:	2b00      	cmp	r3, #0
 801864c:	d1f8      	bne.n	8018640 <appendbuf+0x1c>
    while(argc--) {
 801864e:	4623      	mov	r3, r4
 8018650:	3c01      	subs	r4, #1
 8018652:	2b00      	cmp	r3, #0
 8018654:	d1ef      	bne.n	8018636 <appendbuf+0x12>
}
 8018656:	4803      	ldr	r0, [pc, #12]	; (8018664 <appendbuf+0x40>)
 8018658:	b003      	add	sp, #12
 801865a:	f85d 4b04 	ldr.w	r4, [sp], #4
 801865e:	b004      	add	sp, #16
 8018660:	4770      	bx	lr
 8018662:	bf00      	nop
 8018664:	20003a88 	.word	0x20003a88

08018668 <report_alarm_message>:
{
 8018668:	b570      	push	{r4, r5, r6, lr}
 801866a:	4604      	mov	r4, r0
    hal.stream.write_all(appendbuf(3, "ALARM:", uitoa((uint32_t)alarm_code), ASCII_EOL));
 801866c:	4d08      	ldr	r5, [pc, #32]	; (8018690 <report_alarm_message+0x28>)
 801866e:	f8d5 60b8 	ldr.w	r6, [r5, #184]	; 0xb8
 8018672:	f7fd f881 	bl	8015778 <uitoa>
 8018676:	4602      	mov	r2, r0
 8018678:	4b06      	ldr	r3, [pc, #24]	; (8018694 <report_alarm_message+0x2c>)
 801867a:	4907      	ldr	r1, [pc, #28]	; (8018698 <report_alarm_message+0x30>)
 801867c:	2003      	movs	r0, #3
 801867e:	f7ff ffd1 	bl	8018624 <appendbuf>
 8018682:	47b0      	blx	r6
    hal.delay_ms(100, NULL); // Force delay to ensure message clears output stream buffer.
 8018684:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8018686:	2100      	movs	r1, #0
 8018688:	2064      	movs	r0, #100	; 0x64
 801868a:	4798      	blx	r3
}
 801868c:	4620      	mov	r0, r4
 801868e:	bd70      	pop	{r4, r5, r6, pc}
 8018690:	2000350c 	.word	0x2000350c
 8018694:	080279c0 	.word	0x080279c0
 8018698:	08027374 	.word	0x08027374

0801869c <report_status_message>:
{
 801869c:	b538      	push	{r3, r4, r5, lr}
    switch(status_code) {
 801869e:	4604      	mov	r4, r0
 80186a0:	b930      	cbnz	r0, 80186b0 <report_status_message+0x14>
            hal.stream.write("ok" ASCII_EOL);
 80186a2:	4b0a      	ldr	r3, [pc, #40]	; (80186cc <report_status_message+0x30>)
 80186a4:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80186a8:	4809      	ldr	r0, [pc, #36]	; (80186d0 <report_status_message+0x34>)
 80186aa:	4798      	blx	r3
}
 80186ac:	4620      	mov	r0, r4
 80186ae:	bd38      	pop	{r3, r4, r5, pc}
            hal.stream.write(appendbuf(3, "error:", uitoa((uint32_t)status_code), ASCII_EOL));
 80186b0:	4b06      	ldr	r3, [pc, #24]	; (80186cc <report_status_message+0x30>)
 80186b2:	f8d3 50b4 	ldr.w	r5, [r3, #180]	; 0xb4
 80186b6:	f7fd f85f 	bl	8015778 <uitoa>
 80186ba:	4602      	mov	r2, r0
 80186bc:	4b05      	ldr	r3, [pc, #20]	; (80186d4 <report_status_message+0x38>)
 80186be:	4906      	ldr	r1, [pc, #24]	; (80186d8 <report_status_message+0x3c>)
 80186c0:	2003      	movs	r0, #3
 80186c2:	f7ff ffaf 	bl	8018624 <appendbuf>
 80186c6:	47a8      	blx	r5
            break;
 80186c8:	e7f0      	b.n	80186ac <report_status_message+0x10>
 80186ca:	bf00      	nop
 80186cc:	2000350c 	.word	0x2000350c
 80186d0:	0802737c 	.word	0x0802737c
 80186d4:	080279c0 	.word	0x080279c0
 80186d8:	08027384 	.word	0x08027384

080186dc <report_bitfield>:
{
 80186dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80186e0:	4604      	mov	r4, r0
 80186e2:	4688      	mov	r8, r1
    if((s = (char *)malloc(strlen(format) + 1))) {
 80186e4:	f7ef fcb6 	bl	8008054 <strlen>
 80186e8:	3001      	adds	r0, #1
 80186ea:	f009 fee1 	bl	80224b0 <malloc>
 80186ee:	2800      	cmp	r0, #0
 80186f0:	d049      	beq.n	8018786 <report_bitfield+0xaa>
 80186f2:	4681      	mov	r9, r0
        strcpy(s, format);
 80186f4:	4621      	mov	r1, r4
 80186f6:	f00a fb93 	bl	8022e20 <strcpy>
        char *element = strtok(s, ",");
 80186fa:	4924      	ldr	r1, [pc, #144]	; (801878c <report_bitfield+0xb0>)
 80186fc:	4648      	mov	r0, r9
 80186fe:	f00a fa9b 	bl	8022c38 <strtok>
 8018702:	4604      	mov	r4, r0
    uint_fast16_t val = 1;
 8018704:	2701      	movs	r7, #1
    uint_fast8_t bit = 0;
 8018706:	2600      	movs	r6, #0
        while(element) {
 8018708:	e006      	b.n	8018718 <report_bitfield+0x3c>
            bit++;
 801870a:	3601      	adds	r6, #1
            val <<= 1;
 801870c:	007f      	lsls	r7, r7, #1
            element = strtok(NULL, ",");
 801870e:	491f      	ldr	r1, [pc, #124]	; (801878c <report_bitfield+0xb0>)
 8018710:	2000      	movs	r0, #0
 8018712:	f00a fa91 	bl	8022c38 <strtok>
 8018716:	4604      	mov	r4, r0
        while(element) {
 8018718:	2c00      	cmp	r4, #0
 801871a:	d031      	beq.n	8018780 <report_bitfield+0xa4>
            if(strcmp(element, "N/A")) {
 801871c:	491c      	ldr	r1, [pc, #112]	; (8018790 <report_bitfield+0xb4>)
 801871e:	4620      	mov	r0, r4
 8018720:	f7ef fc8e 	bl	8008040 <strcmp>
 8018724:	2800      	cmp	r0, #0
 8018726:	d0f0      	beq.n	801870a <report_bitfield+0x2e>
                hal.stream.write(ASCII_EOL);
 8018728:	4d1a      	ldr	r5, [pc, #104]	; (8018794 <report_bitfield+0xb8>)
 801872a:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 801872e:	481a      	ldr	r0, [pc, #104]	; (8018798 <report_bitfield+0xbc>)
 8018730:	4798      	blx	r3
                hal.stream.write("    ");
 8018732:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8018736:	4819      	ldr	r0, [pc, #100]	; (801879c <report_bitfield+0xc0>)
 8018738:	4798      	blx	r3
                hal.stream.write(uitoa(bit));
 801873a:	f8d5 a0b4 	ldr.w	sl, [r5, #180]	; 0xb4
 801873e:	4630      	mov	r0, r6
 8018740:	f7fd f81a 	bl	8015778 <uitoa>
 8018744:	47d0      	blx	sl
                hal.stream.write(" - ");
 8018746:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 801874a:	4815      	ldr	r0, [pc, #84]	; (80187a0 <report_bitfield+0xc4>)
 801874c:	4798      	blx	r3
                if(*element)
 801874e:	7823      	ldrb	r3, [r4, #0]
 8018750:	b11b      	cbz	r3, 801875a <report_bitfield+0x7e>
                hal.stream.write(element);
 8018752:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8018756:	4620      	mov	r0, r4
 8018758:	4798      	blx	r3
                if(bitmap) {
 801875a:	f1b8 0f00 	cmp.w	r8, #0
 801875e:	d0d4      	beq.n	801870a <report_bitfield+0x2e>
                    hal.stream.write(" (");
 8018760:	4c0c      	ldr	r4, [pc, #48]	; (8018794 <report_bitfield+0xb8>)
 8018762:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8018766:	480f      	ldr	r0, [pc, #60]	; (80187a4 <report_bitfield+0xc8>)
 8018768:	4798      	blx	r3
                    hal.stream.write(uitoa(val));
 801876a:	f8d4 50b4 	ldr.w	r5, [r4, #180]	; 0xb4
 801876e:	4638      	mov	r0, r7
 8018770:	f7fd f802 	bl	8015778 <uitoa>
 8018774:	47a8      	blx	r5
                    hal.stream.write(")");
 8018776:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801877a:	480b      	ldr	r0, [pc, #44]	; (80187a8 <report_bitfield+0xcc>)
 801877c:	4798      	blx	r3
 801877e:	e7c4      	b.n	801870a <report_bitfield+0x2e>
        free(s);
 8018780:	4648      	mov	r0, r9
 8018782:	f009 fe9d 	bl	80224c0 <free>
}
 8018786:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801878a:	bf00      	nop
 801878c:	08027758 	.word	0x08027758
 8018790:	08027334 	.word	0x08027334
 8018794:	2000350c 	.word	0x2000350c
 8018798:	080279c0 	.word	0x080279c0
 801879c:	0802738c 	.word	0x0802738c
 80187a0:	08027364 	.word	0x08027364
 80187a4:	08027394 	.word	0x08027394
 80187a8:	08026a14 	.word	0x08026a14

080187ac <cmp_setting_group_name>:
{
 80187ac:	b508      	push	{r3, lr}
    return strcmp((*(setting_group_detail_t **)(a))->name, (*(setting_group_detail_t **)(b))->name);
 80187ae:	6803      	ldr	r3, [r0, #0]
 80187b0:	680a      	ldr	r2, [r1, #0]
 80187b2:	6851      	ldr	r1, [r2, #4]
 80187b4:	6858      	ldr	r0, [r3, #4]
 80187b6:	f7ef fc43 	bl	8008040 <strcmp>
}
 80187ba:	bd08      	pop	{r3, pc}

080187bc <write_name>:
{
 80187bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80187be:	4604      	mov	r4, r0
    char *q = hal.stream.write_n ? strchr(s, '?') : NULL;
 80187c0:	4b10      	ldr	r3, [pc, #64]	; (8018804 <write_name+0x48>)
 80187c2:	f8d3 50d8 	ldr.w	r5, [r3, #216]	; 0xd8
 80187c6:	b1bd      	cbz	r5, 80187f8 <write_name+0x3c>
 80187c8:	460f      	mov	r7, r1
 80187ca:	213f      	movs	r1, #63	; 0x3f
 80187cc:	f00a f9ea 	bl	8022ba4 <strchr>
    if(q) {
 80187d0:	4606      	mov	r6, r0
 80187d2:	b188      	cbz	r0, 80187f8 <write_name+0x3c>
        if(q != s)
 80187d4:	4284      	cmp	r4, r0
 80187d6:	d003      	beq.n	80187e0 <write_name+0x24>
            hal.stream.write_n(s, q - s);
 80187d8:	1b01      	subs	r1, r0, r4
 80187da:	b289      	uxth	r1, r1
 80187dc:	4620      	mov	r0, r4
 80187de:	47a8      	blx	r5
        hal.stream.write(uitoa(offset + 1));
 80187e0:	4c08      	ldr	r4, [pc, #32]	; (8018804 <write_name+0x48>)
 80187e2:	f8d4 50b4 	ldr.w	r5, [r4, #180]	; 0xb4
 80187e6:	1c78      	adds	r0, r7, #1
 80187e8:	f7fc ffc6 	bl	8015778 <uitoa>
 80187ec:	47a8      	blx	r5
        hal.stream.write(q + 1);
 80187ee:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 80187f2:	1c70      	adds	r0, r6, #1
 80187f4:	4798      	blx	r3
 80187f6:	e004      	b.n	8018802 <write_name+0x46>
        hal.stream.write(s);
 80187f8:	4b02      	ldr	r3, [pc, #8]	; (8018804 <write_name+0x48>)
 80187fa:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80187fe:	4620      	mov	r0, r4
 8018800:	4798      	blx	r3
}
 8018802:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8018804:	2000350c 	.word	0x2000350c

08018808 <report_settings_detail>:
{
 8018808:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801880c:	460c      	mov	r4, r1
 801880e:	4615      	mov	r5, r2
    uint_fast8_t suboffset = setting->flags.subgroups ? offset / setting->flags.increment : offset;
 8018810:	f891 302c 	ldrb.w	r3, [r1, #44]	; 0x2c
 8018814:	f013 0f04 	tst.w	r3, #4
 8018818:	d004      	beq.n	8018824 <report_settings_detail+0x1c>
 801881a:	f3c3 06c3 	ubfx	r6, r3, #3, #4
 801881e:	fbb2 f6f6 	udiv	r6, r2, r6
 8018822:	e000      	b.n	8018826 <report_settings_detail+0x1e>
 8018824:	4616      	mov	r6, r2
    switch(format)
 8018826:	2803      	cmp	r0, #3
 8018828:	f200 82c3 	bhi.w	8018db2 <report_settings_detail+0x5aa>
 801882c:	e8df f010 	tbh	[pc, r0, lsl #1]
 8018830:	00040122 	.word	0x00040122
 8018834:	01ea01b3 	.word	0x01ea01b3
            hal.stream.write(ASCII_EOL "$");
 8018838:	4f7a      	ldr	r7, [pc, #488]	; (8018a24 <report_settings_detail+0x21c>)
 801883a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801883e:	487a      	ldr	r0, [pc, #488]	; (8018a28 <report_settings_detail+0x220>)
 8018840:	4798      	blx	r3
            hal.stream.write(uitoa(setting->id + offset));
 8018842:	f8d7 80b4 	ldr.w	r8, [r7, #180]	; 0xb4
 8018846:	8820      	ldrh	r0, [r4, #0]
 8018848:	4428      	add	r0, r5
 801884a:	f7fc ff95 	bl	8015778 <uitoa>
 801884e:	47c0      	blx	r8
            hal.stream.write(": ");
 8018850:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8018854:	4875      	ldr	r0, [pc, #468]	; (8018a2c <report_settings_detail+0x224>)
 8018856:	4798      	blx	r3
            if(setting->group == Group_Axis0)
 8018858:	78a3      	ldrb	r3, [r4, #2]
 801885a:	2b2b      	cmp	r3, #43	; 0x2b
 801885c:	d00f      	beq.n	801887e <report_settings_detail+0x76>
            write_name(setting->name, suboffset);
 801885e:	4631      	mov	r1, r6
 8018860:	6860      	ldr	r0, [r4, #4]
 8018862:	f7ff ffab 	bl	80187bc <write_name>
            switch(setting_datatype_to_external(setting->datatype)) {
 8018866:	7b20      	ldrb	r0, [r4, #12]
 8018868:	f004 fb3d 	bl	801cee6 <setting_datatype_to_external>
 801886c:	2809      	cmp	r0, #9
 801886e:	d87d      	bhi.n	801896c <report_settings_detail+0x164>
 8018870:	e8df f000 	tbb	[pc, r0]
 8018874:	6c625852 	.word	0x6c625852
 8018878:	7c7c7c0c 	.word	0x7c7c7c0c
 801887c:	767c      	.short	0x767c
                hal.stream.write(axis_letter[offset]);
 801887e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8018882:	4a6b      	ldr	r2, [pc, #428]	; (8018a30 <report_settings_detail+0x228>)
 8018884:	f852 0025 	ldr.w	r0, [r2, r5, lsl #2]
 8018888:	4798      	blx	r3
 801888a:	e7e8      	b.n	801885e <report_settings_detail+0x56>
                    hal.stream.write(" as axismask");
 801888c:	4b65      	ldr	r3, [pc, #404]	; (8018a24 <report_settings_detail+0x21c>)
 801888e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018892:	4868      	ldr	r0, [pc, #416]	; (8018a34 <report_settings_detail+0x22c>)
 8018894:	4798      	blx	r3
            if(setting->min_value && setting->max_value) {
 8018896:	6963      	ldr	r3, [r4, #20]
 8018898:	2b00      	cmp	r3, #0
 801889a:	d074      	beq.n	8018986 <report_settings_detail+0x17e>
 801889c:	69a3      	ldr	r3, [r4, #24]
 801889e:	2b00      	cmp	r3, #0
 80188a0:	d071      	beq.n	8018986 <report_settings_detail+0x17e>
                hal.stream.write(", range: ");
 80188a2:	4e60      	ldr	r6, [pc, #384]	; (8018a24 <report_settings_detail+0x21c>)
 80188a4:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
 80188a8:	4863      	ldr	r0, [pc, #396]	; (8018a38 <report_settings_detail+0x230>)
 80188aa:	4798      	blx	r3
                hal.stream.write(setting->min_value);
 80188ac:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
 80188b0:	6960      	ldr	r0, [r4, #20]
 80188b2:	4798      	blx	r3
                hal.stream.write(" - ");
 80188b4:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
 80188b8:	4860      	ldr	r0, [pc, #384]	; (8018a3c <report_settings_detail+0x234>)
 80188ba:	4798      	blx	r3
                hal.stream.write(setting->max_value);
 80188bc:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
 80188c0:	69a0      	ldr	r0, [r4, #24]
 80188c2:	4798      	blx	r3
            if(setting->flags.reboot_required)
 80188c4:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 80188c8:	f013 0f01 	tst.w	r3, #1
 80188cc:	d004      	beq.n	80188d8 <report_settings_detail+0xd0>
                hal.stream.write(", reboot required");
 80188ce:	4b55      	ldr	r3, [pc, #340]	; (8018a24 <report_settings_detail+0x21c>)
 80188d0:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80188d4:	485a      	ldr	r0, [pc, #360]	; (8018a40 <report_settings_detail+0x238>)
 80188d6:	4798      	blx	r3
            if(hal.stream.write_n) {
 80188d8:	4b52      	ldr	r3, [pc, #328]	; (8018a24 <report_settings_detail+0x21c>)
 80188da:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 80188de:	2b00      	cmp	r3, #0
 80188e0:	f000 8267 	beq.w	8018db2 <report_settings_detail+0x5aa>
                const char *description = setting_get_description((setting_id_t)(setting->id + offset));
 80188e4:	8820      	ldrh	r0, [r4, #0]
 80188e6:	fa10 f085 	uxtah	r0, r0, r5
 80188ea:	b280      	uxth	r0, r0
 80188ec:	f004 fa4e 	bl	801cd8c <setting_get_description>
                if(description && *description != '\0') {
 80188f0:	4606      	mov	r6, r0
 80188f2:	2800      	cmp	r0, #0
 80188f4:	f000 8082 	beq.w	80189fc <report_settings_detail+0x1f4>
 80188f8:	7803      	ldrb	r3, [r0, #0]
 80188fa:	2b00      	cmp	r3, #0
 80188fc:	d07e      	beq.n	80189fc <report_settings_detail+0x1f4>
                    hal.stream.write(ASCII_EOL);
 80188fe:	4b49      	ldr	r3, [pc, #292]	; (8018a24 <report_settings_detail+0x21c>)
 8018900:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018904:	484f      	ldr	r0, [pc, #316]	; (8018a44 <report_settings_detail+0x23c>)
 8018906:	4798      	blx	r3
                    if((lf = strstr(description, "\\n"))) while(lf) {
 8018908:	494f      	ldr	r1, [pc, #316]	; (8018a48 <report_settings_detail+0x240>)
 801890a:	4630      	mov	r0, r6
 801890c:	f00a f9f0 	bl	8022cf0 <strstr>
 8018910:	4605      	mov	r5, r0
 8018912:	2800      	cmp	r0, #0
 8018914:	d165      	bne.n	80189e2 <report_settings_detail+0x1da>
 8018916:	e066      	b.n	80189e6 <report_settings_detail+0x1de>
                    hal.stream.write(" as boolean");
 8018918:	4b42      	ldr	r3, [pc, #264]	; (8018a24 <report_settings_detail+0x21c>)
 801891a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801891e:	484b      	ldr	r0, [pc, #300]	; (8018a4c <report_settings_detail+0x244>)
 8018920:	4798      	blx	r3
                    break;
 8018922:	e7b8      	b.n	8018896 <report_settings_detail+0x8e>
                    hal.stream.write(" as bitfield:");
 8018924:	4b3f      	ldr	r3, [pc, #252]	; (8018a24 <report_settings_detail+0x21c>)
 8018926:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801892a:	4849      	ldr	r0, [pc, #292]	; (8018a50 <report_settings_detail+0x248>)
 801892c:	4798      	blx	r3
                    report_bitfield(setting->format, true);
 801892e:	2101      	movs	r1, #1
 8018930:	6920      	ldr	r0, [r4, #16]
 8018932:	f7ff fed3 	bl	80186dc <report_bitfield>
                    break;
 8018936:	e7ae      	b.n	8018896 <report_settings_detail+0x8e>
                    hal.stream.write(" as bitfield where setting bit 0 enables the rest:");
 8018938:	4b3a      	ldr	r3, [pc, #232]	; (8018a24 <report_settings_detail+0x21c>)
 801893a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801893e:	4845      	ldr	r0, [pc, #276]	; (8018a54 <report_settings_detail+0x24c>)
 8018940:	4798      	blx	r3
                    report_bitfield(setting->format, true);
 8018942:	2101      	movs	r1, #1
 8018944:	6920      	ldr	r0, [r4, #16]
 8018946:	f7ff fec9 	bl	80186dc <report_bitfield>
                    break;
 801894a:	e7a4      	b.n	8018896 <report_settings_detail+0x8e>
                    hal.stream.write(":");
 801894c:	4b35      	ldr	r3, [pc, #212]	; (8018a24 <report_settings_detail+0x21c>)
 801894e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018952:	4841      	ldr	r0, [pc, #260]	; (8018a58 <report_settings_detail+0x250>)
 8018954:	4798      	blx	r3
                    report_bitfield(setting->format, false);
 8018956:	2100      	movs	r1, #0
 8018958:	6920      	ldr	r0, [r4, #16]
 801895a:	f7ff febf 	bl	80186dc <report_bitfield>
                    break;
 801895e:	e79a      	b.n	8018896 <report_settings_detail+0x8e>
                    hal.stream.write(" as IP address");
 8018960:	4b30      	ldr	r3, [pc, #192]	; (8018a24 <report_settings_detail+0x21c>)
 8018962:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018966:	483d      	ldr	r0, [pc, #244]	; (8018a5c <report_settings_detail+0x254>)
 8018968:	4798      	blx	r3
                    break;
 801896a:	e794      	b.n	8018896 <report_settings_detail+0x8e>
                    if(setting->unit) {
 801896c:	68a3      	ldr	r3, [r4, #8]
 801896e:	2b00      	cmp	r3, #0
 8018970:	d091      	beq.n	8018896 <report_settings_detail+0x8e>
                        hal.stream.write(" in ");
 8018972:	4e2c      	ldr	r6, [pc, #176]	; (8018a24 <report_settings_detail+0x21c>)
 8018974:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
 8018978:	4839      	ldr	r0, [pc, #228]	; (8018a60 <report_settings_detail+0x258>)
 801897a:	4798      	blx	r3
                        hal.stream.write(setting->unit);
 801897c:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
 8018980:	68a0      	ldr	r0, [r4, #8]
 8018982:	4798      	blx	r3
 8018984:	e787      	b.n	8018896 <report_settings_detail+0x8e>
            } else if(!setting_is_list(setting)) {
 8018986:	4620      	mov	r0, r4
 8018988:	f004 fab4 	bl	801cef4 <setting_is_list>
 801898c:	2800      	cmp	r0, #0
 801898e:	d199      	bne.n	80188c4 <report_settings_detail+0xbc>
                if(setting->min_value) {
 8018990:	6963      	ldr	r3, [r4, #20]
 8018992:	b143      	cbz	r3, 80189a6 <report_settings_detail+0x19e>
                    hal.stream.write(", min: ");
 8018994:	4e23      	ldr	r6, [pc, #140]	; (8018a24 <report_settings_detail+0x21c>)
 8018996:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
 801899a:	4832      	ldr	r0, [pc, #200]	; (8018a64 <report_settings_detail+0x25c>)
 801899c:	4798      	blx	r3
                    hal.stream.write(setting->min_value);
 801899e:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
 80189a2:	6960      	ldr	r0, [r4, #20]
 80189a4:	4798      	blx	r3
                if(setting->max_value) {
 80189a6:	69a3      	ldr	r3, [r4, #24]
 80189a8:	2b00      	cmp	r3, #0
 80189aa:	d08b      	beq.n	80188c4 <report_settings_detail+0xbc>
                    hal.stream.write(", max: ");
 80189ac:	4e1d      	ldr	r6, [pc, #116]	; (8018a24 <report_settings_detail+0x21c>)
 80189ae:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
 80189b2:	482d      	ldr	r0, [pc, #180]	; (8018a68 <report_settings_detail+0x260>)
 80189b4:	4798      	blx	r3
                    hal.stream.write(setting->max_value);
 80189b6:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
 80189ba:	69a0      	ldr	r0, [r4, #24]
 80189bc:	4798      	blx	r3
 80189be:	e781      	b.n	80188c4 <report_settings_detail+0xbc>
                        hal.stream.write(ASCII_EOL);
 80189c0:	4f18      	ldr	r7, [pc, #96]	; (8018a24 <report_settings_detail+0x21c>)
 80189c2:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80189c6:	481f      	ldr	r0, [pc, #124]	; (8018a44 <report_settings_detail+0x23c>)
 80189c8:	4798      	blx	r3
                        hal.stream.write_n(description, lf - description);
 80189ca:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 80189ce:	1ba9      	subs	r1, r5, r6
 80189d0:	b289      	uxth	r1, r1
 80189d2:	4630      	mov	r0, r6
 80189d4:	4798      	blx	r3
                        description = lf + 2;
 80189d6:	1cae      	adds	r6, r5, #2
                        lf = strstr(description, "\\n");
 80189d8:	491b      	ldr	r1, [pc, #108]	; (8018a48 <report_settings_detail+0x240>)
 80189da:	4630      	mov	r0, r6
 80189dc:	f00a f988 	bl	8022cf0 <strstr>
 80189e0:	4605      	mov	r5, r0
                    if((lf = strstr(description, "\\n"))) while(lf) {
 80189e2:	2d00      	cmp	r5, #0
 80189e4:	d1ec      	bne.n	80189c0 <report_settings_detail+0x1b8>
                    if(*description != '\0') {
 80189e6:	7833      	ldrb	r3, [r6, #0]
 80189e8:	b143      	cbz	r3, 80189fc <report_settings_detail+0x1f4>
                        hal.stream.write(ASCII_EOL);
 80189ea:	4d0e      	ldr	r5, [pc, #56]	; (8018a24 <report_settings_detail+0x21c>)
 80189ec:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 80189f0:	4814      	ldr	r0, [pc, #80]	; (8018a44 <report_settings_detail+0x23c>)
 80189f2:	4798      	blx	r3
                        hal.stream.write(description);
 80189f4:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 80189f8:	4630      	mov	r0, r6
 80189fa:	4798      	blx	r3
                if(setting->flags.reboot_required) {
 80189fc:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 8018a00:	f013 0f01 	tst.w	r3, #1
 8018a04:	f000 81d5 	beq.w	8018db2 <report_settings_detail+0x5aa>
                    if(description && *description != '\0')
 8018a08:	b136      	cbz	r6, 8018a18 <report_settings_detail+0x210>
 8018a0a:	7833      	ldrb	r3, [r6, #0]
 8018a0c:	b123      	cbz	r3, 8018a18 <report_settings_detail+0x210>
                        hal.stream.write(ASCII_EOL ASCII_EOL);
 8018a0e:	4b05      	ldr	r3, [pc, #20]	; (8018a24 <report_settings_detail+0x21c>)
 8018a10:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018a14:	4815      	ldr	r0, [pc, #84]	; (8018a6c <report_settings_detail+0x264>)
 8018a16:	4798      	blx	r3
                    hal.stream.write(SETTINGS_HARD_RESET_REQUIRED + 4);
 8018a18:	4b02      	ldr	r3, [pc, #8]	; (8018a24 <report_settings_detail+0x21c>)
 8018a1a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018a1e:	4814      	ldr	r0, [pc, #80]	; (8018a70 <report_settings_detail+0x268>)
 8018a20:	4798      	blx	r3
 8018a22:	e1c6      	b.n	8018db2 <report_settings_detail+0x5aa>
 8018a24:	2000350c 	.word	0x2000350c
 8018a28:	080273ec 	.word	0x080273ec
 8018a2c:	080275c0 	.word	0x080275c0
 8018a30:	080271cc 	.word	0x080271cc
 8018a34:	080273f0 	.word	0x080273f0
 8018a38:	08027468 	.word	0x08027468
 8018a3c:	08027364 	.word	0x08027364
 8018a40:	08027484 	.word	0x08027484
 8018a44:	080279c0 	.word	0x080279c0
 8018a48:	08027498 	.word	0x08027498
 8018a4c:	08027400 	.word	0x08027400
 8018a50:	0802740c 	.word	0x0802740c
 8018a54:	0802741c 	.word	0x0802741c
 8018a58:	08027694 	.word	0x08027694
 8018a5c:	08027450 	.word	0x08027450
 8018a60:	08027460 	.word	0x08027460
 8018a64:	08027474 	.word	0x08027474
 8018a68:	0802747c 	.word	0x0802747c
 8018a6c:	0802749c 	.word	0x0802749c
 8018a70:	0802739c 	.word	0x0802739c
            hal.stream.write("[SETTING:");
 8018a74:	4f8f      	ldr	r7, [pc, #572]	; (8018cb4 <report_settings_detail+0x4ac>)
 8018a76:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8018a7a:	488f      	ldr	r0, [pc, #572]	; (8018cb8 <report_settings_detail+0x4b0>)
 8018a7c:	4798      	blx	r3
            hal.stream.write(uitoa(setting->id + offset));
 8018a7e:	f8d7 80b4 	ldr.w	r8, [r7, #180]	; 0xb4
 8018a82:	8820      	ldrh	r0, [r4, #0]
 8018a84:	4428      	add	r0, r5
 8018a86:	f7fc fe77 	bl	8015778 <uitoa>
 8018a8a:	47c0      	blx	r8
            hal.stream.write(vbar);
 8018a8c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8018a90:	488a      	ldr	r0, [pc, #552]	; (8018cbc <report_settings_detail+0x4b4>)
 8018a92:	4798      	blx	r3
            hal.stream.write(uitoa(setting->group + (setting->flags.subgroups ? suboffset : 0)));
 8018a94:	f8d7 70b4 	ldr.w	r7, [r7, #180]	; 0xb4
 8018a98:	78a0      	ldrb	r0, [r4, #2]
 8018a9a:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 8018a9e:	f013 0f04 	tst.w	r3, #4
 8018aa2:	d06e      	beq.n	8018b82 <report_settings_detail+0x37a>
 8018aa4:	4633      	mov	r3, r6
 8018aa6:	4418      	add	r0, r3
 8018aa8:	f7fc fe66 	bl	8015778 <uitoa>
 8018aac:	47b8      	blx	r7
            hal.stream.write(vbar);
 8018aae:	4b81      	ldr	r3, [pc, #516]	; (8018cb4 <report_settings_detail+0x4ac>)
 8018ab0:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018ab4:	4881      	ldr	r0, [pc, #516]	; (8018cbc <report_settings_detail+0x4b4>)
 8018ab6:	4798      	blx	r3
            if(setting->group == Group_Axis0)
 8018ab8:	78a3      	ldrb	r3, [r4, #2]
 8018aba:	2b2b      	cmp	r3, #43	; 0x2b
 8018abc:	d063      	beq.n	8018b86 <report_settings_detail+0x37e>
            write_name(setting->name, suboffset);
 8018abe:	4631      	mov	r1, r6
 8018ac0:	6860      	ldr	r0, [r4, #4]
 8018ac2:	f7ff fe7b 	bl	80187bc <write_name>
            hal.stream.write(vbar);
 8018ac6:	4b7b      	ldr	r3, [pc, #492]	; (8018cb4 <report_settings_detail+0x4ac>)
 8018ac8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018acc:	487b      	ldr	r0, [pc, #492]	; (8018cbc <report_settings_detail+0x4b4>)
 8018ace:	4798      	blx	r3
            if(setting->unit)
 8018ad0:	68a0      	ldr	r0, [r4, #8]
 8018ad2:	b118      	cbz	r0, 8018adc <report_settings_detail+0x2d4>
                hal.stream.write(setting->unit);
 8018ad4:	4b77      	ldr	r3, [pc, #476]	; (8018cb4 <report_settings_detail+0x4ac>)
 8018ad6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018ada:	4798      	blx	r3
            hal.stream.write(vbar);
 8018adc:	4d75      	ldr	r5, [pc, #468]	; (8018cb4 <report_settings_detail+0x4ac>)
 8018ade:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8018ae2:	4e76      	ldr	r6, [pc, #472]	; (8018cbc <report_settings_detail+0x4b4>)
 8018ae4:	4630      	mov	r0, r6
 8018ae6:	4798      	blx	r3
            hal.stream.write(uitoa(setting_datatype_to_external(setting->datatype)));
 8018ae8:	f8d5 70b4 	ldr.w	r7, [r5, #180]	; 0xb4
 8018aec:	7b20      	ldrb	r0, [r4, #12]
 8018aee:	f004 f9fa 	bl	801cee6 <setting_datatype_to_external>
 8018af2:	f7fc fe41 	bl	8015778 <uitoa>
 8018af6:	47b8      	blx	r7
            hal.stream.write(vbar);
 8018af8:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8018afc:	4630      	mov	r0, r6
 8018afe:	4798      	blx	r3
            if(setting->format)
 8018b00:	6920      	ldr	r0, [r4, #16]
 8018b02:	b110      	cbz	r0, 8018b0a <report_settings_detail+0x302>
                hal.stream.write(setting->format);
 8018b04:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8018b08:	4798      	blx	r3
            hal.stream.write(vbar);
 8018b0a:	4b6a      	ldr	r3, [pc, #424]	; (8018cb4 <report_settings_detail+0x4ac>)
 8018b0c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018b10:	486a      	ldr	r0, [pc, #424]	; (8018cbc <report_settings_detail+0x4b4>)
 8018b12:	4798      	blx	r3
            if(setting->min_value && !setting_is_list(setting))
 8018b14:	6963      	ldr	r3, [r4, #20]
 8018b16:	b143      	cbz	r3, 8018b2a <report_settings_detail+0x322>
 8018b18:	4620      	mov	r0, r4
 8018b1a:	f004 f9eb 	bl	801cef4 <setting_is_list>
 8018b1e:	b920      	cbnz	r0, 8018b2a <report_settings_detail+0x322>
                hal.stream.write(setting->min_value);
 8018b20:	4b64      	ldr	r3, [pc, #400]	; (8018cb4 <report_settings_detail+0x4ac>)
 8018b22:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018b26:	6960      	ldr	r0, [r4, #20]
 8018b28:	4798      	blx	r3
            hal.stream.write(vbar);
 8018b2a:	4b62      	ldr	r3, [pc, #392]	; (8018cb4 <report_settings_detail+0x4ac>)
 8018b2c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018b30:	4862      	ldr	r0, [pc, #392]	; (8018cbc <report_settings_detail+0x4b4>)
 8018b32:	4798      	blx	r3
            if(setting->max_value)
 8018b34:	69a0      	ldr	r0, [r4, #24]
 8018b36:	b118      	cbz	r0, 8018b40 <report_settings_detail+0x338>
                hal.stream.write(setting->max_value);
 8018b38:	4b5e      	ldr	r3, [pc, #376]	; (8018cb4 <report_settings_detail+0x4ac>)
 8018b3a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018b3e:	4798      	blx	r3
            hal.stream.write(vbar);
 8018b40:	4d5c      	ldr	r5, [pc, #368]	; (8018cb4 <report_settings_detail+0x4ac>)
 8018b42:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8018b46:	4e5d      	ldr	r6, [pc, #372]	; (8018cbc <report_settings_detail+0x4b4>)
 8018b48:	4630      	mov	r0, r6
 8018b4a:	4798      	blx	r3
            hal.stream.write(uitoa(setting->flags.reboot_required));
 8018b4c:	f8d5 70b4 	ldr.w	r7, [r5, #180]	; 0xb4
 8018b50:	f894 002c 	ldrb.w	r0, [r4, #44]	; 0x2c
 8018b54:	f000 0001 	and.w	r0, r0, #1
 8018b58:	f7fc fe0e 	bl	8015778 <uitoa>
 8018b5c:	47b8      	blx	r7
            hal.stream.write(vbar);
 8018b5e:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8018b62:	4630      	mov	r0, r6
 8018b64:	4798      	blx	r3
            hal.stream.write(uitoa(setting->flags.allow_null));
 8018b66:	f8d5 60b4 	ldr.w	r6, [r5, #180]	; 0xb4
 8018b6a:	f894 002c 	ldrb.w	r0, [r4, #44]	; 0x2c
 8018b6e:	f3c0 0040 	ubfx	r0, r0, #1, #1
 8018b72:	f7fc fe01 	bl	8015778 <uitoa>
 8018b76:	47b0      	blx	r6
            hal.stream.write("]");
 8018b78:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8018b7c:	4850      	ldr	r0, [pc, #320]	; (8018cc0 <report_settings_detail+0x4b8>)
 8018b7e:	4798      	blx	r3
            break;
 8018b80:	e117      	b.n	8018db2 <report_settings_detail+0x5aa>
            hal.stream.write(uitoa(setting->group + (setting->flags.subgroups ? suboffset : 0)));
 8018b82:	2300      	movs	r3, #0
 8018b84:	e78f      	b.n	8018aa6 <report_settings_detail+0x29e>
                hal.stream.write(axis_letter[offset]);
 8018b86:	4b4b      	ldr	r3, [pc, #300]	; (8018cb4 <report_settings_detail+0x4ac>)
 8018b88:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018b8c:	4a4d      	ldr	r2, [pc, #308]	; (8018cc4 <report_settings_detail+0x4bc>)
 8018b8e:	f852 0025 	ldr.w	r0, [r2, r5, lsl #2]
 8018b92:	4798      	blx	r3
 8018b94:	e793      	b.n	8018abe <report_settings_detail+0x2b6>
                write_quoted(uitoa(setting->id + offset), ",");
 8018b96:	8820      	ldrh	r0, [r4, #0]
 8018b98:	4428      	add	r0, r5
 8018b9a:	f7fc fded 	bl	8015778 <uitoa>
 8018b9e:	494a      	ldr	r1, [pc, #296]	; (8018cc8 <report_settings_detail+0x4c0>)
 8018ba0:	f7ff fae6 	bl	8018170 <write_quoted>
                hal.stream.write("\"");
 8018ba4:	4b43      	ldr	r3, [pc, #268]	; (8018cb4 <report_settings_detail+0x4ac>)
 8018ba6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018baa:	4848      	ldr	r0, [pc, #288]	; (8018ccc <report_settings_detail+0x4c4>)
 8018bac:	4798      	blx	r3
                if(setting->group == Group_Axis0)
 8018bae:	78a3      	ldrb	r3, [r4, #2]
 8018bb0:	2b2b      	cmp	r3, #43	; 0x2b
 8018bb2:	d018      	beq.n	8018be6 <report_settings_detail+0x3de>
                write_name(setting->name, suboffset);
 8018bb4:	4631      	mov	r1, r6
 8018bb6:	6860      	ldr	r0, [r4, #4]
 8018bb8:	f7ff fe00 	bl	80187bc <write_name>
                hal.stream.write("\",");
 8018bbc:	4b3d      	ldr	r3, [pc, #244]	; (8018cb4 <report_settings_detail+0x4ac>)
 8018bbe:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018bc2:	4843      	ldr	r0, [pc, #268]	; (8018cd0 <report_settings_detail+0x4c8>)
 8018bc4:	4798      	blx	r3
                if(setting->unit) {
 8018bc6:	68a0      	ldr	r0, [r4, #8]
 8018bc8:	b1a8      	cbz	r0, 8018bf6 <report_settings_detail+0x3ee>
                    write_quoted(setting->unit, ",");
 8018bca:	493f      	ldr	r1, [pc, #252]	; (8018cc8 <report_settings_detail+0x4c0>)
 8018bcc:	f7ff fad0 	bl	8018170 <write_quoted>
                const char *description = setting_get_description((setting_id_t)(setting->id + offset));
 8018bd0:	8820      	ldrh	r0, [r4, #0]
 8018bd2:	fa10 f085 	uxtah	r0, r0, r5
 8018bd6:	b280      	uxth	r0, r0
 8018bd8:	f004 f8d8 	bl	801cd8c <setting_get_description>
                write_quoted(description ? description : "", ",");
 8018bdc:	b180      	cbz	r0, 8018c00 <report_settings_detail+0x3f8>
 8018bde:	493a      	ldr	r1, [pc, #232]	; (8018cc8 <report_settings_detail+0x4c0>)
 8018be0:	f7ff fac6 	bl	8018170 <write_quoted>
            break;
 8018be4:	e0e5      	b.n	8018db2 <report_settings_detail+0x5aa>
                    hal.stream.write(axis_letter[offset]);
 8018be6:	4b33      	ldr	r3, [pc, #204]	; (8018cb4 <report_settings_detail+0x4ac>)
 8018be8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018bec:	4a35      	ldr	r2, [pc, #212]	; (8018cc4 <report_settings_detail+0x4bc>)
 8018bee:	f852 0025 	ldr.w	r0, [r2, r5, lsl #2]
 8018bf2:	4798      	blx	r3
 8018bf4:	e7de      	b.n	8018bb4 <report_settings_detail+0x3ac>
                    write_quoted("", ",");
 8018bf6:	4934      	ldr	r1, [pc, #208]	; (8018cc8 <report_settings_detail+0x4c0>)
 8018bf8:	4836      	ldr	r0, [pc, #216]	; (8018cd4 <report_settings_detail+0x4cc>)
 8018bfa:	f7ff fab9 	bl	8018170 <write_quoted>
 8018bfe:	e7e7      	b.n	8018bd0 <report_settings_detail+0x3c8>
                write_quoted(description ? description : "", ",");
 8018c00:	4834      	ldr	r0, [pc, #208]	; (8018cd4 <report_settings_detail+0x4cc>)
 8018c02:	e7ec      	b.n	8018bde <report_settings_detail+0x3d6>
                hal.stream.write(uitoa(setting->id + offset));
 8018c04:	4f2b      	ldr	r7, [pc, #172]	; (8018cb4 <report_settings_detail+0x4ac>)
 8018c06:	f8d7 80b4 	ldr.w	r8, [r7, #180]	; 0xb4
 8018c0a:	8820      	ldrh	r0, [r4, #0]
 8018c0c:	4428      	add	r0, r5
 8018c0e:	f7fc fdb3 	bl	8015778 <uitoa>
 8018c12:	47c0      	blx	r8
                hal.stream.write("\t");
 8018c14:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8018c18:	482f      	ldr	r0, [pc, #188]	; (8018cd8 <report_settings_detail+0x4d0>)
 8018c1a:	4798      	blx	r3
                if(setting->group == Group_Axis0)
 8018c1c:	78a3      	ldrb	r3, [r4, #2]
 8018c1e:	2b2b      	cmp	r3, #43	; 0x2b
 8018c20:	d024      	beq.n	8018c6c <report_settings_detail+0x464>
                write_name(setting->name, suboffset);
 8018c22:	4631      	mov	r1, r6
 8018c24:	6860      	ldr	r0, [r4, #4]
 8018c26:	f7ff fdc9 	bl	80187bc <write_name>
                hal.stream.write("\t");
 8018c2a:	4b22      	ldr	r3, [pc, #136]	; (8018cb4 <report_settings_detail+0x4ac>)
 8018c2c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018c30:	4829      	ldr	r0, [pc, #164]	; (8018cd8 <report_settings_detail+0x4d0>)
 8018c32:	4798      	blx	r3
                if(setting->unit)
 8018c34:	68a0      	ldr	r0, [r4, #8]
 8018c36:	b300      	cbz	r0, 8018c7a <report_settings_detail+0x472>
                    hal.stream.write(setting->unit);
 8018c38:	4b1e      	ldr	r3, [pc, #120]	; (8018cb4 <report_settings_detail+0x4ac>)
 8018c3a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018c3e:	4798      	blx	r3
                hal.stream.write("\t");
 8018c40:	4b1c      	ldr	r3, [pc, #112]	; (8018cb4 <report_settings_detail+0x4ac>)
 8018c42:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018c46:	4824      	ldr	r0, [pc, #144]	; (8018cd8 <report_settings_detail+0x4d0>)
 8018c48:	4798      	blx	r3
                switch(setting_datatype_to_external(setting->datatype)) {
 8018c4a:	7b20      	ldrb	r0, [r4, #12]
 8018c4c:	f004 f94b 	bl	801cee6 <setting_datatype_to_external>
 8018c50:	2809      	cmp	r0, #9
 8018c52:	d84e      	bhi.n	8018cf2 <report_settings_detail+0x4ea>
 8018c54:	e8df f010 	tbh	[pc, r0, lsl #1]
 8018c58:	00c000ba 	.word	0x00c000ba
 8018c5c:	00cc00c6 	.word	0x00cc00c6
 8018c60:	004800c0 	.word	0x004800c0
 8018c64:	00d800b4 	.word	0x00d800b4
 8018c68:	00d200de 	.word	0x00d200de
                    hal.stream.write(axis_letter[offset]);
 8018c6c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8018c70:	4a14      	ldr	r2, [pc, #80]	; (8018cc4 <report_settings_detail+0x4bc>)
 8018c72:	f852 0025 	ldr.w	r0, [r2, r5, lsl #2]
 8018c76:	4798      	blx	r3
 8018c78:	e7d3      	b.n	8018c22 <report_settings_detail+0x41a>
                else if(setting->datatype == Format_AxisMask || setting->datatype == Format_Bitfield || setting->datatype == Format_XBitfield)
 8018c7a:	7b23      	ldrb	r3, [r4, #12]
 8018c7c:	2b04      	cmp	r3, #4
 8018c7e:	d00a      	beq.n	8018c96 <report_settings_detail+0x48e>
 8018c80:	2b01      	cmp	r3, #1
 8018c82:	d008      	beq.n	8018c96 <report_settings_detail+0x48e>
 8018c84:	2b02      	cmp	r3, #2
 8018c86:	d006      	beq.n	8018c96 <report_settings_detail+0x48e>
                else if(setting->datatype == Format_Bool)
 8018c88:	b95b      	cbnz	r3, 8018ca2 <report_settings_detail+0x49a>
                    hal.stream.write("boolean");
 8018c8a:	4b0a      	ldr	r3, [pc, #40]	; (8018cb4 <report_settings_detail+0x4ac>)
 8018c8c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018c90:	4812      	ldr	r0, [pc, #72]	; (8018cdc <report_settings_detail+0x4d4>)
 8018c92:	4798      	blx	r3
 8018c94:	e7d4      	b.n	8018c40 <report_settings_detail+0x438>
                    hal.stream.write("mask");
 8018c96:	4b07      	ldr	r3, [pc, #28]	; (8018cb4 <report_settings_detail+0x4ac>)
 8018c98:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018c9c:	4810      	ldr	r0, [pc, #64]	; (8018ce0 <report_settings_detail+0x4d8>)
 8018c9e:	4798      	blx	r3
 8018ca0:	e7ce      	b.n	8018c40 <report_settings_detail+0x438>
                else if(setting->datatype == Format_RadioButtons)
 8018ca2:	2b03      	cmp	r3, #3
 8018ca4:	d1cc      	bne.n	8018c40 <report_settings_detail+0x438>
                    hal.stream.write("integer");
 8018ca6:	4b03      	ldr	r3, [pc, #12]	; (8018cb4 <report_settings_detail+0x4ac>)
 8018ca8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018cac:	480d      	ldr	r0, [pc, #52]	; (8018ce4 <report_settings_detail+0x4dc>)
 8018cae:	4798      	blx	r3
 8018cb0:	e7c6      	b.n	8018c40 <report_settings_detail+0x438>
 8018cb2:	bf00      	nop
 8018cb4:	2000350c 	.word	0x2000350c
 8018cb8:	080274a4 	.word	0x080274a4
 8018cbc:	080283e8 	.word	0x080283e8
 8018cc0:	080274b0 	.word	0x080274b0
 8018cc4:	080271cc 	.word	0x080271cc
 8018cc8:	08027758 	.word	0x08027758
 8018ccc:	08027330 	.word	0x08027330
 8018cd0:	080274b4 	.word	0x080274b4
 8018cd4:	080274a0 	.word	0x080274a0
 8018cd8:	080274b8 	.word	0x080274b8
 8018cdc:	08027404 	.word	0x08027404
 8018ce0:	080273f8 	.word	0x080273f8
 8018ce4:	080274bc 	.word	0x080274bc
                        hal.stream.write("integer");
 8018ce8:	4b55      	ldr	r3, [pc, #340]	; (8018e40 <report_settings_detail+0x638>)
 8018cea:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018cee:	4855      	ldr	r0, [pc, #340]	; (8018e44 <report_settings_detail+0x63c>)
 8018cf0:	4798      	blx	r3
                hal.stream.write("\t");
 8018cf2:	4b53      	ldr	r3, [pc, #332]	; (8018e40 <report_settings_detail+0x638>)
 8018cf4:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018cf8:	4853      	ldr	r0, [pc, #332]	; (8018e48 <report_settings_detail+0x640>)
 8018cfa:	4798      	blx	r3
                if(setting->format)
 8018cfc:	6920      	ldr	r0, [r4, #16]
 8018cfe:	2800      	cmp	r0, #0
 8018d00:	f000 808e 	beq.w	8018e20 <report_settings_detail+0x618>
                    hal.stream.write(setting->format);
 8018d04:	4b4e      	ldr	r3, [pc, #312]	; (8018e40 <report_settings_detail+0x638>)
 8018d06:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018d0a:	4798      	blx	r3
                hal.stream.write("\t");
 8018d0c:	4e4c      	ldr	r6, [pc, #304]	; (8018e40 <report_settings_detail+0x638>)
 8018d0e:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
 8018d12:	484d      	ldr	r0, [pc, #308]	; (8018e48 <report_settings_detail+0x640>)
 8018d14:	4798      	blx	r3
                const char *description = setting_get_description((setting_id_t)(setting->id + offset));
 8018d16:	8823      	ldrh	r3, [r4, #0]
 8018d18:	fa13 f085 	uxtah	r0, r3, r5
 8018d1c:	b280      	uxth	r0, r0
 8018d1e:	f004 f835 	bl	801cd8c <setting_get_description>
                hal.stream.write(description ? description : "");
 8018d22:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
 8018d26:	4605      	mov	r5, r0
 8018d28:	2800      	cmp	r0, #0
 8018d2a:	f000 8083 	beq.w	8018e34 <report_settings_detail+0x62c>
 8018d2e:	4798      	blx	r3
                if(setting->flags.reboot_required)
 8018d30:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 8018d34:	f013 0f01 	tst.w	r3, #1
 8018d38:	d009      	beq.n	8018d4e <report_settings_detail+0x546>
                    hal.stream.write(SETTINGS_HARD_RESET_REQUIRED + (description && *description != '\0' ? 0 : 4));
 8018d3a:	4b41      	ldr	r3, [pc, #260]	; (8018e40 <report_settings_detail+0x638>)
 8018d3c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018d40:	2d00      	cmp	r5, #0
 8018d42:	d079      	beq.n	8018e38 <report_settings_detail+0x630>
 8018d44:	782a      	ldrb	r2, [r5, #0]
 8018d46:	2a00      	cmp	r2, #0
 8018d48:	d178      	bne.n	8018e3c <report_settings_detail+0x634>
 8018d4a:	4840      	ldr	r0, [pc, #256]	; (8018e4c <report_settings_detail+0x644>)
 8018d4c:	4798      	blx	r3
                hal.stream.write("\t");
 8018d4e:	4b3c      	ldr	r3, [pc, #240]	; (8018e40 <report_settings_detail+0x638>)
 8018d50:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018d54:	483c      	ldr	r0, [pc, #240]	; (8018e48 <report_settings_detail+0x640>)
 8018d56:	4798      	blx	r3
                if(setting->min_value)
 8018d58:	6960      	ldr	r0, [r4, #20]
 8018d5a:	b118      	cbz	r0, 8018d64 <report_settings_detail+0x55c>
                    hal.stream.write(setting->min_value);
 8018d5c:	4b38      	ldr	r3, [pc, #224]	; (8018e40 <report_settings_detail+0x638>)
 8018d5e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018d62:	4798      	blx	r3
                hal.stream.write("\t");
 8018d64:	4b36      	ldr	r3, [pc, #216]	; (8018e40 <report_settings_detail+0x638>)
 8018d66:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018d6a:	4837      	ldr	r0, [pc, #220]	; (8018e48 <report_settings_detail+0x640>)
 8018d6c:	4798      	blx	r3
                if(setting->max_value)
 8018d6e:	69a0      	ldr	r0, [r4, #24]
 8018d70:	b118      	cbz	r0, 8018d7a <report_settings_detail+0x572>
                    hal.stream.write(setting->max_value);
 8018d72:	4b33      	ldr	r3, [pc, #204]	; (8018e40 <report_settings_detail+0x638>)
 8018d74:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018d78:	4798      	blx	r3
                hal.stream.write("\t");
 8018d7a:	4d31      	ldr	r5, [pc, #196]	; (8018e40 <report_settings_detail+0x638>)
 8018d7c:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8018d80:	4e31      	ldr	r6, [pc, #196]	; (8018e48 <report_settings_detail+0x640>)
 8018d82:	4630      	mov	r0, r6
 8018d84:	4798      	blx	r3
                hal.stream.write(uitoa(setting->flags.reboot_required));
 8018d86:	f8d5 70b4 	ldr.w	r7, [r5, #180]	; 0xb4
 8018d8a:	f894 002c 	ldrb.w	r0, [r4, #44]	; 0x2c
 8018d8e:	f000 0001 	and.w	r0, r0, #1
 8018d92:	f7fc fcf1 	bl	8015778 <uitoa>
 8018d96:	47b8      	blx	r7
                hal.stream.write("\t");
 8018d98:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8018d9c:	4630      	mov	r0, r6
 8018d9e:	4798      	blx	r3
                hal.stream.write(uitoa(setting->flags.allow_null));
 8018da0:	f8d5 50b4 	ldr.w	r5, [r5, #180]	; 0xb4
 8018da4:	f894 002c 	ldrb.w	r0, [r4, #44]	; 0x2c
 8018da8:	f3c0 0040 	ubfx	r0, r0, #1, #1
 8018dac:	f7fc fce4 	bl	8015778 <uitoa>
 8018db0:	47a8      	blx	r5
    hal.stream.write(ASCII_EOL);
 8018db2:	4b23      	ldr	r3, [pc, #140]	; (8018e40 <report_settings_detail+0x638>)
 8018db4:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018db8:	4825      	ldr	r0, [pc, #148]	; (8018e50 <report_settings_detail+0x648>)
 8018dba:	4798      	blx	r3
}
 8018dbc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                        hal.stream.write("float");
 8018dc0:	4b1f      	ldr	r3, [pc, #124]	; (8018e40 <report_settings_detail+0x638>)
 8018dc2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018dc6:	4823      	ldr	r0, [pc, #140]	; (8018e54 <report_settings_detail+0x64c>)
 8018dc8:	4798      	blx	r3
                        break;
 8018dca:	e792      	b.n	8018cf2 <report_settings_detail+0x4ea>
                        hal.stream.write("bool");
 8018dcc:	4b1c      	ldr	r3, [pc, #112]	; (8018e40 <report_settings_detail+0x638>)
 8018dce:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018dd2:	4821      	ldr	r0, [pc, #132]	; (8018e58 <report_settings_detail+0x650>)
 8018dd4:	4798      	blx	r3
                        break;
 8018dd6:	e78c      	b.n	8018cf2 <report_settings_detail+0x4ea>
                        hal.stream.write("bitfield");
 8018dd8:	4b19      	ldr	r3, [pc, #100]	; (8018e40 <report_settings_detail+0x638>)
 8018dda:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018dde:	481f      	ldr	r0, [pc, #124]	; (8018e5c <report_settings_detail+0x654>)
 8018de0:	4798      	blx	r3
                        break;
 8018de2:	e786      	b.n	8018cf2 <report_settings_detail+0x4ea>
                        hal.stream.write("xbitfield");
 8018de4:	4b16      	ldr	r3, [pc, #88]	; (8018e40 <report_settings_detail+0x638>)
 8018de6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018dea:	481d      	ldr	r0, [pc, #116]	; (8018e60 <report_settings_detail+0x658>)
 8018dec:	4798      	blx	r3
                        break;
 8018dee:	e780      	b.n	8018cf2 <report_settings_detail+0x4ea>
                        hal.stream.write("radiobuttons");
 8018df0:	4b13      	ldr	r3, [pc, #76]	; (8018e40 <report_settings_detail+0x638>)
 8018df2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018df6:	481b      	ldr	r0, [pc, #108]	; (8018e64 <report_settings_detail+0x65c>)
 8018df8:	4798      	blx	r3
                        break;
 8018dfa:	e77a      	b.n	8018cf2 <report_settings_detail+0x4ea>
                        hal.stream.write("ipv4");
 8018dfc:	4b10      	ldr	r3, [pc, #64]	; (8018e40 <report_settings_detail+0x638>)
 8018dfe:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018e02:	4819      	ldr	r0, [pc, #100]	; (8018e68 <report_settings_detail+0x660>)
 8018e04:	4798      	blx	r3
                        break;
 8018e06:	e774      	b.n	8018cf2 <report_settings_detail+0x4ea>
                        hal.stream.write("string");
 8018e08:	4b0d      	ldr	r3, [pc, #52]	; (8018e40 <report_settings_detail+0x638>)
 8018e0a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018e0e:	4817      	ldr	r0, [pc, #92]	; (8018e6c <report_settings_detail+0x664>)
 8018e10:	4798      	blx	r3
                        break;
 8018e12:	e76e      	b.n	8018cf2 <report_settings_detail+0x4ea>
                        hal.stream.write("password");
 8018e14:	4b0a      	ldr	r3, [pc, #40]	; (8018e40 <report_settings_detail+0x638>)
 8018e16:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018e1a:	4815      	ldr	r0, [pc, #84]	; (8018e70 <report_settings_detail+0x668>)
 8018e1c:	4798      	blx	r3
                        break;
 8018e1e:	e768      	b.n	8018cf2 <report_settings_detail+0x4ea>
                else if (setting->datatype == Format_AxisMask)
 8018e20:	7b23      	ldrb	r3, [r4, #12]
 8018e22:	2b04      	cmp	r3, #4
 8018e24:	f47f af72 	bne.w	8018d0c <report_settings_detail+0x504>
                    hal.stream.write("axes");
 8018e28:	4b05      	ldr	r3, [pc, #20]	; (8018e40 <report_settings_detail+0x638>)
 8018e2a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018e2e:	4811      	ldr	r0, [pc, #68]	; (8018e74 <report_settings_detail+0x66c>)
 8018e30:	4798      	blx	r3
 8018e32:	e76b      	b.n	8018d0c <report_settings_detail+0x504>
                hal.stream.write(description ? description : "");
 8018e34:	4810      	ldr	r0, [pc, #64]	; (8018e78 <report_settings_detail+0x670>)
 8018e36:	e77a      	b.n	8018d2e <report_settings_detail+0x526>
                    hal.stream.write(SETTINGS_HARD_RESET_REQUIRED + (description && *description != '\0' ? 0 : 4));
 8018e38:	4804      	ldr	r0, [pc, #16]	; (8018e4c <report_settings_detail+0x644>)
 8018e3a:	e787      	b.n	8018d4c <report_settings_detail+0x544>
 8018e3c:	480f      	ldr	r0, [pc, #60]	; (8018e7c <report_settings_detail+0x674>)
 8018e3e:	e785      	b.n	8018d4c <report_settings_detail+0x544>
 8018e40:	2000350c 	.word	0x2000350c
 8018e44:	080274bc 	.word	0x080274bc
 8018e48:	080274b8 	.word	0x080274b8
 8018e4c:	0802739c 	.word	0x0802739c
 8018e50:	080279c0 	.word	0x080279c0
 8018e54:	080274c4 	.word	0x080274c4
 8018e58:	080274cc 	.word	0x080274cc
 8018e5c:	080274d4 	.word	0x080274d4
 8018e60:	080274e0 	.word	0x080274e0
 8018e64:	080274ec 	.word	0x080274ec
 8018e68:	080274fc 	.word	0x080274fc
 8018e6c:	08027504 	.word	0x08027504
 8018e70:	0802750c 	.word	0x0802750c
 8018e74:	08027518 	.word	0x08027518
 8018e78:	080274a0 	.word	0x080274a0
 8018e7c:	08027398 	.word	0x08027398

08018e80 <print_unsorted>:
{
 8018e80:	b570      	push	{r4, r5, r6, lr}
 8018e82:	4604      	mov	r4, r0
 8018e84:	460e      	mov	r6, r1
 8018e86:	4615      	mov	r5, r2
    if(!(((report_args_t *)args)->group == setting->group && ((report_args_t *)args)->offset != offset) &&
 8018e88:	7850      	ldrb	r0, [r2, #1]
 8018e8a:	78a3      	ldrb	r3, [r4, #2]
 8018e8c:	4298      	cmp	r0, r3
 8018e8e:	d00b      	beq.n	8018ea8 <print_unsorted+0x28>
       (setting->is_available == NULL ||setting->is_available(setting)))
 8018e90:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    if(!(((report_args_t *)args)->group == setting->group && ((report_args_t *)args)->offset != offset) &&
 8018e92:	b113      	cbz	r3, 8018e9a <print_unsorted+0x1a>
       (setting->is_available == NULL ||setting->is_available(setting)))
 8018e94:	4620      	mov	r0, r4
 8018e96:	4798      	blx	r3
 8018e98:	b120      	cbz	r0, 8018ea4 <print_unsorted+0x24>
        report_settings_detail(((report_args_t *)args)->format, setting, offset);
 8018e9a:	4632      	mov	r2, r6
 8018e9c:	4621      	mov	r1, r4
 8018e9e:	7828      	ldrb	r0, [r5, #0]
 8018ea0:	f7ff fcb2 	bl	8018808 <report_settings_detail>
}
 8018ea4:	2001      	movs	r0, #1
 8018ea6:	bd70      	pop	{r4, r5, r6, pc}
    if(!(((report_args_t *)args)->group == setting->group && ((report_args_t *)args)->offset != offset) &&
 8018ea8:	6853      	ldr	r3, [r2, #4]
 8018eaa:	428b      	cmp	r3, r1
 8018eac:	d1fa      	bne.n	8018ea4 <print_unsorted+0x24>
 8018eae:	e7ef      	b.n	8018e90 <print_unsorted+0x10>

08018eb0 <print_sorted>:
{
 8018eb0:	b508      	push	{r3, lr}
 8018eb2:	4613      	mov	r3, r2
    if(!(((report_args_t *)args)->group == setting->group && ((report_args_t *)args)->offset != offset))
 8018eb4:	f892 c001 	ldrb.w	ip, [r2, #1]
 8018eb8:	7882      	ldrb	r2, [r0, #2]
 8018eba:	4594      	cmp	ip, r2
 8018ebc:	d102      	bne.n	8018ec4 <print_sorted+0x14>
 8018ebe:	685a      	ldr	r2, [r3, #4]
 8018ec0:	428a      	cmp	r2, r1
 8018ec2:	d104      	bne.n	8018ece <print_sorted+0x1e>
        report_settings_detail (((report_args_t *)args)->format, setting, offset);
 8018ec4:	460a      	mov	r2, r1
 8018ec6:	4601      	mov	r1, r0
 8018ec8:	7818      	ldrb	r0, [r3, #0]
 8018eca:	f7ff fc9d 	bl	8018808 <report_settings_detail>
}
 8018ece:	2001      	movs	r0, #1
 8018ed0:	bd08      	pop	{r3, pc}
	...

08018ed4 <print_settings_details>:
{
 8018ed4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8018ed8:	b083      	sub	sp, #12
 8018eda:	4606      	mov	r6, r0
    bool reported = group == Group_All;
 8018edc:	4688      	mov	r8, r1
 8018ede:	fab1 fb81 	clz	fp, r1
 8018ee2:	ea4f 1b5b 	mov.w	fp, fp, lsr #5
    setting_details_t *details = settings_get_details();
 8018ee6:	f003 f9f3 	bl	801c2d0 <settings_get_details>
 8018eea:	4604      	mov	r4, r0
    args.group = settings_normalize_group(group);
 8018eec:	4640      	mov	r0, r8
 8018eee:	f003 fe91 	bl	801cc14 <settings_normalize_group>
 8018ef2:	f88d 0001 	strb.w	r0, [sp, #1]
    args.offset = group - args.group;
 8018ef6:	eba8 0000 	sub.w	r0, r8, r0
 8018efa:	9001      	str	r0, [sp, #4]
    args.format = format;
 8018efc:	f88d 6000 	strb.w	r6, [sp]
    uint_fast16_t idx, n_settings = 0;
 8018f00:	2500      	movs	r5, #0
        n_settings += details->n_settings;
 8018f02:	8923      	ldrh	r3, [r4, #8]
 8018f04:	441d      	add	r5, r3
    } while((details = details->next));
 8018f06:	69a4      	ldr	r4, [r4, #24]
 8018f08:	2c00      	cmp	r4, #0
 8018f0a:	d1fa      	bne.n	8018f02 <print_settings_details+0x2e>
    if(format == SettingsFormat_Grbl)
 8018f0c:	2e02      	cmp	r6, #2
 8018f0e:	d00f      	beq.n	8018f30 <print_settings_details+0x5c>
    else if(format == SettingsFormat_grblHAL)
 8018f10:	2e03      	cmp	r6, #3
 8018f12:	d013      	beq.n	8018f3c <print_settings_details+0x68>
    details = settings_get_details();
 8018f14:	f003 f9dc 	bl	801c2d0 <settings_get_details>
 8018f18:	4607      	mov	r7, r0
    if((all_settings = psetting = calloc(n_settings, sizeof(setting_detail_t *)))) {
 8018f1a:	2104      	movs	r1, #4
 8018f1c:	4628      	mov	r0, r5
 8018f1e:	f009 faa9 	bl	8022474 <calloc>
 8018f22:	4682      	mov	sl, r0
 8018f24:	2800      	cmp	r0, #0
 8018f26:	d068      	beq.n	8018ffa <print_settings_details+0x126>
 8018f28:	4606      	mov	r6, r0
        n_settings = 0;
 8018f2a:	f04f 0900 	mov.w	r9, #0
 8018f2e:	e028      	b.n	8018f82 <print_settings_details+0xae>
        hal.stream.write("\"$-Code\",\" Setting\",\" Units\",\" Setting Description\"" ASCII_EOL);
 8018f30:	4b34      	ldr	r3, [pc, #208]	; (8019004 <print_settings_details+0x130>)
 8018f32:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018f36:	4834      	ldr	r0, [pc, #208]	; (8019008 <print_settings_details+0x134>)
 8018f38:	4798      	blx	r3
 8018f3a:	e7eb      	b.n	8018f14 <print_settings_details+0x40>
        hal.stream.write("$-Code\tSetting\tUnits\tDatatype\tData format\tSetting Description\tMin\tMax" ASCII_EOL);
 8018f3c:	4b31      	ldr	r3, [pc, #196]	; (8019004 <print_settings_details+0x130>)
 8018f3e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018f42:	4832      	ldr	r0, [pc, #200]	; (801900c <print_settings_details+0x138>)
 8018f44:	4798      	blx	r3
 8018f46:	e7e5      	b.n	8018f14 <print_settings_details+0x40>
                if((group == Group_All || setting->group == args.group) && (setting->is_available == NULL || setting->is_available(setting))) {
 8018f48:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8018f4a:	b113      	cbz	r3, 8018f52 <print_settings_details+0x7e>
 8018f4c:	4628      	mov	r0, r5
 8018f4e:	4798      	blx	r3
 8018f50:	b118      	cbz	r0, 8018f5a <print_settings_details+0x86>
                    *psetting++ = (setting_detail_t *)setting;
 8018f52:	f846 5b04 	str.w	r5, [r6], #4
                    n_settings++;
 8018f56:	f109 0901 	add.w	r9, r9, #1
            for(idx = 0; idx < details->n_settings; idx++) {
 8018f5a:	3401      	adds	r4, #1
 8018f5c:	893b      	ldrh	r3, [r7, #8]
 8018f5e:	42a3      	cmp	r3, r4
 8018f60:	d90d      	bls.n	8018f7e <print_settings_details+0xaa>
                setting = &details->settings[idx];
 8018f62:	68fd      	ldr	r5, [r7, #12]
 8018f64:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 8018f68:	eb05 1503 	add.w	r5, r5, r3, lsl #4
                if((group == Group_All || setting->group == args.group) && (setting->is_available == NULL || setting->is_available(setting))) {
 8018f6c:	f1b8 0f00 	cmp.w	r8, #0
 8018f70:	d0ea      	beq.n	8018f48 <print_settings_details+0x74>
 8018f72:	78aa      	ldrb	r2, [r5, #2]
 8018f74:	f89d 3001 	ldrb.w	r3, [sp, #1]
 8018f78:	429a      	cmp	r2, r3
 8018f7a:	d1ee      	bne.n	8018f5a <print_settings_details+0x86>
 8018f7c:	e7e4      	b.n	8018f48 <print_settings_details+0x74>
        } while((details = details->next));
 8018f7e:	69bf      	ldr	r7, [r7, #24]
 8018f80:	b10f      	cbz	r7, 8018f86 <print_settings_details+0xb2>
            for(idx = 0; idx < details->n_settings; idx++) {
 8018f82:	2400      	movs	r4, #0
 8018f84:	e7ea      	b.n	8018f5c <print_settings_details+0x88>
        qsort(all_settings, n_settings, sizeof(setting_detail_t *), cmp_settings);
 8018f86:	4b22      	ldr	r3, [pc, #136]	; (8019010 <print_settings_details+0x13c>)
 8018f88:	2204      	movs	r2, #4
 8018f8a:	4649      	mov	r1, r9
 8018f8c:	4650      	mov	r0, sl
 8018f8e:	f009 fb8d 	bl	80226ac <qsort>
        for(idx = 0; idx < n_settings; idx++) {
 8018f92:	2400      	movs	r4, #0
 8018f94:	e000      	b.n	8018f98 <print_settings_details+0xc4>
 8018f96:	3401      	adds	r4, #1
 8018f98:	454c      	cmp	r4, r9
 8018f9a:	d209      	bcs.n	8018fb0 <print_settings_details+0xdc>
            if(settings_iterator(all_settings[idx], print_sorted, &args))
 8018f9c:	466a      	mov	r2, sp
 8018f9e:	491d      	ldr	r1, [pc, #116]	; (8019014 <print_settings_details+0x140>)
 8018fa0:	f85a 0024 	ldr.w	r0, [sl, r4, lsl #2]
 8018fa4:	f003 fec0 	bl	801cd28 <settings_iterator>
 8018fa8:	2800      	cmp	r0, #0
 8018faa:	d0f4      	beq.n	8018f96 <print_settings_details+0xc2>
                reported = true;
 8018fac:	4683      	mov	fp, r0
 8018fae:	e7f2      	b.n	8018f96 <print_settings_details+0xc2>
        free(all_settings);
 8018fb0:	4650      	mov	r0, sl
 8018fb2:	f009 fa85 	bl	80224c0 <free>
    return reported ? Status_OK : Status_SettingDisabled;
 8018fb6:	f1bb 0f00 	cmp.w	fp, #0
 8018fba:	d020      	beq.n	8018ffe <print_settings_details+0x12a>
 8018fbc:	2000      	movs	r0, #0
}
 8018fbe:	b003      	add	sp, #12
 8018fc0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if(settings_iterator(setting, print_unsorted, &args))
 8018fc4:	466a      	mov	r2, sp
 8018fc6:	4914      	ldr	r1, [pc, #80]	; (8019018 <print_settings_details+0x144>)
 8018fc8:	f003 feae 	bl	801cd28 <settings_iterator>
 8018fcc:	b100      	cbz	r0, 8018fd0 <print_settings_details+0xfc>
                    reported = true;
 8018fce:	4683      	mov	fp, r0
        for(idx = 0; idx < details->n_settings; idx++) {
 8018fd0:	3401      	adds	r4, #1
 8018fd2:	893b      	ldrh	r3, [r7, #8]
 8018fd4:	42a3      	cmp	r3, r4
 8018fd6:	d90d      	bls.n	8018ff4 <print_settings_details+0x120>
            setting = &details->settings[idx];
 8018fd8:	68f8      	ldr	r0, [r7, #12]
 8018fda:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 8018fde:	eb00 1003 	add.w	r0, r0, r3, lsl #4
            if(group == Group_All || setting->group == args.group) {
 8018fe2:	f1b8 0f00 	cmp.w	r8, #0
 8018fe6:	d0ed      	beq.n	8018fc4 <print_settings_details+0xf0>
 8018fe8:	7882      	ldrb	r2, [r0, #2]
 8018fea:	f89d 3001 	ldrb.w	r3, [sp, #1]
 8018fee:	429a      	cmp	r2, r3
 8018ff0:	d1ee      	bne.n	8018fd0 <print_settings_details+0xfc>
 8018ff2:	e7e7      	b.n	8018fc4 <print_settings_details+0xf0>
    } while((details = details->next));
 8018ff4:	69bf      	ldr	r7, [r7, #24]
 8018ff6:	2f00      	cmp	r7, #0
 8018ff8:	d0dd      	beq.n	8018fb6 <print_settings_details+0xe2>
        for(idx = 0; idx < details->n_settings; idx++) {
 8018ffa:	2400      	movs	r4, #0
 8018ffc:	e7e9      	b.n	8018fd2 <print_settings_details+0xfe>
    return reported ? Status_OK : Status_SettingDisabled;
 8018ffe:	2035      	movs	r0, #53	; 0x35
 8019000:	e7dd      	b.n	8018fbe <print_settings_details+0xea>
 8019002:	bf00      	nop
 8019004:	2000350c 	.word	0x2000350c
 8019008:	08027520 	.word	0x08027520
 801900c:	08027558 	.word	0x08027558
 8019010:	08018165 	.word	0x08018165
 8019014:	08018eb1 	.word	0x08018eb1
 8019018:	08018e81 	.word	0x08018e81

0801901c <print_setting_group>:
{
 801901c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801901e:	4604      	mov	r4, r0
 8019020:	460d      	mov	r5, r1
    if(settings_is_group_available(group->id)) {
 8019022:	7840      	ldrb	r0, [r0, #1]
 8019024:	f003 fef2 	bl	801ce0c <settings_is_group_available>
 8019028:	b178      	cbz	r0, 801904a <print_setting_group+0x2e>
        if(!prefix) {
 801902a:	b17d      	cbz	r5, 801904c <print_setting_group+0x30>
        } else if(group->id != Group_Root) {
 801902c:	7863      	ldrb	r3, [r4, #1]
 801902e:	b163      	cbz	r3, 801904a <print_setting_group+0x2e>
            hal.stream.write(prefix);
 8019030:	4e18      	ldr	r6, [pc, #96]	; (8019094 <print_setting_group+0x78>)
 8019032:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
 8019036:	4628      	mov	r0, r5
 8019038:	4798      	blx	r3
            hal.stream.write(group->name);
 801903a:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
 801903e:	6860      	ldr	r0, [r4, #4]
 8019040:	4798      	blx	r3
            hal.stream.write(ASCII_EOL);
 8019042:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
 8019046:	4814      	ldr	r0, [pc, #80]	; (8019098 <print_setting_group+0x7c>)
 8019048:	4798      	blx	r3
}
 801904a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            hal.stream.write("[SETTINGGROUP:");
 801904c:	4d11      	ldr	r5, [pc, #68]	; (8019094 <print_setting_group+0x78>)
 801904e:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8019052:	4812      	ldr	r0, [pc, #72]	; (801909c <print_setting_group+0x80>)
 8019054:	4798      	blx	r3
            hal.stream.write(uitoa(group->id));
 8019056:	f8d5 60b4 	ldr.w	r6, [r5, #180]	; 0xb4
 801905a:	7860      	ldrb	r0, [r4, #1]
 801905c:	f7fc fb8c 	bl	8015778 <uitoa>
 8019060:	47b0      	blx	r6
            hal.stream.write(vbar);
 8019062:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8019066:	4e0e      	ldr	r6, [pc, #56]	; (80190a0 <print_setting_group+0x84>)
 8019068:	4630      	mov	r0, r6
 801906a:	4798      	blx	r3
            hal.stream.write(uitoa(group->parent));
 801906c:	f8d5 70b4 	ldr.w	r7, [r5, #180]	; 0xb4
 8019070:	7820      	ldrb	r0, [r4, #0]
 8019072:	f7fc fb81 	bl	8015778 <uitoa>
 8019076:	47b8      	blx	r7
            hal.stream.write(vbar);
 8019078:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 801907c:	4630      	mov	r0, r6
 801907e:	4798      	blx	r3
            hal.stream.write(group->name);
 8019080:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8019084:	6860      	ldr	r0, [r4, #4]
 8019086:	4798      	blx	r3
            hal.stream.write("]" ASCII_EOL);
 8019088:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 801908c:	4805      	ldr	r0, [pc, #20]	; (80190a4 <print_setting_group+0x88>)
 801908e:	4798      	blx	r3
 8019090:	e7db      	b.n	801904a <print_setting_group+0x2e>
 8019092:	bf00      	nop
 8019094:	2000350c 	.word	0x2000350c
 8019098:	080279c0 	.word	0x080279c0
 801909c:	080275a0 	.word	0x080275a0
 80190a0:	080283e8 	.word	0x080283e8
 80190a4:	0802cde0 	.word	0x0802cde0

080190a8 <report_setting>:
{
 80190a8:	b538      	push	{r3, r4, r5, lr}
 80190aa:	4604      	mov	r4, r0
 80190ac:	460d      	mov	r5, r1
    appendbuf(3, "$", uitoa(setting->id + offset), "=");
 80190ae:	8800      	ldrh	r0, [r0, #0]
 80190b0:	4408      	add	r0, r1
 80190b2:	f7fc fb61 	bl	8015778 <uitoa>
 80190b6:	4602      	mov	r2, r0
 80190b8:	4b0c      	ldr	r3, [pc, #48]	; (80190ec <report_setting+0x44>)
 80190ba:	490d      	ldr	r1, [pc, #52]	; (80190f0 <report_setting+0x48>)
 80190bc:	2003      	movs	r0, #3
 80190be:	f7ff fab1 	bl	8018624 <appendbuf>
    char *value = setting_get_value(setting, offset);
 80190c2:	4629      	mov	r1, r5
 80190c4:	4620      	mov	r0, r4
 80190c6:	f003 fb17 	bl	801c6f8 <setting_get_value>
    if(value) {
 80190ca:	b168      	cbz	r0, 80190e8 <report_setting+0x40>
 80190cc:	4605      	mov	r5, r0
        hal.stream.write(buf);
 80190ce:	4c09      	ldr	r4, [pc, #36]	; (80190f4 <report_setting+0x4c>)
 80190d0:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 80190d4:	4808      	ldr	r0, [pc, #32]	; (80190f8 <report_setting+0x50>)
 80190d6:	4798      	blx	r3
        hal.stream.write(value);
 80190d8:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 80190dc:	4628      	mov	r0, r5
 80190de:	4798      	blx	r3
        hal.stream.write(ASCII_EOL);
 80190e0:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 80190e4:	4805      	ldr	r0, [pc, #20]	; (80190fc <report_setting+0x54>)
 80190e6:	4798      	blx	r3
}
 80190e8:	2001      	movs	r0, #1
 80190ea:	bd38      	pop	{r3, r4, r5, pc}
 80190ec:	080275b0 	.word	0x080275b0
 80190f0:	08027338 	.word	0x08027338
 80190f4:	2000350c 	.word	0x2000350c
 80190f8:	20003a88 	.word	0x20003a88
 80190fc:	080279c0 	.word	0x080279c0

08019100 <add_limits>:
{
 8019100:	b082      	sub	sp, #8
 8019102:	9101      	str	r1, [sp, #4]
    buf = axis_signals_tostring(buf, limits.min);
 8019104:	f89d 3004 	ldrb.w	r3, [sp, #4]
    signals.mask &= AXES_BITMASK;
 8019108:	f003 0307 	and.w	r3, r3, #7
    uint_fast16_t idx = 0;
 801910c:	2200      	movs	r2, #0
    while(signals.mask) {
 801910e:	e002      	b.n	8019116 <add_limits+0x16>
        idx++;
 8019110:	3201      	adds	r2, #1
        signals.mask >>= 1;
 8019112:	f3c3 0347 	ubfx	r3, r3, #1, #8
    while(signals.mask) {
 8019116:	b2db      	uxtb	r3, r3
 8019118:	b14b      	cbz	r3, 801912e <add_limits+0x2e>
        if(signals.mask & 0x01)
 801911a:	f013 0f01 	tst.w	r3, #1
 801911e:	d0f7      	beq.n	8019110 <add_limits+0x10>
            *buf++ = *axis_letter[idx];
 8019120:	492a      	ldr	r1, [pc, #168]	; (80191cc <add_limits+0xcc>)
 8019122:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
 8019126:	7809      	ldrb	r1, [r1, #0]
 8019128:	f800 1b01 	strb.w	r1, [r0], #1
 801912c:	e7f0      	b.n	8019110 <add_limits+0x10>
    *buf = '\0';
 801912e:	2200      	movs	r2, #0
 8019130:	7002      	strb	r2, [r0, #0]
    *buf++ = ',';
 8019132:	232c      	movs	r3, #44	; 0x2c
 8019134:	f800 3b01 	strb.w	r3, [r0], #1
    buf = axis_signals_tostring(buf, limits.max);
 8019138:	f89d 3005 	ldrb.w	r3, [sp, #5]
    signals.mask &= AXES_BITMASK;
 801913c:	f003 0307 	and.w	r3, r3, #7
    while(signals.mask) {
 8019140:	e002      	b.n	8019148 <add_limits+0x48>
        idx++;
 8019142:	3201      	adds	r2, #1
        signals.mask >>= 1;
 8019144:	f3c3 0347 	ubfx	r3, r3, #1, #8
    while(signals.mask) {
 8019148:	b2db      	uxtb	r3, r3
 801914a:	b14b      	cbz	r3, 8019160 <add_limits+0x60>
        if(signals.mask & 0x01)
 801914c:	f013 0f01 	tst.w	r3, #1
 8019150:	d0f7      	beq.n	8019142 <add_limits+0x42>
            *buf++ = *axis_letter[idx];
 8019152:	491e      	ldr	r1, [pc, #120]	; (80191cc <add_limits+0xcc>)
 8019154:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
 8019158:	7809      	ldrb	r1, [r1, #0]
 801915a:	f800 1b01 	strb.w	r1, [r0], #1
 801915e:	e7f0      	b.n	8019142 <add_limits+0x42>
    *buf = '\0';
 8019160:	2200      	movs	r2, #0
 8019162:	7002      	strb	r2, [r0, #0]
    *buf++ = ',';
 8019164:	232c      	movs	r3, #44	; 0x2c
 8019166:	f800 3b01 	strb.w	r3, [r0], #1
    buf = axis_signals_tostring(buf, limits.min2);
 801916a:	f89d 3006 	ldrb.w	r3, [sp, #6]
    signals.mask &= AXES_BITMASK;
 801916e:	f003 0307 	and.w	r3, r3, #7
    while(signals.mask) {
 8019172:	e002      	b.n	801917a <add_limits+0x7a>
        idx++;
 8019174:	3201      	adds	r2, #1
        signals.mask >>= 1;
 8019176:	f3c3 0347 	ubfx	r3, r3, #1, #8
    while(signals.mask) {
 801917a:	b2db      	uxtb	r3, r3
 801917c:	b14b      	cbz	r3, 8019192 <add_limits+0x92>
        if(signals.mask & 0x01)
 801917e:	f013 0f01 	tst.w	r3, #1
 8019182:	d0f7      	beq.n	8019174 <add_limits+0x74>
            *buf++ = *axis_letter[idx];
 8019184:	4911      	ldr	r1, [pc, #68]	; (80191cc <add_limits+0xcc>)
 8019186:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
 801918a:	7809      	ldrb	r1, [r1, #0]
 801918c:	f800 1b01 	strb.w	r1, [r0], #1
 8019190:	e7f0      	b.n	8019174 <add_limits+0x74>
    *buf = '\0';
 8019192:	2200      	movs	r2, #0
 8019194:	7002      	strb	r2, [r0, #0]
    *buf++ = ',';
 8019196:	232c      	movs	r3, #44	; 0x2c
 8019198:	f800 3b01 	strb.w	r3, [r0], #1
    buf = axis_signals_tostring(buf, limits.max2);
 801919c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    signals.mask &= AXES_BITMASK;
 80191a0:	f003 0307 	and.w	r3, r3, #7
    while(signals.mask) {
 80191a4:	e002      	b.n	80191ac <add_limits+0xac>
        idx++;
 80191a6:	3201      	adds	r2, #1
        signals.mask >>= 1;
 80191a8:	f3c3 0347 	ubfx	r3, r3, #1, #8
    while(signals.mask) {
 80191ac:	b2db      	uxtb	r3, r3
 80191ae:	b14b      	cbz	r3, 80191c4 <add_limits+0xc4>
        if(signals.mask & 0x01)
 80191b0:	f013 0f01 	tst.w	r3, #1
 80191b4:	d0f7      	beq.n	80191a6 <add_limits+0xa6>
            *buf++ = *axis_letter[idx];
 80191b6:	4905      	ldr	r1, [pc, #20]	; (80191cc <add_limits+0xcc>)
 80191b8:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
 80191bc:	7809      	ldrb	r1, [r1, #0]
 80191be:	f800 1b01 	strb.w	r1, [r0], #1
 80191c2:	e7f0      	b.n	80191a6 <add_limits+0xa6>
    *buf = '\0';
 80191c4:	7003      	strb	r3, [r0, #0]
}
 80191c6:	b002      	add	sp, #8
 80191c8:	4770      	bx	lr
 80191ca:	bf00      	nop
 80191cc:	080271cc 	.word	0x080271cc

080191d0 <report_init>:
    get_axis_value = settings.flags.report_inches ? get_axis_value_inches : get_axis_value_mm;
 80191d0:	4b0b      	ldr	r3, [pc, #44]	; (8019200 <report_init+0x30>)
 80191d2:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 80191d6:	f013 0301 	ands.w	r3, r3, #1
 80191da:	d00b      	beq.n	80191f4 <report_init+0x24>
 80191dc:	4909      	ldr	r1, [pc, #36]	; (8019204 <report_init+0x34>)
 80191de:	4a0a      	ldr	r2, [pc, #40]	; (8019208 <report_init+0x38>)
 80191e0:	6011      	str	r1, [r2, #0]
    get_axis_values = settings.flags.report_inches ? get_axis_values_inches : get_axis_values_mm;
 80191e2:	b14b      	cbz	r3, 80191f8 <report_init+0x28>
 80191e4:	4909      	ldr	r1, [pc, #36]	; (801920c <report_init+0x3c>)
 80191e6:	4a0a      	ldr	r2, [pc, #40]	; (8019210 <report_init+0x40>)
 80191e8:	6011      	str	r1, [r2, #0]
    get_rate_value = settings.flags.report_inches ? get_rate_value_inch : get_rate_value_mm;
 80191ea:	b13b      	cbz	r3, 80191fc <report_init+0x2c>
 80191ec:	4a09      	ldr	r2, [pc, #36]	; (8019214 <report_init+0x44>)
 80191ee:	4b0a      	ldr	r3, [pc, #40]	; (8019218 <report_init+0x48>)
 80191f0:	601a      	str	r2, [r3, #0]
}
 80191f2:	4770      	bx	lr
    get_axis_value = settings.flags.report_inches ? get_axis_value_inches : get_axis_value_mm;
 80191f4:	4909      	ldr	r1, [pc, #36]	; (801921c <report_init+0x4c>)
 80191f6:	e7f2      	b.n	80191de <report_init+0xe>
    get_axis_values = settings.flags.report_inches ? get_axis_values_inches : get_axis_values_mm;
 80191f8:	4909      	ldr	r1, [pc, #36]	; (8019220 <report_init+0x50>)
 80191fa:	e7f4      	b.n	80191e6 <report_init+0x16>
    get_rate_value = settings.flags.report_inches ? get_rate_value_inch : get_rate_value_mm;
 80191fc:	4a09      	ldr	r2, [pc, #36]	; (8019224 <report_init+0x54>)
 80191fe:	e7f6      	b.n	80191ee <report_init+0x1e>
 8019200:	20003b14 	.word	0x20003b14
 8019204:	080185b5 	.word	0x080185b5
 8019208:	20003ac0 	.word	0x20003ac0
 801920c:	08018515 	.word	0x08018515
 8019210:	20003ac4 	.word	0x20003ac4
 8019214:	08018229 	.word	0x08018229
 8019218:	20003ac8 	.word	0x20003ac8
 801921c:	0801859d 	.word	0x0801859d
 8019220:	080184a1 	.word	0x080184a1
 8019224:	08018219 	.word	0x08018219

08019228 <report_message>:
{
 8019228:	b538      	push	{r3, r4, r5, lr}
 801922a:	4605      	mov	r5, r0
 801922c:	460c      	mov	r4, r1
    hal.stream.write("[MSG:");
 801922e:	4b0f      	ldr	r3, [pc, #60]	; (801926c <report_message+0x44>)
 8019230:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8019234:	480e      	ldr	r0, [pc, #56]	; (8019270 <report_message+0x48>)
 8019236:	4798      	blx	r3
    switch(type) {
 8019238:	2c01      	cmp	r4, #1
 801923a:	d00b      	beq.n	8019254 <report_message+0x2c>
 801923c:	2c02      	cmp	r4, #2
 801923e:	d00f      	beq.n	8019260 <report_message+0x38>
    hal.stream.write(msg);
 8019240:	4c0a      	ldr	r4, [pc, #40]	; (801926c <report_message+0x44>)
 8019242:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8019246:	4628      	mov	r0, r5
 8019248:	4798      	blx	r3
    hal.stream.write("]" ASCII_EOL);
 801924a:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801924e:	4809      	ldr	r0, [pc, #36]	; (8019274 <report_message+0x4c>)
 8019250:	4798      	blx	r3
}
 8019252:	bd38      	pop	{r3, r4, r5, pc}
            hal.stream.write("Info: ");
 8019254:	4b05      	ldr	r3, [pc, #20]	; (801926c <report_message+0x44>)
 8019256:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801925a:	4807      	ldr	r0, [pc, #28]	; (8019278 <report_message+0x50>)
 801925c:	4798      	blx	r3
            break;
 801925e:	e7ef      	b.n	8019240 <report_message+0x18>
            hal.stream.write("Warning: ");
 8019260:	4b02      	ldr	r3, [pc, #8]	; (801926c <report_message+0x44>)
 8019262:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8019266:	4805      	ldr	r0, [pc, #20]	; (801927c <report_message+0x54>)
 8019268:	4798      	blx	r3
            break;
 801926a:	e7e9      	b.n	8019240 <report_message+0x18>
 801926c:	2000350c 	.word	0x2000350c
 8019270:	080275b4 	.word	0x080275b4
 8019274:	0802cde0 	.word	0x0802cde0
 8019278:	080275bc 	.word	0x080275bc
 801927c:	080275c4 	.word	0x080275c4

08019280 <report_feedback_message>:
{
 8019280:	b510      	push	{r4, lr}
 8019282:	4604      	mov	r4, r0
    const message_t *msg = message_get(id);
 8019284:	f7fa fc84 	bl	8013b90 <message_get>
    report_message(msg ? msg->text : "", msg ? msg->type : Message_Plain);
 8019288:	4603      	mov	r3, r0
 801928a:	b168      	cbz	r0, 80192a8 <report_feedback_message+0x28>
 801928c:	6840      	ldr	r0, [r0, #4]
 801928e:	b16b      	cbz	r3, 80192ac <report_feedback_message+0x2c>
 8019290:	7859      	ldrb	r1, [r3, #1]
 8019292:	f7ff ffc9 	bl	8019228 <report_message>
    if(id == Message_None && grbl.on_gcode_message)
 8019296:	b92c      	cbnz	r4, 80192a4 <report_feedback_message+0x24>
 8019298:	4b05      	ldr	r3, [pc, #20]	; (80192b0 <report_feedback_message+0x30>)
 801929a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801929e:	b10b      	cbz	r3, 80192a4 <report_feedback_message+0x24>
        grbl.on_gcode_message("");
 80192a0:	4804      	ldr	r0, [pc, #16]	; (80192b4 <report_feedback_message+0x34>)
 80192a2:	4798      	blx	r3
}
 80192a4:	4620      	mov	r0, r4
 80192a6:	bd10      	pop	{r4, pc}
    report_message(msg ? msg->text : "", msg ? msg->type : Message_Plain);
 80192a8:	4802      	ldr	r0, [pc, #8]	; (80192b4 <report_feedback_message+0x34>)
 80192aa:	e7f0      	b.n	801928e <report_feedback_message+0xe>
 80192ac:	2100      	movs	r1, #0
 80192ae:	e7f0      	b.n	8019292 <report_feedback_message+0x12>
 80192b0:	2000343c 	.word	0x2000343c
 80192b4:	080274a0 	.word	0x080274a0

080192b8 <report_grbl_setting>:
{
 80192b8:	b570      	push	{r4, r5, r6, lr}
 80192ba:	4604      	mov	r4, r0
 80192bc:	460d      	mov	r5, r1
    const setting_detail_t *setting = setting_get_details(id, NULL);
 80192be:	2100      	movs	r1, #0
 80192c0:	f003 fcb0 	bl	801cc24 <setting_get_details>
    if(setting)
 80192c4:	b138      	cbz	r0, 80192d6 <report_grbl_setting+0x1e>
        grbl.report.setting(setting, id - setting->id, data);
 80192c6:	4a05      	ldr	r2, [pc, #20]	; (80192dc <report_grbl_setting+0x24>)
 80192c8:	6956      	ldr	r6, [r2, #20]
 80192ca:	8801      	ldrh	r1, [r0, #0]
 80192cc:	462a      	mov	r2, r5
 80192ce:	1a61      	subs	r1, r4, r1
 80192d0:	47b0      	blx	r6
    status_code_t status = Status_OK;
 80192d2:	2000      	movs	r0, #0
}
 80192d4:	bd70      	pop	{r4, r5, r6, pc}
        status = Status_SettingDisabled;
 80192d6:	2035      	movs	r0, #53	; 0x35
 80192d8:	e7fc      	b.n	80192d4 <report_grbl_setting+0x1c>
 80192da:	bf00      	nop
 80192dc:	2000343c 	.word	0x2000343c

080192e0 <report_grbl_settings>:
{
 80192e0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80192e4:	4606      	mov	r6, r0
 80192e6:	4689      	mov	r9, r1
    setting_details_t *details = settings_get_details();
 80192e8:	f002 fff2 	bl	801c2d0 <settings_get_details>
    uint_fast16_t idx, n_settings = 0;
 80192ec:	2400      	movs	r4, #0
        n_settings += details->n_settings;
 80192ee:	8903      	ldrh	r3, [r0, #8]
 80192f0:	441c      	add	r4, r3
    } while((details = details->next));
 80192f2:	6980      	ldr	r0, [r0, #24]
 80192f4:	2800      	cmp	r0, #0
 80192f6:	d1fa      	bne.n	80192ee <report_grbl_settings+0xe>
    details = settings_get_details();
 80192f8:	f002 ffea 	bl	801c2d0 <settings_get_details>
 80192fc:	4683      	mov	fp, r0
    if((all_settings = psetting = calloc(n_settings, sizeof(setting_detail_t *)))) {
 80192fe:	2104      	movs	r1, #4
 8019300:	4620      	mov	r0, r4
 8019302:	f009 f8b7 	bl	8022474 <calloc>
 8019306:	4680      	mov	r8, r0
 8019308:	2800      	cmp	r0, #0
 801930a:	d067      	beq.n	80193dc <report_grbl_settings+0xfc>
 801930c:	4682      	mov	sl, r0
        n_settings = 0;
 801930e:	2700      	movs	r7, #0
        for(idx = 0; idx < details->n_settings; idx++) {
 8019310:	463d      	mov	r5, r7
 8019312:	e00a      	b.n	801932a <report_grbl_settings+0x4a>
                  (setting->is_available == NULL ||setting->is_available(setting))) {
 8019314:	6aa3      	ldr	r3, [r4, #40]	; 0x28
            if((all || setting->type == Setting_IsLegacy || setting->type == Setting_IsLegacyFn) &&
 8019316:	b113      	cbz	r3, 801931e <report_grbl_settings+0x3e>
                  (setting->is_available == NULL ||setting->is_available(setting))) {
 8019318:	4620      	mov	r0, r4
 801931a:	4798      	blx	r3
 801931c:	b120      	cbz	r0, 8019328 <report_grbl_settings+0x48>
                *psetting++ = (setting_detail_t *)setting;
 801931e:	4653      	mov	r3, sl
 8019320:	f843 4b04 	str.w	r4, [r3], #4
                n_settings++;
 8019324:	3701      	adds	r7, #1
                *psetting++ = (setting_detail_t *)setting;
 8019326:	469a      	mov	sl, r3
        for(idx = 0; idx < details->n_settings; idx++) {
 8019328:	3501      	adds	r5, #1
 801932a:	f8bb 3008 	ldrh.w	r3, [fp, #8]
 801932e:	42ab      	cmp	r3, r5
 8019330:	d90d      	bls.n	801934e <report_grbl_settings+0x6e>
            setting = &details->settings[idx];
 8019332:	f8db 400c 	ldr.w	r4, [fp, #12]
 8019336:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 801933a:	eb04 1403 	add.w	r4, r4, r3, lsl #4
            if((all || setting->type == Setting_IsLegacy || setting->type == Setting_IsLegacyFn) &&
 801933e:	2e00      	cmp	r6, #0
 8019340:	d1e8      	bne.n	8019314 <report_grbl_settings+0x34>
 8019342:	7f23      	ldrb	r3, [r4, #28]
 8019344:	2b04      	cmp	r3, #4
 8019346:	d0e5      	beq.n	8019314 <report_grbl_settings+0x34>
 8019348:	2b05      	cmp	r3, #5
 801934a:	d1ed      	bne.n	8019328 <report_grbl_settings+0x48>
 801934c:	e7e2      	b.n	8019314 <report_grbl_settings+0x34>
        if(all && (details = details->next)) do {
 801934e:	b116      	cbz	r6, 8019356 <report_grbl_settings+0x76>
 8019350:	f8db 6018 	ldr.w	r6, [fp, #24]
 8019354:	bb06      	cbnz	r6, 8019398 <report_grbl_settings+0xb8>
        qsort(all_settings, n_settings, sizeof(setting_detail_t *), cmp_settings);
 8019356:	4b22      	ldr	r3, [pc, #136]	; (80193e0 <report_grbl_settings+0x100>)
 8019358:	2204      	movs	r2, #4
 801935a:	4639      	mov	r1, r7
 801935c:	4640      	mov	r0, r8
 801935e:	f009 f9a5 	bl	80226ac <qsort>
        for(idx = 0; idx < n_settings; idx++)
 8019362:	2400      	movs	r4, #0
 8019364:	e021      	b.n	80193aa <report_grbl_settings+0xca>
                    *psetting++ = (setting_detail_t *)setting;
 8019366:	4653      	mov	r3, sl
 8019368:	f843 4b04 	str.w	r4, [r3], #4
                    n_settings++;
 801936c:	3701      	adds	r7, #1
                    *psetting++ = (setting_detail_t *)setting;
 801936e:	469a      	mov	sl, r3
            for(idx = 0; idx < details->n_settings; idx++) {
 8019370:	3501      	adds	r5, #1
 8019372:	8933      	ldrh	r3, [r6, #8]
 8019374:	42ab      	cmp	r3, r5
 8019376:	d90c      	bls.n	8019392 <report_grbl_settings+0xb2>
                setting = &details->settings[idx];
 8019378:	68f4      	ldr	r4, [r6, #12]
 801937a:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 801937e:	eb04 1403 	add.w	r4, r4, r3, lsl #4
                if(setting->is_available == NULL ||setting->is_available(setting)) {
 8019382:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8019384:	2b00      	cmp	r3, #0
 8019386:	d0ee      	beq.n	8019366 <report_grbl_settings+0x86>
 8019388:	4620      	mov	r0, r4
 801938a:	4798      	blx	r3
 801938c:	2800      	cmp	r0, #0
 801938e:	d0ef      	beq.n	8019370 <report_grbl_settings+0x90>
 8019390:	e7e9      	b.n	8019366 <report_grbl_settings+0x86>
        } while((details = details->next));
 8019392:	69b6      	ldr	r6, [r6, #24]
 8019394:	2e00      	cmp	r6, #0
 8019396:	d0de      	beq.n	8019356 <report_grbl_settings+0x76>
            for(idx = 0; idx < details->n_settings; idx++) {
 8019398:	2500      	movs	r5, #0
 801939a:	e7ea      	b.n	8019372 <report_grbl_settings+0x92>
            settings_iterator(all_settings[idx], print_setting, data);
 801939c:	464a      	mov	r2, r9
 801939e:	4911      	ldr	r1, [pc, #68]	; (80193e4 <report_grbl_settings+0x104>)
 80193a0:	f858 0024 	ldr.w	r0, [r8, r4, lsl #2]
 80193a4:	f003 fcc0 	bl	801cd28 <settings_iterator>
        for(idx = 0; idx < n_settings; idx++)
 80193a8:	3401      	adds	r4, #1
 80193aa:	42bc      	cmp	r4, r7
 80193ac:	d3f6      	bcc.n	801939c <report_grbl_settings+0xbc>
        free(all_settings);
 80193ae:	4640      	mov	r0, r8
 80193b0:	f009 f886 	bl	80224c0 <free>
}
 80193b4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
            settings_iterator(&details->settings[idx], print_setting, data);
 80193b8:	f8db 300c 	ldr.w	r3, [fp, #12]
 80193bc:	eb05 0045 	add.w	r0, r5, r5, lsl #1
 80193c0:	464a      	mov	r2, r9
 80193c2:	4908      	ldr	r1, [pc, #32]	; (80193e4 <report_grbl_settings+0x104>)
 80193c4:	eb03 1000 	add.w	r0, r3, r0, lsl #4
 80193c8:	f003 fcae 	bl	801cd28 <settings_iterator>
        for(idx = 0; idx < n_settings; idx++)
 80193cc:	3501      	adds	r5, #1
 80193ce:	42a5      	cmp	r5, r4
 80193d0:	d3f2      	bcc.n	80193b8 <report_grbl_settings+0xd8>
    } while((details = details->next));
 80193d2:	f8db b018 	ldr.w	fp, [fp, #24]
 80193d6:	f1bb 0f00 	cmp.w	fp, #0
 80193da:	d0eb      	beq.n	80193b4 <report_grbl_settings+0xd4>
        for(idx = 0; idx < n_settings; idx++)
 80193dc:	2500      	movs	r5, #0
 80193de:	e7f6      	b.n	80193ce <report_grbl_settings+0xee>
 80193e0:	08018165 	.word	0x08018165
 80193e4:	08018245 	.word	0x08018245

080193e8 <report_probe_parameters>:
{
 80193e8:	b570      	push	{r4, r5, r6, lr}
 80193ea:	b084      	sub	sp, #16
    system_convert_array_steps_to_mpos(print_position, sys.probe_position);
 80193ec:	4d11      	ldr	r5, [pc, #68]	; (8019434 <report_probe_parameters+0x4c>)
 80193ee:	4629      	mov	r1, r5
 80193f0:	a801      	add	r0, sp, #4
 80193f2:	f007 fdf3 	bl	8020fdc <system_convert_array_steps_to_mpos>
    hal.stream.write("[PRB:");
 80193f6:	4c10      	ldr	r4, [pc, #64]	; (8019438 <report_probe_parameters+0x50>)
 80193f8:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 80193fc:	480f      	ldr	r0, [pc, #60]	; (801943c <report_probe_parameters+0x54>)
 80193fe:	4798      	blx	r3
    hal.stream.write(get_axis_values(print_position));
 8019400:	f8d4 60b4 	ldr.w	r6, [r4, #180]	; 0xb4
 8019404:	4b0e      	ldr	r3, [pc, #56]	; (8019440 <report_probe_parameters+0x58>)
 8019406:	681b      	ldr	r3, [r3, #0]
 8019408:	a801      	add	r0, sp, #4
 801940a:	4798      	blx	r3
 801940c:	47b0      	blx	r6
    hal.stream.write(sys.flags.probe_succeeded ? ":1" : ":0");
 801940e:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8019412:	f815 2c22 	ldrb.w	r2, [r5, #-34]
 8019416:	f012 0f02 	tst.w	r2, #2
 801941a:	d008      	beq.n	801942e <report_probe_parameters+0x46>
 801941c:	4809      	ldr	r0, [pc, #36]	; (8019444 <report_probe_parameters+0x5c>)
 801941e:	4798      	blx	r3
    hal.stream.write("]" ASCII_EOL);
 8019420:	4b05      	ldr	r3, [pc, #20]	; (8019438 <report_probe_parameters+0x50>)
 8019422:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8019426:	4808      	ldr	r0, [pc, #32]	; (8019448 <report_probe_parameters+0x60>)
 8019428:	4798      	blx	r3
}
 801942a:	b004      	add	sp, #16
 801942c:	bd70      	pop	{r4, r5, r6, pc}
    hal.stream.write(sys.flags.probe_succeeded ? ":1" : ":0");
 801942e:	4807      	ldr	r0, [pc, #28]	; (801944c <report_probe_parameters+0x64>)
 8019430:	e7f5      	b.n	801941e <report_probe_parameters+0x36>
 8019432:	bf00      	nop
 8019434:	200036fc 	.word	0x200036fc
 8019438:	2000350c 	.word	0x2000350c
 801943c:	080275d0 	.word	0x080275d0
 8019440:	20003ac4 	.word	0x20003ac4
 8019444:	08027874 	.word	0x08027874
 8019448:	0802cde0 	.word	0x0802cde0
 801944c:	0802787c 	.word	0x0802787c

08019450 <report_home_position>:
{
 8019450:	b570      	push	{r4, r5, r6, lr}
    hal.stream.write("[HOME:");
 8019452:	4c0e      	ldr	r4, [pc, #56]	; (801948c <report_home_position+0x3c>)
 8019454:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8019458:	480d      	ldr	r0, [pc, #52]	; (8019490 <report_home_position+0x40>)
 801945a:	4798      	blx	r3
    hal.stream.write(get_axis_values(sys.home_position));
 801945c:	f8d4 60b4 	ldr.w	r6, [r4, #180]	; 0xb4
 8019460:	4b0c      	ldr	r3, [pc, #48]	; (8019494 <report_home_position+0x44>)
 8019462:	681b      	ldr	r3, [r3, #0]
 8019464:	4d0c      	ldr	r5, [pc, #48]	; (8019498 <report_home_position+0x48>)
 8019466:	4628      	mov	r0, r5
 8019468:	4798      	blx	r3
 801946a:	47b0      	blx	r6
    hal.stream.write(":");
 801946c:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8019470:	480a      	ldr	r0, [pc, #40]	; (801949c <report_home_position+0x4c>)
 8019472:	4798      	blx	r3
    hal.stream.write(uitoa(sys.homed.mask));
 8019474:	f8d4 60b4 	ldr.w	r6, [r4, #180]	; 0xb4
 8019478:	f815 0c04 	ldrb.w	r0, [r5, #-4]
 801947c:	f7fc f97c 	bl	8015778 <uitoa>
 8019480:	47b0      	blx	r6
    hal.stream.write("]" ASCII_EOL);
 8019482:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8019486:	4806      	ldr	r0, [pc, #24]	; (80194a0 <report_home_position+0x50>)
 8019488:	4798      	blx	r3
}
 801948a:	bd70      	pop	{r4, r5, r6, pc}
 801948c:	2000350c 	.word	0x2000350c
 8019490:	080275d8 	.word	0x080275d8
 8019494:	20003ac4 	.word	0x20003ac4
 8019498:	2000371c 	.word	0x2000371c
 801949c:	08027694 	.word	0x08027694
 80194a0:	0802cde0 	.word	0x0802cde0

080194a4 <report_tool_offsets>:
{
 80194a4:	b538      	push	{r3, r4, r5, lr}
    hal.stream.write("[TLO:");
 80194a6:	4c08      	ldr	r4, [pc, #32]	; (80194c8 <report_tool_offsets+0x24>)
 80194a8:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 80194ac:	4807      	ldr	r0, [pc, #28]	; (80194cc <report_tool_offsets+0x28>)
 80194ae:	4798      	blx	r3
    hal.stream.write(get_axis_values(gc_state.tool_length_offset));
 80194b0:	f8d4 50b4 	ldr.w	r5, [r4, #180]	; 0xb4
 80194b4:	4b06      	ldr	r3, [pc, #24]	; (80194d0 <report_tool_offsets+0x2c>)
 80194b6:	681b      	ldr	r3, [r3, #0]
 80194b8:	4806      	ldr	r0, [pc, #24]	; (80194d4 <report_tool_offsets+0x30>)
 80194ba:	4798      	blx	r3
 80194bc:	47a8      	blx	r5
    hal.stream.write("]" ASCII_EOL);
 80194be:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 80194c2:	4805      	ldr	r0, [pc, #20]	; (80194d8 <report_tool_offsets+0x34>)
 80194c4:	4798      	blx	r3
}
 80194c6:	bd38      	pop	{r3, r4, r5, pc}
 80194c8:	2000350c 	.word	0x2000350c
 80194cc:	080275e0 	.word	0x080275e0
 80194d0:	20003ac4 	.word	0x20003ac4
 80194d4:	200033cc 	.word	0x200033cc
 80194d8:	0802cde0 	.word	0x0802cde0

080194dc <report_ngc_parameter>:
{
 80194dc:	b530      	push	{r4, r5, lr}
 80194de:	b083      	sub	sp, #12
 80194e0:	4604      	mov	r4, r0
    hal.stream.write("[PARAM:");
 80194e2:	4d15      	ldr	r5, [pc, #84]	; (8019538 <report_ngc_parameter+0x5c>)
 80194e4:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 80194e8:	4814      	ldr	r0, [pc, #80]	; (801953c <report_ngc_parameter+0x60>)
 80194ea:	4798      	blx	r3
    hal.stream.write(uitoa(id));
 80194ec:	f8d5 50b4 	ldr.w	r5, [r5, #180]	; 0xb4
 80194f0:	4620      	mov	r0, r4
 80194f2:	f7fc f941 	bl	8015778 <uitoa>
 80194f6:	47a8      	blx	r5
    if(ngc_param_get(id, &value)) {
 80194f8:	a901      	add	r1, sp, #4
 80194fa:	4620      	mov	r0, r4
 80194fc:	f7fb ff24 	bl	8015348 <ngc_param_get>
 8019500:	b1a0      	cbz	r0, 801952c <report_ngc_parameter+0x50>
        hal.stream.write("=");
 8019502:	4c0d      	ldr	r4, [pc, #52]	; (8019538 <report_ngc_parameter+0x5c>)
 8019504:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8019508:	480d      	ldr	r0, [pc, #52]	; (8019540 <report_ngc_parameter+0x64>)
 801950a:	4798      	blx	r3
        hal.stream.write(ftoa(value, 3));
 801950c:	f8d4 40b4 	ldr.w	r4, [r4, #180]	; 0xb4
 8019510:	2003      	movs	r0, #3
 8019512:	ed9d 0a01 	vldr	s0, [sp, #4]
 8019516:	f7fc f951 	bl	80157bc <ftoa>
 801951a:	47a0      	blx	r4
    hal.stream.write("]" ASCII_EOL);
 801951c:	4b06      	ldr	r3, [pc, #24]	; (8019538 <report_ngc_parameter+0x5c>)
 801951e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8019522:	4808      	ldr	r0, [pc, #32]	; (8019544 <report_ngc_parameter+0x68>)
 8019524:	4798      	blx	r3
}
 8019526:	2000      	movs	r0, #0
 8019528:	b003      	add	sp, #12
 801952a:	bd30      	pop	{r4, r5, pc}
        hal.stream.write("=N/A");
 801952c:	4b02      	ldr	r3, [pc, #8]	; (8019538 <report_ngc_parameter+0x5c>)
 801952e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8019532:	4805      	ldr	r0, [pc, #20]	; (8019548 <report_ngc_parameter+0x6c>)
 8019534:	4798      	blx	r3
 8019536:	e7f1      	b.n	801951c <report_ngc_parameter+0x40>
 8019538:	2000350c 	.word	0x2000350c
 801953c:	080275e8 	.word	0x080275e8
 8019540:	080275b0 	.word	0x080275b0
 8019544:	0802cde0 	.word	0x0802cde0
 8019548:	080275f0 	.word	0x080275f0

0801954c <report_named_ngc_parameter>:
{
 801954c:	b530      	push	{r4, r5, lr}
 801954e:	b083      	sub	sp, #12
 8019550:	4604      	mov	r4, r0
    hal.stream.write("[PARAM:");
 8019552:	4d14      	ldr	r5, [pc, #80]	; (80195a4 <report_named_ngc_parameter+0x58>)
 8019554:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8019558:	4813      	ldr	r0, [pc, #76]	; (80195a8 <report_named_ngc_parameter+0x5c>)
 801955a:	4798      	blx	r3
    hal.stream.write(arg);
 801955c:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8019560:	4620      	mov	r0, r4
 8019562:	4798      	blx	r3
    if(ngc_named_param_get(arg, &value)) {
 8019564:	a901      	add	r1, sp, #4
 8019566:	4620      	mov	r0, r4
 8019568:	f7fc f8aa 	bl	80156c0 <ngc_named_param_get>
 801956c:	b198      	cbz	r0, 8019596 <report_named_ngc_parameter+0x4a>
        hal.stream.write("=");
 801956e:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8019572:	480e      	ldr	r0, [pc, #56]	; (80195ac <report_named_ngc_parameter+0x60>)
 8019574:	4798      	blx	r3
        hal.stream.write(ftoa(value, 3));
 8019576:	f8d5 40b4 	ldr.w	r4, [r5, #180]	; 0xb4
 801957a:	2003      	movs	r0, #3
 801957c:	ed9d 0a01 	vldr	s0, [sp, #4]
 8019580:	f7fc f91c 	bl	80157bc <ftoa>
 8019584:	47a0      	blx	r4
    hal.stream.write("]" ASCII_EOL);
 8019586:	4b07      	ldr	r3, [pc, #28]	; (80195a4 <report_named_ngc_parameter+0x58>)
 8019588:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801958c:	4808      	ldr	r0, [pc, #32]	; (80195b0 <report_named_ngc_parameter+0x64>)
 801958e:	4798      	blx	r3
}
 8019590:	2000      	movs	r0, #0
 8019592:	b003      	add	sp, #12
 8019594:	bd30      	pop	{r4, r5, pc}
        hal.stream.write("=N/A");
 8019596:	4b03      	ldr	r3, [pc, #12]	; (80195a4 <report_named_ngc_parameter+0x58>)
 8019598:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801959c:	4805      	ldr	r0, [pc, #20]	; (80195b4 <report_named_ngc_parameter+0x68>)
 801959e:	4798      	blx	r3
 80195a0:	e7f1      	b.n	8019586 <report_named_ngc_parameter+0x3a>
 80195a2:	bf00      	nop
 80195a4:	2000350c 	.word	0x2000350c
 80195a8:	080275e8 	.word	0x080275e8
 80195ac:	080275b0 	.word	0x080275b0
 80195b0:	0802cde0 	.word	0x0802cde0
 80195b4:	080275f0 	.word	0x080275f0

080195b8 <report_ngc_parameters>:
{
 80195b8:	b570      	push	{r4, r5, r6, lr}
 80195ba:	b084      	sub	sp, #16
    if(gc_state.modal.scaling_active) {
 80195bc:	4b4f      	ldr	r3, [pc, #316]	; (80196fc <report_ngc_parameters+0x144>)
 80195be:	7f9b      	ldrb	r3, [r3, #30]
 80195c0:	b183      	cbz	r3, 80195e4 <report_ngc_parameters+0x2c>
        hal.stream.write("[G51:");
 80195c2:	4c4f      	ldr	r4, [pc, #316]	; (8019700 <report_ngc_parameters+0x148>)
 80195c4:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 80195c8:	484e      	ldr	r0, [pc, #312]	; (8019704 <report_ngc_parameters+0x14c>)
 80195ca:	4798      	blx	r3
        hal.stream.write(get_axis_values(gc_get_scaling()));
 80195cc:	f8d4 50b4 	ldr.w	r5, [r4, #180]	; 0xb4
 80195d0:	4b4d      	ldr	r3, [pc, #308]	; (8019708 <report_ngc_parameters+0x150>)
 80195d2:	681e      	ldr	r6, [r3, #0]
 80195d4:	f7f5 fcce 	bl	800ef74 <gc_get_scaling>
 80195d8:	47b0      	blx	r6
 80195da:	47a8      	blx	r5
        hal.stream.write("]" ASCII_EOL);
 80195dc:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 80195e0:	484a      	ldr	r0, [pc, #296]	; (801970c <report_ngc_parameters+0x154>)
 80195e2:	4798      	blx	r3
{
 80195e4:	2400      	movs	r4, #0
 80195e6:	e01c      	b.n	8019622 <report_ngc_parameters+0x6a>
            grbl.report.status_message(Status_SettingReadFail);
 80195e8:	4b49      	ldr	r3, [pc, #292]	; (8019710 <report_ngc_parameters+0x158>)
 80195ea:	689b      	ldr	r3, [r3, #8]
 80195ec:	2007      	movs	r0, #7
 80195ee:	4798      	blx	r3
            return;
 80195f0:	e056      	b.n	80196a0 <report_ngc_parameters+0xe8>
                hal.stream.write("28");
 80195f2:	4b43      	ldr	r3, [pc, #268]	; (8019700 <report_ngc_parameters+0x148>)
 80195f4:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80195f8:	4846      	ldr	r0, [pc, #280]	; (8019714 <report_ngc_parameters+0x15c>)
 80195fa:	4798      	blx	r3
        if(idx != CoordinateSystem_G92) {
 80195fc:	2c0b      	cmp	r4, #11
 80195fe:	d00f      	beq.n	8019620 <report_ngc_parameters+0x68>
            hal.stream.write(":");
 8019600:	4d3f      	ldr	r5, [pc, #252]	; (8019700 <report_ngc_parameters+0x148>)
 8019602:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8019606:	4844      	ldr	r0, [pc, #272]	; (8019718 <report_ngc_parameters+0x160>)
 8019608:	4798      	blx	r3
            hal.stream.write(get_axis_values(coord_data));
 801960a:	f8d5 60b4 	ldr.w	r6, [r5, #180]	; 0xb4
 801960e:	4b3e      	ldr	r3, [pc, #248]	; (8019708 <report_ngc_parameters+0x150>)
 8019610:	681b      	ldr	r3, [r3, #0]
 8019612:	a801      	add	r0, sp, #4
 8019614:	4798      	blx	r3
 8019616:	47b0      	blx	r6
            hal.stream.write("]" ASCII_EOL);
 8019618:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 801961c:	483b      	ldr	r0, [pc, #236]	; (801970c <report_ngc_parameters+0x154>)
 801961e:	4798      	blx	r3
    for (idx = 0; idx < N_CoordinateSystems; idx++) {
 8019620:	3401      	adds	r4, #1
 8019622:	2c0b      	cmp	r4, #11
 8019624:	d81f      	bhi.n	8019666 <report_ngc_parameters+0xae>
        if (!(settings_read_coord_data((coord_system_id_t)idx, &coord_data))) {
 8019626:	b2e5      	uxtb	r5, r4
 8019628:	a901      	add	r1, sp, #4
 801962a:	4628      	mov	r0, r5
 801962c:	f003 f9e2 	bl	801c9f4 <settings_read_coord_data>
 8019630:	2800      	cmp	r0, #0
 8019632:	d0d9      	beq.n	80195e8 <report_ngc_parameters+0x30>
        hal.stream.write("[G");
 8019634:	4b32      	ldr	r3, [pc, #200]	; (8019700 <report_ngc_parameters+0x148>)
 8019636:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801963a:	4838      	ldr	r0, [pc, #224]	; (801971c <report_ngc_parameters+0x164>)
 801963c:	4798      	blx	r3
        switch (idx) {
 801963e:	2c0a      	cmp	r4, #10
 8019640:	d00b      	beq.n	801965a <report_ngc_parameters+0xa2>
 8019642:	2c0b      	cmp	r4, #11
 8019644:	d0da      	beq.n	80195fc <report_ngc_parameters+0x44>
 8019646:	2c09      	cmp	r4, #9
 8019648:	d0d3      	beq.n	80195f2 <report_ngc_parameters+0x3a>
                hal.stream.write(map_coord_system((coord_system_id_t)idx));
 801964a:	4b2d      	ldr	r3, [pc, #180]	; (8019700 <report_ngc_parameters+0x148>)
 801964c:	f8d3 60b4 	ldr.w	r6, [r3, #180]	; 0xb4
 8019650:	4628      	mov	r0, r5
 8019652:	f7fe ffc1 	bl	80185d8 <map_coord_system>
 8019656:	47b0      	blx	r6
                break;
 8019658:	e7d0      	b.n	80195fc <report_ngc_parameters+0x44>
                hal.stream.write("30");
 801965a:	4b29      	ldr	r3, [pc, #164]	; (8019700 <report_ngc_parameters+0x148>)
 801965c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8019660:	482f      	ldr	r0, [pc, #188]	; (8019720 <report_ngc_parameters+0x168>)
 8019662:	4798      	blx	r3
                break;
 8019664:	e7ca      	b.n	80195fc <report_ngc_parameters+0x44>
    hal.stream.write("92:");
 8019666:	4c26      	ldr	r4, [pc, #152]	; (8019700 <report_ngc_parameters+0x148>)
 8019668:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801966c:	482d      	ldr	r0, [pc, #180]	; (8019724 <report_ngc_parameters+0x16c>)
 801966e:	4798      	blx	r3
    hal.stream.write(get_axis_values(gc_state.g92_coord_offset));
 8019670:	f8d4 50b4 	ldr.w	r5, [r4, #180]	; 0xb4
 8019674:	4b24      	ldr	r3, [pc, #144]	; (8019708 <report_ngc_parameters+0x150>)
 8019676:	681b      	ldr	r3, [r3, #0]
 8019678:	482b      	ldr	r0, [pc, #172]	; (8019728 <report_ngc_parameters+0x170>)
 801967a:	4798      	blx	r3
 801967c:	47a8      	blx	r5
    hal.stream.write("]" ASCII_EOL);
 801967e:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8019682:	4822      	ldr	r0, [pc, #136]	; (801970c <report_ngc_parameters+0x154>)
 8019684:	4798      	blx	r3
    if(settings.homing.flags.enabled)
 8019686:	4b29      	ldr	r3, [pc, #164]	; (801972c <report_ngc_parameters+0x174>)
 8019688:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 801968c:	f013 0f01 	tst.w	r3, #1
 8019690:	d108      	bne.n	80196a4 <report_ngc_parameters+0xec>
    report_tool_offsets();      // Print tool length offset value.
 8019692:	f7ff ff07 	bl	80194a4 <report_tool_offsets>
    report_probe_parameters();  // Print probe parameters. Not persistent in memory.
 8019696:	f7ff fea7 	bl	80193e8 <report_probe_parameters>
    if(sys.tlo_reference_set.mask) { // Print tool length reference offset. Not persistent in memory.
 801969a:	4b25      	ldr	r3, [pc, #148]	; (8019730 <report_ngc_parameters+0x178>)
 801969c:	79db      	ldrb	r3, [r3, #7]
 801969e:	b923      	cbnz	r3, 80196aa <report_ngc_parameters+0xf2>
}
 80196a0:	b004      	add	sp, #16
 80196a2:	bd70      	pop	{r4, r5, r6, pc}
        report_home_position();
 80196a4:	f7ff fed4 	bl	8019450 <report_home_position>
 80196a8:	e7f3      	b.n	8019692 <report_ngc_parameters+0xda>
        gc_get_plane_data(&plane, gc_state.modal.plane_select);
 80196aa:	4b14      	ldr	r3, [pc, #80]	; (80196fc <report_ngc_parameters+0x144>)
 80196ac:	7999      	ldrb	r1, [r3, #6]
 80196ae:	4668      	mov	r0, sp
 80196b0:	f7f5 fd26 	bl	800f100 <gc_get_plane_data>
        hal.stream.write("[TLR:");
 80196b4:	4c12      	ldr	r4, [pc, #72]	; (8019700 <report_ngc_parameters+0x148>)
 80196b6:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 80196ba:	481e      	ldr	r0, [pc, #120]	; (8019734 <report_ngc_parameters+0x17c>)
 80196bc:	4798      	blx	r3
        hal.stream.write(get_axis_value(sys.tlo_reference[plane.axis_linear] / settings.axis[plane.axis_linear].steps_per_mm));
 80196be:	f8d4 50b4 	ldr.w	r5, [r4, #180]	; 0xb4
 80196c2:	4b1d      	ldr	r3, [pc, #116]	; (8019738 <report_ngc_parameters+0x180>)
 80196c4:	6819      	ldr	r1, [r3, #0]
 80196c6:	f89d 3002 	ldrb.w	r3, [sp, #2]
 80196ca:	1c98      	adds	r0, r3, #2
 80196cc:	4a18      	ldr	r2, [pc, #96]	; (8019730 <report_ngc_parameters+0x178>)
 80196ce:	eb02 0280 	add.w	r2, r2, r0, lsl #2
 80196d2:	edd2 7a00 	vldr	s15, [r2]
 80196d6:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80196da:	4a14      	ldr	r2, [pc, #80]	; (801972c <report_ngc_parameters+0x174>)
 80196dc:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80196e0:	ed93 0a0c 	vldr	s0, [r3, #48]	; 0x30
 80196e4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80196e8:	ee87 0a80 	vdiv.f32	s0, s15, s0
 80196ec:	4788      	blx	r1
 80196ee:	47a8      	blx	r5
        hal.stream.write("]" ASCII_EOL);
 80196f0:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 80196f4:	4805      	ldr	r0, [pc, #20]	; (801970c <report_ngc_parameters+0x154>)
 80196f6:	4798      	blx	r3
 80196f8:	e7d2      	b.n	80196a0 <report_ngc_parameters+0xe8>
 80196fa:	bf00      	nop
 80196fc:	20003344 	.word	0x20003344
 8019700:	2000350c 	.word	0x2000350c
 8019704:	080275f8 	.word	0x080275f8
 8019708:	20003ac4 	.word	0x20003ac4
 801970c:	0802cde0 	.word	0x0802cde0
 8019710:	2000343c 	.word	0x2000343c
 8019714:	08027604 	.word	0x08027604
 8019718:	08027694 	.word	0x08027694
 801971c:	08027600 	.word	0x08027600
 8019720:	08027608 	.word	0x08027608
 8019724:	0802760c 	.word	0x0802760c
 8019728:	200033c0 	.word	0x200033c0
 801972c:	20003b14 	.word	0x20003b14
 8019730:	200036c4 	.word	0x200036c4
 8019734:	08027610 	.word	0x08027610
 8019738:	20003ac0 	.word	0x20003ac0

0801973c <report_gcode_modes>:
{
 801973c:	b570      	push	{r4, r5, r6, lr}
    hal.stream.write("[GC:G");
 801973e:	4b87      	ldr	r3, [pc, #540]	; (801995c <report_gcode_modes+0x220>)
 8019740:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8019744:	4886      	ldr	r0, [pc, #536]	; (8019960 <report_gcode_modes+0x224>)
 8019746:	4798      	blx	r3
    if (gc_state.modal.motion >= MotionMode_ProbeToward) {
 8019748:	4b86      	ldr	r3, [pc, #536]	; (8019964 <report_gcode_modes+0x228>)
 801974a:	8818      	ldrh	r0, [r3, #0]
 801974c:	288b      	cmp	r0, #139	; 0x8b
 801974e:	f240 8088 	bls.w	8019862 <report_gcode_modes+0x126>
        hal.stream.write("38.");
 8019752:	4c82      	ldr	r4, [pc, #520]	; (801995c <report_gcode_modes+0x220>)
 8019754:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8019758:	4883      	ldr	r0, [pc, #524]	; (8019968 <report_gcode_modes+0x22c>)
 801975a:	4798      	blx	r3
        hal.stream.write(uitoa((uint32_t)(gc_state.modal.motion - (MotionMode_ProbeToward - 2))));
 801975c:	f8d4 40b4 	ldr.w	r4, [r4, #180]	; 0xb4
 8019760:	4b80      	ldr	r3, [pc, #512]	; (8019964 <report_gcode_modes+0x228>)
 8019762:	8818      	ldrh	r0, [r3, #0]
 8019764:	388a      	subs	r0, #138	; 0x8a
 8019766:	f7fc f807 	bl	8015778 <uitoa>
 801976a:	47a0      	blx	r4
    hal.stream.write(" G");
 801976c:	4c7b      	ldr	r4, [pc, #492]	; (801995c <report_gcode_modes+0x220>)
 801976e:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8019772:	487e      	ldr	r0, [pc, #504]	; (801996c <report_gcode_modes+0x230>)
 8019774:	4798      	blx	r3
    hal.stream.write(map_coord_system(gc_state.modal.coord_system.id));
 8019776:	f8d4 40b4 	ldr.w	r4, [r4, #180]	; 0xb4
 801977a:	4b7a      	ldr	r3, [pc, #488]	; (8019964 <report_gcode_modes+0x228>)
 801977c:	7d18      	ldrb	r0, [r3, #20]
 801977e:	f7fe ff2b 	bl	80185d8 <map_coord_system>
 8019782:	47a0      	blx	r4
    uint_fast32_t idx = N_AXIS;
 8019784:	2303      	movs	r3, #3
        idx--;
 8019786:	3b01      	subs	r3, #1
        active = !(gc_state.g92_coord_offset[idx] == 0.0f || gc_state.g92_coord_offset[idx] == -0.0f);
 8019788:	f103 011e 	add.w	r1, r3, #30
 801978c:	4a75      	ldr	r2, [pc, #468]	; (8019964 <report_gcode_modes+0x228>)
 801978e:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8019792:	edd2 7a01 	vldr	s15, [r2, #4]
    } while(idx && !active);
 8019796:	b123      	cbz	r3, 80197a2 <report_gcode_modes+0x66>
 8019798:	eef5 7a40 	vcmp.f32	s15, #0.0
 801979c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80197a0:	d0f1      	beq.n	8019786 <report_gcode_modes+0x4a>
    if(is_g92_active())
 80197a2:	eef5 7a40 	vcmp.f32	s15, #0.0
 80197a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80197aa:	d004      	beq.n	80197b6 <report_gcode_modes+0x7a>
        hal.stream.write(" G92");
 80197ac:	4b6b      	ldr	r3, [pc, #428]	; (801995c <report_gcode_modes+0x220>)
 80197ae:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80197b2:	486f      	ldr	r0, [pc, #444]	; (8019970 <report_gcode_modes+0x234>)
 80197b4:	4798      	blx	r3
    if(settings.mode == Mode_Lathe)
 80197b6:	4b6f      	ldr	r3, [pc, #444]	; (8019974 <report_gcode_modes+0x238>)
 80197b8:	7e1b      	ldrb	r3, [r3, #24]
 80197ba:	2b02      	cmp	r3, #2
 80197bc:	d058      	beq.n	8019870 <report_gcode_modes+0x134>
    hal.stream.write(" G");
 80197be:	4c67      	ldr	r4, [pc, #412]	; (801995c <report_gcode_modes+0x220>)
 80197c0:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 80197c4:	4869      	ldr	r0, [pc, #420]	; (801996c <report_gcode_modes+0x230>)
 80197c6:	4798      	blx	r3
    hal.stream.write(uitoa((uint32_t)(gc_state.modal.plane_select + 17)));
 80197c8:	f8d4 60b4 	ldr.w	r6, [r4, #180]	; 0xb4
 80197cc:	4d65      	ldr	r5, [pc, #404]	; (8019964 <report_gcode_modes+0x228>)
 80197ce:	79a8      	ldrb	r0, [r5, #6]
 80197d0:	3011      	adds	r0, #17
 80197d2:	f7fb ffd1 	bl	8015778 <uitoa>
 80197d6:	47b0      	blx	r6
    hal.stream.write(gc_state.modal.units_imperial ? " G20" : " G21");
 80197d8:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 80197dc:	78ea      	ldrb	r2, [r5, #3]
 80197de:	2a00      	cmp	r2, #0
 80197e0:	d051      	beq.n	8019886 <report_gcode_modes+0x14a>
 80197e2:	4865      	ldr	r0, [pc, #404]	; (8019978 <report_gcode_modes+0x23c>)
 80197e4:	4798      	blx	r3
    hal.stream.write(gc_state.modal.distance_incremental ? " G91" : " G90");
 80197e6:	4b5d      	ldr	r3, [pc, #372]	; (801995c <report_gcode_modes+0x220>)
 80197e8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80197ec:	4a5d      	ldr	r2, [pc, #372]	; (8019964 <report_gcode_modes+0x228>)
 80197ee:	7912      	ldrb	r2, [r2, #4]
 80197f0:	2a00      	cmp	r2, #0
 80197f2:	d04a      	beq.n	801988a <report_gcode_modes+0x14e>
 80197f4:	4861      	ldr	r0, [pc, #388]	; (801997c <report_gcode_modes+0x240>)
 80197f6:	4798      	blx	r3
    hal.stream.write(" G");
 80197f8:	4c58      	ldr	r4, [pc, #352]	; (801995c <report_gcode_modes+0x220>)
 80197fa:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 80197fe:	485b      	ldr	r0, [pc, #364]	; (801996c <report_gcode_modes+0x230>)
 8019800:	4798      	blx	r3
    hal.stream.write(uitoa((uint32_t)(94 - gc_state.modal.feed_mode)));
 8019802:	f8d4 40b4 	ldr.w	r4, [r4, #180]	; 0xb4
 8019806:	4b57      	ldr	r3, [pc, #348]	; (8019964 <report_gcode_modes+0x228>)
 8019808:	7898      	ldrb	r0, [r3, #2]
 801980a:	f1c0 005e 	rsb	r0, r0, #94	; 0x5e
 801980e:	f7fb ffb3 	bl	8015778 <uitoa>
 8019812:	47a0      	blx	r4
    if(settings.mode == Mode_Lathe && gc_spindle_get()->cap.variable)
 8019814:	4b57      	ldr	r3, [pc, #348]	; (8019974 <report_gcode_modes+0x238>)
 8019816:	7e1b      	ldrb	r3, [r3, #24]
 8019818:	2b02      	cmp	r3, #2
 801981a:	d038      	beq.n	801988e <report_gcode_modes+0x152>
    if(gc_state.modal.tool_offset_mode == ToolLengthOffset_Cancel)
 801981c:	4b51      	ldr	r3, [pc, #324]	; (8019964 <report_gcode_modes+0x228>)
 801981e:	79db      	ldrb	r3, [r3, #7]
 8019820:	2b00      	cmp	r3, #0
 8019822:	d145      	bne.n	80198b0 <report_gcode_modes+0x174>
        hal.stream.write(" G49");
 8019824:	4b4d      	ldr	r3, [pc, #308]	; (801995c <report_gcode_modes+0x220>)
 8019826:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801982a:	4855      	ldr	r0, [pc, #340]	; (8019980 <report_gcode_modes+0x244>)
 801982c:	4798      	blx	r3
    hal.stream.write(gc_state.canned.retract_mode == CCRetractMode_RPos ? " G99" : " G98");
 801982e:	4b4b      	ldr	r3, [pc, #300]	; (801995c <report_gcode_modes+0x220>)
 8019830:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8019834:	4a4b      	ldr	r2, [pc, #300]	; (8019964 <report_gcode_modes+0x228>)
 8019836:	f892 2046 	ldrb.w	r2, [r2, #70]	; 0x46
 801983a:	2a01      	cmp	r2, #1
 801983c:	d04b      	beq.n	80198d6 <report_gcode_modes+0x19a>
 801983e:	4851      	ldr	r0, [pc, #324]	; (8019984 <report_gcode_modes+0x248>)
 8019840:	4798      	blx	r3
    if(gc_state.modal.scaling_active) {
 8019842:	4b48      	ldr	r3, [pc, #288]	; (8019964 <report_gcode_modes+0x228>)
 8019844:	7f9b      	ldrb	r3, [r3, #30]
 8019846:	2b00      	cmp	r3, #0
 8019848:	d07a      	beq.n	8019940 <report_gcode_modes+0x204>
        hal.stream.write(" G51:");
 801984a:	4b44      	ldr	r3, [pc, #272]	; (801995c <report_gcode_modes+0x220>)
 801984c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8019850:	484d      	ldr	r0, [pc, #308]	; (8019988 <report_gcode_modes+0x24c>)
 8019852:	4798      	blx	r3
        axis_signals_tostring(buf, gc_get_g51_state());
 8019854:	f7f5 fb92 	bl	800ef7c <gc_get_g51_state>
    signals.mask &= AXES_BITMASK;
 8019858:	f000 0007 	and.w	r0, r0, #7
    uint_fast16_t idx = 0;
 801985c:	2200      	movs	r2, #0
    while(signals.mask) {
 801985e:	4b4b      	ldr	r3, [pc, #300]	; (801998c <report_gcode_modes+0x250>)
 8019860:	e03e      	b.n	80198e0 <report_gcode_modes+0x1a4>
        hal.stream.write(uitoa((uint32_t)gc_state.modal.motion));
 8019862:	4b3e      	ldr	r3, [pc, #248]	; (801995c <report_gcode_modes+0x220>)
 8019864:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8019868:	f7fb ff86 	bl	8015778 <uitoa>
 801986c:	47a0      	blx	r4
 801986e:	e77d      	b.n	801976c <report_gcode_modes+0x30>
        hal.stream.write(gc_state.modal.diameter_mode ? " G7" : " G8");
 8019870:	4b3a      	ldr	r3, [pc, #232]	; (801995c <report_gcode_modes+0x220>)
 8019872:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8019876:	4a3b      	ldr	r2, [pc, #236]	; (8019964 <report_gcode_modes+0x228>)
 8019878:	7952      	ldrb	r2, [r2, #5]
 801987a:	b112      	cbz	r2, 8019882 <report_gcode_modes+0x146>
 801987c:	4844      	ldr	r0, [pc, #272]	; (8019990 <report_gcode_modes+0x254>)
 801987e:	4798      	blx	r3
 8019880:	e79d      	b.n	80197be <report_gcode_modes+0x82>
 8019882:	4844      	ldr	r0, [pc, #272]	; (8019994 <report_gcode_modes+0x258>)
 8019884:	e7fb      	b.n	801987e <report_gcode_modes+0x142>
    hal.stream.write(gc_state.modal.units_imperial ? " G20" : " G21");
 8019886:	4844      	ldr	r0, [pc, #272]	; (8019998 <report_gcode_modes+0x25c>)
 8019888:	e7ac      	b.n	80197e4 <report_gcode_modes+0xa8>
    hal.stream.write(gc_state.modal.distance_incremental ? " G91" : " G90");
 801988a:	4844      	ldr	r0, [pc, #272]	; (801999c <report_gcode_modes+0x260>)
 801988c:	e7b3      	b.n	80197f6 <report_gcode_modes+0xba>
    if(settings.mode == Mode_Lathe && gc_spindle_get()->cap.variable)
 801988e:	f7f5 fcff 	bl	800f290 <gc_spindle_get>
 8019892:	7a43      	ldrb	r3, [r0, #9]
 8019894:	f013 0f01 	tst.w	r3, #1
 8019898:	d0c0      	beq.n	801981c <report_gcode_modes+0xe0>
        hal.stream.write(gc_state.modal.spindle.rpm_mode == SpindleSpeedMode_RPM ? " G97" : " G96");
 801989a:	4b30      	ldr	r3, [pc, #192]	; (801995c <report_gcode_modes+0x220>)
 801989c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80198a0:	4a30      	ldr	r2, [pc, #192]	; (8019964 <report_gcode_modes+0x228>)
 80198a2:	7ed2      	ldrb	r2, [r2, #27]
 80198a4:	b912      	cbnz	r2, 80198ac <report_gcode_modes+0x170>
 80198a6:	483e      	ldr	r0, [pc, #248]	; (80199a0 <report_gcode_modes+0x264>)
 80198a8:	4798      	blx	r3
 80198aa:	e7b7      	b.n	801981c <report_gcode_modes+0xe0>
 80198ac:	483d      	ldr	r0, [pc, #244]	; (80199a4 <report_gcode_modes+0x268>)
 80198ae:	e7fb      	b.n	80198a8 <report_gcode_modes+0x16c>
        hal.stream.write(" G43");
 80198b0:	4b2a      	ldr	r3, [pc, #168]	; (801995c <report_gcode_modes+0x220>)
 80198b2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80198b6:	483c      	ldr	r0, [pc, #240]	; (80199a8 <report_gcode_modes+0x26c>)
 80198b8:	4798      	blx	r3
        if(gc_state.modal.tool_offset_mode != ToolLengthOffset_Enable)
 80198ba:	4b2a      	ldr	r3, [pc, #168]	; (8019964 <report_gcode_modes+0x228>)
 80198bc:	79db      	ldrb	r3, [r3, #7]
 80198be:	2b01      	cmp	r3, #1
 80198c0:	d0b5      	beq.n	801982e <report_gcode_modes+0xf2>
            hal.stream.write(gc_state.modal.tool_offset_mode == ToolLengthOffset_EnableDynamic ? ".1" : ".2");
 80198c2:	4a26      	ldr	r2, [pc, #152]	; (801995c <report_gcode_modes+0x220>)
 80198c4:	f8d2 20b4 	ldr.w	r2, [r2, #180]	; 0xb4
 80198c8:	2b02      	cmp	r3, #2
 80198ca:	d002      	beq.n	80198d2 <report_gcode_modes+0x196>
 80198cc:	4837      	ldr	r0, [pc, #220]	; (80199ac <report_gcode_modes+0x270>)
 80198ce:	4790      	blx	r2
 80198d0:	e7ad      	b.n	801982e <report_gcode_modes+0xf2>
 80198d2:	4837      	ldr	r0, [pc, #220]	; (80199b0 <report_gcode_modes+0x274>)
 80198d4:	e7fb      	b.n	80198ce <report_gcode_modes+0x192>
    hal.stream.write(gc_state.canned.retract_mode == CCRetractMode_RPos ? " G99" : " G98");
 80198d6:	4837      	ldr	r0, [pc, #220]	; (80199b4 <report_gcode_modes+0x278>)
 80198d8:	e7b2      	b.n	8019840 <report_gcode_modes+0x104>
        idx++;
 80198da:	3201      	adds	r2, #1
        signals.mask >>= 1;
 80198dc:	f3c0 0047 	ubfx	r0, r0, #1, #8
    while(signals.mask) {
 80198e0:	b2c0      	uxtb	r0, r0
 80198e2:	b148      	cbz	r0, 80198f8 <report_gcode_modes+0x1bc>
        if(signals.mask & 0x01)
 80198e4:	f010 0f01 	tst.w	r0, #1
 80198e8:	d0f7      	beq.n	80198da <report_gcode_modes+0x19e>
            *buf++ = *axis_letter[idx];
 80198ea:	4933      	ldr	r1, [pc, #204]	; (80199b8 <report_gcode_modes+0x27c>)
 80198ec:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
 80198f0:	7809      	ldrb	r1, [r1, #0]
 80198f2:	f803 1b01 	strb.w	r1, [r3], #1
 80198f6:	e7f0      	b.n	80198da <report_gcode_modes+0x19e>
    *buf = '\0';
 80198f8:	2200      	movs	r2, #0
 80198fa:	701a      	strb	r2, [r3, #0]
        hal.stream.write(buf);
 80198fc:	4b17      	ldr	r3, [pc, #92]	; (801995c <report_gcode_modes+0x220>)
 80198fe:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8019902:	4822      	ldr	r0, [pc, #136]	; (801998c <report_gcode_modes+0x250>)
 8019904:	4798      	blx	r3
    if (gc_state.modal.program_flow) {
 8019906:	4b17      	ldr	r3, [pc, #92]	; (8019964 <report_gcode_modes+0x228>)
 8019908:	7e1b      	ldrb	r3, [r3, #24]
 801990a:	2b00      	cmp	r3, #0
 801990c:	d05f      	beq.n	80199ce <report_gcode_modes+0x292>
        switch (gc_state.modal.program_flow) {
 801990e:	2b1e      	cmp	r3, #30
 8019910:	d81c      	bhi.n	801994c <report_gcode_modes+0x210>
 8019912:	b25a      	sxtb	r2, r3
 8019914:	2a00      	cmp	r2, #0
 8019916:	d05a      	beq.n	80199ce <report_gcode_modes+0x292>
 8019918:	3b01      	subs	r3, #1
 801991a:	2b1d      	cmp	r3, #29
 801991c:	d857      	bhi.n	80199ce <report_gcode_modes+0x292>
 801991e:	e8df f003 	tbb	[pc, r3]
 8019922:	6963      	.short	0x6963
 8019924:	56565651 	.word	0x56565651
 8019928:	56565656 	.word	0x56565656
 801992c:	56565656 	.word	0x56565656
 8019930:	56565656 	.word	0x56565656
 8019934:	56565656 	.word	0x56565656
 8019938:	56565656 	.word	0x56565656
 801993c:	6f565656 	.word	0x6f565656
        hal.stream.write(" G50");
 8019940:	4b06      	ldr	r3, [pc, #24]	; (801995c <report_gcode_modes+0x220>)
 8019942:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8019946:	481d      	ldr	r0, [pc, #116]	; (80199bc <report_gcode_modes+0x280>)
 8019948:	4798      	blx	r3
 801994a:	e7dc      	b.n	8019906 <report_gcode_modes+0x1ca>
        switch (gc_state.modal.program_flow) {
 801994c:	2b3c      	cmp	r3, #60	; 0x3c
 801994e:	d13e      	bne.n	80199ce <report_gcode_modes+0x292>
                hal.stream.write(" M60");
 8019950:	4b02      	ldr	r3, [pc, #8]	; (801995c <report_gcode_modes+0x220>)
 8019952:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8019956:	481a      	ldr	r0, [pc, #104]	; (80199c0 <report_gcode_modes+0x284>)
 8019958:	4798      	blx	r3
                break;
 801995a:	e038      	b.n	80199ce <report_gcode_modes+0x292>
 801995c:	2000350c 	.word	0x2000350c
 8019960:	08027668 	.word	0x08027668
 8019964:	20003344 	.word	0x20003344
 8019968:	08027670 	.word	0x08027670
 801996c:	08027674 	.word	0x08027674
 8019970:	08027678 	.word	0x08027678
 8019974:	20003b14 	.word	0x20003b14
 8019978:	08027620 	.word	0x08027620
 801997c:	08027630 	.word	0x08027630
 8019980:	08027680 	.word	0x08027680
 8019984:	08027660 	.word	0x08027660
 8019988:	08027690 	.word	0x08027690
 801998c:	20003a88 	.word	0x20003a88
 8019990:	08027618 	.word	0x08027618
 8019994:	0802761c 	.word	0x0802761c
 8019998:	08027628 	.word	0x08027628
 801999c:	08027638 	.word	0x08027638
 80199a0:	08027640 	.word	0x08027640
 80199a4:	08027648 	.word	0x08027648
 80199a8:	08027688 	.word	0x08027688
 80199ac:	08027654 	.word	0x08027654
 80199b0:	08027650 	.word	0x08027650
 80199b4:	08027658 	.word	0x08027658
 80199b8:	080271cc 	.word	0x080271cc
 80199bc:	08027698 	.word	0x08027698
 80199c0:	080276b4 	.word	0x080276b4
                hal.stream.write(" M0");
 80199c4:	4b5a      	ldr	r3, [pc, #360]	; (8019b30 <report_gcode_modes+0x3f4>)
 80199c6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80199ca:	485a      	ldr	r0, [pc, #360]	; (8019b34 <report_gcode_modes+0x3f8>)
 80199cc:	4798      	blx	r3
    hal.stream.write(gc_state.modal.spindle.state.on ? (gc_state.modal.spindle.state.ccw ? " M4" : " M3") : " M5");
 80199ce:	4b58      	ldr	r3, [pc, #352]	; (8019b30 <report_gcode_modes+0x3f4>)
 80199d0:	f8d3 20b4 	ldr.w	r2, [r3, #180]	; 0xb4
 80199d4:	4b58      	ldr	r3, [pc, #352]	; (8019b38 <report_gcode_modes+0x3fc>)
 80199d6:	7e9b      	ldrb	r3, [r3, #26]
 80199d8:	f013 0f01 	tst.w	r3, #1
 80199dc:	d016      	beq.n	8019a0c <report_gcode_modes+0x2d0>
 80199de:	f013 0f02 	tst.w	r3, #2
 80199e2:	d034      	beq.n	8019a4e <report_gcode_modes+0x312>
 80199e4:	4855      	ldr	r0, [pc, #340]	; (8019b3c <report_gcode_modes+0x400>)
 80199e6:	e012      	b.n	8019a0e <report_gcode_modes+0x2d2>
                hal.stream.write(" M1");
 80199e8:	4b51      	ldr	r3, [pc, #324]	; (8019b30 <report_gcode_modes+0x3f4>)
 80199ea:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80199ee:	4854      	ldr	r0, [pc, #336]	; (8019b40 <report_gcode_modes+0x404>)
 80199f0:	4798      	blx	r3
                break;
 80199f2:	e7ec      	b.n	80199ce <report_gcode_modes+0x292>
                hal.stream.write(" M2");
 80199f4:	4b4e      	ldr	r3, [pc, #312]	; (8019b30 <report_gcode_modes+0x3f4>)
 80199f6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80199fa:	4852      	ldr	r0, [pc, #328]	; (8019b44 <report_gcode_modes+0x408>)
 80199fc:	4798      	blx	r3
                break;
 80199fe:	e7e6      	b.n	80199ce <report_gcode_modes+0x292>
                hal.stream.write(" M30");
 8019a00:	4b4b      	ldr	r3, [pc, #300]	; (8019b30 <report_gcode_modes+0x3f4>)
 8019a02:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8019a06:	4850      	ldr	r0, [pc, #320]	; (8019b48 <report_gcode_modes+0x40c>)
 8019a08:	4798      	blx	r3
                break;
 8019a0a:	e7e0      	b.n	80199ce <report_gcode_modes+0x292>
    hal.stream.write(gc_state.modal.spindle.state.on ? (gc_state.modal.spindle.state.ccw ? " M4" : " M3") : " M5");
 8019a0c:	484f      	ldr	r0, [pc, #316]	; (8019b4c <report_gcode_modes+0x410>)
 8019a0e:	4790      	blx	r2
    if(gc_state.tool_change)
 8019a10:	4b49      	ldr	r3, [pc, #292]	; (8019b38 <report_gcode_modes+0x3fc>)
 8019a12:	f893 3077 	ldrb.w	r3, [r3, #119]	; 0x77
 8019a16:	b123      	cbz	r3, 8019a22 <report_gcode_modes+0x2e6>
        hal.stream.write(" M6");
 8019a18:	4b45      	ldr	r3, [pc, #276]	; (8019b30 <report_gcode_modes+0x3f4>)
 8019a1a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8019a1e:	484c      	ldr	r0, [pc, #304]	; (8019b50 <report_gcode_modes+0x414>)
 8019a20:	4798      	blx	r3
    if (gc_state.modal.coolant.value) {
 8019a22:	4b45      	ldr	r3, [pc, #276]	; (8019b38 <report_gcode_modes+0x3fc>)
 8019a24:	7e5b      	ldrb	r3, [r3, #25]
 8019a26:	b1a3      	cbz	r3, 8019a52 <report_gcode_modes+0x316>
        if (gc_state.modal.coolant.mist)
 8019a28:	f013 0f02 	tst.w	r3, #2
 8019a2c:	d004      	beq.n	8019a38 <report_gcode_modes+0x2fc>
             hal.stream.write(" M7");
 8019a2e:	4b40      	ldr	r3, [pc, #256]	; (8019b30 <report_gcode_modes+0x3f4>)
 8019a30:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8019a34:	4847      	ldr	r0, [pc, #284]	; (8019b54 <report_gcode_modes+0x418>)
 8019a36:	4798      	blx	r3
        if (gc_state.modal.coolant.flood)
 8019a38:	4b3f      	ldr	r3, [pc, #252]	; (8019b38 <report_gcode_modes+0x3fc>)
 8019a3a:	7e5b      	ldrb	r3, [r3, #25]
 8019a3c:	f013 0f01 	tst.w	r3, #1
 8019a40:	d00c      	beq.n	8019a5c <report_gcode_modes+0x320>
            hal.stream.write(" M8");
 8019a42:	4b3b      	ldr	r3, [pc, #236]	; (8019b30 <report_gcode_modes+0x3f4>)
 8019a44:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8019a48:	4843      	ldr	r0, [pc, #268]	; (8019b58 <report_gcode_modes+0x41c>)
 8019a4a:	4798      	blx	r3
 8019a4c:	e006      	b.n	8019a5c <report_gcode_modes+0x320>
    hal.stream.write(gc_state.modal.spindle.state.on ? (gc_state.modal.spindle.state.ccw ? " M4" : " M3") : " M5");
 8019a4e:	4843      	ldr	r0, [pc, #268]	; (8019b5c <report_gcode_modes+0x420>)
 8019a50:	e7dd      	b.n	8019a0e <report_gcode_modes+0x2d2>
        hal.stream.write(" M9");
 8019a52:	4b37      	ldr	r3, [pc, #220]	; (8019b30 <report_gcode_modes+0x3f4>)
 8019a54:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8019a58:	4841      	ldr	r0, [pc, #260]	; (8019b60 <report_gcode_modes+0x424>)
 8019a5a:	4798      	blx	r3
    if (sys.override.control.feed_rate_disable)
 8019a5c:	4b41      	ldr	r3, [pc, #260]	; (8019b64 <report_gcode_modes+0x428>)
 8019a5e:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8019a62:	f013 0f01 	tst.w	r3, #1
 8019a66:	d004      	beq.n	8019a72 <report_gcode_modes+0x336>
        hal.stream.write(" M50");
 8019a68:	4b31      	ldr	r3, [pc, #196]	; (8019b30 <report_gcode_modes+0x3f4>)
 8019a6a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8019a6e:	483e      	ldr	r0, [pc, #248]	; (8019b68 <report_gcode_modes+0x42c>)
 8019a70:	4798      	blx	r3
    if (sys.override.control.spindle_rpm_disable)
 8019a72:	4b3c      	ldr	r3, [pc, #240]	; (8019b64 <report_gcode_modes+0x428>)
 8019a74:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8019a78:	f013 0f04 	tst.w	r3, #4
 8019a7c:	d004      	beq.n	8019a88 <report_gcode_modes+0x34c>
        hal.stream.write(" M51");
 8019a7e:	4b2c      	ldr	r3, [pc, #176]	; (8019b30 <report_gcode_modes+0x3f4>)
 8019a80:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8019a84:	4839      	ldr	r0, [pc, #228]	; (8019b6c <report_gcode_modes+0x430>)
 8019a86:	4798      	blx	r3
    if (sys.override.control.feed_hold_disable)
 8019a88:	4b36      	ldr	r3, [pc, #216]	; (8019b64 <report_gcode_modes+0x428>)
 8019a8a:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8019a8e:	f013 0f02 	tst.w	r3, #2
 8019a92:	d004      	beq.n	8019a9e <report_gcode_modes+0x362>
        hal.stream.write(" M53");
 8019a94:	4b26      	ldr	r3, [pc, #152]	; (8019b30 <report_gcode_modes+0x3f4>)
 8019a96:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8019a9a:	4835      	ldr	r0, [pc, #212]	; (8019b70 <report_gcode_modes+0x434>)
 8019a9c:	4798      	blx	r3
    if (settings.parking.flags.enable_override_control && sys.override.control.parking_disable)
 8019a9e:	4b35      	ldr	r3, [pc, #212]	; (8019b74 <report_gcode_modes+0x438>)
 8019aa0:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 8019aa4:	f013 0f04 	tst.w	r3, #4
 8019aa8:	d00a      	beq.n	8019ac0 <report_gcode_modes+0x384>
 8019aaa:	4b2e      	ldr	r3, [pc, #184]	; (8019b64 <report_gcode_modes+0x428>)
 8019aac:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8019ab0:	f013 0f08 	tst.w	r3, #8
 8019ab4:	d004      	beq.n	8019ac0 <report_gcode_modes+0x384>
        hal.stream.write(" M56");
 8019ab6:	4b1e      	ldr	r3, [pc, #120]	; (8019b30 <report_gcode_modes+0x3f4>)
 8019ab8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8019abc:	482e      	ldr	r0, [pc, #184]	; (8019b78 <report_gcode_modes+0x43c>)
 8019abe:	4798      	blx	r3
    hal.stream.write(appendbuf(2, " T", uitoa((uint32_t)gc_state.tool->tool_id)));
 8019ac0:	4d1b      	ldr	r5, [pc, #108]	; (8019b30 <report_gcode_modes+0x3f4>)
 8019ac2:	f8d5 60b4 	ldr.w	r6, [r5, #180]	; 0xb4
 8019ac6:	4c1c      	ldr	r4, [pc, #112]	; (8019b38 <report_gcode_modes+0x3fc>)
 8019ac8:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 8019acc:	6918      	ldr	r0, [r3, #16]
 8019ace:	f7fb fe53 	bl	8015778 <uitoa>
 8019ad2:	4602      	mov	r2, r0
 8019ad4:	4929      	ldr	r1, [pc, #164]	; (8019b7c <report_gcode_modes+0x440>)
 8019ad6:	2002      	movs	r0, #2
 8019ad8:	f7fe fda4 	bl	8018624 <appendbuf>
 8019adc:	47b0      	blx	r6
    hal.stream.write(appendbuf(2, " F", get_rate_value(gc_state.feed_rate)));
 8019ade:	f8d5 50b4 	ldr.w	r5, [r5, #180]	; 0xb4
 8019ae2:	4b27      	ldr	r3, [pc, #156]	; (8019b80 <report_gcode_modes+0x444>)
 8019ae4:	681b      	ldr	r3, [r3, #0]
 8019ae6:	ed94 0a16 	vldr	s0, [r4, #88]	; 0x58
 8019aea:	4798      	blx	r3
 8019aec:	4602      	mov	r2, r0
 8019aee:	4925      	ldr	r1, [pc, #148]	; (8019b84 <report_gcode_modes+0x448>)
 8019af0:	2002      	movs	r0, #2
 8019af2:	f7fe fd97 	bl	8018624 <appendbuf>
 8019af6:	47a8      	blx	r5
    if(gc_spindle_get()->cap.variable)
 8019af8:	f7f5 fbca 	bl	800f290 <gc_spindle_get>
 8019afc:	7a43      	ldrb	r3, [r0, #9]
 8019afe:	f013 0f01 	tst.w	r3, #1
 8019b02:	d105      	bne.n	8019b10 <report_gcode_modes+0x3d4>
    hal.stream.write("]" ASCII_EOL);
 8019b04:	4b0a      	ldr	r3, [pc, #40]	; (8019b30 <report_gcode_modes+0x3f4>)
 8019b06:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8019b0a:	481f      	ldr	r0, [pc, #124]	; (8019b88 <report_gcode_modes+0x44c>)
 8019b0c:	4798      	blx	r3
}
 8019b0e:	bd70      	pop	{r4, r5, r6, pc}
        hal.stream.write(appendbuf(2, " S", ftoa(gc_state.spindle.rpm, N_DECIMAL_RPMVALUE)));
 8019b10:	4b07      	ldr	r3, [pc, #28]	; (8019b30 <report_gcode_modes+0x3f4>)
 8019b12:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8019b16:	2000      	movs	r0, #0
 8019b18:	4b07      	ldr	r3, [pc, #28]	; (8019b38 <report_gcode_modes+0x3fc>)
 8019b1a:	ed93 0a12 	vldr	s0, [r3, #72]	; 0x48
 8019b1e:	f7fb fe4d 	bl	80157bc <ftoa>
 8019b22:	4602      	mov	r2, r0
 8019b24:	4919      	ldr	r1, [pc, #100]	; (8019b8c <report_gcode_modes+0x450>)
 8019b26:	2002      	movs	r0, #2
 8019b28:	f7fe fd7c 	bl	8018624 <appendbuf>
 8019b2c:	47a0      	blx	r4
 8019b2e:	e7e9      	b.n	8019b04 <report_gcode_modes+0x3c8>
 8019b30:	2000350c 	.word	0x2000350c
 8019b34:	080276a0 	.word	0x080276a0
 8019b38:	20003344 	.word	0x20003344
 8019b3c:	08028010 	.word	0x08028010
 8019b40:	080276a4 	.word	0x080276a4
 8019b44:	080276a8 	.word	0x080276a8
 8019b48:	080276ac 	.word	0x080276ac
 8019b4c:	08028018 	.word	0x08028018
 8019b50:	08028020 	.word	0x08028020
 8019b54:	08028028 	.word	0x08028028
 8019b58:	080276bc 	.word	0x080276bc
 8019b5c:	08028008 	.word	0x08028008
 8019b60:	080276c0 	.word	0x080276c0
 8019b64:	200036c4 	.word	0x200036c4
 8019b68:	080276c4 	.word	0x080276c4
 8019b6c:	080276cc 	.word	0x080276cc
 8019b70:	080276d4 	.word	0x080276d4
 8019b74:	20003b14 	.word	0x20003b14
 8019b78:	080276dc 	.word	0x080276dc
 8019b7c:	080276e4 	.word	0x080276e4
 8019b80:	20003ac8 	.word	0x20003ac8
 8019b84:	080276e8 	.word	0x080276e8
 8019b88:	0802cde0 	.word	0x0802cde0
 8019b8c:	080276ec 	.word	0x080276ec

08019b90 <report_startup_line>:
{
 8019b90:	b570      	push	{r4, r5, r6, lr}
 8019b92:	460d      	mov	r5, r1
    hal.stream.write(appendbuf(3, "$N", uitoa((uint32_t)n), "="));
 8019b94:	4c0a      	ldr	r4, [pc, #40]	; (8019bc0 <report_startup_line+0x30>)
 8019b96:	f8d4 60b4 	ldr.w	r6, [r4, #180]	; 0xb4
 8019b9a:	f7fb fded 	bl	8015778 <uitoa>
 8019b9e:	4602      	mov	r2, r0
 8019ba0:	4b08      	ldr	r3, [pc, #32]	; (8019bc4 <report_startup_line+0x34>)
 8019ba2:	4909      	ldr	r1, [pc, #36]	; (8019bc8 <report_startup_line+0x38>)
 8019ba4:	2003      	movs	r0, #3
 8019ba6:	f7fe fd3d 	bl	8018624 <appendbuf>
 8019baa:	47b0      	blx	r6
    hal.stream.write(line);
 8019bac:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8019bb0:	4628      	mov	r0, r5
 8019bb2:	4798      	blx	r3
    hal.stream.write(ASCII_EOL);
 8019bb4:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8019bb8:	4804      	ldr	r0, [pc, #16]	; (8019bcc <report_startup_line+0x3c>)
 8019bba:	4798      	blx	r3
}
 8019bbc:	bd70      	pop	{r4, r5, r6, pc}
 8019bbe:	bf00      	nop
 8019bc0:	2000350c 	.word	0x2000350c
 8019bc4:	080275b0 	.word	0x080275b0
 8019bc8:	080276f0 	.word	0x080276f0
 8019bcc:	080279c0 	.word	0x080279c0

08019bd0 <report_execute_startup_message>:
{
 8019bd0:	b570      	push	{r4, r5, r6, lr}
 8019bd2:	4606      	mov	r6, r0
 8019bd4:	460c      	mov	r4, r1
    hal.stream.write(">");
 8019bd6:	4d09      	ldr	r5, [pc, #36]	; (8019bfc <report_execute_startup_message+0x2c>)
 8019bd8:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8019bdc:	4808      	ldr	r0, [pc, #32]	; (8019c00 <report_execute_startup_message+0x30>)
 8019bde:	4798      	blx	r3
    hal.stream.write(line);
 8019be0:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8019be4:	4630      	mov	r0, r6
 8019be6:	4798      	blx	r3
    hal.stream.write(":");
 8019be8:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8019bec:	4805      	ldr	r0, [pc, #20]	; (8019c04 <report_execute_startup_message+0x34>)
 8019bee:	4798      	blx	r3
    grbl.report.status_message(status_code);
 8019bf0:	4b05      	ldr	r3, [pc, #20]	; (8019c08 <report_execute_startup_message+0x38>)
 8019bf2:	689b      	ldr	r3, [r3, #8]
 8019bf4:	4620      	mov	r0, r4
 8019bf6:	4798      	blx	r3
}
 8019bf8:	bd70      	pop	{r4, r5, r6, pc}
 8019bfa:	bf00      	nop
 8019bfc:	2000350c 	.word	0x2000350c
 8019c00:	080276f4 	.word	0x080276f4
 8019c04:	08027694 	.word	0x08027694
 8019c08:	2000343c 	.word	0x2000343c

08019c0c <report_build_info>:
{
 8019c0c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8019c0e:	b09b      	sub	sp, #108	; 0x6c
 8019c10:	4605      	mov	r5, r0
    hal.stream.write("[VER:" GRBL_VERSION ".");
 8019c12:	4c75      	ldr	r4, [pc, #468]	; (8019de8 <report_build_info+0x1dc>)
 8019c14:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8019c18:	4874      	ldr	r0, [pc, #464]	; (8019dec <report_build_info+0x1e0>)
 8019c1a:	4798      	blx	r3
    hal.stream.write(uitoa(GRBL_BUILD));
 8019c1c:	f8d4 60b4 	ldr.w	r6, [r4, #180]	; 0xb4
 8019c20:	4873      	ldr	r0, [pc, #460]	; (8019df0 <report_build_info+0x1e4>)
 8019c22:	f7fb fda9 	bl	8015778 <uitoa>
 8019c26:	47b0      	blx	r6
    hal.stream.write(":");
 8019c28:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8019c2c:	4871      	ldr	r0, [pc, #452]	; (8019df4 <report_build_info+0x1e8>)
 8019c2e:	4798      	blx	r3
    hal.stream.write(line);
 8019c30:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8019c34:	4628      	mov	r0, r5
 8019c36:	4798      	blx	r3
    hal.stream.write("]" ASCII_EOL);
 8019c38:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8019c3c:	486e      	ldr	r0, [pc, #440]	; (8019df8 <report_build_info+0x1ec>)
 8019c3e:	4798      	blx	r3
    strcpy(buf, "[OPT:");
 8019c40:	4b6e      	ldr	r3, [pc, #440]	; (8019dfc <report_build_info+0x1f0>)
 8019c42:	e893 0003 	ldmia.w	r3, {r0, r1}
 8019c46:	9001      	str	r0, [sp, #4]
 8019c48:	f8ad 1008 	strh.w	r1, [sp, #8]
    if(spindle_get_caps(false).variable)
 8019c4c:	2000      	movs	r0, #0
 8019c4e:	f003 fdc7 	bl	801d7e0 <spindle_get_caps>
 8019c52:	f010 0f01 	tst.w	r0, #1
 8019c56:	f000 80c4 	beq.w	8019de2 <report_build_info+0x1d6>
        *append++ = 'V';
 8019c5a:	2356      	movs	r3, #86	; 0x56
 8019c5c:	f88d 3009 	strb.w	r3, [sp, #9]
 8019c60:	f10d 020a 	add.w	r2, sp, #10
    *append++ = 'N';
 8019c64:	4613      	mov	r3, r2
 8019c66:	214e      	movs	r1, #78	; 0x4e
 8019c68:	f803 1b01 	strb.w	r1, [r3], #1
    if(hal.driver_cap.mist_control)
 8019c6c:	495e      	ldr	r1, [pc, #376]	; (8019de8 <report_build_info+0x1dc>)
 8019c6e:	f891 11a4 	ldrb.w	r1, [r1, #420]	; 0x1a4
 8019c72:	f011 0f01 	tst.w	r1, #1
 8019c76:	d002      	beq.n	8019c7e <report_build_info+0x72>
        *append++ = 'M';
 8019c78:	1c93      	adds	r3, r2, #2
 8019c7a:	214d      	movs	r1, #77	; 0x4d
 8019c7c:	7051      	strb	r1, [r2, #1]
    if(settings.parking.flags.enabled)
 8019c7e:	4a60      	ldr	r2, [pc, #384]	; (8019e00 <report_build_info+0x1f4>)
 8019c80:	f892 2128 	ldrb.w	r2, [r2, #296]	; 0x128
 8019c84:	f012 0f01 	tst.w	r2, #1
 8019c88:	d002      	beq.n	8019c90 <report_build_info+0x84>
        *append++ = 'P';
 8019c8a:	2250      	movs	r2, #80	; 0x50
 8019c8c:	f803 2b01 	strb.w	r2, [r3], #1
    if(settings.homing.flags.force_set_origin)
 8019c90:	4a5b      	ldr	r2, [pc, #364]	; (8019e00 <report_build_info+0x1f4>)
 8019c92:	f892 2114 	ldrb.w	r2, [r2, #276]	; 0x114
 8019c96:	f012 0f08 	tst.w	r2, #8
 8019c9a:	d002      	beq.n	8019ca2 <report_build_info+0x96>
        *append++ = 'Z';
 8019c9c:	225a      	movs	r2, #90	; 0x5a
 8019c9e:	f803 2b01 	strb.w	r2, [r3], #1
    if(settings.homing.flags.single_axis_commands)
 8019ca2:	4a57      	ldr	r2, [pc, #348]	; (8019e00 <report_build_info+0x1f4>)
 8019ca4:	f892 2114 	ldrb.w	r2, [r2, #276]	; 0x114
 8019ca8:	f012 0f02 	tst.w	r2, #2
 8019cac:	d002      	beq.n	8019cb4 <report_build_info+0xa8>
        *append++ = 'H';
 8019cae:	2248      	movs	r2, #72	; 0x48
 8019cb0:	f803 2b01 	strb.w	r2, [r3], #1
    if(settings.limits.flags.two_switches)
 8019cb4:	4a52      	ldr	r2, [pc, #328]	; (8019e00 <report_build_info+0x1f4>)
 8019cb6:	f892 2124 	ldrb.w	r2, [r2, #292]	; 0x124
 8019cba:	f012 0f10 	tst.w	r2, #16
 8019cbe:	d002      	beq.n	8019cc6 <report_build_info+0xba>
        *append++ = 'T';
 8019cc0:	2254      	movs	r2, #84	; 0x54
 8019cc2:	f803 2b01 	strb.w	r2, [r3], #1
    if(settings.probe.allow_feed_override)
 8019cc6:	4a4e      	ldr	r2, [pc, #312]	; (8019e00 <report_build_info+0x1f4>)
 8019cc8:	f892 2100 	ldrb.w	r2, [r2, #256]	; 0x100
 8019ccc:	f012 0f10 	tst.w	r2, #16
 8019cd0:	d002      	beq.n	8019cd8 <report_build_info+0xcc>
        *append++ = 'A';
 8019cd2:	2241      	movs	r2, #65	; 0x41
 8019cd4:	f803 2b01 	strb.w	r2, [r3], #1
    if(settings.spindle.flags.enable_rpm_controlled)
 8019cd8:	4a49      	ldr	r2, [pc, #292]	; (8019e00 <report_build_info+0x1f4>)
 8019cda:	f892 20e7 	ldrb.w	r2, [r2, #231]	; 0xe7
 8019cde:	f012 0f01 	tst.w	r2, #1
 8019ce2:	d002      	beq.n	8019cea <report_build_info+0xde>
        *append++ = '0';
 8019ce4:	2230      	movs	r2, #48	; 0x30
 8019ce6:	f803 2b01 	strb.w	r2, [r3], #1
    if(hal.driver_cap.software_debounce)
 8019cea:	4a3f      	ldr	r2, [pc, #252]	; (8019de8 <report_build_info+0x1dc>)
 8019cec:	f892 21a4 	ldrb.w	r2, [r2, #420]	; 0x1a4
 8019cf0:	f012 0f02 	tst.w	r2, #2
 8019cf4:	d002      	beq.n	8019cfc <report_build_info+0xf0>
        *append++ = 'S';
 8019cf6:	2253      	movs	r2, #83	; 0x53
 8019cf8:	f803 2b01 	strb.w	r2, [r3], #1
    if(settings.parking.flags.enable_override_control)
 8019cfc:	4a40      	ldr	r2, [pc, #256]	; (8019e00 <report_build_info+0x1f4>)
 8019cfe:	f892 2128 	ldrb.w	r2, [r2, #296]	; 0x128
 8019d02:	f012 0f04 	tst.w	r2, #4
 8019d06:	d002      	beq.n	8019d0e <report_build_info+0x102>
        *append++ = 'R';
 8019d08:	2252      	movs	r2, #82	; 0x52
 8019d0a:	f803 2b01 	strb.w	r2, [r3], #1
    if(!settings.homing.flags.init_lock)
 8019d0e:	4a3c      	ldr	r2, [pc, #240]	; (8019e00 <report_build_info+0x1f4>)
 8019d10:	f892 2114 	ldrb.w	r2, [r2, #276]	; 0x114
 8019d14:	f012 0f04 	tst.w	r2, #4
 8019d18:	d102      	bne.n	8019d20 <report_build_info+0x114>
        *append++ = 'L';
 8019d1a:	224c      	movs	r2, #76	; 0x4c
 8019d1c:	f803 2b01 	strb.w	r2, [r3], #1
    if(hal.signals_cap.safety_door_ajar)
 8019d20:	4a31      	ldr	r2, [pc, #196]	; (8019de8 <report_build_info+0x1dc>)
 8019d22:	f892 21a8 	ldrb.w	r2, [r2, #424]	; 0x1a8
 8019d26:	f012 0f08 	tst.w	r2, #8
 8019d2a:	d002      	beq.n	8019d32 <report_build_info+0x126>
        *append++ = '+';
 8019d2c:	222b      	movs	r2, #43	; 0x2b
 8019d2e:	f803 2b01 	strb.w	r2, [r3], #1
    if(!settings.status_report.sync_on_wco_change) // NOTE: Shown when disabled.
 8019d32:	4a33      	ldr	r2, [pc, #204]	; (8019e00 <report_build_info+0x1f4>)
 8019d34:	f892 20fd 	ldrb.w	r2, [r2, #253]	; 0xfd
 8019d38:	f012 0f01 	tst.w	r2, #1
 8019d3c:	d102      	bne.n	8019d44 <report_build_info+0x138>
        *append++ = 'W';
 8019d3e:	2257      	movs	r2, #87	; 0x57
 8019d40:	f803 2b01 	strb.w	r2, [r3], #1
    if(hal.stepper.get_ganged)
 8019d44:	4a28      	ldr	r2, [pc, #160]	; (8019de8 <report_build_info+0x1dc>)
 8019d46:	f8d2 209c 	ldr.w	r2, [r2, #156]	; 0x9c
 8019d4a:	b112      	cbz	r2, 8019d52 <report_build_info+0x146>
        *append++ = '2';
 8019d4c:	2232      	movs	r2, #50	; 0x32
 8019d4e:	f803 2b01 	strb.w	r2, [r3], #1
    *append++ = ',';
 8019d52:	222c      	movs	r2, #44	; 0x2c
 8019d54:	701a      	strb	r2, [r3, #0]
    *append = '\0';
 8019d56:	2400      	movs	r4, #0
 8019d58:	705c      	strb	r4, [r3, #1]
    hal.stream.write(buf);
 8019d5a:	4d23      	ldr	r5, [pc, #140]	; (8019de8 <report_build_info+0x1dc>)
 8019d5c:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8019d60:	a801      	add	r0, sp, #4
 8019d62:	4798      	blx	r3
    hal.stream.write(uitoa((uint32_t)plan_get_buffer_size()));
 8019d64:	f8d5 60b4 	ldr.w	r6, [r5, #180]	; 0xb4
 8019d68:	f7fc fbba 	bl	80164e0 <plan_get_buffer_size>
 8019d6c:	f7fb fd04 	bl	8015778 <uitoa>
 8019d70:	47b0      	blx	r6
    hal.stream.write(",");
 8019d72:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8019d76:	4e23      	ldr	r6, [pc, #140]	; (8019e04 <report_build_info+0x1f8>)
 8019d78:	4630      	mov	r0, r6
 8019d7a:	4798      	blx	r3
    hal.stream.write(uitoa(hal.rx_buffer_size));
 8019d7c:	f8d5 70b4 	ldr.w	r7, [r5, #180]	; 0xb4
 8019d80:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8019d82:	f7fb fcf9 	bl	8015778 <uitoa>
 8019d86:	47b8      	blx	r7
        hal.stream.write(",");
 8019d88:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8019d8c:	4630      	mov	r0, r6
 8019d8e:	4798      	blx	r3
        hal.stream.write(uitoa((uint32_t)N_AXIS));
 8019d90:	f8d5 70b4 	ldr.w	r7, [r5, #180]	; 0xb4
 8019d94:	2003      	movs	r0, #3
 8019d96:	f7fb fcef 	bl	8015778 <uitoa>
 8019d9a:	47b8      	blx	r7
        hal.stream.write(",");
 8019d9c:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8019da0:	4630      	mov	r0, r6
 8019da2:	4798      	blx	r3
        hal.stream.write("0");
 8019da4:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8019da8:	4817      	ldr	r0, [pc, #92]	; (8019e08 <report_build_info+0x1fc>)
 8019daa:	4798      	blx	r3
    hal.stream.write("]" ASCII_EOL);
 8019dac:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 8019db0:	4811      	ldr	r0, [pc, #68]	; (8019df8 <report_build_info+0x1ec>)
 8019db2:	4798      	blx	r3
        nvs_io_t *nvs = nvs_buffer_get_physical();
 8019db4:	f7fc fa78 	bl	80162a8 <nvs_buffer_get_physical>
 8019db8:	4606      	mov	r6, r0
        strcat(strcpy(buf, "[AXS:"), uitoa(N_AXIS));
 8019dba:	4b14      	ldr	r3, [pc, #80]	; (8019e0c <report_build_info+0x200>)
 8019dbc:	e893 0003 	ldmia.w	r3, {r0, r1}
 8019dc0:	9001      	str	r0, [sp, #4]
 8019dc2:	f8ad 1008 	strh.w	r1, [sp, #8]
 8019dc6:	2003      	movs	r0, #3
 8019dc8:	f7fb fcd6 	bl	8015778 <uitoa>
 8019dcc:	4601      	mov	r1, r0
 8019dce:	a801      	add	r0, sp, #4
 8019dd0:	f008 fed9 	bl	8022b86 <strcat>
        *append++ = ':';
 8019dd4:	233a      	movs	r3, #58	; 0x3a
 8019dd6:	f88d 300a 	strb.w	r3, [sp, #10]
        for(idx = 0; idx < N_AXIS; idx++)
 8019dda:	4622      	mov	r2, r4
        *append++ = ':';
 8019ddc:	f10d 030b 	add.w	r3, sp, #11
        for(idx = 0; idx < N_AXIS; idx++)
 8019de0:	e01d      	b.n	8019e1e <report_build_info+0x212>
    char *append = &buf[5];
 8019de2:	f10d 0209 	add.w	r2, sp, #9
 8019de6:	e73d      	b.n	8019c64 <report_build_info+0x58>
 8019de8:	2000350c 	.word	0x2000350c
 8019dec:	08027724 	.word	0x08027724
 8019df0:	0134b2a9 	.word	0x0134b2a9
 8019df4:	08027694 	.word	0x08027694
 8019df8:	0802cde0 	.word	0x0802cde0
 8019dfc:	08027730 	.word	0x08027730
 8019e00:	20003b14 	.word	0x20003b14
 8019e04:	08027758 	.word	0x08027758
 8019e08:	08027ef0 	.word	0x08027ef0
 8019e0c:	08027738 	.word	0x08027738
            *append++ = *axis_letter[idx];
 8019e10:	49a8      	ldr	r1, [pc, #672]	; (801a0b4 <report_build_info+0x4a8>)
 8019e12:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
 8019e16:	7809      	ldrb	r1, [r1, #0]
 8019e18:	f803 1b01 	strb.w	r1, [r3], #1
        for(idx = 0; idx < N_AXIS; idx++)
 8019e1c:	3201      	adds	r2, #1
 8019e1e:	2a02      	cmp	r2, #2
 8019e20:	d9f6      	bls.n	8019e10 <report_build_info+0x204>
        *append = '\0';
 8019e22:	2200      	movs	r2, #0
 8019e24:	701a      	strb	r2, [r3, #0]
        hal.stream.write(strcat(buf, "]" ASCII_EOL));
 8019e26:	4ba4      	ldr	r3, [pc, #656]	; (801a0b8 <report_build_info+0x4ac>)
 8019e28:	f8d3 50b4 	ldr.w	r5, [r3, #180]	; 0xb4
 8019e2c:	ac01      	add	r4, sp, #4
 8019e2e:	4620      	mov	r0, r4
 8019e30:	f7ee f910 	bl	8008054 <strlen>
 8019e34:	4603      	mov	r3, r0
 8019e36:	4aa1      	ldr	r2, [pc, #644]	; (801a0bc <report_build_info+0x4b0>)
 8019e38:	6810      	ldr	r0, [r2, #0]
 8019e3a:	50e0      	str	r0, [r4, r3]
 8019e3c:	4620      	mov	r0, r4
 8019e3e:	47a8      	blx	r5
        strcpy(buf, "[NEWOPT:ENUMS,RT");
 8019e40:	4d9f      	ldr	r5, [pc, #636]	; (801a0c0 <report_build_info+0x4b4>)
 8019e42:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019e44:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8019e46:	682b      	ldr	r3, [r5, #0]
 8019e48:	7023      	strb	r3, [r4, #0]
        strcat(buf, settings.flags.legacy_rt_commands ? "+," : "-,");
 8019e4a:	4b9e      	ldr	r3, [pc, #632]	; (801a0c4 <report_build_info+0x4b8>)
 8019e4c:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 8019e50:	f013 0f40 	tst.w	r3, #64	; 0x40
 8019e54:	f000 819f 	beq.w	801a196 <report_build_info+0x58a>
 8019e58:	4d9b      	ldr	r5, [pc, #620]	; (801a0c8 <report_build_info+0x4bc>)
 8019e5a:	ac01      	add	r4, sp, #4
 8019e5c:	4620      	mov	r0, r4
 8019e5e:	f7ee f8f9 	bl	8008054 <strlen>
 8019e62:	1823      	adds	r3, r4, r0
 8019e64:	8829      	ldrh	r1, [r5, #0]
 8019e66:	78aa      	ldrb	r2, [r5, #2]
 8019e68:	5221      	strh	r1, [r4, r0]
 8019e6a:	709a      	strb	r2, [r3, #2]
        if(settings.homing.flags.enabled)
 8019e6c:	4b95      	ldr	r3, [pc, #596]	; (801a0c4 <report_build_info+0x4b8>)
 8019e6e:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 8019e72:	f013 0f01 	tst.w	r3, #1
 8019e76:	f040 8190 	bne.w	801a19a <report_build_info+0x58e>
        if(!hal.probe.get_state)
 8019e7a:	4b8f      	ldr	r3, [pc, #572]	; (801a0b8 <report_build_info+0x4ac>)
 8019e7c:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 8019e80:	2b00      	cmp	r3, #0
 8019e82:	f000 8195 	beq.w	801a1b0 <report_build_info+0x5a4>
        else if(hal.signals_cap.probe_disconnected)
 8019e86:	4b8c      	ldr	r3, [pc, #560]	; (801a0b8 <report_build_info+0x4ac>)
 8019e88:	f993 31a8 	ldrsb.w	r3, [r3, #424]	; 0x1a8
 8019e8c:	2b00      	cmp	r3, #0
 8019e8e:	f2c0 819c 	blt.w	801a1ca <report_build_info+0x5be>
        if(hal.signals_cap.stop_disable)
 8019e92:	4b89      	ldr	r3, [pc, #548]	; (801a0b8 <report_build_info+0x4ac>)
 8019e94:	f893 31a8 	ldrb.w	r3, [r3, #424]	; 0x1a8
 8019e98:	f013 0f20 	tst.w	r3, #32
 8019e9c:	f040 819e 	bne.w	801a1dc <report_build_info+0x5d0>
        if(hal.signals_cap.block_delete)
 8019ea0:	4b85      	ldr	r3, [pc, #532]	; (801a0b8 <report_build_info+0x4ac>)
 8019ea2:	f893 31a8 	ldrb.w	r3, [r3, #424]	; 0x1a8
 8019ea6:	f013 0f10 	tst.w	r3, #16
 8019eaa:	f040 81a0 	bne.w	801a1ee <report_build_info+0x5e2>
        if(hal.signals_cap.e_stop)
 8019eae:	4b82      	ldr	r3, [pc, #520]	; (801a0b8 <report_build_info+0x4ac>)
 8019eb0:	f893 31a8 	ldrb.w	r3, [r3, #424]	; 0x1a8
 8019eb4:	f013 0f40 	tst.w	r3, #64	; 0x40
 8019eb8:	f040 81a2 	bne.w	801a200 <report_build_info+0x5f4>
        if(hal.driver_cap.mpg_mode)
 8019ebc:	4b7e      	ldr	r3, [pc, #504]	; (801a0b8 <report_build_info+0x4ac>)
 8019ebe:	f893 31a5 	ldrb.w	r3, [r3, #421]	; 0x1a5
 8019ec2:	f013 0f40 	tst.w	r3, #64	; 0x40
 8019ec6:	f040 81a4 	bne.w	801a212 <report_build_info+0x606>
        if(settings.mode == Mode_Lathe)
 8019eca:	4b7e      	ldr	r3, [pc, #504]	; (801a0c4 <report_build_info+0x4b8>)
 8019ecc:	7e1b      	ldrb	r3, [r3, #24]
 8019ece:	2b02      	cmp	r3, #2
 8019ed0:	f000 81ab 	beq.w	801a22a <report_build_info+0x61e>
        if(hal.driver_cap.laser_ppi_mode)
 8019ed4:	4b78      	ldr	r3, [pc, #480]	; (801a0b8 <report_build_info+0x4ac>)
 8019ed6:	f993 31a5 	ldrsb.w	r3, [r3, #421]	; 0x1a5
 8019eda:	2b00      	cmp	r3, #0
 8019edc:	f2c0 81b3 	blt.w	801a246 <report_build_info+0x63a>
        if(hal.reboot)
 8019ee0:	4b75      	ldr	r3, [pc, #468]	; (801a0b8 <report_build_info+0x4ac>)
 8019ee2:	f8d3 3180 	ldr.w	r3, [r3, #384]	; 0x180
 8019ee6:	b14b      	cbz	r3, 8019efc <report_build_info+0x2f0>
            strcat(buf, "REBOOT,");
 8019ee8:	ac01      	add	r4, sp, #4
 8019eea:	4620      	mov	r0, r4
 8019eec:	f7ee f8b2 	bl	8008054 <strlen>
 8019ef0:	4603      	mov	r3, r0
 8019ef2:	1825      	adds	r5, r4, r0
 8019ef4:	4a75      	ldr	r2, [pc, #468]	; (801a0cc <report_build_info+0x4c0>)
 8019ef6:	ca03      	ldmia	r2!, {r0, r1}
 8019ef8:	50e0      	str	r0, [r4, r3]
 8019efa:	6069      	str	r1, [r5, #4]
        if(hal.tool.change)
 8019efc:	4b6e      	ldr	r3, [pc, #440]	; (801a0b8 <report_build_info+0x4ac>)
 8019efe:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 8019f02:	b153      	cbz	r3, 8019f1a <report_build_info+0x30e>
            strcat(buf, hal.driver_cap.atc ? "ATC," : "TC,"); // Tool change supported (M6)
 8019f04:	4b6c      	ldr	r3, [pc, #432]	; (801a0b8 <report_build_info+0x4ac>)
 8019f06:	f893 31a6 	ldrb.w	r3, [r3, #422]	; 0x1a6
 8019f0a:	f013 0f01 	tst.w	r3, #1
 8019f0e:	f000 81a6 	beq.w	801a25e <report_build_info+0x652>
 8019f12:	496f      	ldr	r1, [pc, #444]	; (801a0d0 <report_build_info+0x4c4>)
 8019f14:	a801      	add	r0, sp, #4
 8019f16:	f008 fe36 	bl	8022b86 <strcat>
        if(hal.driver_cap.spindle_sync)
 8019f1a:	4b67      	ldr	r3, [pc, #412]	; (801a0b8 <report_build_info+0x4ac>)
 8019f1c:	f893 31a5 	ldrb.w	r3, [r3, #421]	; 0x1a5
 8019f20:	f013 0f01 	tst.w	r3, #1
 8019f24:	f040 819d 	bne.w	801a262 <report_build_info+0x656>
        strcat(buf, "SED,");
 8019f28:	ac01      	add	r4, sp, #4
 8019f2a:	4620      	mov	r0, r4
 8019f2c:	f7ee f892 	bl	8008054 <strlen>
 8019f30:	4603      	mov	r3, r0
 8019f32:	1821      	adds	r1, r4, r0
 8019f34:	4a67      	ldr	r2, [pc, #412]	; (801a0d4 <report_build_info+0x4c8>)
 8019f36:	6810      	ldr	r0, [r2, #0]
 8019f38:	50e0      	str	r0, [r4, r3]
 8019f3a:	7913      	ldrb	r3, [r2, #4]
 8019f3c:	710b      	strb	r3, [r1, #4]
        if(hal.rtc.get_datetime)
 8019f3e:	4b5e      	ldr	r3, [pc, #376]	; (801a0b8 <report_build_info+0x4ac>)
 8019f40:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
 8019f44:	b14b      	cbz	r3, 8019f5a <report_build_info+0x34e>
            strcat(buf, "RTC,");
 8019f46:	4620      	mov	r0, r4
 8019f48:	f7ee f884 	bl	8008054 <strlen>
 8019f4c:	4603      	mov	r3, r0
 8019f4e:	1821      	adds	r1, r4, r0
 8019f50:	4a61      	ldr	r2, [pc, #388]	; (801a0d8 <report_build_info+0x4cc>)
 8019f52:	6810      	ldr	r0, [r2, #0]
 8019f54:	50e0      	str	r0, [r4, r3]
 8019f56:	7913      	ldrb	r3, [r2, #4]
 8019f58:	710b      	strb	r3, [r1, #4]
        append = &buf[strlen(buf) - 1];
 8019f5a:	a801      	add	r0, sp, #4
 8019f5c:	f7ee f87a 	bl	8008054 <strlen>
        if(*append == ',')
 8019f60:	f100 0367 	add.w	r3, r0, #103	; 0x67
        append = &buf[strlen(buf) - 1];
 8019f64:	3801      	subs	r0, #1
        if(*append == ',')
 8019f66:	446b      	add	r3, sp
 8019f68:	f813 3c64 	ldrb.w	r3, [r3, #-100]
 8019f6c:	2b2c      	cmp	r3, #44	; 0x2c
 8019f6e:	f000 8181 	beq.w	801a274 <report_build_info+0x668>
        hal.stream.write(buf);
 8019f72:	4c51      	ldr	r4, [pc, #324]	; (801a0b8 <report_build_info+0x4ac>)
 8019f74:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8019f78:	a801      	add	r0, sp, #4
 8019f7a:	4798      	blx	r3
        grbl.on_report_options(true);
 8019f7c:	4b57      	ldr	r3, [pc, #348]	; (801a0dc <report_build_info+0x4d0>)
 8019f7e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8019f80:	2001      	movs	r0, #1
 8019f82:	4798      	blx	r3
        hal.stream.write("]" ASCII_EOL);
 8019f84:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8019f88:	484c      	ldr	r0, [pc, #304]	; (801a0bc <report_build_info+0x4b0>)
 8019f8a:	4798      	blx	r3
        hal.stream.write("[FIRMWARE:grblHAL]" ASCII_EOL);
 8019f8c:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8019f90:	4853      	ldr	r0, [pc, #332]	; (801a0e0 <report_build_info+0x4d4>)
 8019f92:	4798      	blx	r3
        if(!(nvs->type == NVS_None || nvs->type == NVS_Emulated)) {
 8019f94:	7833      	ldrb	r3, [r6, #0]
 8019f96:	b33b      	cbz	r3, 8019fe8 <report_build_info+0x3dc>
 8019f98:	2b04      	cmp	r3, #4
 8019f9a:	d025      	beq.n	8019fe8 <report_build_info+0x3dc>
            hal.stream.write("[NVS STORAGE:");
 8019f9c:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8019fa0:	4850      	ldr	r0, [pc, #320]	; (801a0e4 <report_build_info+0x4d8>)
 8019fa2:	4798      	blx	r3
            *buf = '\0';
 8019fa4:	2300      	movs	r3, #0
 8019fa6:	f88d 3004 	strb.w	r3, [sp, #4]
            if(hal.nvs.type == NVS_Emulated)
 8019faa:	f894 3144 	ldrb.w	r3, [r4, #324]	; 0x144
 8019fae:	2b04      	cmp	r3, #4
 8019fb0:	f000 8168 	beq.w	801a284 <report_build_info+0x678>
            strcat(buf, nvs->type == NVS_Flash ? "FLASH" : (nvs->type == NVS_FRAM ? "FRAM" : "EEPROM"));
 8019fb4:	7833      	ldrb	r3, [r6, #0]
 8019fb6:	2b03      	cmp	r3, #3
 8019fb8:	f000 816e 	beq.w	801a298 <report_build_info+0x68c>
 8019fbc:	2b02      	cmp	r3, #2
 8019fbe:	f000 8169 	beq.w	801a294 <report_build_info+0x688>
 8019fc2:	4949      	ldr	r1, [pc, #292]	; (801a0e8 <report_build_info+0x4dc>)
 8019fc4:	a801      	add	r0, sp, #4
 8019fc6:	f008 fdde 	bl	8022b86 <strcat>
            if(hal.nvs.size_max) {
 8019fca:	4b3b      	ldr	r3, [pc, #236]	; (801a0b8 <report_build_info+0x4ac>)
 8019fcc:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 8019fd0:	2b00      	cmp	r3, #0
 8019fd2:	f040 8163 	bne.w	801a29c <report_build_info+0x690>
            hal.stream.write(buf);
 8019fd6:	4c38      	ldr	r4, [pc, #224]	; (801a0b8 <report_build_info+0x4ac>)
 8019fd8:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8019fdc:	a801      	add	r0, sp, #4
 8019fde:	4798      	blx	r3
            hal.stream.write("]" ASCII_EOL);
 8019fe0:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8019fe4:	4835      	ldr	r0, [pc, #212]	; (801a0bc <report_build_info+0x4b0>)
 8019fe6:	4798      	blx	r3
        if(hal.get_free_mem) {
 8019fe8:	4b33      	ldr	r3, [pc, #204]	; (801a0b8 <report_build_info+0x4ac>)
 8019fea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8019fec:	b183      	cbz	r3, 801a010 <report_build_info+0x404>
            hal.stream.write("[FREE MEMORY:");
 8019fee:	4c32      	ldr	r4, [pc, #200]	; (801a0b8 <report_build_info+0x4ac>)
 8019ff0:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8019ff4:	483d      	ldr	r0, [pc, #244]	; (801a0ec <report_build_info+0x4e0>)
 8019ff6:	4798      	blx	r3
            hal.stream.write(uitoa(hal.get_free_mem() / 1024));
 8019ff8:	f8d4 50b4 	ldr.w	r5, [r4, #180]	; 0xb4
 8019ffc:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8019ffe:	4798      	blx	r3
 801a000:	0a80      	lsrs	r0, r0, #10
 801a002:	f7fb fbb9 	bl	8015778 <uitoa>
 801a006:	47a8      	blx	r5
            hal.stream.write("K]" ASCII_EOL);
 801a008:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801a00c:	4838      	ldr	r0, [pc, #224]	; (801a0f0 <report_build_info+0x4e4>)
 801a00e:	4798      	blx	r3
        if(hal.info) {
 801a010:	4b29      	ldr	r3, [pc, #164]	; (801a0b8 <report_build_info+0x4ac>)
 801a012:	685b      	ldr	r3, [r3, #4]
 801a014:	b163      	cbz	r3, 801a030 <report_build_info+0x424>
            hal.stream.write("[DRIVER:");
 801a016:	4c28      	ldr	r4, [pc, #160]	; (801a0b8 <report_build_info+0x4ac>)
 801a018:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801a01c:	4835      	ldr	r0, [pc, #212]	; (801a0f4 <report_build_info+0x4e8>)
 801a01e:	4798      	blx	r3
            hal.stream.write(hal.info);
 801a020:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801a024:	6860      	ldr	r0, [r4, #4]
 801a026:	4798      	blx	r3
            hal.stream.write("]" ASCII_EOL);
 801a028:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801a02c:	4823      	ldr	r0, [pc, #140]	; (801a0bc <report_build_info+0x4b0>)
 801a02e:	4798      	blx	r3
        if(hal.driver_version) {
 801a030:	4b21      	ldr	r3, [pc, #132]	; (801a0b8 <report_build_info+0x4ac>)
 801a032:	689b      	ldr	r3, [r3, #8]
 801a034:	b163      	cbz	r3, 801a050 <report_build_info+0x444>
            hal.stream.write("[DRIVER VERSION:");
 801a036:	4c20      	ldr	r4, [pc, #128]	; (801a0b8 <report_build_info+0x4ac>)
 801a038:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801a03c:	482e      	ldr	r0, [pc, #184]	; (801a0f8 <report_build_info+0x4ec>)
 801a03e:	4798      	blx	r3
            hal.stream.write(hal.driver_version);
 801a040:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801a044:	68a0      	ldr	r0, [r4, #8]
 801a046:	4798      	blx	r3
            hal.stream.write("]" ASCII_EOL);
 801a048:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801a04c:	481b      	ldr	r0, [pc, #108]	; (801a0bc <report_build_info+0x4b0>)
 801a04e:	4798      	blx	r3
        if(hal.driver_options) {
 801a050:	4b19      	ldr	r3, [pc, #100]	; (801a0b8 <report_build_info+0x4ac>)
 801a052:	68db      	ldr	r3, [r3, #12]
 801a054:	b163      	cbz	r3, 801a070 <report_build_info+0x464>
            hal.stream.write("[DRIVER OPTIONS:");
 801a056:	4c18      	ldr	r4, [pc, #96]	; (801a0b8 <report_build_info+0x4ac>)
 801a058:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801a05c:	4827      	ldr	r0, [pc, #156]	; (801a0fc <report_build_info+0x4f0>)
 801a05e:	4798      	blx	r3
            hal.stream.write(hal.driver_options);
 801a060:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801a064:	68e0      	ldr	r0, [r4, #12]
 801a066:	4798      	blx	r3
            hal.stream.write("]" ASCII_EOL);
 801a068:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801a06c:	4813      	ldr	r0, [pc, #76]	; (801a0bc <report_build_info+0x4b0>)
 801a06e:	4798      	blx	r3
        if(hal.board) {
 801a070:	4b11      	ldr	r3, [pc, #68]	; (801a0b8 <report_build_info+0x4ac>)
 801a072:	695b      	ldr	r3, [r3, #20]
 801a074:	b163      	cbz	r3, 801a090 <report_build_info+0x484>
            hal.stream.write("[BOARD:");
 801a076:	4c10      	ldr	r4, [pc, #64]	; (801a0b8 <report_build_info+0x4ac>)
 801a078:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801a07c:	4820      	ldr	r0, [pc, #128]	; (801a100 <report_build_info+0x4f4>)
 801a07e:	4798      	blx	r3
            hal.stream.write(hal.board);
 801a080:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801a084:	6960      	ldr	r0, [r4, #20]
 801a086:	4798      	blx	r3
            hal.stream.write("]" ASCII_EOL);
 801a088:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801a08c:	480b      	ldr	r0, [pc, #44]	; (801a0bc <report_build_info+0x4b0>)
 801a08e:	4798      	blx	r3
        if(hal.max_step_rate) {
 801a090:	4b09      	ldr	r3, [pc, #36]	; (801a0b8 <report_build_info+0x4ac>)
 801a092:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801a094:	2b00      	cmp	r3, #0
 801a096:	d039      	beq.n	801a10c <report_build_info+0x500>
            hal.stream.write("[MAX STEP RATE:");
 801a098:	4c07      	ldr	r4, [pc, #28]	; (801a0b8 <report_build_info+0x4ac>)
 801a09a:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801a09e:	4819      	ldr	r0, [pc, #100]	; (801a104 <report_build_info+0x4f8>)
 801a0a0:	4798      	blx	r3
            hal.stream.write(uitoa(hal.max_step_rate));
 801a0a2:	f8d4 50b4 	ldr.w	r5, [r4, #180]	; 0xb4
 801a0a6:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 801a0a8:	f7fb fb66 	bl	8015778 <uitoa>
 801a0ac:	47a8      	blx	r5
            hal.stream.write(" Hz]" ASCII_EOL);
 801a0ae:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801a0b2:	e029      	b.n	801a108 <report_build_info+0x4fc>
 801a0b4:	080271cc 	.word	0x080271cc
 801a0b8:	2000350c 	.word	0x2000350c
 801a0bc:	0802cde0 	.word	0x0802cde0
 801a0c0:	08027740 	.word	0x08027740
 801a0c4:	20003b14 	.word	0x20003b14
 801a0c8:	080276f8 	.word	0x080276f8
 801a0cc:	08027790 	.word	0x08027790
 801a0d0:	08027700 	.word	0x08027700
 801a0d4:	0802779c 	.word	0x0802779c
 801a0d8:	080277a4 	.word	0x080277a4
 801a0dc:	2000343c 	.word	0x2000343c
 801a0e0:	080277ac 	.word	0x080277ac
 801a0e4:	080277c4 	.word	0x080277c4
 801a0e8:	0802770c 	.word	0x0802770c
 801a0ec:	080277dc 	.word	0x080277dc
 801a0f0:	080277ec 	.word	0x080277ec
 801a0f4:	080277f4 	.word	0x080277f4
 801a0f8:	08027800 	.word	0x08027800
 801a0fc:	08027814 	.word	0x08027814
 801a100:	08027828 	.word	0x08027828
 801a104:	08027830 	.word	0x08027830
 801a108:	4871      	ldr	r0, [pc, #452]	; (801a2d0 <report_build_info+0x6c4>)
 801a10a:	4798      	blx	r3
        if(hal.port.num_digital_in + hal.port.num_digital_out + hal.port.num_analog_in + hal.port.num_analog_out > 0) {
 801a10c:	4a71      	ldr	r2, [pc, #452]	; (801a2d4 <report_build_info+0x6c8>)
 801a10e:	f892 3114 	ldrb.w	r3, [r2, #276]	; 0x114
 801a112:	f892 1115 	ldrb.w	r1, [r2, #277]	; 0x115
 801a116:	440b      	add	r3, r1
 801a118:	f892 1116 	ldrb.w	r1, [r2, #278]	; 0x116
 801a11c:	440b      	add	r3, r1
 801a11e:	f892 2117 	ldrb.w	r2, [r2, #279]	; 0x117
 801a122:	42d3      	cmn	r3, r2
 801a124:	d031      	beq.n	801a18a <report_build_info+0x57e>
            hal.stream.write("[AUX IO:");
 801a126:	4c6b      	ldr	r4, [pc, #428]	; (801a2d4 <report_build_info+0x6c8>)
 801a128:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801a12c:	486a      	ldr	r0, [pc, #424]	; (801a2d8 <report_build_info+0x6cc>)
 801a12e:	4798      	blx	r3
            hal.stream.write(uitoa(hal.port.num_digital_in));
 801a130:	f8d4 50b4 	ldr.w	r5, [r4, #180]	; 0xb4
 801a134:	f894 0114 	ldrb.w	r0, [r4, #276]	; 0x114
 801a138:	f7fb fb1e 	bl	8015778 <uitoa>
 801a13c:	47a8      	blx	r5
            hal.stream.write(",");
 801a13e:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801a142:	4d66      	ldr	r5, [pc, #408]	; (801a2dc <report_build_info+0x6d0>)
 801a144:	4628      	mov	r0, r5
 801a146:	4798      	blx	r3
            hal.stream.write(uitoa(hal.port.num_digital_out));
 801a148:	f8d4 60b4 	ldr.w	r6, [r4, #180]	; 0xb4
 801a14c:	f894 0115 	ldrb.w	r0, [r4, #277]	; 0x115
 801a150:	f7fb fb12 	bl	8015778 <uitoa>
 801a154:	47b0      	blx	r6
            hal.stream.write(",");
 801a156:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801a15a:	4628      	mov	r0, r5
 801a15c:	4798      	blx	r3
            hal.stream.write(uitoa(hal.port.num_analog_in));
 801a15e:	f8d4 60b4 	ldr.w	r6, [r4, #180]	; 0xb4
 801a162:	f894 0116 	ldrb.w	r0, [r4, #278]	; 0x116
 801a166:	f7fb fb07 	bl	8015778 <uitoa>
 801a16a:	47b0      	blx	r6
            hal.stream.write(",");
 801a16c:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801a170:	4628      	mov	r0, r5
 801a172:	4798      	blx	r3
            hal.stream.write(uitoa(hal.port.num_analog_out));
 801a174:	f8d4 50b4 	ldr.w	r5, [r4, #180]	; 0xb4
 801a178:	f894 0117 	ldrb.w	r0, [r4, #279]	; 0x117
 801a17c:	f7fb fafc 	bl	8015778 <uitoa>
 801a180:	47a8      	blx	r5
            hal.stream.write("]" ASCII_EOL);
 801a182:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801a186:	4856      	ldr	r0, [pc, #344]	; (801a2e0 <report_build_info+0x6d4>)
 801a188:	4798      	blx	r3
        grbl.on_report_options(false);
 801a18a:	4b56      	ldr	r3, [pc, #344]	; (801a2e4 <report_build_info+0x6d8>)
 801a18c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801a18e:	2000      	movs	r0, #0
 801a190:	4798      	blx	r3
}
 801a192:	b01b      	add	sp, #108	; 0x6c
 801a194:	bdf0      	pop	{r4, r5, r6, r7, pc}
        strcat(buf, settings.flags.legacy_rt_commands ? "+," : "-,");
 801a196:	4d54      	ldr	r5, [pc, #336]	; (801a2e8 <report_build_info+0x6dc>)
 801a198:	e65f      	b.n	8019e5a <report_build_info+0x24e>
            strcat(buf, "HOME,");
 801a19a:	4620      	mov	r0, r4
 801a19c:	f7ed ff5a 	bl	8008054 <strlen>
 801a1a0:	4603      	mov	r3, r0
 801a1a2:	1821      	adds	r1, r4, r0
 801a1a4:	4a51      	ldr	r2, [pc, #324]	; (801a2ec <report_build_info+0x6e0>)
 801a1a6:	6810      	ldr	r0, [r2, #0]
 801a1a8:	50e0      	str	r0, [r4, r3]
 801a1aa:	8893      	ldrh	r3, [r2, #4]
 801a1ac:	808b      	strh	r3, [r1, #4]
 801a1ae:	e664      	b.n	8019e7a <report_build_info+0x26e>
            strcat(buf, "NOPROBE,");
 801a1b0:	ac01      	add	r4, sp, #4
 801a1b2:	4620      	mov	r0, r4
 801a1b4:	f7ed ff4e 	bl	8008054 <strlen>
 801a1b8:	4602      	mov	r2, r0
 801a1ba:	1825      	adds	r5, r4, r0
 801a1bc:	4b4c      	ldr	r3, [pc, #304]	; (801a2f0 <report_build_info+0x6e4>)
 801a1be:	cb03      	ldmia	r3!, {r0, r1}
 801a1c0:	50a0      	str	r0, [r4, r2]
 801a1c2:	6069      	str	r1, [r5, #4]
 801a1c4:	781b      	ldrb	r3, [r3, #0]
 801a1c6:	722b      	strb	r3, [r5, #8]
 801a1c8:	e663      	b.n	8019e92 <report_build_info+0x286>
            strcat(buf, "PC,");
 801a1ca:	ac01      	add	r4, sp, #4
 801a1cc:	4620      	mov	r0, r4
 801a1ce:	f7ed ff41 	bl	8008054 <strlen>
 801a1d2:	4603      	mov	r3, r0
 801a1d4:	4a47      	ldr	r2, [pc, #284]	; (801a2f4 <report_build_info+0x6e8>)
 801a1d6:	6810      	ldr	r0, [r2, #0]
 801a1d8:	50e0      	str	r0, [r4, r3]
 801a1da:	e65a      	b.n	8019e92 <report_build_info+0x286>
            strcat(buf, "OS,");
 801a1dc:	ac01      	add	r4, sp, #4
 801a1de:	4620      	mov	r0, r4
 801a1e0:	f7ed ff38 	bl	8008054 <strlen>
 801a1e4:	4603      	mov	r3, r0
 801a1e6:	4a44      	ldr	r2, [pc, #272]	; (801a2f8 <report_build_info+0x6ec>)
 801a1e8:	6810      	ldr	r0, [r2, #0]
 801a1ea:	50e0      	str	r0, [r4, r3]
 801a1ec:	e658      	b.n	8019ea0 <report_build_info+0x294>
            strcat(buf, "BD,");
 801a1ee:	ac01      	add	r4, sp, #4
 801a1f0:	4620      	mov	r0, r4
 801a1f2:	f7ed ff2f 	bl	8008054 <strlen>
 801a1f6:	4603      	mov	r3, r0
 801a1f8:	4a40      	ldr	r2, [pc, #256]	; (801a2fc <report_build_info+0x6f0>)
 801a1fa:	6810      	ldr	r0, [r2, #0]
 801a1fc:	50e0      	str	r0, [r4, r3]
 801a1fe:	e656      	b.n	8019eae <report_build_info+0x2a2>
            strcat(buf, "ES,");
 801a200:	ac01      	add	r4, sp, #4
 801a202:	4620      	mov	r0, r4
 801a204:	f7ed ff26 	bl	8008054 <strlen>
 801a208:	4603      	mov	r3, r0
 801a20a:	4a3d      	ldr	r2, [pc, #244]	; (801a300 <report_build_info+0x6f4>)
 801a20c:	6810      	ldr	r0, [r2, #0]
 801a20e:	50e0      	str	r0, [r4, r3]
 801a210:	e654      	b.n	8019ebc <report_build_info+0x2b0>
            strcat(buf, "MPG,");
 801a212:	ac01      	add	r4, sp, #4
 801a214:	4620      	mov	r0, r4
 801a216:	f7ed ff1d 	bl	8008054 <strlen>
 801a21a:	4603      	mov	r3, r0
 801a21c:	1821      	adds	r1, r4, r0
 801a21e:	4a39      	ldr	r2, [pc, #228]	; (801a304 <report_build_info+0x6f8>)
 801a220:	6810      	ldr	r0, [r2, #0]
 801a222:	50e0      	str	r0, [r4, r3]
 801a224:	7913      	ldrb	r3, [r2, #4]
 801a226:	710b      	strb	r3, [r1, #4]
 801a228:	e64f      	b.n	8019eca <report_build_info+0x2be>
            strcat(buf, "LATHE,");
 801a22a:	ac01      	add	r4, sp, #4
 801a22c:	4620      	mov	r0, r4
 801a22e:	f7ed ff11 	bl	8008054 <strlen>
 801a232:	4603      	mov	r3, r0
 801a234:	1821      	adds	r1, r4, r0
 801a236:	4a34      	ldr	r2, [pc, #208]	; (801a308 <report_build_info+0x6fc>)
 801a238:	6810      	ldr	r0, [r2, #0]
 801a23a:	50e0      	str	r0, [r4, r3]
 801a23c:	8890      	ldrh	r0, [r2, #4]
 801a23e:	7993      	ldrb	r3, [r2, #6]
 801a240:	8088      	strh	r0, [r1, #4]
 801a242:	718b      	strb	r3, [r1, #6]
 801a244:	e646      	b.n	8019ed4 <report_build_info+0x2c8>
            strcat(buf, "PPI,");
 801a246:	ac01      	add	r4, sp, #4
 801a248:	4620      	mov	r0, r4
 801a24a:	f7ed ff03 	bl	8008054 <strlen>
 801a24e:	4603      	mov	r3, r0
 801a250:	1821      	adds	r1, r4, r0
 801a252:	4a2e      	ldr	r2, [pc, #184]	; (801a30c <report_build_info+0x700>)
 801a254:	6810      	ldr	r0, [r2, #0]
 801a256:	50e0      	str	r0, [r4, r3]
 801a258:	7913      	ldrb	r3, [r2, #4]
 801a25a:	710b      	strb	r3, [r1, #4]
 801a25c:	e640      	b.n	8019ee0 <report_build_info+0x2d4>
            strcat(buf, hal.driver_cap.atc ? "ATC," : "TC,"); // Tool change supported (M6)
 801a25e:	492c      	ldr	r1, [pc, #176]	; (801a310 <report_build_info+0x704>)
 801a260:	e658      	b.n	8019f14 <report_build_info+0x308>
            strcat(buf, "SS,");
 801a262:	ac01      	add	r4, sp, #4
 801a264:	4620      	mov	r0, r4
 801a266:	f7ed fef5 	bl	8008054 <strlen>
 801a26a:	4603      	mov	r3, r0
 801a26c:	4a29      	ldr	r2, [pc, #164]	; (801a314 <report_build_info+0x708>)
 801a26e:	6810      	ldr	r0, [r2, #0]
 801a270:	50e0      	str	r0, [r4, r3]
 801a272:	e659      	b.n	8019f28 <report_build_info+0x31c>
            *append = '\0';
 801a274:	f100 0368 	add.w	r3, r0, #104	; 0x68
 801a278:	eb0d 0003 	add.w	r0, sp, r3
 801a27c:	2300      	movs	r3, #0
 801a27e:	f800 3c64 	strb.w	r3, [r0, #-100]
 801a282:	e676      	b.n	8019f72 <report_build_info+0x366>
                strcat(buf, "*");
 801a284:	ac01      	add	r4, sp, #4
 801a286:	4620      	mov	r0, r4
 801a288:	f7ed fee4 	bl	8008054 <strlen>
 801a28c:	4b22      	ldr	r3, [pc, #136]	; (801a318 <report_build_info+0x70c>)
 801a28e:	881b      	ldrh	r3, [r3, #0]
 801a290:	5223      	strh	r3, [r4, r0]
 801a292:	e68f      	b.n	8019fb4 <report_build_info+0x3a8>
            strcat(buf, nvs->type == NVS_Flash ? "FLASH" : (nvs->type == NVS_FRAM ? "FRAM" : "EEPROM"));
 801a294:	4921      	ldr	r1, [pc, #132]	; (801a31c <report_build_info+0x710>)
 801a296:	e695      	b.n	8019fc4 <report_build_info+0x3b8>
 801a298:	4921      	ldr	r1, [pc, #132]	; (801a320 <report_build_info+0x714>)
 801a29a:	e693      	b.n	8019fc4 <report_build_info+0x3b8>
                strcat(buf, " ");
 801a29c:	a801      	add	r0, sp, #4
 801a29e:	f7ed fed9 	bl	8008054 <strlen>
 801a2a2:	4b20      	ldr	r3, [pc, #128]	; (801a324 <report_build_info+0x718>)
 801a2a4:	881b      	ldrh	r3, [r3, #0]
 801a2a6:	aa01      	add	r2, sp, #4
 801a2a8:	5213      	strh	r3, [r2, r0]
                strcat(buf, uitoa(hal.nvs.size_max / 1024));
 801a2aa:	4b0a      	ldr	r3, [pc, #40]	; (801a2d4 <report_build_info+0x6c8>)
 801a2ac:	f8d3 014c 	ldr.w	r0, [r3, #332]	; 0x14c
 801a2b0:	0a80      	lsrs	r0, r0, #10
 801a2b2:	f7fb fa61 	bl	8015778 <uitoa>
 801a2b6:	4601      	mov	r1, r0
 801a2b8:	a801      	add	r0, sp, #4
 801a2ba:	f008 fc64 	bl	8022b86 <strcat>
                strcat(buf, "K");
 801a2be:	a801      	add	r0, sp, #4
 801a2c0:	f7ed fec8 	bl	8008054 <strlen>
 801a2c4:	4b18      	ldr	r3, [pc, #96]	; (801a328 <report_build_info+0x71c>)
 801a2c6:	881b      	ldrh	r3, [r3, #0]
 801a2c8:	aa01      	add	r2, sp, #4
 801a2ca:	5213      	strh	r3, [r2, r0]
 801a2cc:	e683      	b.n	8019fd6 <report_build_info+0x3ca>
 801a2ce:	bf00      	nop
 801a2d0:	08027840 	.word	0x08027840
 801a2d4:	2000350c 	.word	0x2000350c
 801a2d8:	08027848 	.word	0x08027848
 801a2dc:	08027758 	.word	0x08027758
 801a2e0:	0802cde0 	.word	0x0802cde0
 801a2e4:	2000343c 	.word	0x2000343c
 801a2e8:	080276fc 	.word	0x080276fc
 801a2ec:	08027754 	.word	0x08027754
 801a2f0:	0802775c 	.word	0x0802775c
 801a2f4:	08027768 	.word	0x08027768
 801a2f8:	0802776c 	.word	0x0802776c
 801a2fc:	08027770 	.word	0x08027770
 801a300:	08027774 	.word	0x08027774
 801a304:	08027778 	.word	0x08027778
 801a308:	08027780 	.word	0x08027780
 801a30c:	08027788 	.word	0x08027788
 801a310:	08027708 	.word	0x08027708
 801a314:	08027798 	.word	0x08027798
 801a318:	080277d4 	.word	0x080277d4
 801a31c:	0802771c 	.word	0x0802771c
 801a320:	08027714 	.word	0x08027714
 801a324:	08027470 	.word	0x08027470
 801a328:	080277d8 	.word	0x080277d8

0801a32c <report_realtime_status>:
{
 801a32c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801a330:	b08b      	sub	sp, #44	; 0x2c
    report_tracking_flags_t report = system_get_rt_report_flags();
 801a332:	f006 ff7f 	bl	8021234 <system_get_rt_report_flags>
 801a336:	4604      	mov	r4, r0
    probe_state_t probe_state = {
 801a338:	f04f 0802 	mov.w	r8, #2
    system_convert_array_steps_to_mpos(print_position, sys.position);
 801a33c:	499f      	ldr	r1, [pc, #636]	; (801a5bc <report_realtime_status+0x290>)
 801a33e:	a806      	add	r0, sp, #24
 801a340:	f006 fe4c 	bl	8020fdc <system_convert_array_steps_to_mpos>
    if(hal.probe.get_state)
 801a344:	4b9e      	ldr	r3, [pc, #632]	; (801a5c0 <report_realtime_status+0x294>)
 801a346:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 801a34a:	b10b      	cbz	r3, 801a350 <report_realtime_status+0x24>
        probe_state = hal.probe.get_state();
 801a34c:	4798      	blx	r3
 801a34e:	4680      	mov	r8, r0
    hal.stream.write_all("<");
 801a350:	4b9b      	ldr	r3, [pc, #620]	; (801a5c0 <report_realtime_status+0x294>)
 801a352:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801a356:	489b      	ldr	r0, [pc, #620]	; (801a5c4 <report_realtime_status+0x298>)
 801a358:	4798      	blx	r3
    sys_state_t state = state_get();
 801a35a:	f004 f943 	bl	801e5e4 <state_get>
    switch (gc_state.tool_change && state == STATE_CYCLE ? STATE_TOOL_CHANGE : state) {
 801a35e:	4b9a      	ldr	r3, [pc, #616]	; (801a5c8 <report_realtime_status+0x29c>)
 801a360:	f893 3077 	ldrb.w	r3, [r3, #119]	; 0x77
 801a364:	b10b      	cbz	r3, 801a36a <report_realtime_status+0x3e>
 801a366:	2808      	cmp	r0, #8
 801a368:	d032      	beq.n	801a3d0 <report_realtime_status+0xa4>
 801a36a:	2820      	cmp	r0, #32
 801a36c:	d824      	bhi.n	801a3b8 <report_realtime_status+0x8c>
 801a36e:	2820      	cmp	r0, #32
 801a370:	d833      	bhi.n	801a3da <report_realtime_status+0xae>
 801a372:	e8df f010 	tbh	[pc, r0, lsl #1]
 801a376:	00cf      	.short	0x00cf
 801a378:	016d014f 	.word	0x016d014f
 801a37c:	011d0032 	.word	0x011d0032
 801a380:	00320032 	.word	0x00320032
 801a384:	00d50032 	.word	0x00d50032
 801a388:	00320032 	.word	0x00320032
 801a38c:	00320032 	.word	0x00320032
 801a390:	00320032 	.word	0x00320032
 801a394:	01070032 	.word	0x01070032
 801a398:	00320032 	.word	0x00320032
 801a39c:	00320032 	.word	0x00320032
 801a3a0:	00320032 	.word	0x00320032
 801a3a4:	00320032 	.word	0x00320032
 801a3a8:	00320032 	.word	0x00320032
 801a3ac:	00320032 	.word	0x00320032
 801a3b0:	00320032 	.word	0x00320032
 801a3b4:	01170032 	.word	0x01170032
 801a3b8:	2880      	cmp	r0, #128	; 0x80
 801a3ba:	f000 814f 	beq.w	801a65c <report_realtime_status+0x330>
 801a3be:	f240 8097 	bls.w	801a4f0 <report_realtime_status+0x1c4>
 801a3c2:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 801a3c6:	f000 8125 	beq.w	801a614 <report_realtime_status+0x2e8>
 801a3ca:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 801a3ce:	d104      	bne.n	801a3da <report_realtime_status+0xae>
            hal.stream.write_all("Tool");
 801a3d0:	4b7b      	ldr	r3, [pc, #492]	; (801a5c0 <report_realtime_status+0x294>)
 801a3d2:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801a3d6:	487d      	ldr	r0, [pc, #500]	; (801a5cc <report_realtime_status+0x2a0>)
 801a3d8:	4798      	blx	r3
    if (!settings.status_report.machine_position || report.wco) {
 801a3da:	4b7d      	ldr	r3, [pc, #500]	; (801a5d0 <report_realtime_status+0x2a4>)
 801a3dc:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 801a3e0:	f013 0f01 	tst.w	r3, #1
 801a3e4:	f000 815c 	beq.w	801a6a0 <report_realtime_status+0x374>
 801a3e8:	f414 7f80 	tst.w	r4, #256	; 0x100
 801a3ec:	f040 815a 	bne.w	801a6a4 <report_realtime_status+0x378>
    hal.stream.write_all(settings.status_report.machine_position ? "|MPos:" : "|WPos:");
 801a3f0:	4b73      	ldr	r3, [pc, #460]	; (801a5c0 <report_realtime_status+0x294>)
 801a3f2:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801a3f6:	4a76      	ldr	r2, [pc, #472]	; (801a5d0 <report_realtime_status+0x2a4>)
 801a3f8:	f892 20fc 	ldrb.w	r2, [r2, #252]	; 0xfc
 801a3fc:	f012 0f01 	tst.w	r2, #1
 801a400:	f000 8152 	beq.w	801a6a8 <report_realtime_status+0x37c>
 801a404:	4873      	ldr	r0, [pc, #460]	; (801a5d4 <report_realtime_status+0x2a8>)
 801a406:	4798      	blx	r3
    hal.stream.write_all(get_axis_values(print_position));
 801a408:	4b6d      	ldr	r3, [pc, #436]	; (801a5c0 <report_realtime_status+0x294>)
 801a40a:	f8d3 50b8 	ldr.w	r5, [r3, #184]	; 0xb8
 801a40e:	4b72      	ldr	r3, [pc, #456]	; (801a5d8 <report_realtime_status+0x2ac>)
 801a410:	681b      	ldr	r3, [r3, #0]
 801a412:	a806      	add	r0, sp, #24
 801a414:	4798      	blx	r3
 801a416:	47a8      	blx	r5
    if (settings.status_report.buffer_state) {
 801a418:	4b6d      	ldr	r3, [pc, #436]	; (801a5d0 <report_realtime_status+0x2a4>)
 801a41a:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 801a41e:	f013 0f02 	tst.w	r3, #2
 801a422:	d017      	beq.n	801a454 <report_realtime_status+0x128>
        hal.stream.write_all("|Bf:");
 801a424:	4d66      	ldr	r5, [pc, #408]	; (801a5c0 <report_realtime_status+0x294>)
 801a426:	f8d5 30b8 	ldr.w	r3, [r5, #184]	; 0xb8
 801a42a:	486c      	ldr	r0, [pc, #432]	; (801a5dc <report_realtime_status+0x2b0>)
 801a42c:	4798      	blx	r3
        hal.stream.write_all(uitoa((uint32_t)plan_get_block_buffer_available()));
 801a42e:	f8d5 60b8 	ldr.w	r6, [r5, #184]	; 0xb8
 801a432:	f7fc fc2f 	bl	8016c94 <plan_get_block_buffer_available>
 801a436:	f7fb f99f 	bl	8015778 <uitoa>
 801a43a:	47b0      	blx	r6
        hal.stream.write_all(",");
 801a43c:	f8d5 30b8 	ldr.w	r3, [r5, #184]	; 0xb8
 801a440:	4867      	ldr	r0, [pc, #412]	; (801a5e0 <report_realtime_status+0x2b4>)
 801a442:	4798      	blx	r3
        hal.stream.write_all(uitoa(hal.stream.get_rx_buffer_free()));
 801a444:	f8d5 60b8 	ldr.w	r6, [r5, #184]	; 0xb8
 801a448:	f8d5 30b0 	ldr.w	r3, [r5, #176]	; 0xb0
 801a44c:	4798      	blx	r3
 801a44e:	f7fb f993 	bl	8015778 <uitoa>
 801a452:	47b0      	blx	r6
    if(settings.status_report.line_numbers) {
 801a454:	4b5e      	ldr	r3, [pc, #376]	; (801a5d0 <report_realtime_status+0x2a4>)
 801a456:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 801a45a:	f013 0f04 	tst.w	r3, #4
 801a45e:	f040 8125 	bne.w	801a6ac <report_realtime_status+0x380>
    spindle_0 = spindle_get(0);
 801a462:	2000      	movs	r0, #0
 801a464:	f003 fa76 	bl	801d954 <spindle_get>
 801a468:	4606      	mov	r6, r0
    spindle_0_state = spindle_0->get_state();
 801a46a:	6a03      	ldr	r3, [r0, #32]
 801a46c:	4798      	blx	r3
 801a46e:	4607      	mov	r7, r0
    if(settings.status_report.feed_speed) {
 801a470:	4b57      	ldr	r3, [pc, #348]	; (801a5d0 <report_realtime_status+0x2a4>)
 801a472:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 801a476:	f013 0f08 	tst.w	r3, #8
 801a47a:	f000 8141 	beq.w	801a700 <report_realtime_status+0x3d4>
        if(spindle_0->cap.variable) {
 801a47e:	7a73      	ldrb	r3, [r6, #9]
 801a480:	f013 0f01 	tst.w	r3, #1
 801a484:	f000 812d 	beq.w	801a6e2 <report_realtime_status+0x3b6>
            hal.stream.write_all(appendbuf(2, "|FS:", get_rate_value(st_get_realtime_rate())));
 801a488:	4d4d      	ldr	r5, [pc, #308]	; (801a5c0 <report_realtime_status+0x294>)
 801a48a:	f8d5 90b8 	ldr.w	r9, [r5, #184]	; 0xb8
 801a48e:	4b55      	ldr	r3, [pc, #340]	; (801a5e4 <report_realtime_status+0x2b8>)
 801a490:	f8d3 a000 	ldr.w	sl, [r3]
 801a494:	f005 fbd0 	bl	801fc38 <st_get_realtime_rate>
 801a498:	47d0      	blx	sl
 801a49a:	4602      	mov	r2, r0
 801a49c:	4952      	ldr	r1, [pc, #328]	; (801a5e8 <report_realtime_status+0x2bc>)
 801a49e:	2002      	movs	r0, #2
 801a4a0:	f7fe f8c0 	bl	8018624 <appendbuf>
 801a4a4:	47c8      	blx	r9
            hal.stream.write_all(appendbuf(2, ",", uitoa(spindle_0_state.on ? lroundf(spindle_0->param->rpm_overridden) : 0)));
 801a4a6:	f8d5 50b8 	ldr.w	r5, [r5, #184]	; 0xb8
 801a4aa:	f017 0f01 	tst.w	r7, #1
 801a4ae:	f040 8112 	bne.w	801a6d6 <report_realtime_status+0x3aa>
 801a4b2:	2000      	movs	r0, #0
 801a4b4:	f7fb f960 	bl	8015778 <uitoa>
 801a4b8:	4602      	mov	r2, r0
 801a4ba:	4949      	ldr	r1, [pc, #292]	; (801a5e0 <report_realtime_status+0x2b4>)
 801a4bc:	2002      	movs	r0, #2
 801a4be:	f7fe f8b1 	bl	8018624 <appendbuf>
 801a4c2:	47a8      	blx	r5
            if(spindle_0->get_data /* && sys.mpg_mode */)
 801a4c4:	6b73      	ldr	r3, [r6, #52]	; 0x34
 801a4c6:	2b00      	cmp	r3, #0
 801a4c8:	f000 811a 	beq.w	801a700 <report_realtime_status+0x3d4>
                hal.stream.write_all(appendbuf(2, ",", uitoa(lroundf(spindle_0->get_data(SpindleData_RPM)->rpm))));
 801a4cc:	4a3c      	ldr	r2, [pc, #240]	; (801a5c0 <report_realtime_status+0x294>)
 801a4ce:	f8d2 50b8 	ldr.w	r5, [r2, #184]	; 0xb8
 801a4d2:	2001      	movs	r0, #1
 801a4d4:	4798      	blx	r3
 801a4d6:	ed90 0a00 	vldr	s0, [r0]
 801a4da:	f009 fb5a 	bl	8023b92 <lroundf>
 801a4de:	f7fb f94b 	bl	8015778 <uitoa>
 801a4e2:	4602      	mov	r2, r0
 801a4e4:	493e      	ldr	r1, [pc, #248]	; (801a5e0 <report_realtime_status+0x2b4>)
 801a4e6:	2002      	movs	r0, #2
 801a4e8:	f7fe f89c 	bl	8018624 <appendbuf>
 801a4ec:	47a8      	blx	r5
 801a4ee:	e107      	b.n	801a700 <report_realtime_status+0x3d4>
    switch (gc_state.tool_change && state == STATE_CYCLE ? STATE_TOOL_CHANGE : state) {
 801a4f0:	2840      	cmp	r0, #64	; 0x40
 801a4f2:	f47f af72 	bne.w	801a3da <report_realtime_status+0xae>
            hal.stream.write_all(appendbuf(2, "Door:", uitoa((uint32_t)sys.parking_state)));
 801a4f6:	4b32      	ldr	r3, [pc, #200]	; (801a5c0 <report_realtime_status+0x294>)
 801a4f8:	f8d3 50b8 	ldr.w	r5, [r3, #184]	; 0xb8
 801a4fc:	4b3b      	ldr	r3, [pc, #236]	; (801a5ec <report_realtime_status+0x2c0>)
 801a4fe:	f893 0034 	ldrb.w	r0, [r3, #52]	; 0x34
 801a502:	f7fb f939 	bl	8015778 <uitoa>
 801a506:	4602      	mov	r2, r0
 801a508:	4939      	ldr	r1, [pc, #228]	; (801a5f0 <report_realtime_status+0x2c4>)
 801a50a:	2002      	movs	r0, #2
 801a50c:	f7fe f88a 	bl	8018624 <appendbuf>
 801a510:	47a8      	blx	r5
            break;
 801a512:	e762      	b.n	801a3da <report_realtime_status+0xae>
            hal.stream.write_all("Idle");
 801a514:	4b2a      	ldr	r3, [pc, #168]	; (801a5c0 <report_realtime_status+0x294>)
 801a516:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801a51a:	4836      	ldr	r0, [pc, #216]	; (801a5f4 <report_realtime_status+0x2c8>)
 801a51c:	4798      	blx	r3
            break;
 801a51e:	e75c      	b.n	801a3da <report_realtime_status+0xae>
            hal.stream.write_all("Run");
 801a520:	4b27      	ldr	r3, [pc, #156]	; (801a5c0 <report_realtime_status+0x294>)
 801a522:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801a526:	4834      	ldr	r0, [pc, #208]	; (801a5f8 <report_realtime_status+0x2cc>)
 801a528:	4798      	blx	r3
            if(sys.probing_state == Probing_Active && settings.status_report.run_substate)
 801a52a:	4b30      	ldr	r3, [pc, #192]	; (801a5ec <report_realtime_status+0x2c0>)
 801a52c:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 801a530:	b2db      	uxtb	r3, r3
 801a532:	2b01      	cmp	r3, #1
 801a534:	d011      	beq.n	801a55a <report_realtime_status+0x22e>
            else if (probing)
 801a536:	4b31      	ldr	r3, [pc, #196]	; (801a5fc <report_realtime_status+0x2d0>)
 801a538:	781b      	ldrb	r3, [r3, #0]
 801a53a:	b11b      	cbz	r3, 801a544 <report_realtime_status+0x218>
                probing = probe_state.triggered;
 801a53c:	f3c8 0200 	ubfx	r2, r8, #0, #1
 801a540:	4b2e      	ldr	r3, [pc, #184]	; (801a5fc <report_realtime_status+0x2d0>)
 801a542:	701a      	strb	r2, [r3, #0]
            if(sys.flags.feed_hold_pending)
 801a544:	4b29      	ldr	r3, [pc, #164]	; (801a5ec <report_realtime_status+0x2c0>)
 801a546:	7d9b      	ldrb	r3, [r3, #22]
 801a548:	f013 0f20 	tst.w	r3, #32
 801a54c:	d00f      	beq.n	801a56e <report_realtime_status+0x242>
                hal.stream.write_all(":1");
 801a54e:	4b1c      	ldr	r3, [pc, #112]	; (801a5c0 <report_realtime_status+0x294>)
 801a550:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801a554:	482a      	ldr	r0, [pc, #168]	; (801a600 <report_realtime_status+0x2d4>)
 801a556:	4798      	blx	r3
 801a558:	e73f      	b.n	801a3da <report_realtime_status+0xae>
            if(sys.probing_state == Probing_Active && settings.status_report.run_substate)
 801a55a:	4b1d      	ldr	r3, [pc, #116]	; (801a5d0 <report_realtime_status+0x2a4>)
 801a55c:	f893 30fd 	ldrb.w	r3, [r3, #253]	; 0xfd
 801a560:	f013 0f08 	tst.w	r3, #8
 801a564:	d0e7      	beq.n	801a536 <report_realtime_status+0x20a>
                probing = true;
 801a566:	4b25      	ldr	r3, [pc, #148]	; (801a5fc <report_realtime_status+0x2d0>)
 801a568:	2201      	movs	r2, #1
 801a56a:	701a      	strb	r2, [r3, #0]
 801a56c:	e7ea      	b.n	801a544 <report_realtime_status+0x218>
            else if(probing)
 801a56e:	4b23      	ldr	r3, [pc, #140]	; (801a5fc <report_realtime_status+0x2d0>)
 801a570:	781b      	ldrb	r3, [r3, #0]
 801a572:	2b00      	cmp	r3, #0
 801a574:	f43f af31 	beq.w	801a3da <report_realtime_status+0xae>
                hal.stream.write_all(":2");
 801a578:	4b11      	ldr	r3, [pc, #68]	; (801a5c0 <report_realtime_status+0x294>)
 801a57a:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801a57e:	4821      	ldr	r0, [pc, #132]	; (801a604 <report_realtime_status+0x2d8>)
 801a580:	4798      	blx	r3
 801a582:	e72a      	b.n	801a3da <report_realtime_status+0xae>
            hal.stream.write_all(appendbuf(2, "Hold:", uitoa((uint32_t)(sys.holding_state - 1))));
 801a584:	4b0e      	ldr	r3, [pc, #56]	; (801a5c0 <report_realtime_status+0x294>)
 801a586:	f8d3 50b8 	ldr.w	r5, [r3, #184]	; 0xb8
 801a58a:	4b18      	ldr	r3, [pc, #96]	; (801a5ec <report_realtime_status+0x2c0>)
 801a58c:	f893 0035 	ldrb.w	r0, [r3, #53]	; 0x35
 801a590:	3801      	subs	r0, #1
 801a592:	f7fb f8f1 	bl	8015778 <uitoa>
 801a596:	4602      	mov	r2, r0
 801a598:	491b      	ldr	r1, [pc, #108]	; (801a608 <report_realtime_status+0x2dc>)
 801a59a:	2002      	movs	r0, #2
 801a59c:	f7fe f842 	bl	8018624 <appendbuf>
 801a5a0:	47a8      	blx	r5
            break;
 801a5a2:	e71a      	b.n	801a3da <report_realtime_status+0xae>
            hal.stream.write_all("Jog");
 801a5a4:	4b06      	ldr	r3, [pc, #24]	; (801a5c0 <report_realtime_status+0x294>)
 801a5a6:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801a5aa:	4818      	ldr	r0, [pc, #96]	; (801a60c <report_realtime_status+0x2e0>)
 801a5ac:	4798      	blx	r3
            break;
 801a5ae:	e714      	b.n	801a3da <report_realtime_status+0xae>
            hal.stream.write_all("Home");
 801a5b0:	4b03      	ldr	r3, [pc, #12]	; (801a5c0 <report_realtime_status+0x294>)
 801a5b2:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801a5b6:	4816      	ldr	r0, [pc, #88]	; (801a610 <report_realtime_status+0x2e4>)
 801a5b8:	4798      	blx	r3
            break;
 801a5ba:	e70e      	b.n	801a3da <report_realtime_status+0xae>
 801a5bc:	2000374c 	.word	0x2000374c
 801a5c0:	2000350c 	.word	0x2000350c
 801a5c4:	08027890 	.word	0x08027890
 801a5c8:	20003344 	.word	0x20003344
 801a5cc:	080278e0 	.word	0x080278e0
 801a5d0:	20003b14 	.word	0x20003b14
 801a5d4:	08027854 	.word	0x08027854
 801a5d8:	20003ac4 	.word	0x20003ac4
 801a5dc:	080278e8 	.word	0x080278e8
 801a5e0:	08027758 	.word	0x08027758
 801a5e4:	20003ac8 	.word	0x20003ac8
 801a5e8:	080278f8 	.word	0x080278f8
 801a5ec:	200036c4 	.word	0x200036c4
 801a5f0:	080278d0 	.word	0x080278d0
 801a5f4:	08027894 	.word	0x08027894
 801a5f8:	0802789c 	.word	0x0802789c
 801a5fc:	20003af5 	.word	0x20003af5
 801a600:	08027874 	.word	0x08027874
 801a604:	080278a0 	.word	0x080278a0
 801a608:	080278a4 	.word	0x080278a4
 801a60c:	080278ac 	.word	0x080278ac
 801a610:	080278b0 	.word	0x080278b0
            if((report.all || settings.status_report.alarm_substate) && sys.alarm)
 801a614:	2c00      	cmp	r4, #0
 801a616:	db05      	blt.n	801a624 <report_realtime_status+0x2f8>
 801a618:	4ba8      	ldr	r3, [pc, #672]	; (801a8bc <report_realtime_status+0x590>)
 801a61a:	f893 30fd 	ldrb.w	r3, [r3, #253]	; 0xfd
 801a61e:	f013 0f04 	tst.w	r3, #4
 801a622:	d003      	beq.n	801a62c <report_realtime_status+0x300>
 801a624:	4ba6      	ldr	r3, [pc, #664]	; (801a8c0 <report_realtime_status+0x594>)
 801a626:	f893 007c 	ldrb.w	r0, [r3, #124]	; 0x7c
 801a62a:	b928      	cbnz	r0, 801a638 <report_realtime_status+0x30c>
                hal.stream.write_all("Alarm");
 801a62c:	4ba5      	ldr	r3, [pc, #660]	; (801a8c4 <report_realtime_status+0x598>)
 801a62e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801a632:	48a5      	ldr	r0, [pc, #660]	; (801a8c8 <report_realtime_status+0x59c>)
 801a634:	4798      	blx	r3
 801a636:	e6d0      	b.n	801a3da <report_realtime_status+0xae>
                hal.stream.write_all(appendbuf(2, "Alarm:", uitoa((uint32_t)sys.alarm)));
 801a638:	4ba2      	ldr	r3, [pc, #648]	; (801a8c4 <report_realtime_status+0x598>)
 801a63a:	f8d3 50b8 	ldr.w	r5, [r3, #184]	; 0xb8
 801a63e:	f7fb f89b 	bl	8015778 <uitoa>
 801a642:	4602      	mov	r2, r0
 801a644:	49a1      	ldr	r1, [pc, #644]	; (801a8cc <report_realtime_status+0x5a0>)
 801a646:	2002      	movs	r0, #2
 801a648:	f7fd ffec 	bl	8018624 <appendbuf>
 801a64c:	47a8      	blx	r5
 801a64e:	e6c4      	b.n	801a3da <report_realtime_status+0xae>
            hal.stream.write_all("Check");
 801a650:	4b9c      	ldr	r3, [pc, #624]	; (801a8c4 <report_realtime_status+0x598>)
 801a652:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801a656:	489e      	ldr	r0, [pc, #632]	; (801a8d0 <report_realtime_status+0x5a4>)
 801a658:	4798      	blx	r3
            break;
 801a65a:	e6be      	b.n	801a3da <report_realtime_status+0xae>
            hal.stream.write_all("Sleep");
 801a65c:	4b99      	ldr	r3, [pc, #612]	; (801a8c4 <report_realtime_status+0x598>)
 801a65e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801a662:	489c      	ldr	r0, [pc, #624]	; (801a8d4 <report_realtime_status+0x5a8>)
 801a664:	4798      	blx	r3
            break;
 801a666:	e6b8      	b.n	801a3da <report_realtime_status+0xae>
        for (idx = 0; idx < N_AXIS; idx++) {
 801a668:	3501      	adds	r5, #1
 801a66a:	2d02      	cmp	r5, #2
 801a66c:	f63f aec0 	bhi.w	801a3f0 <report_realtime_status+0xc4>
            wco[idx] = gc_get_offset(idx);
 801a670:	4628      	mov	r0, r5
 801a672:	f7f4 fcd3 	bl	800f01c <gc_get_offset>
 801a676:	ab0a      	add	r3, sp, #40	; 0x28
 801a678:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 801a67c:	ed03 0a07 	vstr	s0, [r3, #-28]	; 0xffffffe4
            if (!settings.status_report.machine_position)
 801a680:	4b8e      	ldr	r3, [pc, #568]	; (801a8bc <report_realtime_status+0x590>)
 801a682:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 801a686:	f013 0f01 	tst.w	r3, #1
 801a68a:	d1ed      	bne.n	801a668 <report_realtime_status+0x33c>
                print_position[idx] -= wco[idx];
 801a68c:	ab0a      	add	r3, sp, #40	; 0x28
 801a68e:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 801a692:	ed53 7a04 	vldr	s15, [r3, #-16]
 801a696:	ee77 7ac0 	vsub.f32	s15, s15, s0
 801a69a:	ed43 7a04 	vstr	s15, [r3, #-16]
 801a69e:	e7e3      	b.n	801a668 <report_realtime_status+0x33c>
 801a6a0:	2500      	movs	r5, #0
 801a6a2:	e7e2      	b.n	801a66a <report_realtime_status+0x33e>
 801a6a4:	2500      	movs	r5, #0
 801a6a6:	e7e0      	b.n	801a66a <report_realtime_status+0x33e>
    hal.stream.write_all(settings.status_report.machine_position ? "|MPos:" : "|WPos:");
 801a6a8:	488b      	ldr	r0, [pc, #556]	; (801a8d8 <report_realtime_status+0x5ac>)
 801a6aa:	e6ac      	b.n	801a406 <report_realtime_status+0xda>
        plan_block_t *cur_block = plan_get_current_block();
 801a6ac:	f7fc f802 	bl	80166b4 <plan_get_current_block>
        if (cur_block != NULL && cur_block->line_number > 0)
 801a6b0:	2800      	cmp	r0, #0
 801a6b2:	f43f aed6 	beq.w	801a462 <report_realtime_status+0x136>
 801a6b6:	6980      	ldr	r0, [r0, #24]
 801a6b8:	2800      	cmp	r0, #0
 801a6ba:	f77f aed2 	ble.w	801a462 <report_realtime_status+0x136>
            hal.stream.write_all(appendbuf(2, "|Ln:", uitoa((uint32_t)cur_block->line_number)));
 801a6be:	4b81      	ldr	r3, [pc, #516]	; (801a8c4 <report_realtime_status+0x598>)
 801a6c0:	f8d3 50b8 	ldr.w	r5, [r3, #184]	; 0xb8
 801a6c4:	f7fb f858 	bl	8015778 <uitoa>
 801a6c8:	4602      	mov	r2, r0
 801a6ca:	4984      	ldr	r1, [pc, #528]	; (801a8dc <report_realtime_status+0x5b0>)
 801a6cc:	2002      	movs	r0, #2
 801a6ce:	f7fd ffa9 	bl	8018624 <appendbuf>
 801a6d2:	47a8      	blx	r5
 801a6d4:	e6c5      	b.n	801a462 <report_realtime_status+0x136>
            hal.stream.write_all(appendbuf(2, ",", uitoa(spindle_0_state.on ? lroundf(spindle_0->param->rpm_overridden) : 0)));
 801a6d6:	6873      	ldr	r3, [r6, #4]
 801a6d8:	ed93 0a01 	vldr	s0, [r3, #4]
 801a6dc:	f009 fa59 	bl	8023b92 <lroundf>
 801a6e0:	e6e8      	b.n	801a4b4 <report_realtime_status+0x188>
            hal.stream.write_all(appendbuf(2, "|F:", get_rate_value(st_get_realtime_rate())));
 801a6e2:	4b78      	ldr	r3, [pc, #480]	; (801a8c4 <report_realtime_status+0x598>)
 801a6e4:	f8d3 50b8 	ldr.w	r5, [r3, #184]	; 0xb8
 801a6e8:	4b7d      	ldr	r3, [pc, #500]	; (801a8e0 <report_realtime_status+0x5b4>)
 801a6ea:	f8d3 9000 	ldr.w	r9, [r3]
 801a6ee:	f005 faa3 	bl	801fc38 <st_get_realtime_rate>
 801a6f2:	47c8      	blx	r9
 801a6f4:	4602      	mov	r2, r0
 801a6f6:	497b      	ldr	r1, [pc, #492]	; (801a8e4 <report_realtime_status+0x5b8>)
 801a6f8:	2002      	movs	r0, #2
 801a6fa:	f7fd ff93 	bl	8018624 <appendbuf>
 801a6fe:	47a8      	blx	r5
    if(settings.status_report.pin_state) {
 801a700:	4b6e      	ldr	r3, [pc, #440]	; (801a8bc <report_realtime_status+0x590>)
 801a702:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 801a706:	f013 0f10 	tst.w	r3, #16
 801a70a:	d02b      	beq.n	801a764 <report_realtime_status+0x438>
        axes_signals_t lim_pin_state = limit_signals_merge(hal.limits.get_state());
 801a70c:	f8df 91b4 	ldr.w	r9, [pc, #436]	; 801a8c4 <report_realtime_status+0x598>
 801a710:	f8d9 3058 	ldr.w	r3, [r9, #88]	; 0x58
 801a714:	4798      	blx	r3
 801a716:	9009      	str	r0, [sp, #36]	; 0x24
 801a718:	f7f8 fdee 	bl	80132f8 <limit_signals_merge>
 801a71c:	4605      	mov	r5, r0
        control_signals_t ctrl_pin_state = hal.control.get_state();
 801a71e:	f8d9 3068 	ldr.w	r3, [r9, #104]	; 0x68
 801a722:	4798      	blx	r3
 801a724:	4603      	mov	r3, r0
        ctrl_pin_state.cycle_start |= sys.report.cycle_start;
 801a726:	4966      	ldr	r1, [pc, #408]	; (801a8c0 <report_realtime_status+0x594>)
 801a728:	f891 2033 	ldrb.w	r2, [r1, #51]	; 0x33
 801a72c:	f3c2 1280 	ubfx	r2, r2, #6, #1
 801a730:	f3c3 0080 	ubfx	r0, r3, #2, #1
 801a734:	4302      	orrs	r2, r0
 801a736:	f362 0382 	bfi	r3, r2, #2, #1
        if (lim_pin_state.value | ctrl_pin_state.value | probe_state.triggered | !probe_state.connected | sys.flags.block_delete_enabled) {
 801a73a:	fa5f fe85 	uxtb.w	lr, r5
 801a73e:	fa1f fc83 	uxth.w	ip, r3
 801a742:	ea4e 020c 	orr.w	r2, lr, ip
 801a746:	f008 0001 	and.w	r0, r8, #1
 801a74a:	4302      	orrs	r2, r0
 801a74c:	fa5f f988 	uxtb.w	r9, r8
 801a750:	f018 0802 	ands.w	r8, r8, #2
 801a754:	bf08      	it	eq
 801a756:	f042 0201 	orreq.w	r2, r2, #1
 801a75a:	7d89      	ldrb	r1, [r1, #22]
 801a75c:	f3c1 1100 	ubfx	r1, r1, #4, #1
 801a760:	430a      	orrs	r2, r1
 801a762:	d115      	bne.n	801a790 <report_realtime_status+0x464>
    if(settings.status_report.work_coord_offset) {
 801a764:	4b55      	ldr	r3, [pc, #340]	; (801a8bc <report_realtime_status+0x590>)
 801a766:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 801a76a:	f013 0f20 	tst.w	r3, #32
 801a76e:	f000 8093 	beq.w	801a898 <report_realtime_status+0x56c>
        if(wco_counter > 0 && !report.wco) {
 801a772:	4b5d      	ldr	r3, [pc, #372]	; (801a8e8 <report_realtime_status+0x5bc>)
 801a774:	781b      	ldrb	r3, [r3, #0]
 801a776:	2b00      	cmp	r3, #0
 801a778:	f000 8083 	beq.w	801a882 <report_realtime_status+0x556>
 801a77c:	f414 7f80 	tst.w	r4, #256	; 0x100
 801a780:	d17f      	bne.n	801a882 <report_realtime_status+0x556>
            if(wco_counter > (REPORT_WCO_REFRESH_IDLE_COUNT - 1) && state_get() == STATE_IDLE)
 801a782:	2b09      	cmp	r3, #9
 801a784:	d875      	bhi.n	801a872 <report_realtime_status+0x546>
            wco_counter--;
 801a786:	4a58      	ldr	r2, [pc, #352]	; (801a8e8 <report_realtime_status+0x5bc>)
 801a788:	7813      	ldrb	r3, [r2, #0]
 801a78a:	3b01      	subs	r3, #1
 801a78c:	7013      	strb	r3, [r2, #0]
 801a78e:	e085      	b.n	801a89c <report_realtime_status+0x570>
            strcpy(buf, "|Pn:");
 801a790:	4a56      	ldr	r2, [pc, #344]	; (801a8ec <report_realtime_status+0x5c0>)
 801a792:	4957      	ldr	r1, [pc, #348]	; (801a8f0 <report_realtime_status+0x5c4>)
 801a794:	c903      	ldmia	r1, {r0, r1}
 801a796:	6010      	str	r0, [r2, #0]
 801a798:	7111      	strb	r1, [r2, #4]
            if(probe_state.triggered)
 801a79a:	f019 0f01 	tst.w	r9, #1
 801a79e:	d019      	beq.n	801a7d4 <report_realtime_status+0x4a8>
                *append++ = 'P';
 801a7a0:	2150      	movs	r1, #80	; 0x50
 801a7a2:	7111      	strb	r1, [r2, #4]
 801a7a4:	3205      	adds	r2, #5
            if(!probe_state.connected)
 801a7a6:	f1b8 0f00 	cmp.w	r8, #0
 801a7aa:	d102      	bne.n	801a7b2 <report_realtime_status+0x486>
                *append++ = 'O';
 801a7ac:	214f      	movs	r1, #79	; 0x4f
 801a7ae:	f802 1b01 	strb.w	r1, [r2], #1
            if(lim_pin_state.value && !ctrl_pin_state.limits_override)
 801a7b2:	f1be 0f00 	cmp.w	lr, #0
 801a7b6:	d002      	beq.n	801a7be <report_realtime_status+0x492>
 801a7b8:	f413 6f80 	tst.w	r3, #1024	; 0x400
 801a7bc:	d00c      	beq.n	801a7d8 <report_realtime_status+0x4ac>
            if(ctrl_pin_state.value)
 801a7be:	f1bc 0f00 	cmp.w	ip, #0
 801a7c2:	d120      	bne.n	801a806 <report_realtime_status+0x4da>
            *append = '\0';
 801a7c4:	2300      	movs	r3, #0
 801a7c6:	7013      	strb	r3, [r2, #0]
            hal.stream.write_all(buf);
 801a7c8:	4b3e      	ldr	r3, [pc, #248]	; (801a8c4 <report_realtime_status+0x598>)
 801a7ca:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801a7ce:	4847      	ldr	r0, [pc, #284]	; (801a8ec <report_realtime_status+0x5c0>)
 801a7d0:	4798      	blx	r3
 801a7d2:	e7c7      	b.n	801a764 <report_realtime_status+0x438>
            char *append = &buf[4];
 801a7d4:	4a47      	ldr	r2, [pc, #284]	; (801a8f4 <report_realtime_status+0x5c8>)
 801a7d6:	e7e6      	b.n	801a7a6 <report_realtime_status+0x47a>
    signals.mask &= AXES_BITMASK;
 801a7d8:	f005 0507 	and.w	r5, r5, #7
    uint_fast16_t idx = 0;
 801a7dc:	2100      	movs	r1, #0
 801a7de:	4628      	mov	r0, r5
    while(signals.mask) {
 801a7e0:	e002      	b.n	801a7e8 <report_realtime_status+0x4bc>
        idx++;
 801a7e2:	3101      	adds	r1, #1
        signals.mask >>= 1;
 801a7e4:	f3c0 0047 	ubfx	r0, r0, #1, #8
    while(signals.mask) {
 801a7e8:	b2c0      	uxtb	r0, r0
 801a7ea:	b148      	cbz	r0, 801a800 <report_realtime_status+0x4d4>
        if(signals.mask & 0x01)
 801a7ec:	f010 0f01 	tst.w	r0, #1
 801a7f0:	d0f7      	beq.n	801a7e2 <report_realtime_status+0x4b6>
            *buf++ = *axis_letter[idx];
 801a7f2:	4d41      	ldr	r5, [pc, #260]	; (801a8f8 <report_realtime_status+0x5cc>)
 801a7f4:	f855 5021 	ldr.w	r5, [r5, r1, lsl #2]
 801a7f8:	782d      	ldrb	r5, [r5, #0]
 801a7fa:	f802 5b01 	strb.w	r5, [r2], #1
 801a7fe:	e7f0      	b.n	801a7e2 <report_realtime_status+0x4b6>
    *buf = '\0';
 801a800:	2100      	movs	r1, #0
 801a802:	7011      	strb	r1, [r2, #0]
    return buf;
 801a804:	e7db      	b.n	801a7be <report_realtime_status+0x492>
    if(!hal.signals_cap.stop_disable)
 801a806:	492f      	ldr	r1, [pc, #188]	; (801a8c4 <report_realtime_status+0x598>)
 801a808:	f891 11a8 	ldrb.w	r1, [r1, #424]	; 0x1a8
 801a80c:	f011 0f20 	tst.w	r1, #32
 801a810:	d105      	bne.n	801a81e <report_realtime_status+0x4f2>
        signals.stop_disable = sys.flags.optional_stop_disable;
 801a812:	492b      	ldr	r1, [pc, #172]	; (801a8c0 <report_realtime_status+0x594>)
 801a814:	7d89      	ldrb	r1, [r1, #22]
 801a816:	f3c1 1180 	ubfx	r1, r1, #6, #1
 801a81a:	f361 1345 	bfi	r3, r1, #5, #1
    if(!signals.deasserted)
 801a81e:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 801a822:	d123      	bne.n	801a86c <report_realtime_status+0x540>
    char *map = (char *)signals_map;
 801a824:	4935      	ldr	r1, [pc, #212]	; (801a8fc <report_realtime_status+0x5d0>)
 801a826:	e00a      	b.n	801a83e <report_realtime_status+0x512>
                    if(hal.signals_cap.safety_door_ajar)
 801a828:	4d26      	ldr	r5, [pc, #152]	; (801a8c4 <report_realtime_status+0x598>)
 801a82a:	f895 51a8 	ldrb.w	r5, [r5, #424]	; 0x1a8
 801a82e:	f015 0f08 	tst.w	r5, #8
 801a832:	d001      	beq.n	801a838 <report_realtime_status+0x50c>
                        *buf++ = *map;
 801a834:	f802 0b01 	strb.w	r0, [r2], #1
        map++;
 801a838:	3101      	adds	r1, #1
        signals.mask >>= 1;
 801a83a:	f3c3 034f 	ubfx	r3, r3, #1, #16
      while(signals.mask) {
 801a83e:	b29b      	uxth	r3, r3
 801a840:	b1a3      	cbz	r3, 801a86c <report_realtime_status+0x540>
        if(signals.mask & 0x01) {
 801a842:	f013 0f01 	tst.w	r3, #1
 801a846:	d0f7      	beq.n	801a838 <report_realtime_status+0x50c>
            switch(*map) {
 801a848:	7808      	ldrb	r0, [r1, #0]
 801a84a:	2844      	cmp	r0, #68	; 0x44
 801a84c:	d0ec      	beq.n	801a828 <report_realtime_status+0x4fc>
 801a84e:	284c      	cmp	r0, #76	; 0x4c
 801a850:	d004      	beq.n	801a85c <report_realtime_status+0x530>
 801a852:	2820      	cmp	r0, #32
 801a854:	d0f0      	beq.n	801a838 <report_realtime_status+0x50c>
                    *buf++ = *map;
 801a856:	f802 0b01 	strb.w	r0, [r2], #1
                    break;
 801a85a:	e7ed      	b.n	801a838 <report_realtime_status+0x50c>
                    if(sys.flags.block_delete_enabled)
 801a85c:	4d18      	ldr	r5, [pc, #96]	; (801a8c0 <report_realtime_status+0x594>)
 801a85e:	7dad      	ldrb	r5, [r5, #22]
 801a860:	f015 0f10 	tst.w	r5, #16
 801a864:	d0e8      	beq.n	801a838 <report_realtime_status+0x50c>
                        *buf++ = *map;
 801a866:	f802 0b01 	strb.w	r0, [r2], #1
 801a86a:	e7e5      	b.n	801a838 <report_realtime_status+0x50c>
    *buf = '\0';
 801a86c:	2300      	movs	r3, #0
 801a86e:	7013      	strb	r3, [r2, #0]
    return buf;
 801a870:	e7a8      	b.n	801a7c4 <report_realtime_status+0x498>
            if(wco_counter > (REPORT_WCO_REFRESH_IDLE_COUNT - 1) && state_get() == STATE_IDLE)
 801a872:	f003 feb7 	bl	801e5e4 <state_get>
 801a876:	2800      	cmp	r0, #0
 801a878:	d185      	bne.n	801a786 <report_realtime_status+0x45a>
                wco_counter = REPORT_WCO_REFRESH_IDLE_COUNT - 1;
 801a87a:	4b1b      	ldr	r3, [pc, #108]	; (801a8e8 <report_realtime_status+0x5bc>)
 801a87c:	2209      	movs	r2, #9
 801a87e:	701a      	strb	r2, [r3, #0]
 801a880:	e781      	b.n	801a786 <report_realtime_status+0x45a>
            wco_counter = state_get() & (STATE_HOMING|STATE_CYCLE|STATE_HOLD|STATE_JOG|STATE_SAFETY_DOOR)
 801a882:	f003 feaf 	bl	801e5e4 <state_get>
 801a886:	f010 0f7c 	tst.w	r0, #124	; 0x7c
 801a88a:	d003      	beq.n	801a894 <report_realtime_status+0x568>
 801a88c:	221d      	movs	r2, #29
 801a88e:	4b16      	ldr	r3, [pc, #88]	; (801a8e8 <report_realtime_status+0x5bc>)
 801a890:	701a      	strb	r2, [r3, #0]
 801a892:	e003      	b.n	801a89c <report_realtime_status+0x570>
 801a894:	2209      	movs	r2, #9
 801a896:	e7fa      	b.n	801a88e <report_realtime_status+0x562>
        report.wco = Off;
 801a898:	f36f 2408 	bfc	r4, #8, #1
    if(settings.status_report.overrides) {
 801a89c:	4b07      	ldr	r3, [pc, #28]	; (801a8bc <report_realtime_status+0x590>)
 801a89e:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 801a8a2:	f013 0f40 	tst.w	r3, #64	; 0x40
 801a8a6:	d05d      	beq.n	801a964 <report_realtime_status+0x638>
        if (override_counter > 0 && !report.overrides)
 801a8a8:	4b15      	ldr	r3, [pc, #84]	; (801a900 <report_realtime_status+0x5d4>)
 801a8aa:	781b      	ldrb	r3, [r3, #0]
 801a8ac:	b353      	cbz	r3, 801a904 <report_realtime_status+0x5d8>
 801a8ae:	f014 0f40 	tst.w	r4, #64	; 0x40
 801a8b2:	d127      	bne.n	801a904 <report_realtime_status+0x5d8>
            override_counter--;
 801a8b4:	3b01      	subs	r3, #1
 801a8b6:	4a12      	ldr	r2, [pc, #72]	; (801a900 <report_realtime_status+0x5d4>)
 801a8b8:	7013      	strb	r3, [r2, #0]
 801a8ba:	e055      	b.n	801a968 <report_realtime_status+0x63c>
 801a8bc:	20003b14 	.word	0x20003b14
 801a8c0:	200036c4 	.word	0x200036c4
 801a8c4:	2000350c 	.word	0x2000350c
 801a8c8:	080278c0 	.word	0x080278c0
 801a8cc:	080278b8 	.word	0x080278b8
 801a8d0:	080278c8 	.word	0x080278c8
 801a8d4:	080278d8 	.word	0x080278d8
 801a8d8:	0802785c 	.word	0x0802785c
 801a8dc:	080278f0 	.word	0x080278f0
 801a8e0:	20003ac8 	.word	0x20003ac8
 801a8e4:	08027900 	.word	0x08027900
 801a8e8:	20003b00 	.word	0x20003b00
 801a8ec:	20003a88 	.word	0x20003a88
 801a8f0:	08027904 	.word	0x08027904
 801a8f4:	20003a8c 	.word	0x20003a8c
 801a8f8:	080271cc 	.word	0x080271cc
 801a8fc:	080283d4 	.word	0x080283d4
 801a900:	20003af4 	.word	0x20003af4
        else if((report.overrides = !report.wco)) {
 801a904:	f3c4 2307 	ubfx	r3, r4, #8, #8
 801a908:	f083 0301 	eor.w	r3, r3, #1
 801a90c:	f003 0301 	and.w	r3, r3, #1
 801a910:	f363 1486 	bfi	r4, r3, #6, #1
 801a914:	b343      	cbz	r3, 801a968 <report_realtime_status+0x63c>
            report.spindle = report.spindle || spindle_0_state.on;
 801a916:	f014 0f10 	tst.w	r4, #16
 801a91a:	d104      	bne.n	801a926 <report_realtime_status+0x5fa>
 801a91c:	f017 0f01 	tst.w	r7, #1
 801a920:	d00e      	beq.n	801a940 <report_realtime_status+0x614>
 801a922:	2301      	movs	r3, #1
 801a924:	e000      	b.n	801a928 <report_realtime_status+0x5fc>
 801a926:	2301      	movs	r3, #1
 801a928:	f363 1404 	bfi	r4, r3, #4, #1
            report.coolant = report.coolant || hal.coolant.get_state().value != 0;
 801a92c:	f014 0f20 	tst.w	r4, #32
 801a930:	d108      	bne.n	801a944 <report_realtime_status+0x618>
 801a932:	4b99      	ldr	r3, [pc, #612]	; (801ab98 <report_realtime_status+0x86c>)
 801a934:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801a936:	4798      	blx	r3
 801a938:	b2c0      	uxtb	r0, r0
 801a93a:	b978      	cbnz	r0, 801a95c <report_realtime_status+0x630>
 801a93c:	2300      	movs	r3, #0
 801a93e:	e002      	b.n	801a946 <report_realtime_status+0x61a>
            report.spindle = report.spindle || spindle_0_state.on;
 801a940:	2300      	movs	r3, #0
 801a942:	e7f1      	b.n	801a928 <report_realtime_status+0x5fc>
            report.coolant = report.coolant || hal.coolant.get_state().value != 0;
 801a944:	2301      	movs	r3, #1
 801a946:	f363 1445 	bfi	r4, r3, #5, #1
            override_counter = state_get() & (STATE_HOMING|STATE_CYCLE|STATE_HOLD|STATE_JOG|STATE_SAFETY_DOOR)
 801a94a:	f003 fe4b 	bl	801e5e4 <state_get>
 801a94e:	f010 0f7c 	tst.w	r0, #124	; 0x7c
 801a952:	d005      	beq.n	801a960 <report_realtime_status+0x634>
 801a954:	2213      	movs	r2, #19
 801a956:	4b91      	ldr	r3, [pc, #580]	; (801ab9c <report_realtime_status+0x870>)
 801a958:	701a      	strb	r2, [r3, #0]
 801a95a:	e005      	b.n	801a968 <report_realtime_status+0x63c>
            report.coolant = report.coolant || hal.coolant.get_state().value != 0;
 801a95c:	2301      	movs	r3, #1
 801a95e:	e7f2      	b.n	801a946 <report_realtime_status+0x61a>
            override_counter = state_get() & (STATE_HOMING|STATE_CYCLE|STATE_HOLD|STATE_JOG|STATE_SAFETY_DOOR)
 801a960:	2209      	movs	r2, #9
 801a962:	e7f8      	b.n	801a956 <report_realtime_status+0x62a>
        report.overrides = Off;
 801a964:	f36f 1486 	bfc	r4, #6, #1
    if(report.value || gc_state.tool_change) {
 801a968:	9400      	str	r4, [sp, #0]
 801a96a:	b92c      	cbnz	r4, 801a978 <report_realtime_status+0x64c>
 801a96c:	4b8c      	ldr	r3, [pc, #560]	; (801aba0 <report_realtime_status+0x874>)
 801a96e:	f893 3077 	ldrb.w	r3, [r3, #119]	; 0x77
 801a972:	2b00      	cmp	r3, #0
 801a974:	f000 80d9 	beq.w	801ab2a <report_realtime_status+0x7fe>
        if(report.wco) {
 801a978:	f3c4 2907 	ubfx	r9, r4, #8, #8
 801a97c:	46c8      	mov	r8, r9
 801a97e:	f414 7f80 	tst.w	r4, #256	; 0x100
 801a982:	d00b      	beq.n	801a99c <report_realtime_status+0x670>
            hal.stream.write_all("|WCO:");
 801a984:	4d84      	ldr	r5, [pc, #528]	; (801ab98 <report_realtime_status+0x86c>)
 801a986:	f8d5 30b8 	ldr.w	r3, [r5, #184]	; 0xb8
 801a98a:	4886      	ldr	r0, [pc, #536]	; (801aba4 <report_realtime_status+0x878>)
 801a98c:	4798      	blx	r3
            hal.stream.write_all(get_axis_values(wco));
 801a98e:	f8d5 50b8 	ldr.w	r5, [r5, #184]	; 0xb8
 801a992:	4b85      	ldr	r3, [pc, #532]	; (801aba8 <report_realtime_status+0x87c>)
 801a994:	681b      	ldr	r3, [r3, #0]
 801a996:	a803      	add	r0, sp, #12
 801a998:	4798      	blx	r3
 801a99a:	47a8      	blx	r5
        if(report.gwco) {
 801a99c:	f018 0f02 	tst.w	r8, #2
 801a9a0:	d00b      	beq.n	801a9ba <report_realtime_status+0x68e>
            hal.stream.write_all("|WCS:G");
 801a9a2:	4d7d      	ldr	r5, [pc, #500]	; (801ab98 <report_realtime_status+0x86c>)
 801a9a4:	f8d5 30b8 	ldr.w	r3, [r5, #184]	; 0xb8
 801a9a8:	4880      	ldr	r0, [pc, #512]	; (801abac <report_realtime_status+0x880>)
 801a9aa:	4798      	blx	r3
            hal.stream.write_all(map_coord_system(gc_state.modal.coord_system.id));
 801a9ac:	f8d5 50b8 	ldr.w	r5, [r5, #184]	; 0xb8
 801a9b0:	4b7b      	ldr	r3, [pc, #492]	; (801aba0 <report_realtime_status+0x874>)
 801a9b2:	7d18      	ldrb	r0, [r3, #20]
 801a9b4:	f7fd fe10 	bl	80185d8 <map_coord_system>
 801a9b8:	47a8      	blx	r5
        if(report.overrides) {
 801a9ba:	b2e5      	uxtb	r5, r4
 801a9bc:	f014 0f40 	tst.w	r4, #64	; 0x40
 801a9c0:	f040 8112 	bne.w	801abe8 <report_realtime_status+0x8bc>
        if(report.spindle || report.coolant || report.tool || gc_state.tool_change) {
 801a9c4:	f015 0fb0 	tst.w	r5, #176	; 0xb0
 801a9c8:	d104      	bne.n	801a9d4 <report_realtime_status+0x6a8>
 801a9ca:	4b75      	ldr	r3, [pc, #468]	; (801aba0 <report_realtime_status+0x874>)
 801a9cc:	f893 3077 	ldrb.w	r3, [r3, #119]	; 0x77
 801a9d0:	2b00      	cmp	r3, #0
 801a9d2:	d03c      	beq.n	801aa4e <report_realtime_status+0x722>
            coolant_state_t cl_state = hal.coolant.get_state();
 801a9d4:	4b70      	ldr	r3, [pc, #448]	; (801ab98 <report_realtime_status+0x86c>)
 801a9d6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801a9d8:	4798      	blx	r3
            strcpy(buf, "|A:");
 801a9da:	4b75      	ldr	r3, [pc, #468]	; (801abb0 <report_realtime_status+0x884>)
 801a9dc:	4a75      	ldr	r2, [pc, #468]	; (801abb4 <report_realtime_status+0x888>)
 801a9de:	601a      	str	r2, [r3, #0]
            if (spindle_0_state.on)
 801a9e0:	b2fa      	uxtb	r2, r7
 801a9e2:	f017 0f01 	tst.w	r7, #1
 801a9e6:	f000 8130 	beq.w	801ac4a <report_realtime_status+0x91e>
                *append++ = spindle_0_state.ccw ? 'C' : 'S';
 801a9ea:	f012 0f02 	tst.w	r2, #2
 801a9ee:	f000 812a 	beq.w	801ac46 <report_realtime_status+0x91a>
 801a9f2:	2143      	movs	r1, #67	; 0x43
 801a9f4:	4b6e      	ldr	r3, [pc, #440]	; (801abb0 <report_realtime_status+0x884>)
 801a9f6:	70d9      	strb	r1, [r3, #3]
 801a9f8:	3304      	adds	r3, #4
            if(spindle_0_state.encoder_error && hal.driver_cap.spindle_sync)
 801a9fa:	f012 0f20 	tst.w	r2, #32
 801a9fe:	d008      	beq.n	801aa12 <report_realtime_status+0x6e6>
 801aa00:	4a65      	ldr	r2, [pc, #404]	; (801ab98 <report_realtime_status+0x86c>)
 801aa02:	f892 21a5 	ldrb.w	r2, [r2, #421]	; 0x1a5
 801aa06:	f012 0f01 	tst.w	r2, #1
 801aa0a:	d002      	beq.n	801aa12 <report_realtime_status+0x6e6>
                *append++ = 'E';
 801aa0c:	2245      	movs	r2, #69	; 0x45
 801aa0e:	f803 2b01 	strb.w	r2, [r3], #1
            if (cl_state.flood)
 801aa12:	b2c2      	uxtb	r2, r0
 801aa14:	f010 0f01 	tst.w	r0, #1
 801aa18:	d002      	beq.n	801aa20 <report_realtime_status+0x6f4>
                *append++ = 'F';
 801aa1a:	2146      	movs	r1, #70	; 0x46
 801aa1c:	f803 1b01 	strb.w	r1, [r3], #1
            if (cl_state.mist)
 801aa20:	f012 0f02 	tst.w	r2, #2
 801aa24:	d002      	beq.n	801aa2c <report_realtime_status+0x700>
                *append++ = 'M';
 801aa26:	224d      	movs	r2, #77	; 0x4d
 801aa28:	f803 2b01 	strb.w	r2, [r3], #1
            if(gc_state.tool_change && !report.tool)
 801aa2c:	4a5c      	ldr	r2, [pc, #368]	; (801aba0 <report_realtime_status+0x874>)
 801aa2e:	f892 2077 	ldrb.w	r2, [r2, #119]	; 0x77
 801aa32:	b12a      	cbz	r2, 801aa40 <report_realtime_status+0x714>
 801aa34:	f015 0f80 	tst.w	r5, #128	; 0x80
 801aa38:	d102      	bne.n	801aa40 <report_realtime_status+0x714>
                *append++ = 'T';
 801aa3a:	2254      	movs	r2, #84	; 0x54
 801aa3c:	f803 2b01 	strb.w	r2, [r3], #1
            *append = '\0';
 801aa40:	2200      	movs	r2, #0
 801aa42:	701a      	strb	r2, [r3, #0]
            hal.stream.write_all(buf);
 801aa44:	4b54      	ldr	r3, [pc, #336]	; (801ab98 <report_realtime_status+0x86c>)
 801aa46:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801aa4a:	4859      	ldr	r0, [pc, #356]	; (801abb0 <report_realtime_status+0x884>)
 801aa4c:	4798      	blx	r3
        if(report.scaling) {
 801aa4e:	f015 0f02 	tst.w	r5, #2
 801aa52:	f040 80fc 	bne.w	801ac4e <report_realtime_status+0x922>
        if((report.all || report.mpg_mode) && settings.report_interval) {
 801aa56:	4b58      	ldr	r3, [pc, #352]	; (801abb8 <report_realtime_status+0x88c>)
 801aa58:	9a00      	ldr	r2, [sp, #0]
 801aa5a:	421a      	tst	r2, r3
 801aa5c:	d013      	beq.n	801aa86 <report_realtime_status+0x75a>
 801aa5e:	4b57      	ldr	r3, [pc, #348]	; (801abbc <report_realtime_status+0x890>)
 801aa60:	8a9b      	ldrh	r3, [r3, #20]
 801aa62:	b183      	cbz	r3, 801aa86 <report_realtime_status+0x75a>
            hal.stream.write_all(sys.flags.auto_reporting ? "|AR:" : "|AR");
 801aa64:	4b4c      	ldr	r3, [pc, #304]	; (801ab98 <report_realtime_status+0x86c>)
 801aa66:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801aa6a:	4a55      	ldr	r2, [pc, #340]	; (801abc0 <report_realtime_status+0x894>)
 801aa6c:	7dd2      	ldrb	r2, [r2, #23]
 801aa6e:	f012 0f02 	tst.w	r2, #2
 801aa72:	f000 810e 	beq.w	801ac92 <report_realtime_status+0x966>
 801aa76:	4853      	ldr	r0, [pc, #332]	; (801abc4 <report_realtime_status+0x898>)
 801aa78:	4798      	blx	r3
            if(sys.flags.auto_reporting)
 801aa7a:	4b51      	ldr	r3, [pc, #324]	; (801abc0 <report_realtime_status+0x894>)
 801aa7c:	7ddb      	ldrb	r3, [r3, #23]
 801aa7e:	f013 0f02 	tst.w	r3, #2
 801aa82:	f040 8108 	bne.w	801ac96 <report_realtime_status+0x96a>
        if(report.mpg_mode)
 801aa86:	f015 0f01 	tst.w	r5, #1
 801aa8a:	d00a      	beq.n	801aaa2 <report_realtime_status+0x776>
            hal.stream.write_all(sys.mpg_mode ? "|MPG:1" : "|MPG:0");
 801aa8c:	4b42      	ldr	r3, [pc, #264]	; (801ab98 <report_realtime_status+0x86c>)
 801aa8e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801aa92:	4a4b      	ldr	r2, [pc, #300]	; (801abc0 <report_realtime_status+0x894>)
 801aa94:	f892 207f 	ldrb.w	r2, [r2, #127]	; 0x7f
 801aa98:	2a00      	cmp	r2, #0
 801aa9a:	f000 8105 	beq.w	801aca8 <report_realtime_status+0x97c>
 801aa9e:	484a      	ldr	r0, [pc, #296]	; (801abc8 <report_realtime_status+0x89c>)
 801aaa0:	4798      	blx	r3
        if(report.homed && (sys.homing.mask || settings.homing.flags.single_axis_commands || settings.homing.flags.manual)) {
 801aaa2:	f015 0f04 	tst.w	r5, #4
 801aaa6:	d020      	beq.n	801aaea <report_realtime_status+0x7be>
 801aaa8:	4b45      	ldr	r3, [pc, #276]	; (801abc0 <report_realtime_status+0x894>)
 801aaaa:	7e9b      	ldrb	r3, [r3, #26]
 801aaac:	b92b      	cbnz	r3, 801aaba <report_realtime_status+0x78e>
 801aaae:	4a43      	ldr	r2, [pc, #268]	; (801abbc <report_realtime_status+0x890>)
 801aab0:	f892 2114 	ldrb.w	r2, [r2, #276]	; 0x114
 801aab4:	f012 0f12 	tst.w	r2, #18
 801aab8:	d017      	beq.n	801aaea <report_realtime_status+0x7be>
            axes_signals_t homing = {sys.homing.mask ? sys.homing.mask : AXES_BITMASK};
 801aaba:	b903      	cbnz	r3, 801aabe <report_realtime_status+0x792>
 801aabc:	2307      	movs	r3, #7
            hal.stream.write_all(appendbuf(2, "|H:", (homing.mask & sys.homed.mask) == homing.mask ? "1" : "0"));
 801aabe:	4a36      	ldr	r2, [pc, #216]	; (801ab98 <report_realtime_status+0x86c>)
 801aac0:	f8d2 60b8 	ldr.w	r6, [r2, #184]	; 0xb8
 801aac4:	4a3e      	ldr	r2, [pc, #248]	; (801abc0 <report_realtime_status+0x894>)
 801aac6:	f892 2054 	ldrb.w	r2, [r2, #84]	; 0x54
 801aaca:	4393      	bics	r3, r2
 801aacc:	f000 80ee 	beq.w	801acac <report_realtime_status+0x980>
 801aad0:	4a3e      	ldr	r2, [pc, #248]	; (801abcc <report_realtime_status+0x8a0>)
 801aad2:	493f      	ldr	r1, [pc, #252]	; (801abd0 <report_realtime_status+0x8a4>)
 801aad4:	2002      	movs	r0, #2
 801aad6:	f7fd fda5 	bl	8018624 <appendbuf>
 801aada:	47b0      	blx	r6
            if(settings.homing.flags.single_axis_commands)
 801aadc:	4b37      	ldr	r3, [pc, #220]	; (801abbc <report_realtime_status+0x890>)
 801aade:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 801aae2:	f013 0f02 	tst.w	r3, #2
 801aae6:	f040 80e3 	bne.w	801acb0 <report_realtime_status+0x984>
        if(report.xmode && settings.mode == Mode_Lathe)
 801aaea:	f015 0f08 	tst.w	r5, #8
 801aaee:	d004      	beq.n	801aafa <report_realtime_status+0x7ce>
 801aaf0:	4b32      	ldr	r3, [pc, #200]	; (801abbc <report_realtime_status+0x890>)
 801aaf2:	7e1b      	ldrb	r3, [r3, #24]
 801aaf4:	2b02      	cmp	r3, #2
 801aaf6:	f000 80ea 	beq.w	801acce <report_realtime_status+0x9a2>
        if(report.tool)
 801aafa:	f015 0f80 	tst.w	r5, #128	; 0x80
 801aafe:	f040 80f1 	bne.w	801ace4 <report_realtime_status+0x9b8>
        if(report.tlo_reference)
 801ab02:	f019 0f80 	tst.w	r9, #128	; 0x80
 801ab06:	f040 80fd 	bne.w	801ad04 <report_realtime_status+0x9d8>
        if(report.m66result && sys.var5399 > -2) { // M66 result
 801ab0a:	f018 0f08 	tst.w	r8, #8
 801ab0e:	d00c      	beq.n	801ab2a <report_realtime_status+0x7fe>
 801ab10:	4b2b      	ldr	r3, [pc, #172]	; (801abc0 <report_realtime_status+0x894>)
 801ab12:	6d18      	ldr	r0, [r3, #80]	; 0x50
 801ab14:	f1b0 3fff 	cmp.w	r0, #4294967295
 801ab18:	db07      	blt.n	801ab2a <report_realtime_status+0x7fe>
            if(sys.var5399 >= 0)
 801ab1a:	2800      	cmp	r0, #0
 801ab1c:	f280 8103 	bge.w	801ad26 <report_realtime_status+0x9fa>
                hal.stream.write_all("|In:-1");
 801ab20:	4b1d      	ldr	r3, [pc, #116]	; (801ab98 <report_realtime_status+0x86c>)
 801ab22:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801ab26:	482b      	ldr	r0, [pc, #172]	; (801abd4 <report_realtime_status+0x8a8>)
 801ab28:	4798      	blx	r3
    if(grbl.on_realtime_report)
 801ab2a:	4b2b      	ldr	r3, [pc, #172]	; (801abd8 <report_realtime_status+0x8ac>)
 801ab2c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 801ab2e:	b12b      	cbz	r3, 801ab3c <report_realtime_status+0x810>
        grbl.on_realtime_report(hal.stream.write_all, sys.report);
 801ab30:	4a23      	ldr	r2, [pc, #140]	; (801abc0 <report_realtime_status+0x894>)
 801ab32:	6b11      	ldr	r1, [r2, #48]	; 0x30
 801ab34:	4a18      	ldr	r2, [pc, #96]	; (801ab98 <report_realtime_status+0x86c>)
 801ab36:	f8d2 00b8 	ldr.w	r0, [r2, #184]	; 0xb8
 801ab3a:	4798      	blx	r3
    if(report.all) {
 801ab3c:	2c00      	cmp	r4, #0
 801ab3e:	f2c0 80fe 	blt.w	801ad3e <report_realtime_status+0xa12>
    if(settings.status_report.parser_state) {
 801ab42:	4b1e      	ldr	r3, [pc, #120]	; (801abbc <report_realtime_status+0x890>)
 801ab44:	f893 30fd 	ldrb.w	r3, [r3, #253]	; 0xfd
 801ab48:	f013 0f02 	tst.w	r3, #2
 801ab4c:	f000 8104 	beq.w	801ad58 <report_realtime_status+0xa2c>
        bool is_changed = feed_rate != gc_state.feed_rate || spindle_rpm != gc_state.spindle.rpm || tool_id != gc_state.tool->tool_id;
 801ab50:	4b13      	ldr	r3, [pc, #76]	; (801aba0 <report_realtime_status+0x874>)
 801ab52:	edd3 7a16 	vldr	s15, [r3, #88]	; 0x58
 801ab56:	4b21      	ldr	r3, [pc, #132]	; (801abdc <report_realtime_status+0x8b0>)
 801ab58:	ed93 7a00 	vldr	s14, [r3]
 801ab5c:	eef4 7a47 	vcmp.f32	s15, s14
 801ab60:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ab64:	f040 810d 	bne.w	801ad82 <report_realtime_status+0xa56>
 801ab68:	4b0d      	ldr	r3, [pc, #52]	; (801aba0 <report_realtime_status+0x874>)
 801ab6a:	edd3 6a12 	vldr	s13, [r3, #72]	; 0x48
 801ab6e:	4b1c      	ldr	r3, [pc, #112]	; (801abe0 <report_realtime_status+0x8b4>)
 801ab70:	ed93 7a00 	vldr	s14, [r3]
 801ab74:	eef4 6a47 	vcmp.f32	s13, s14
 801ab78:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ab7c:	f040 8121 	bne.w	801adc2 <report_realtime_status+0xa96>
 801ab80:	4b07      	ldr	r3, [pc, #28]	; (801aba0 <report_realtime_status+0x874>)
 801ab82:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 801ab86:	691a      	ldr	r2, [r3, #16]
 801ab88:	4b16      	ldr	r3, [pc, #88]	; (801abe4 <report_realtime_status+0x8b8>)
 801ab8a:	681b      	ldr	r3, [r3, #0]
 801ab8c:	429a      	cmp	r2, r3
 801ab8e:	f000 811a 	beq.w	801adc6 <report_realtime_status+0xa9a>
 801ab92:	2301      	movs	r3, #1
 801ab94:	e0f6      	b.n	801ad84 <report_realtime_status+0xa58>
 801ab96:	bf00      	nop
 801ab98:	2000350c 	.word	0x2000350c
 801ab9c:	20003af4 	.word	0x20003af4
 801aba0:	20003344 	.word	0x20003344
 801aba4:	0802790c 	.word	0x0802790c
 801aba8:	20003ac4 	.word	0x20003ac4
 801abac:	08027914 	.word	0x08027914
 801abb0:	20003a88 	.word	0x20003a88
 801abb4:	003a417c 	.word	0x003a417c
 801abb8:	80000001 	.word	0x80000001
 801abbc:	20003b14 	.word	0x20003b14
 801abc0:	200036c4 	.word	0x200036c4
 801abc4:	08027864 	.word	0x08027864
 801abc8:	08027870 	.word	0x08027870
 801abcc:	08027ef0 	.word	0x08027ef0
 801abd0:	0802792c 	.word	0x0802792c
 801abd4:	08027944 	.word	0x08027944
 801abd8:	2000343c 	.word	0x2000343c
 801abdc:	20003ab8 	.word	0x20003ab8
 801abe0:	20003af8 	.word	0x20003af8
 801abe4:	20003afc 	.word	0x20003afc
            hal.stream.write_all(appendbuf(2, "|Ov:", uitoa((uint32_t)sys.override.feed_rate)));
 801abe8:	f8df a260 	ldr.w	sl, [pc, #608]	; 801ae4c <report_realtime_status+0xb20>
 801abec:	f8da 30b8 	ldr.w	r3, [sl, #184]	; 0xb8
 801abf0:	9301      	str	r3, [sp, #4]
 801abf2:	f8df b270 	ldr.w	fp, [pc, #624]	; 801ae64 <report_realtime_status+0xb38>
 801abf6:	f8db 001c 	ldr.w	r0, [fp, #28]
 801abfa:	f7fa fdbd 	bl	8015778 <uitoa>
 801abfe:	4602      	mov	r2, r0
 801ac00:	498e      	ldr	r1, [pc, #568]	; (801ae3c <report_realtime_status+0xb10>)
 801ac02:	2002      	movs	r0, #2
 801ac04:	f7fd fd0e 	bl	8018624 <appendbuf>
 801ac08:	9b01      	ldr	r3, [sp, #4]
 801ac0a:	4798      	blx	r3
            hal.stream.write_all(appendbuf(2, ",", uitoa((uint32_t)sys.override.rapid_rate)));
 801ac0c:	f8da 30b8 	ldr.w	r3, [sl, #184]	; 0xb8
 801ac10:	9301      	str	r3, [sp, #4]
 801ac12:	f8db 0020 	ldr.w	r0, [fp, #32]
 801ac16:	f7fa fdaf 	bl	8015778 <uitoa>
 801ac1a:	4602      	mov	r2, r0
 801ac1c:	f8df b248 	ldr.w	fp, [pc, #584]	; 801ae68 <report_realtime_status+0xb3c>
 801ac20:	4659      	mov	r1, fp
 801ac22:	2002      	movs	r0, #2
 801ac24:	f7fd fcfe 	bl	8018624 <appendbuf>
 801ac28:	9b01      	ldr	r3, [sp, #4]
 801ac2a:	4798      	blx	r3
            hal.stream.write_all(appendbuf(2, ",", uitoa((uint32_t)spindle_0->param->override_pct)));
 801ac2c:	f8da a0b8 	ldr.w	sl, [sl, #184]	; 0xb8
 801ac30:	6873      	ldr	r3, [r6, #4]
 801ac32:	68d8      	ldr	r0, [r3, #12]
 801ac34:	f7fa fda0 	bl	8015778 <uitoa>
 801ac38:	4602      	mov	r2, r0
 801ac3a:	4659      	mov	r1, fp
 801ac3c:	2002      	movs	r0, #2
 801ac3e:	f7fd fcf1 	bl	8018624 <appendbuf>
 801ac42:	47d0      	blx	sl
 801ac44:	e6be      	b.n	801a9c4 <report_realtime_status+0x698>
                *append++ = spindle_0_state.ccw ? 'C' : 'S';
 801ac46:	2153      	movs	r1, #83	; 0x53
 801ac48:	e6d4      	b.n	801a9f4 <report_realtime_status+0x6c8>
            char *append = &buf[3];
 801ac4a:	4b7d      	ldr	r3, [pc, #500]	; (801ae40 <report_realtime_status+0xb14>)
 801ac4c:	e6d5      	b.n	801a9fa <report_realtime_status+0x6ce>
            axis_signals_tostring(buf, gc_get_g51_state());
 801ac4e:	f7f4 f995 	bl	800ef7c <gc_get_g51_state>
    signals.mask &= AXES_BITMASK;
 801ac52:	f000 0007 	and.w	r0, r0, #7
    uint_fast16_t idx = 0;
 801ac56:	2200      	movs	r2, #0
    while(signals.mask) {
 801ac58:	4b7a      	ldr	r3, [pc, #488]	; (801ae44 <report_realtime_status+0xb18>)
 801ac5a:	e002      	b.n	801ac62 <report_realtime_status+0x936>
        idx++;
 801ac5c:	3201      	adds	r2, #1
        signals.mask >>= 1;
 801ac5e:	f3c0 0047 	ubfx	r0, r0, #1, #8
    while(signals.mask) {
 801ac62:	b2c0      	uxtb	r0, r0
 801ac64:	b148      	cbz	r0, 801ac7a <report_realtime_status+0x94e>
        if(signals.mask & 0x01)
 801ac66:	f010 0f01 	tst.w	r0, #1
 801ac6a:	d0f7      	beq.n	801ac5c <report_realtime_status+0x930>
            *buf++ = *axis_letter[idx];
 801ac6c:	4976      	ldr	r1, [pc, #472]	; (801ae48 <report_realtime_status+0xb1c>)
 801ac6e:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
 801ac72:	7809      	ldrb	r1, [r1, #0]
 801ac74:	f803 1b01 	strb.w	r1, [r3], #1
 801ac78:	e7f0      	b.n	801ac5c <report_realtime_status+0x930>
    *buf = '\0';
 801ac7a:	2200      	movs	r2, #0
 801ac7c:	701a      	strb	r2, [r3, #0]
            hal.stream.write_all("|Sc:");
 801ac7e:	4e73      	ldr	r6, [pc, #460]	; (801ae4c <report_realtime_status+0xb20>)
 801ac80:	f8d6 30b8 	ldr.w	r3, [r6, #184]	; 0xb8
 801ac84:	4872      	ldr	r0, [pc, #456]	; (801ae50 <report_realtime_status+0xb24>)
 801ac86:	4798      	blx	r3
            hal.stream.write_all(buf);
 801ac88:	f8d6 30b8 	ldr.w	r3, [r6, #184]	; 0xb8
 801ac8c:	486d      	ldr	r0, [pc, #436]	; (801ae44 <report_realtime_status+0xb18>)
 801ac8e:	4798      	blx	r3
 801ac90:	e6e1      	b.n	801aa56 <report_realtime_status+0x72a>
            hal.stream.write_all(sys.flags.auto_reporting ? "|AR:" : "|AR");
 801ac92:	4870      	ldr	r0, [pc, #448]	; (801ae54 <report_realtime_status+0xb28>)
 801ac94:	e6f0      	b.n	801aa78 <report_realtime_status+0x74c>
                hal.stream.write_all(uitoa(settings.report_interval));
 801ac96:	4b6d      	ldr	r3, [pc, #436]	; (801ae4c <report_realtime_status+0xb20>)
 801ac98:	f8d3 60b8 	ldr.w	r6, [r3, #184]	; 0xb8
 801ac9c:	4b6e      	ldr	r3, [pc, #440]	; (801ae58 <report_realtime_status+0xb2c>)
 801ac9e:	8a98      	ldrh	r0, [r3, #20]
 801aca0:	f7fa fd6a 	bl	8015778 <uitoa>
 801aca4:	47b0      	blx	r6
 801aca6:	e6ee      	b.n	801aa86 <report_realtime_status+0x75a>
            hal.stream.write_all(sys.mpg_mode ? "|MPG:1" : "|MPG:0");
 801aca8:	486c      	ldr	r0, [pc, #432]	; (801ae5c <report_realtime_status+0xb30>)
 801acaa:	e6f9      	b.n	801aaa0 <report_realtime_status+0x774>
            hal.stream.write_all(appendbuf(2, "|H:", (homing.mask & sys.homed.mask) == homing.mask ? "1" : "0"));
 801acac:	4a6c      	ldr	r2, [pc, #432]	; (801ae60 <report_realtime_status+0xb34>)
 801acae:	e710      	b.n	801aad2 <report_realtime_status+0x7a6>
                hal.stream.write_all(appendbuf(2, ",", uitoa(sys.homed.mask)));
 801acb0:	4b66      	ldr	r3, [pc, #408]	; (801ae4c <report_realtime_status+0xb20>)
 801acb2:	f8d3 60b8 	ldr.w	r6, [r3, #184]	; 0xb8
 801acb6:	4b6b      	ldr	r3, [pc, #428]	; (801ae64 <report_realtime_status+0xb38>)
 801acb8:	f893 0054 	ldrb.w	r0, [r3, #84]	; 0x54
 801acbc:	f7fa fd5c 	bl	8015778 <uitoa>
 801acc0:	4602      	mov	r2, r0
 801acc2:	4969      	ldr	r1, [pc, #420]	; (801ae68 <report_realtime_status+0xb3c>)
 801acc4:	2002      	movs	r0, #2
 801acc6:	f7fd fcad 	bl	8018624 <appendbuf>
 801acca:	47b0      	blx	r6
 801accc:	e70d      	b.n	801aaea <report_realtime_status+0x7be>
            hal.stream.write_all(gc_state.modal.diameter_mode ? "|D:1" : "|D:0");
 801acce:	4b5f      	ldr	r3, [pc, #380]	; (801ae4c <report_realtime_status+0xb20>)
 801acd0:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801acd4:	4a65      	ldr	r2, [pc, #404]	; (801ae6c <report_realtime_status+0xb40>)
 801acd6:	7952      	ldrb	r2, [r2, #5]
 801acd8:	b112      	cbz	r2, 801ace0 <report_realtime_status+0x9b4>
 801acda:	4865      	ldr	r0, [pc, #404]	; (801ae70 <report_realtime_status+0xb44>)
 801acdc:	4798      	blx	r3
 801acde:	e70c      	b.n	801aafa <report_realtime_status+0x7ce>
 801ace0:	4864      	ldr	r0, [pc, #400]	; (801ae74 <report_realtime_status+0xb48>)
 801ace2:	e7fb      	b.n	801acdc <report_realtime_status+0x9b0>
            hal.stream.write_all(appendbuf(2, "|T:", uitoa((uint32_t)gc_state.tool->tool_id)));
 801ace4:	4b59      	ldr	r3, [pc, #356]	; (801ae4c <report_realtime_status+0xb20>)
 801ace6:	f8d3 50b8 	ldr.w	r5, [r3, #184]	; 0xb8
 801acea:	4b60      	ldr	r3, [pc, #384]	; (801ae6c <report_realtime_status+0xb40>)
 801acec:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 801acf0:	6918      	ldr	r0, [r3, #16]
 801acf2:	f7fa fd41 	bl	8015778 <uitoa>
 801acf6:	4602      	mov	r2, r0
 801acf8:	495f      	ldr	r1, [pc, #380]	; (801ae78 <report_realtime_status+0xb4c>)
 801acfa:	2002      	movs	r0, #2
 801acfc:	f7fd fc92 	bl	8018624 <appendbuf>
 801ad00:	47a8      	blx	r5
 801ad02:	e6fe      	b.n	801ab02 <report_realtime_status+0x7d6>
            hal.stream.write_all(appendbuf(2, "|TLR:", uitoa(sys.tlo_reference_set.mask != 0)));
 801ad04:	4b51      	ldr	r3, [pc, #324]	; (801ae4c <report_realtime_status+0xb20>)
 801ad06:	f8d3 50b8 	ldr.w	r5, [r3, #184]	; 0xb8
 801ad0a:	4b56      	ldr	r3, [pc, #344]	; (801ae64 <report_realtime_status+0xb38>)
 801ad0c:	79d8      	ldrb	r0, [r3, #7]
 801ad0e:	3800      	subs	r0, #0
 801ad10:	bf18      	it	ne
 801ad12:	2001      	movne	r0, #1
 801ad14:	f7fa fd30 	bl	8015778 <uitoa>
 801ad18:	4602      	mov	r2, r0
 801ad1a:	4958      	ldr	r1, [pc, #352]	; (801ae7c <report_realtime_status+0xb50>)
 801ad1c:	2002      	movs	r0, #2
 801ad1e:	f7fd fc81 	bl	8018624 <appendbuf>
 801ad22:	47a8      	blx	r5
 801ad24:	e6f1      	b.n	801ab0a <report_realtime_status+0x7de>
                hal.stream.write_all(appendbuf(2, "|In:", uitoa(sys.var5399)));
 801ad26:	4b49      	ldr	r3, [pc, #292]	; (801ae4c <report_realtime_status+0xb20>)
 801ad28:	f8d3 50b8 	ldr.w	r5, [r3, #184]	; 0xb8
 801ad2c:	f7fa fd24 	bl	8015778 <uitoa>
 801ad30:	4602      	mov	r2, r0
 801ad32:	4953      	ldr	r1, [pc, #332]	; (801ae80 <report_realtime_status+0xb54>)
 801ad34:	2002      	movs	r0, #2
 801ad36:	f7fd fc75 	bl	8018624 <appendbuf>
 801ad3a:	47a8      	blx	r5
 801ad3c:	e6f5      	b.n	801ab2a <report_realtime_status+0x7fe>
        hal.stream.write_all("|FW:grblHAL");
 801ad3e:	4b43      	ldr	r3, [pc, #268]	; (801ae4c <report_realtime_status+0xb20>)
 801ad40:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801ad44:	484f      	ldr	r0, [pc, #316]	; (801ae84 <report_realtime_status+0xb58>)
 801ad46:	4798      	blx	r3
        if(sys.blocking_event)
 801ad48:	4b46      	ldr	r3, [pc, #280]	; (801ae64 <report_realtime_status+0xb38>)
 801ad4a:	795b      	ldrb	r3, [r3, #5]
 801ad4c:	b123      	cbz	r3, 801ad58 <report_realtime_status+0xa2c>
            hal.stream.write_all("|$C:1");
 801ad4e:	4b3f      	ldr	r3, [pc, #252]	; (801ae4c <report_realtime_status+0xb20>)
 801ad50:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801ad54:	484c      	ldr	r0, [pc, #304]	; (801ae88 <report_realtime_status+0xb5c>)
 801ad56:	4798      	blx	r3
    hal.stream.write_all(">" ASCII_EOL);
 801ad58:	4b3c      	ldr	r3, [pc, #240]	; (801ae4c <report_realtime_status+0xb20>)
 801ad5a:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801ad5e:	484b      	ldr	r0, [pc, #300]	; (801ae8c <report_realtime_status+0xb60>)
 801ad60:	4798      	blx	r3
    system_add_rt_report(Report_ClearAll);
 801ad62:	2000      	movs	r0, #0
 801ad64:	f006 fa6c 	bl	8021240 <system_add_rt_report>
    if(settings.status_report.work_coord_offset && wco_counter == 0)
 801ad68:	4b3b      	ldr	r3, [pc, #236]	; (801ae58 <report_realtime_status+0xb2c>)
 801ad6a:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 801ad6e:	f013 0f20 	tst.w	r3, #32
 801ad72:	d003      	beq.n	801ad7c <report_realtime_status+0xa50>
 801ad74:	4b46      	ldr	r3, [pc, #280]	; (801ae90 <report_realtime_status+0xb64>)
 801ad76:	781b      	ldrb	r3, [r3, #0]
 801ad78:	2b00      	cmp	r3, #0
 801ad7a:	d05a      	beq.n	801ae32 <report_realtime_status+0xb06>
}
 801ad7c:	b00b      	add	sp, #44	; 0x2c
 801ad7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        bool is_changed = feed_rate != gc_state.feed_rate || spindle_rpm != gc_state.spindle.rpm || tool_id != gc_state.tool->tool_id;
 801ad82:	2301      	movs	r3, #1
        if(is_changed) {
 801ad84:	461d      	mov	r5, r3
 801ad86:	b303      	cbz	r3, 801adca <report_realtime_status+0xa9e>
            feed_rate = gc_state.feed_rate;
 801ad88:	4b42      	ldr	r3, [pc, #264]	; (801ae94 <report_realtime_status+0xb68>)
 801ad8a:	edc3 7a00 	vstr	s15, [r3]
            tool_id = gc_state.tool->tool_id;
 801ad8e:	4b37      	ldr	r3, [pc, #220]	; (801ae6c <report_realtime_status+0xb40>)
 801ad90:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 801ad94:	6911      	ldr	r1, [r2, #16]
 801ad96:	4a40      	ldr	r2, [pc, #256]	; (801ae98 <report_realtime_status+0xb6c>)
 801ad98:	6011      	str	r1, [r2, #0]
            spindle_rpm = gc_state.spindle.rpm;
 801ad9a:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 801ad9c:	4b3f      	ldr	r3, [pc, #252]	; (801ae9c <report_realtime_status+0xb70>)
 801ad9e:	601a      	str	r2, [r3, #0]
        if (is_changed)
 801ada0:	b12d      	cbz	r5, 801adae <report_realtime_status+0xa82>
            system_set_exec_state_flag(EXEC_GCODE_REPORT);
 801ada2:	4b2a      	ldr	r3, [pc, #168]	; (801ae4c <report_realtime_status+0xb20>)
 801ada4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801ada6:	f44f 6100 	mov.w	r1, #2048	; 0x800
 801adaa:	483d      	ldr	r0, [pc, #244]	; (801aea0 <report_realtime_status+0xb74>)
 801adac:	4798      	blx	r3
        if(report.tool_offset)
 801adae:	f414 6f80 	tst.w	r4, #1024	; 0x400
 801adb2:	d0d1      	beq.n	801ad58 <report_realtime_status+0xa2c>
            system_set_exec_state_flag(EXEC_TLO_REPORT);
 801adb4:	4b25      	ldr	r3, [pc, #148]	; (801ae4c <report_realtime_status+0xb20>)
 801adb6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801adb8:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 801adbc:	4838      	ldr	r0, [pc, #224]	; (801aea0 <report_realtime_status+0xb74>)
 801adbe:	4798      	blx	r3
 801adc0:	e7ca      	b.n	801ad58 <report_realtime_status+0xa2c>
        bool is_changed = feed_rate != gc_state.feed_rate || spindle_rpm != gc_state.spindle.rpm || tool_id != gc_state.tool->tool_id;
 801adc2:	2301      	movs	r3, #1
 801adc4:	e7de      	b.n	801ad84 <report_realtime_status+0xa58>
 801adc6:	2300      	movs	r3, #0
 801adc8:	e7dc      	b.n	801ad84 <report_realtime_status+0xa58>
    uint_fast32_t idx = N_AXIS;
 801adca:	2303      	movs	r3, #3
        idx--;
 801adcc:	3b01      	subs	r3, #1
        active = !(gc_state.g92_coord_offset[idx] == 0.0f || gc_state.g92_coord_offset[idx] == -0.0f);
 801adce:	f103 011e 	add.w	r1, r3, #30
 801add2:	4a26      	ldr	r2, [pc, #152]	; (801ae6c <report_realtime_status+0xb40>)
 801add4:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 801add8:	edd2 7a01 	vldr	s15, [r2, #4]
 801addc:	eef5 7a40 	vcmp.f32	s15, #0.0
 801ade0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ade4:	bf14      	ite	ne
 801ade6:	2201      	movne	r2, #1
 801ade8:	2200      	moveq	r2, #0
    } while(idx && !active);
 801adea:	b123      	cbz	r3, 801adf6 <report_realtime_status+0xaca>
 801adec:	eef5 7a40 	vcmp.f32	s15, #0.0
 801adf0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801adf4:	d0ea      	beq.n	801adcc <report_realtime_status+0xaa0>
        } else if ((is_changed = g92_active != is_g92_active()))
 801adf6:	4b2b      	ldr	r3, [pc, #172]	; (801aea4 <report_realtime_status+0xb78>)
 801adf8:	781b      	ldrb	r3, [r3, #0]
 801adfa:	4293      	cmp	r3, r2
 801adfc:	bf14      	ite	ne
 801adfe:	2501      	movne	r5, #1
 801ae00:	2500      	moveq	r5, #0
 801ae02:	d004      	beq.n	801ae0e <report_realtime_status+0xae2>
            g92_active = !g92_active;
 801ae04:	f083 0301 	eor.w	r3, r3, #1
 801ae08:	4a26      	ldr	r2, [pc, #152]	; (801aea4 <report_realtime_status+0xb78>)
 801ae0a:	7013      	strb	r3, [r2, #0]
 801ae0c:	e7c8      	b.n	801ada0 <report_realtime_status+0xa74>
        else if(memcmp(&last_state, &gc_state.modal, sizeof(gc_modal_t))) {
 801ae0e:	2228      	movs	r2, #40	; 0x28
 801ae10:	4916      	ldr	r1, [pc, #88]	; (801ae6c <report_realtime_status+0xb40>)
 801ae12:	4825      	ldr	r0, [pc, #148]	; (801aea8 <report_realtime_status+0xb7c>)
 801ae14:	f007 fe9f 	bl	8022b56 <memcmp>
 801ae18:	2800      	cmp	r0, #0
 801ae1a:	d0c1      	beq.n	801ada0 <report_realtime_status+0xa74>
            last_state = gc_state.modal;
 801ae1c:	4d22      	ldr	r5, [pc, #136]	; (801aea8 <report_realtime_status+0xb7c>)
 801ae1e:	4e13      	ldr	r6, [pc, #76]	; (801ae6c <report_realtime_status+0xb40>)
 801ae20:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 801ae22:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801ae24:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 801ae26:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801ae28:	e896 0003 	ldmia.w	r6, {r0, r1}
 801ae2c:	e885 0003 	stmia.w	r5, {r0, r1}
        if (is_changed)
 801ae30:	e7b7      	b.n	801ada2 <report_realtime_status+0xa76>
        system_add_rt_report(Report_WCO); // Set to report on next request
 801ae32:	f44f 7080 	mov.w	r0, #256	; 0x100
 801ae36:	f006 fa03 	bl	8021240 <system_add_rt_report>
}
 801ae3a:	e79f      	b.n	801ad7c <report_realtime_status+0xa50>
 801ae3c:	0802791c 	.word	0x0802791c
 801ae40:	20003a8b 	.word	0x20003a8b
 801ae44:	20003a88 	.word	0x20003a88
 801ae48:	080271cc 	.word	0x080271cc
 801ae4c:	2000350c 	.word	0x2000350c
 801ae50:	08027924 	.word	0x08027924
 801ae54:	0802786c 	.word	0x0802786c
 801ae58:	20003b14 	.word	0x20003b14
 801ae5c:	08027878 	.word	0x08027878
 801ae60:	08027efc 	.word	0x08027efc
 801ae64:	200036c4 	.word	0x200036c4
 801ae68:	08027758 	.word	0x08027758
 801ae6c:	20003344 	.word	0x20003344
 801ae70:	08027880 	.word	0x08027880
 801ae74:	08027888 	.word	0x08027888
 801ae78:	08027930 	.word	0x08027930
 801ae7c:	08027934 	.word	0x08027934
 801ae80:	0802793c 	.word	0x0802793c
 801ae84:	0802794c 	.word	0x0802794c
 801ae88:	08027958 	.word	0x08027958
 801ae8c:	0802c5b8 	.word	0x0802c5b8
 801ae90:	20003b00 	.word	0x20003b00
 801ae94:	20003ab8 	.word	0x20003ab8
 801ae98:	20003afc 	.word	0x20003afc
 801ae9c:	20003af8 	.word	0x20003af8
 801aea0:	2000370c 	.word	0x2000370c
 801aea4:	20003abc 	.word	0x20003abc
 801aea8:	20003acc 	.word	0x20003acc

0801aeac <report_settings_details>:
{
 801aeac:	b538      	push	{r3, r4, r5, lr}
 801aeae:	4605      	mov	r5, r0
    if(id != Setting_SettingsAll) {
 801aeb0:	f240 238a 	movw	r3, #650	; 0x28a
 801aeb4:	4299      	cmp	r1, r3
 801aeb6:	d00f      	beq.n	801aed8 <report_settings_details+0x2c>
 801aeb8:	460c      	mov	r4, r1
        const setting_detail_t *setting = setting_get_details(id, NULL);
 801aeba:	2100      	movs	r1, #0
 801aebc:	4620      	mov	r0, r4
 801aebe:	f001 feb1 	bl	801cc24 <setting_get_details>
        if(setting)
 801aec2:	4601      	mov	r1, r0
 801aec4:	b130      	cbz	r0, 801aed4 <report_settings_details+0x28>
            report_settings_detail(format, setting, id - setting->id);
 801aec6:	8802      	ldrh	r2, [r0, #0]
 801aec8:	1aa2      	subs	r2, r4, r2
 801aeca:	4628      	mov	r0, r5
 801aecc:	f7fd fc9c 	bl	8018808 <report_settings_detail>
        status_code_t status = Status_OK;
 801aed0:	2000      	movs	r0, #0
 801aed2:	e004      	b.n	801aede <report_settings_details+0x32>
            status = Status_SettingDisabled;
 801aed4:	2035      	movs	r0, #53	; 0x35
        return status;
 801aed6:	e002      	b.n	801aede <report_settings_details+0x32>
    return print_settings_details(format, group);
 801aed8:	4611      	mov	r1, r2
 801aeda:	f7fd fffb 	bl	8018ed4 <print_settings_details>
}
 801aede:	bd38      	pop	{r3, r4, r5, pc}

0801aee0 <report_group_settings>:
{
 801aee0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801aee4:	b089      	sub	sp, #36	; 0x24
 801aee6:	4680      	mov	r8, r0
 801aee8:	460e      	mov	r6, r1
 801aeea:	4617      	mov	r7, r2
    for(idx = 0; idx < n_groups; idx++) {
 801aeec:	2400      	movs	r4, #0
    bool found = false;
 801aeee:	46a1      	mov	r9, r4
    for(idx = 0; idx < n_groups; idx++) {
 801aef0:	e017      	b.n	801af22 <report_group_settings+0x42>
            *s++ = CAPS(c);
 801aef2:	f803 2b01 	strb.w	r2, [r3], #1
        while((c = *s))
 801aef6:	781a      	ldrb	r2, [r3, #0]
 801aef8:	b13a      	cbz	r2, 801af0a <report_group_settings+0x2a>
            *s++ = CAPS(c);
 801aefa:	f1a2 0161 	sub.w	r1, r2, #97	; 0x61
 801aefe:	b2c9      	uxtb	r1, r1
 801af00:	2919      	cmp	r1, #25
 801af02:	d8f6      	bhi.n	801aef2 <report_group_settings+0x12>
 801af04:	f002 025f 	and.w	r2, r2, #95	; 0x5f
 801af08:	e7f3      	b.n	801aef2 <report_group_settings+0x12>
        if((found = matchhere(args, group))) {
 801af0a:	a901      	add	r1, sp, #4
 801af0c:	4638      	mov	r0, r7
 801af0e:	f7fd f8e3 	bl	80180d8 <matchhere>
 801af12:	2800      	cmp	r0, #0
 801af14:	bf14      	ite	ne
 801af16:	f04f 0901 	movne.w	r9, #1
 801af1a:	f04f 0900 	moveq.w	r9, #0
 801af1e:	d10d      	bne.n	801af3c <report_group_settings+0x5c>
    for(idx = 0; idx < n_groups; idx++) {
 801af20:	3401      	adds	r4, #1
 801af22:	42b4      	cmp	r4, r6
 801af24:	d21d      	bcs.n	801af62 <report_group_settings+0x82>
        strncpy(group, groups[idx].name, sizeof(group) - 1);
 801af26:	eb04 0544 	add.w	r5, r4, r4, lsl #1
 801af2a:	eb08 0585 	add.w	r5, r8, r5, lsl #2
 801af2e:	2219      	movs	r2, #25
 801af30:	6869      	ldr	r1, [r5, #4]
 801af32:	a801      	add	r0, sp, #4
 801af34:	f007 fe55 	bl	8022be2 <strncpy>
        s = group;
 801af38:	ab01      	add	r3, sp, #4
        while((c = *s))
 801af3a:	e7dc      	b.n	801aef6 <report_group_settings+0x16>
            hal.stream.write(ASCII_EOL "---- ");
 801af3c:	4c0b      	ldr	r4, [pc, #44]	; (801af6c <report_group_settings+0x8c>)
 801af3e:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801af42:	480b      	ldr	r0, [pc, #44]	; (801af70 <report_group_settings+0x90>)
 801af44:	4798      	blx	r3
            hal.stream.write(groups[idx].name);
 801af46:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801af4a:	6868      	ldr	r0, [r5, #4]
 801af4c:	4798      	blx	r3
            hal.stream.write(":" ASCII_EOL);
 801af4e:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801af52:	4808      	ldr	r0, [pc, #32]	; (801af74 <report_group_settings+0x94>)
 801af54:	4798      	blx	r3
            report_settings_details(SettingsFormat_HumanReadable, Setting_SettingsAll, groups[idx].id);
 801af56:	786a      	ldrb	r2, [r5, #1]
 801af58:	f240 218a 	movw	r1, #650	; 0x28a
 801af5c:	2001      	movs	r0, #1
 801af5e:	f7ff ffa5 	bl	801aeac <report_settings_details>
}
 801af62:	4648      	mov	r0, r9
 801af64:	b009      	add	sp, #36	; 0x24
 801af66:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801af6a:	bf00      	nop
 801af6c:	2000350c 	.word	0x2000350c
 801af70:	08027960 	.word	0x08027960
 801af74:	08027968 	.word	0x08027968

0801af78 <report_setting_description>:
{
 801af78:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 801af7c:	4606      	mov	r6, r0
 801af7e:	460c      	mov	r4, r1
    const setting_detail_t *setting = setting_get_details(id, NULL);
 801af80:	2100      	movs	r1, #0
 801af82:	4620      	mov	r0, r4
 801af84:	f001 fe4e 	bl	801cc24 <setting_get_details>
 801af88:	4607      	mov	r7, r0
    const char *description = setting_get_description(id);
 801af8a:	4620      	mov	r0, r4
 801af8c:	f001 fefe 	bl	801cd8c <setting_get_description>
 801af90:	4680      	mov	r8, r0
    if(format == SettingsFormat_MachineReadable) {
 801af92:	b976      	cbnz	r6, 801afb2 <report_setting_description+0x3a>
        hal.stream.write("[SETTINGDESCR:");
 801af94:	4d1c      	ldr	r5, [pc, #112]	; (801b008 <report_setting_description+0x90>)
 801af96:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 801af9a:	481c      	ldr	r0, [pc, #112]	; (801b00c <report_setting_description+0x94>)
 801af9c:	4798      	blx	r3
        hal.stream.write(uitoa(id));
 801af9e:	f8d5 90b4 	ldr.w	r9, [r5, #180]	; 0xb4
 801afa2:	4620      	mov	r0, r4
 801afa4:	f7fa fbe8 	bl	8015778 <uitoa>
 801afa8:	47c8      	blx	r9
        hal.stream.write(vbar);
 801afaa:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 801afae:	4818      	ldr	r0, [pc, #96]	; (801b010 <report_setting_description+0x98>)
 801afb0:	4798      	blx	r3
    hal.stream.write(description ? description : (setting ? "" : "N/A"));
 801afb2:	4b15      	ldr	r3, [pc, #84]	; (801b008 <report_setting_description+0x90>)
 801afb4:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801afb8:	f1b8 0f00 	cmp.w	r8, #0
 801afbc:	d01b      	beq.n	801aff6 <report_setting_description+0x7e>
 801afbe:	4640      	mov	r0, r8
 801afc0:	4798      	blx	r3
    if(setting && setting->flags.reboot_required)
 801afc2:	b17f      	cbz	r7, 801afe4 <report_setting_description+0x6c>
 801afc4:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 801afc8:	f013 0f01 	tst.w	r3, #1
 801afcc:	d00a      	beq.n	801afe4 <report_setting_description+0x6c>
        hal.stream.write(SETTINGS_HARD_RESET_REQUIRED + (description && *description != '\0' ? 0 : 4));
 801afce:	4b0e      	ldr	r3, [pc, #56]	; (801b008 <report_setting_description+0x90>)
 801afd0:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801afd4:	f1b8 0f00 	cmp.w	r8, #0
 801afd8:	d012      	beq.n	801b000 <report_setting_description+0x88>
 801afda:	f898 2000 	ldrb.w	r2, [r8]
 801afde:	b98a      	cbnz	r2, 801b004 <report_setting_description+0x8c>
 801afe0:	480c      	ldr	r0, [pc, #48]	; (801b014 <report_setting_description+0x9c>)
 801afe2:	4798      	blx	r3
    if(format == SettingsFormat_MachineReadable)
 801afe4:	b926      	cbnz	r6, 801aff0 <report_setting_description+0x78>
        hal.stream.write("]" ASCII_EOL);
 801afe6:	4b08      	ldr	r3, [pc, #32]	; (801b008 <report_setting_description+0x90>)
 801afe8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801afec:	480a      	ldr	r0, [pc, #40]	; (801b018 <report_setting_description+0xa0>)
 801afee:	4798      	blx	r3
}
 801aff0:	2000      	movs	r0, #0
 801aff2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    hal.stream.write(description ? description : (setting ? "" : "N/A"));
 801aff6:	b10f      	cbz	r7, 801affc <report_setting_description+0x84>
 801aff8:	4808      	ldr	r0, [pc, #32]	; (801b01c <report_setting_description+0xa4>)
 801affa:	e7e1      	b.n	801afc0 <report_setting_description+0x48>
 801affc:	4808      	ldr	r0, [pc, #32]	; (801b020 <report_setting_description+0xa8>)
 801affe:	e7df      	b.n	801afc0 <report_setting_description+0x48>
        hal.stream.write(SETTINGS_HARD_RESET_REQUIRED + (description && *description != '\0' ? 0 : 4));
 801b000:	4804      	ldr	r0, [pc, #16]	; (801b014 <report_setting_description+0x9c>)
 801b002:	e7ee      	b.n	801afe2 <report_setting_description+0x6a>
 801b004:	4807      	ldr	r0, [pc, #28]	; (801b024 <report_setting_description+0xac>)
 801b006:	e7ec      	b.n	801afe2 <report_setting_description+0x6a>
 801b008:	2000350c 	.word	0x2000350c
 801b00c:	0802796c 	.word	0x0802796c
 801b010:	080283e8 	.word	0x080283e8
 801b014:	0802739c 	.word	0x0802739c
 801b018:	0802cde0 	.word	0x0802cde0
 801b01c:	080274a0 	.word	0x080274a0
 801b020:	08027334 	.word	0x08027334
 801b024:	08027398 	.word	0x08027398

0801b028 <report_alarm_details>:
{
 801b028:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801b02a:	4606      	mov	r6, r0
    alarm_details_t *details = grbl.on_get_alarms();
 801b02c:	4b25      	ldr	r3, [pc, #148]	; (801b0c4 <report_alarm_details+0x9c>)
 801b02e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801b030:	4798      	blx	r3
 801b032:	4604      	mov	r4, r0
    if(grbl_format)
 801b034:	b126      	cbz	r6, 801b040 <report_alarm_details+0x18>
        hal.stream.write("\"Alarm Code in v1.1+\",\" Alarm Message in v1.0-\",\" Alarm Description\"" ASCII_EOL);
 801b036:	4b24      	ldr	r3, [pc, #144]	; (801b0c8 <report_alarm_details+0xa0>)
 801b038:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801b03c:	4823      	ldr	r0, [pc, #140]	; (801b0cc <report_alarm_details+0xa4>)
 801b03e:	4798      	blx	r3
{
 801b040:	2500      	movs	r5, #0
        n_alarms += details->n_alarms;
 801b042:	8823      	ldrh	r3, [r4, #0]
 801b044:	441d      	add	r5, r3
    } while((details = details->next));
 801b046:	68a4      	ldr	r4, [r4, #8]
 801b048:	2c00      	cmp	r4, #0
 801b04a:	d1fa      	bne.n	801b042 <report_alarm_details+0x1a>
    details = grbl.on_get_alarms();
 801b04c:	4b1d      	ldr	r3, [pc, #116]	; (801b0c4 <report_alarm_details+0x9c>)
 801b04e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801b050:	4798      	blx	r3
 801b052:	4604      	mov	r4, r0
    if((all_alarms = palarm = calloc(n_alarms, sizeof(alarm_detail_t *)))) {
 801b054:	2104      	movs	r1, #4
 801b056:	4628      	mov	r0, r5
 801b058:	f007 fa0c 	bl	8022474 <calloc>
 801b05c:	4607      	mov	r7, r0
 801b05e:	b328      	cbz	r0, 801b0ac <report_alarm_details+0x84>
 801b060:	4603      	mov	r3, r0
 801b062:	e00a      	b.n	801b07a <report_alarm_details+0x52>
                *palarm++ = (alarm_detail_t *)&(details->alarms[idx]);
 801b064:	6861      	ldr	r1, [r4, #4]
 801b066:	eb01 01c2 	add.w	r1, r1, r2, lsl #3
 801b06a:	f843 1b04 	str.w	r1, [r3], #4
            for(idx = 0; idx < details->n_alarms; idx++)
 801b06e:	3201      	adds	r2, #1
 801b070:	8821      	ldrh	r1, [r4, #0]
 801b072:	4291      	cmp	r1, r2
 801b074:	d8f6      	bhi.n	801b064 <report_alarm_details+0x3c>
        } while((details = details->next));
 801b076:	68a4      	ldr	r4, [r4, #8]
 801b078:	b10c      	cbz	r4, 801b07e <report_alarm_details+0x56>
            for(idx = 0; idx < details->n_alarms; idx++)
 801b07a:	2200      	movs	r2, #0
 801b07c:	e7f8      	b.n	801b070 <report_alarm_details+0x48>
        qsort(all_alarms, n_alarms, sizeof(alarm_detail_t *), cmp_alarms);
 801b07e:	4b14      	ldr	r3, [pc, #80]	; (801b0d0 <report_alarm_details+0xa8>)
 801b080:	2204      	movs	r2, #4
 801b082:	4629      	mov	r1, r5
 801b084:	4638      	mov	r0, r7
 801b086:	f007 fb11 	bl	80226ac <qsort>
        for(idx = 0; idx < n_alarms; idx++)
 801b08a:	e005      	b.n	801b098 <report_alarm_details+0x70>
            print_alarm(all_alarms[idx], grbl_format);
 801b08c:	4631      	mov	r1, r6
 801b08e:	f857 0024 	ldr.w	r0, [r7, r4, lsl #2]
 801b092:	f7fd f8f9 	bl	8018288 <print_alarm>
        for(idx = 0; idx < n_alarms; idx++)
 801b096:	3401      	adds	r4, #1
 801b098:	42ac      	cmp	r4, r5
 801b09a:	d3f7      	bcc.n	801b08c <report_alarm_details+0x64>
        free(all_alarms);
 801b09c:	4638      	mov	r0, r7
 801b09e:	f007 fa0f 	bl	80224c0 <free>
}
 801b0a2:	2000      	movs	r0, #0
 801b0a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    } while((details = details->next));
 801b0a6:	68a4      	ldr	r4, [r4, #8]
 801b0a8:	2c00      	cmp	r4, #0
 801b0aa:	d0fa      	beq.n	801b0a2 <report_alarm_details+0x7a>
        for(idx = 0; idx < details->n_alarms; idx++)
 801b0ac:	2500      	movs	r5, #0
 801b0ae:	8823      	ldrh	r3, [r4, #0]
 801b0b0:	42ab      	cmp	r3, r5
 801b0b2:	d9f8      	bls.n	801b0a6 <report_alarm_details+0x7e>
            print_alarm(&details->alarms[idx], grbl_format);
 801b0b4:	6860      	ldr	r0, [r4, #4]
 801b0b6:	4631      	mov	r1, r6
 801b0b8:	eb00 00c5 	add.w	r0, r0, r5, lsl #3
 801b0bc:	f7fd f8e4 	bl	8018288 <print_alarm>
        for(idx = 0; idx < details->n_alarms; idx++)
 801b0c0:	3501      	adds	r5, #1
 801b0c2:	e7f4      	b.n	801b0ae <report_alarm_details+0x86>
 801b0c4:	2000343c 	.word	0x2000343c
 801b0c8:	2000350c 	.word	0x2000350c
 801b0cc:	0802797c 	.word	0x0802797c
 801b0d0:	080181a9 	.word	0x080181a9

0801b0d4 <report_error_details>:
{
 801b0d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801b0d6:	4606      	mov	r6, r0
    error_details_t *details = grbl.on_get_errors();
 801b0d8:	4b25      	ldr	r3, [pc, #148]	; (801b170 <report_error_details+0x9c>)
 801b0da:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801b0dc:	4798      	blx	r3
 801b0de:	4604      	mov	r4, r0
    if(grbl_format)
 801b0e0:	b126      	cbz	r6, 801b0ec <report_error_details+0x18>
        hal.stream.write("\"Error Code in v1.1+\",\"Error Message in v1.0-\",\"Error Description\"" ASCII_EOL);
 801b0e2:	4b24      	ldr	r3, [pc, #144]	; (801b174 <report_error_details+0xa0>)
 801b0e4:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801b0e8:	4823      	ldr	r0, [pc, #140]	; (801b178 <report_error_details+0xa4>)
 801b0ea:	4798      	blx	r3
{
 801b0ec:	2500      	movs	r5, #0
        n_errors += details->n_errors;
 801b0ee:	8823      	ldrh	r3, [r4, #0]
 801b0f0:	441d      	add	r5, r3
    } while((details = details->next));
 801b0f2:	68a4      	ldr	r4, [r4, #8]
 801b0f4:	2c00      	cmp	r4, #0
 801b0f6:	d1fa      	bne.n	801b0ee <report_error_details+0x1a>
    details = grbl.on_get_errors();
 801b0f8:	4b1d      	ldr	r3, [pc, #116]	; (801b170 <report_error_details+0x9c>)
 801b0fa:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801b0fc:	4798      	blx	r3
 801b0fe:	4604      	mov	r4, r0
    if((all_errors = perror = calloc(n_errors, sizeof(status_detail_t *)))) {
 801b100:	2104      	movs	r1, #4
 801b102:	4628      	mov	r0, r5
 801b104:	f007 f9b6 	bl	8022474 <calloc>
 801b108:	4607      	mov	r7, r0
 801b10a:	b328      	cbz	r0, 801b158 <report_error_details+0x84>
 801b10c:	4603      	mov	r3, r0
 801b10e:	e00a      	b.n	801b126 <report_error_details+0x52>
                *perror++ = (status_detail_t *)&(details->errors[idx]);
 801b110:	6861      	ldr	r1, [r4, #4]
 801b112:	eb01 01c2 	add.w	r1, r1, r2, lsl #3
 801b116:	f843 1b04 	str.w	r1, [r3], #4
            for(idx = 0; idx < details->n_errors; idx++)
 801b11a:	3201      	adds	r2, #1
 801b11c:	8821      	ldrh	r1, [r4, #0]
 801b11e:	4291      	cmp	r1, r2
 801b120:	d8f6      	bhi.n	801b110 <report_error_details+0x3c>
        } while((details = details->next));
 801b122:	68a4      	ldr	r4, [r4, #8]
 801b124:	b10c      	cbz	r4, 801b12a <report_error_details+0x56>
            for(idx = 0; idx < details->n_errors; idx++)
 801b126:	2200      	movs	r2, #0
 801b128:	e7f8      	b.n	801b11c <report_error_details+0x48>
        qsort(all_errors, n_errors, sizeof(status_detail_t *), cmp_errors);
 801b12a:	4b14      	ldr	r3, [pc, #80]	; (801b17c <report_error_details+0xa8>)
 801b12c:	2204      	movs	r2, #4
 801b12e:	4629      	mov	r1, r5
 801b130:	4638      	mov	r0, r7
 801b132:	f007 fabb 	bl	80226ac <qsort>
        for(idx = 0; idx < n_errors; idx++)
 801b136:	e005      	b.n	801b144 <report_error_details+0x70>
            print_error(all_errors[idx], grbl_format);
 801b138:	4631      	mov	r1, r6
 801b13a:	f857 0024 	ldr.w	r0, [r7, r4, lsl #2]
 801b13e:	f7fd f8ed 	bl	801831c <print_error>
        for(idx = 0; idx < n_errors; idx++)
 801b142:	3401      	adds	r4, #1
 801b144:	42ac      	cmp	r4, r5
 801b146:	d3f7      	bcc.n	801b138 <report_error_details+0x64>
        free(all_errors);
 801b148:	4638      	mov	r0, r7
 801b14a:	f007 f9b9 	bl	80224c0 <free>
}
 801b14e:	2000      	movs	r0, #0
 801b150:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    } while((details = details->next));
 801b152:	68a4      	ldr	r4, [r4, #8]
 801b154:	2c00      	cmp	r4, #0
 801b156:	d0fa      	beq.n	801b14e <report_error_details+0x7a>
        for(idx = 0; idx < details->n_errors; idx++)
 801b158:	2500      	movs	r5, #0
 801b15a:	8823      	ldrh	r3, [r4, #0]
 801b15c:	42ab      	cmp	r3, r5
 801b15e:	d9f8      	bls.n	801b152 <report_error_details+0x7e>
            print_error(&details->errors[idx], grbl_format);
 801b160:	6860      	ldr	r0, [r4, #4]
 801b162:	4631      	mov	r1, r6
 801b164:	eb00 00c5 	add.w	r0, r0, r5, lsl #3
 801b168:	f7fd f8d8 	bl	801831c <print_error>
        for(idx = 0; idx < details->n_errors; idx++)
 801b16c:	3501      	adds	r5, #1
 801b16e:	e7f4      	b.n	801b15a <report_error_details+0x86>
 801b170:	2000343c 	.word	0x2000343c
 801b174:	2000350c 	.word	0x2000350c
 801b178:	080279c4 	.word	0x080279c4
 801b17c:	080181b5 	.word	0x080181b5

0801b180 <report_setting_group_details>:
{
 801b180:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801b184:	4683      	mov	fp, r0
 801b186:	468a      	mov	sl, r1
    setting_details_t *details = settings_get_details();
 801b188:	f001 f8a2 	bl	801c2d0 <settings_get_details>
    uint_fast16_t idx, n_groups = 0;
 801b18c:	f04f 0900 	mov.w	r9, #0
        n_groups += details->n_groups;
 801b190:	7803      	ldrb	r3, [r0, #0]
 801b192:	4499      	add	r9, r3
    } while((details = details->next));
 801b194:	6980      	ldr	r0, [r0, #24]
 801b196:	2800      	cmp	r0, #0
 801b198:	d1fa      	bne.n	801b190 <report_setting_group_details+0x10>
    details = settings_get_details();
 801b19a:	f001 f899 	bl	801c2d0 <settings_get_details>
 801b19e:	4607      	mov	r7, r0
    if((all_groups = group = calloc(n_groups, sizeof(setting_group_detail_t *)))) {
 801b1a0:	2104      	movs	r1, #4
 801b1a2:	4648      	mov	r0, r9
 801b1a4:	f007 f966 	bl	8022474 <calloc>
 801b1a8:	4680      	mov	r8, r0
 801b1aa:	2800      	cmp	r0, #0
 801b1ac:	d035      	beq.n	801b21a <report_setting_group_details+0x9a>
 801b1ae:	4606      	mov	r6, r0
 801b1b0:	e013      	b.n	801b1da <report_setting_group_details+0x5a>
            for(idx = 0; idx < details->n_groups; idx++) {
 801b1b2:	3401      	adds	r4, #1
 801b1b4:	783b      	ldrb	r3, [r7, #0]
 801b1b6:	42a3      	cmp	r3, r4
 801b1b8:	d90d      	bls.n	801b1d6 <report_setting_group_details+0x56>
                if(!group_is_dup(all_groups, details->groups[idx].id))
 801b1ba:	687d      	ldr	r5, [r7, #4]
 801b1bc:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 801b1c0:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 801b1c4:	7869      	ldrb	r1, [r5, #1]
 801b1c6:	4640      	mov	r0, r8
 801b1c8:	f7fd f800 	bl	80181cc <group_is_dup>
 801b1cc:	2800      	cmp	r0, #0
 801b1ce:	d1f0      	bne.n	801b1b2 <report_setting_group_details+0x32>
                    *group++ = (setting_group_detail_t *)&details->groups[idx];
 801b1d0:	f846 5b04 	str.w	r5, [r6], #4
 801b1d4:	e7ed      	b.n	801b1b2 <report_setting_group_details+0x32>
        } while((details = details->next));
 801b1d6:	69bf      	ldr	r7, [r7, #24]
 801b1d8:	b10f      	cbz	r7, 801b1de <report_setting_group_details+0x5e>
            for(idx = 0; idx < details->n_groups; idx++) {
 801b1da:	2400      	movs	r4, #0
 801b1dc:	e7ea      	b.n	801b1b4 <report_setting_group_details+0x34>
        qsort(all_groups, n_groups, sizeof(setting_group_detail_t *), by_id ? cmp_setting_group_id : cmp_setting_group_name);
 801b1de:	f1bb 0f00 	cmp.w	fp, #0
 801b1e2:	d007      	beq.n	801b1f4 <report_setting_group_details+0x74>
 801b1e4:	4b14      	ldr	r3, [pc, #80]	; (801b238 <report_setting_group_details+0xb8>)
 801b1e6:	2204      	movs	r2, #4
 801b1e8:	4649      	mov	r1, r9
 801b1ea:	4640      	mov	r0, r8
 801b1ec:	f007 fa5e 	bl	80226ac <qsort>
        for(idx = 0; idx < n_groups; idx++)
 801b1f0:	2400      	movs	r4, #0
 801b1f2:	e007      	b.n	801b204 <report_setting_group_details+0x84>
        qsort(all_groups, n_groups, sizeof(setting_group_detail_t *), by_id ? cmp_setting_group_id : cmp_setting_group_name);
 801b1f4:	4b11      	ldr	r3, [pc, #68]	; (801b23c <report_setting_group_details+0xbc>)
 801b1f6:	e7f6      	b.n	801b1e6 <report_setting_group_details+0x66>
            print_setting_group(all_groups[idx], prefix);
 801b1f8:	4651      	mov	r1, sl
 801b1fa:	f858 0024 	ldr.w	r0, [r8, r4, lsl #2]
 801b1fe:	f7fd ff0d 	bl	801901c <print_setting_group>
        for(idx = 0; idx < n_groups; idx++)
 801b202:	3401      	adds	r4, #1
 801b204:	454c      	cmp	r4, r9
 801b206:	d3f7      	bcc.n	801b1f8 <report_setting_group_details+0x78>
        free(all_groups);
 801b208:	4640      	mov	r0, r8
 801b20a:	f007 f959 	bl	80224c0 <free>
}
 801b20e:	2000      	movs	r0, #0
 801b210:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    } while((details = details->next));
 801b214:	69bf      	ldr	r7, [r7, #24]
 801b216:	2f00      	cmp	r7, #0
 801b218:	d0f9      	beq.n	801b20e <report_setting_group_details+0x8e>
        for(idx = 0; idx < details->n_groups; idx++)
 801b21a:	2400      	movs	r4, #0
 801b21c:	783b      	ldrb	r3, [r7, #0]
 801b21e:	42a3      	cmp	r3, r4
 801b220:	d9f8      	bls.n	801b214 <report_setting_group_details+0x94>
            print_setting_group(&details->groups[idx], prefix);
 801b222:	687b      	ldr	r3, [r7, #4]
 801b224:	eb04 0044 	add.w	r0, r4, r4, lsl #1
 801b228:	4651      	mov	r1, sl
 801b22a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 801b22e:	f7fd fef5 	bl	801901c <print_setting_group>
        for(idx = 0; idx < details->n_groups; idx++)
 801b232:	3401      	adds	r4, #1
 801b234:	e7f2      	b.n	801b21c <report_setting_group_details+0x9c>
 801b236:	bf00      	nop
 801b238:	080181c1 	.word	0x080181c1
 801b23c:	080187ad 	.word	0x080187ad

0801b240 <report_help>:
{
 801b240:	b538      	push	{r3, r4, r5, lr}
 801b242:	4604      	mov	r4, r0
    while(*args == ' ')
 801b244:	e000      	b.n	801b248 <report_help+0x8>
        args++;
 801b246:	3401      	adds	r4, #1
    while(*args == ' ')
 801b248:	7823      	ldrb	r3, [r4, #0]
 801b24a:	2b20      	cmp	r3, #32
 801b24c:	d0fb      	beq.n	801b246 <report_help+0x6>
    if(*args == '\0') {
 801b24e:	b9f3      	cbnz	r3, 801b28e <report_help+0x4e>
        hal.stream.write("Help topics:" ASCII_EOL);
 801b250:	4c2c      	ldr	r4, [pc, #176]	; (801b304 <report_help+0xc4>)
 801b252:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801b256:	482c      	ldr	r0, [pc, #176]	; (801b308 <report_help+0xc8>)
 801b258:	4798      	blx	r3
        hal.stream.write(" Commands" ASCII_EOL);
 801b25a:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801b25e:	482b      	ldr	r0, [pc, #172]	; (801b30c <report_help+0xcc>)
 801b260:	4798      	blx	r3
        hal.stream.write(" Settings" ASCII_EOL);
 801b262:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801b266:	482a      	ldr	r0, [pc, #168]	; (801b310 <report_help+0xd0>)
 801b268:	4798      	blx	r3
        report_setting_group_details(false, " ");
 801b26a:	492a      	ldr	r1, [pc, #168]	; (801b314 <report_help+0xd4>)
 801b26c:	2000      	movs	r0, #0
 801b26e:	f7ff ff87 	bl	801b180 <report_setting_group_details>
}
 801b272:	2000      	movs	r0, #0
 801b274:	bd38      	pop	{r3, r4, r5, pc}
            *s++ = CAPS(c);
 801b276:	f803 2b01 	strb.w	r2, [r3], #1
        while((c = *s))
 801b27a:	781a      	ldrb	r2, [r3, #0]
 801b27c:	b14a      	cbz	r2, 801b292 <report_help+0x52>
            *s++ = CAPS(c);
 801b27e:	f1a2 0161 	sub.w	r1, r2, #97	; 0x61
 801b282:	b2c9      	uxtb	r1, r1
 801b284:	2919      	cmp	r1, #25
 801b286:	d8f6      	bhi.n	801b276 <report_help+0x36>
 801b288:	f002 025f 	and.w	r2, r2, #95	; 0x5f
 801b28c:	e7f3      	b.n	801b276 <report_help+0x36>
        char c, *s = args;
 801b28e:	4623      	mov	r3, r4
 801b290:	e7f3      	b.n	801b27a <report_help+0x3a>
        if(matchhere(args, "COMMANDS")) {
 801b292:	4921      	ldr	r1, [pc, #132]	; (801b318 <report_help+0xd8>)
 801b294:	4620      	mov	r0, r4
 801b296:	f7fc ff1f 	bl	80180d8 <matchhere>
 801b29a:	b128      	cbz	r0, 801b2a8 <report_help+0x68>
            if(grbl.on_report_command_help)
 801b29c:	4b1f      	ldr	r3, [pc, #124]	; (801b31c <report_help+0xdc>)
 801b29e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801b2a0:	2b00      	cmp	r3, #0
 801b2a2:	d0e6      	beq.n	801b272 <report_help+0x32>
                grbl.on_report_command_help();
 801b2a4:	4798      	blx	r3
 801b2a6:	e7e4      	b.n	801b272 <report_help+0x32>
        } else if(matchhere(args, "SETTINGS"))
 801b2a8:	491d      	ldr	r1, [pc, #116]	; (801b320 <report_help+0xe0>)
 801b2aa:	4620      	mov	r0, r4
 801b2ac:	f7fc ff14 	bl	80180d8 <matchhere>
 801b2b0:	b130      	cbz	r0, 801b2c0 <report_help+0x80>
            report_settings_details(SettingsFormat_HumanReadable, Setting_SettingsAll, Group_All);
 801b2b2:	2200      	movs	r2, #0
 801b2b4:	f240 218a 	movw	r1, #650	; 0x28a
 801b2b8:	2001      	movs	r0, #1
 801b2ba:	f7ff fdf7 	bl	801aeac <report_settings_details>
 801b2be:	e7d8      	b.n	801b272 <report_help+0x32>
            setting_details_t *settings_info = settings_get_details();
 801b2c0:	f001 f806 	bl	801c2d0 <settings_get_details>
 801b2c4:	4605      	mov	r5, r0
            found = report_group_settings(settings_info->groups, settings_info->n_groups, args);
 801b2c6:	4622      	mov	r2, r4
 801b2c8:	7801      	ldrb	r1, [r0, #0]
 801b2ca:	6840      	ldr	r0, [r0, #4]
 801b2cc:	f7ff fe08 	bl	801aee0 <report_group_settings>
            if(!found && (settings_info = settings_info->next)) do {
 801b2d0:	4603      	mov	r3, r0
 801b2d2:	b908      	cbnz	r0, 801b2d8 <report_help+0x98>
 801b2d4:	69ad      	ldr	r5, [r5, #24]
 801b2d6:	b955      	cbnz	r5, 801b2ee <report_help+0xae>
            if(!found)
 801b2d8:	2b00      	cmp	r3, #0
 801b2da:	d1ca      	bne.n	801b272 <report_help+0x32>
                hal.stream.write( ASCII_EOL "N/A" ASCII_EOL);
 801b2dc:	4b09      	ldr	r3, [pc, #36]	; (801b304 <report_help+0xc4>)
 801b2de:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801b2e2:	4810      	ldr	r0, [pc, #64]	; (801b324 <report_help+0xe4>)
 801b2e4:	4798      	blx	r3
 801b2e6:	e7c4      	b.n	801b272 <report_help+0x32>
            } while((settings_info = settings_info->next));
 801b2e8:	69ad      	ldr	r5, [r5, #24]
 801b2ea:	2d00      	cmp	r5, #0
 801b2ec:	d0f4      	beq.n	801b2d8 <report_help+0x98>
                if(settings_info->groups && (found = report_group_settings(settings_info->groups, settings_info->n_groups, args)))
 801b2ee:	6868      	ldr	r0, [r5, #4]
 801b2f0:	2800      	cmp	r0, #0
 801b2f2:	d0f9      	beq.n	801b2e8 <report_help+0xa8>
 801b2f4:	4622      	mov	r2, r4
 801b2f6:	7829      	ldrb	r1, [r5, #0]
 801b2f8:	f7ff fdf2 	bl	801aee0 <report_group_settings>
 801b2fc:	4603      	mov	r3, r0
 801b2fe:	2800      	cmp	r0, #0
 801b300:	d0f2      	beq.n	801b2e8 <report_help+0xa8>
 801b302:	e7e9      	b.n	801b2d8 <report_help+0x98>
 801b304:	2000350c 	.word	0x2000350c
 801b308:	08027a0c 	.word	0x08027a0c
 801b30c:	08027a1c 	.word	0x08027a1c
 801b310:	08027a28 	.word	0x08027a28
 801b314:	08027470 	.word	0x08027470
 801b318:	08027a34 	.word	0x08027a34
 801b31c:	2000343c 	.word	0x2000343c
 801b320:	08027a40 	.word	0x08027a40
 801b324:	08027a4c 	.word	0x08027a4c

0801b328 <report_last_signals_event>:
{
 801b328:	b538      	push	{r3, r4, r5, lr}
    strcpy(buf, "[LASTEVENTS:");
 801b32a:	4b29      	ldr	r3, [pc, #164]	; (801b3d0 <report_last_signals_event+0xa8>)
 801b32c:	4c29      	ldr	r4, [pc, #164]	; (801b3d4 <report_last_signals_event+0xac>)
 801b32e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801b330:	c407      	stmia	r4!, {r0, r1, r2}
 801b332:	7023      	strb	r3, [r4, #0]
    append = control_signals_tostring(append, sys.last_event.control);
 801b334:	4b28      	ldr	r3, [pc, #160]	; (801b3d8 <report_last_signals_event+0xb0>)
 801b336:	f8b3 3080 	ldrh.w	r3, [r3, #128]	; 0x80
    if(!hal.signals_cap.stop_disable)
 801b33a:	4a28      	ldr	r2, [pc, #160]	; (801b3dc <report_last_signals_event+0xb4>)
 801b33c:	f892 21a8 	ldrb.w	r2, [r2, #424]	; 0x1a8
 801b340:	f012 0f20 	tst.w	r2, #32
 801b344:	d105      	bne.n	801b352 <report_last_signals_event+0x2a>
        signals.stop_disable = sys.flags.optional_stop_disable;
 801b346:	4a24      	ldr	r2, [pc, #144]	; (801b3d8 <report_last_signals_event+0xb0>)
 801b348:	7d92      	ldrb	r2, [r2, #22]
 801b34a:	f3c2 1280 	ubfx	r2, r2, #6, #1
 801b34e:	f362 1345 	bfi	r3, r2, #5, #1
    if(!signals.deasserted)
 801b352:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 801b356:	d102      	bne.n	801b35e <report_last_signals_event+0x36>
    char *map = (char *)signals_map;
 801b358:	4a21      	ldr	r2, [pc, #132]	; (801b3e0 <report_last_signals_event+0xb8>)
 801b35a:	4822      	ldr	r0, [pc, #136]	; (801b3e4 <report_last_signals_event+0xbc>)
 801b35c:	e020      	b.n	801b3a0 <report_last_signals_event+0x78>
 801b35e:	4821      	ldr	r0, [pc, #132]	; (801b3e4 <report_last_signals_event+0xbc>)
    *buf = '\0';
 801b360:	2400      	movs	r4, #0
 801b362:	7004      	strb	r4, [r0, #0]
    *append++ = ',';
 801b364:	232c      	movs	r3, #44	; 0x2c
 801b366:	f800 3b01 	strb.w	r3, [r0], #1
    append = add_limits(append, sys.last_event.limits);
 801b36a:	4b1b      	ldr	r3, [pc, #108]	; (801b3d8 <report_last_signals_event+0xb0>)
 801b36c:	f8d3 1082 	ldr.w	r1, [r3, #130]	; 0x82
 801b370:	f7fd fec6 	bl	8019100 <add_limits>
    hal.stream.write(buf);
 801b374:	4d19      	ldr	r5, [pc, #100]	; (801b3dc <report_last_signals_event+0xb4>)
 801b376:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 801b37a:	4816      	ldr	r0, [pc, #88]	; (801b3d4 <report_last_signals_event+0xac>)
 801b37c:	4798      	blx	r3
    hal.stream.write("]" ASCII_EOL);
 801b37e:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 801b382:	4819      	ldr	r0, [pc, #100]	; (801b3e8 <report_last_signals_event+0xc0>)
 801b384:	4798      	blx	r3
}
 801b386:	4620      	mov	r0, r4
 801b388:	bd38      	pop	{r3, r4, r5, pc}
                    if(hal.signals_cap.safety_door_ajar)
 801b38a:	4c14      	ldr	r4, [pc, #80]	; (801b3dc <report_last_signals_event+0xb4>)
 801b38c:	f894 41a8 	ldrb.w	r4, [r4, #424]	; 0x1a8
 801b390:	f014 0f08 	tst.w	r4, #8
 801b394:	d001      	beq.n	801b39a <report_last_signals_event+0x72>
                        *buf++ = *map;
 801b396:	f800 1b01 	strb.w	r1, [r0], #1
        map++;
 801b39a:	3201      	adds	r2, #1
        signals.mask >>= 1;
 801b39c:	f3c3 034f 	ubfx	r3, r3, #1, #16
      while(signals.mask) {
 801b3a0:	b29b      	uxth	r3, r3
 801b3a2:	2b00      	cmp	r3, #0
 801b3a4:	d0dc      	beq.n	801b360 <report_last_signals_event+0x38>
        if(signals.mask & 0x01) {
 801b3a6:	f013 0f01 	tst.w	r3, #1
 801b3aa:	d0f6      	beq.n	801b39a <report_last_signals_event+0x72>
            switch(*map) {
 801b3ac:	7811      	ldrb	r1, [r2, #0]
 801b3ae:	2944      	cmp	r1, #68	; 0x44
 801b3b0:	d0eb      	beq.n	801b38a <report_last_signals_event+0x62>
 801b3b2:	294c      	cmp	r1, #76	; 0x4c
 801b3b4:	d004      	beq.n	801b3c0 <report_last_signals_event+0x98>
 801b3b6:	2920      	cmp	r1, #32
 801b3b8:	d0ef      	beq.n	801b39a <report_last_signals_event+0x72>
                    *buf++ = *map;
 801b3ba:	f800 1b01 	strb.w	r1, [r0], #1
                    break;
 801b3be:	e7ec      	b.n	801b39a <report_last_signals_event+0x72>
                    if(sys.flags.block_delete_enabled)
 801b3c0:	4c05      	ldr	r4, [pc, #20]	; (801b3d8 <report_last_signals_event+0xb0>)
 801b3c2:	7da4      	ldrb	r4, [r4, #22]
 801b3c4:	f014 0f10 	tst.w	r4, #16
 801b3c8:	d0e7      	beq.n	801b39a <report_last_signals_event+0x72>
                        *buf++ = *map;
 801b3ca:	f800 1b01 	strb.w	r1, [r0], #1
 801b3ce:	e7e4      	b.n	801b39a <report_last_signals_event+0x72>
 801b3d0:	08027a54 	.word	0x08027a54
 801b3d4:	20003a88 	.word	0x20003a88
 801b3d8:	200036c4 	.word	0x200036c4
 801b3dc:	2000350c 	.word	0x2000350c
 801b3e0:	080283d4 	.word	0x080283d4
 801b3e4:	20003a94 	.word	0x20003a94
 801b3e8:	0802cde0 	.word	0x0802cde0

0801b3ec <report_current_limit_state>:
{
 801b3ec:	b570      	push	{r4, r5, r6, lr}
 801b3ee:	b082      	sub	sp, #8
    strcpy(buf, "[LIMITS:");
 801b3f0:	4e0c      	ldr	r6, [pc, #48]	; (801b424 <report_current_limit_state+0x38>)
 801b3f2:	4b0d      	ldr	r3, [pc, #52]	; (801b428 <report_current_limit_state+0x3c>)
 801b3f4:	4634      	mov	r4, r6
 801b3f6:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 801b3fa:	c403      	stmia	r4!, {r0, r1}
 801b3fc:	7022      	strb	r2, [r4, #0]
    append = add_limits(append, hal.limits.get_state());
 801b3fe:	4d0b      	ldr	r5, [pc, #44]	; (801b42c <report_current_limit_state+0x40>)
 801b400:	6dab      	ldr	r3, [r5, #88]	; 0x58
 801b402:	4798      	blx	r3
 801b404:	4601      	mov	r1, r0
 801b406:	9001      	str	r0, [sp, #4]
 801b408:	4620      	mov	r0, r4
 801b40a:	f7fd fe79 	bl	8019100 <add_limits>
    hal.stream.write(buf);
 801b40e:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 801b412:	4630      	mov	r0, r6
 801b414:	4798      	blx	r3
    hal.stream.write("]" ASCII_EOL);
 801b416:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 801b41a:	4805      	ldr	r0, [pc, #20]	; (801b430 <report_current_limit_state+0x44>)
 801b41c:	4798      	blx	r3
}
 801b41e:	2000      	movs	r0, #0
 801b420:	b002      	add	sp, #8
 801b422:	bd70      	pop	{r4, r5, r6, pc}
 801b424:	20003a88 	.word	0x20003a88
 801b428:	08027a64 	.word	0x08027a64
 801b42c:	2000350c 	.word	0x2000350c
 801b430:	0802cde0 	.word	0x0802cde0

0801b434 <report_spindle_data>:
{
 801b434:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801b438:	ed2d 8b02 	vpush	{d8}
    spindle_ptrs_t *spindle = gc_spindle_get();
 801b43c:	f7f3 ff28 	bl	800f290 <gc_spindle_get>
 801b440:	4605      	mov	r5, r0
    if(spindle->get_data) {
 801b442:	6b43      	ldr	r3, [r0, #52]	; 0x34
 801b444:	2b00      	cmp	r3, #0
 801b446:	d037      	beq.n	801b4b8 <report_spindle_data+0x84>
        float apos = spindle->get_data(SpindleData_AngularPosition)->angular_position;
 801b448:	2002      	movs	r0, #2
 801b44a:	4798      	blx	r3
 801b44c:	ed90 8a03 	vldr	s16, [r0, #12]
        spindle_data_t *data = spindle->get_data(SpindleData_Counters);
 801b450:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 801b452:	2000      	movs	r0, #0
 801b454:	4798      	blx	r3
 801b456:	4606      	mov	r6, r0
        hal.stream.write("[SPINDLE:");
 801b458:	4c1c      	ldr	r4, [pc, #112]	; (801b4cc <report_spindle_data+0x98>)
 801b45a:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801b45e:	481c      	ldr	r0, [pc, #112]	; (801b4d0 <report_spindle_data+0x9c>)
 801b460:	4798      	blx	r3
        hal.stream.write(uitoa(data->index_count));
 801b462:	f8d4 70b4 	ldr.w	r7, [r4, #180]	; 0xb4
 801b466:	6970      	ldr	r0, [r6, #20]
 801b468:	f7fa f986 	bl	8015778 <uitoa>
 801b46c:	47b8      	blx	r7
        hal.stream.write(",");
 801b46e:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801b472:	4f18      	ldr	r7, [pc, #96]	; (801b4d4 <report_spindle_data+0xa0>)
 801b474:	4638      	mov	r0, r7
 801b476:	4798      	blx	r3
        hal.stream.write(uitoa(data->pulse_count));
 801b478:	f8d4 80b4 	ldr.w	r8, [r4, #180]	; 0xb4
 801b47c:	69b0      	ldr	r0, [r6, #24]
 801b47e:	f7fa f97b 	bl	8015778 <uitoa>
 801b482:	47c0      	blx	r8
        hal.stream.write(",");
 801b484:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801b488:	4638      	mov	r0, r7
 801b48a:	4798      	blx	r3
        hal.stream.write(uitoa(data->error_count));
 801b48c:	f8d4 80b4 	ldr.w	r8, [r4, #180]	; 0xb4
 801b490:	69f0      	ldr	r0, [r6, #28]
 801b492:	f7fa f971 	bl	8015778 <uitoa>
 801b496:	47c0      	blx	r8
        hal.stream.write(",");
 801b498:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801b49c:	4638      	mov	r0, r7
 801b49e:	4798      	blx	r3
        hal.stream.write(ftoa(apos, 3));
 801b4a0:	f8d4 60b4 	ldr.w	r6, [r4, #180]	; 0xb4
 801b4a4:	2003      	movs	r0, #3
 801b4a6:	eeb0 0a48 	vmov.f32	s0, s16
 801b4aa:	f7fa f987 	bl	80157bc <ftoa>
 801b4ae:	47b0      	blx	r6
        hal.stream.write("]" ASCII_EOL);
 801b4b0:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 801b4b4:	4808      	ldr	r0, [pc, #32]	; (801b4d8 <report_spindle_data+0xa4>)
 801b4b6:	4798      	blx	r3
    return spindle->get_data ? Status_OK : Status_InvalidStatement;
 801b4b8:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 801b4ba:	b123      	cbz	r3, 801b4c6 <report_spindle_data+0x92>
 801b4bc:	2000      	movs	r0, #0
}
 801b4be:	ecbd 8b02 	vpop	{d8}
 801b4c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return spindle->get_data ? Status_OK : Status_InvalidStatement;
 801b4c6:	2003      	movs	r0, #3
 801b4c8:	e7f9      	b.n	801b4be <report_spindle_data+0x8a>
 801b4ca:	bf00      	nop
 801b4cc:	2000350c 	.word	0x2000350c
 801b4d0:	08027a70 	.word	0x08027a70
 801b4d4:	08027758 	.word	0x08027758
 801b4d8:	0802cde0 	.word	0x0802cde0

0801b4dc <report_pins>:
{
 801b4dc:	b508      	push	{r3, lr}
    if(hal.enumerate_pins)
 801b4de:	4b05      	ldr	r3, [pc, #20]	; (801b4f4 <report_pins+0x18>)
 801b4e0:	f8d3 3170 	ldr.w	r3, [r3, #368]	; 0x170
 801b4e4:	b11b      	cbz	r3, 801b4ee <report_pins+0x12>
        hal.enumerate_pins(false, report_pin, NULL);
 801b4e6:	2200      	movs	r2, #0
 801b4e8:	4903      	ldr	r1, [pc, #12]	; (801b4f8 <report_pins+0x1c>)
 801b4ea:	4610      	mov	r0, r2
 801b4ec:	4798      	blx	r3
}
 801b4ee:	2000      	movs	r0, #0
 801b4f0:	bd08      	pop	{r3, pc}
 801b4f2:	bf00      	nop
 801b4f4:	2000350c 	.word	0x2000350c
 801b4f8:	080183b1 	.word	0x080183b1

0801b4fc <report_time>:
    if(hal.rtc.get_datetime) {
 801b4fc:	4b1d      	ldr	r3, [pc, #116]	; (801b574 <report_time+0x78>)
 801b4fe:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
 801b502:	2b00      	cmp	r3, #0
 801b504:	d031      	beq.n	801b56a <report_time+0x6e>
{
 801b506:	b570      	push	{r4, r5, r6, lr}
 801b508:	b08a      	sub	sp, #40	; 0x28
        if((ok = !!hal.rtc.get_datetime(&time))) {
 801b50a:	a801      	add	r0, sp, #4
 801b50c:	4798      	blx	r3
 801b50e:	4604      	mov	r4, r0
 801b510:	b338      	cbz	r0, 801b562 <report_time+0x66>
            hal.stream.write("[RTC:");
 801b512:	4d18      	ldr	r5, [pc, #96]	; (801b574 <report_time+0x78>)
 801b514:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 801b518:	4817      	ldr	r0, [pc, #92]	; (801b578 <report_time+0x7c>)
 801b51a:	4798      	blx	r3
            hal.stream.write(uitoa(time.tm_year + 1900));
 801b51c:	f8d5 60b4 	ldr.w	r6, [r5, #180]	; 0xb4
 801b520:	9806      	ldr	r0, [sp, #24]
 801b522:	f200 706c 	addw	r0, r0, #1900	; 0x76c
 801b526:	f7fa f927 	bl	8015778 <uitoa>
 801b52a:	47b0      	blx	r6
            print_uito2a("-", time.tm_mon + 1);
 801b52c:	4e13      	ldr	r6, [pc, #76]	; (801b57c <report_time+0x80>)
 801b52e:	9905      	ldr	r1, [sp, #20]
 801b530:	3101      	adds	r1, #1
 801b532:	4630      	mov	r0, r6
 801b534:	f7fc ff74 	bl	8018420 <print_uito2a>
            print_uito2a("-", time.tm_mday);
 801b538:	9904      	ldr	r1, [sp, #16]
 801b53a:	4630      	mov	r0, r6
 801b53c:	f7fc ff70 	bl	8018420 <print_uito2a>
            print_uito2a("T", time.tm_hour);
 801b540:	9903      	ldr	r1, [sp, #12]
 801b542:	480f      	ldr	r0, [pc, #60]	; (801b580 <report_time+0x84>)
 801b544:	f7fc ff6c 	bl	8018420 <print_uito2a>
            print_uito2a(":", time.tm_min);
 801b548:	4e0e      	ldr	r6, [pc, #56]	; (801b584 <report_time+0x88>)
 801b54a:	9902      	ldr	r1, [sp, #8]
 801b54c:	4630      	mov	r0, r6
 801b54e:	f7fc ff67 	bl	8018420 <print_uito2a>
            print_uito2a(":", time.tm_sec);
 801b552:	9901      	ldr	r1, [sp, #4]
 801b554:	4630      	mov	r0, r6
 801b556:	f7fc ff63 	bl	8018420 <print_uito2a>
            hal.stream.write("]" ASCII_EOL);
 801b55a:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 801b55e:	480a      	ldr	r0, [pc, #40]	; (801b588 <report_time+0x8c>)
 801b560:	4798      	blx	r3
    return ok ? Status_OK : Status_InvalidStatement;
 801b562:	b124      	cbz	r4, 801b56e <report_time+0x72>
 801b564:	2000      	movs	r0, #0
}
 801b566:	b00a      	add	sp, #40	; 0x28
 801b568:	bd70      	pop	{r4, r5, r6, pc}
    return ok ? Status_OK : Status_InvalidStatement;
 801b56a:	2003      	movs	r0, #3
}
 801b56c:	4770      	bx	lr
    return ok ? Status_OK : Status_InvalidStatement;
 801b56e:	2003      	movs	r0, #3
 801b570:	e7f9      	b.n	801b566 <report_time+0x6a>
 801b572:	bf00      	nop
 801b574:	2000350c 	.word	0x2000350c
 801b578:	08027a7c 	.word	0x08027a7c
 801b57c:	08027a84 	.word	0x08027a84
 801b580:	08027a88 	.word	0x08027a88
 801b584:	08027694 	.word	0x08027694
 801b588:	0802cde0 	.word	0x0802cde0

0801b58c <report_spindles>:

status_code_t report_spindles (void)
{
 801b58c:	b508      	push	{r3, lr}
    if(!spindle_enumerate_spindles(report_spindle, NULL))
 801b58e:	2100      	movs	r1, #0
 801b590:	4805      	ldr	r0, [pc, #20]	; (801b5a8 <report_spindles+0x1c>)
 801b592:	f002 f989 	bl	801d8a8 <spindle_enumerate_spindles>
 801b596:	b920      	cbnz	r0, 801b5a2 <report_spindles+0x16>
        hal.stream.write("No spindles registered." ASCII_EOL);
 801b598:	4b04      	ldr	r3, [pc, #16]	; (801b5ac <report_spindles+0x20>)
 801b59a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801b59e:	4804      	ldr	r0, [pc, #16]	; (801b5b0 <report_spindles+0x24>)
 801b5a0:	4798      	blx	r3

    return Status_OK;
}
 801b5a2:	2000      	movs	r0, #0
 801b5a4:	bd08      	pop	{r3, pc}
 801b5a6:	bf00      	nop
 801b5a8:	08018455 	.word	0x08018455
 801b5ac:	2000350c 	.word	0x2000350c
 801b5b0:	08027a8c 	.word	0x08027a8c

0801b5b4 <report_pid_log>:

void report_pid_log (void)
{
 801b5b4:	b508      	push	{r3, lr}
    } while(idx != sys.pid_log.idx);

    hal.stream.write("]" ASCII_EOL);
    grbl.report.status_message(Status_OK);
#else
    grbl.report.status_message(Status_GcodeUnsupportedCommand);
 801b5b6:	4b02      	ldr	r3, [pc, #8]	; (801b5c0 <report_pid_log+0xc>)
 801b5b8:	689b      	ldr	r3, [r3, #8]
 801b5ba:	2014      	movs	r0, #20
 801b5bc:	4798      	blx	r3
#endif
}
 801b5be:	bd08      	pop	{r3, pc}
 801b5c0:	2000343c 	.word	0x2000343c

0801b5c4 <report_init_fns>:
    .alarm_message = report_alarm_message,
    .setting = report_setting
};

void report_init_fns (void)
{
 801b5c4:	b538      	push	{r3, r4, r5, lr}
    memcpy(&grbl.report, &report_fns, sizeof(report_t));
 801b5c6:	4d07      	ldr	r5, [pc, #28]	; (801b5e4 <report_init_fns+0x20>)
 801b5c8:	46ac      	mov	ip, r5
 801b5ca:	4c07      	ldr	r4, [pc, #28]	; (801b5e8 <report_init_fns+0x24>)
 801b5cc:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801b5ce:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801b5d2:	e894 0003 	ldmia.w	r4, {r0, r1}
 801b5d6:	e88c 0003 	stmia.w	ip, {r0, r1}

    if(grbl.on_report_handlers_init)
 801b5da:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 801b5dc:	b103      	cbz	r3, 801b5e0 <report_init_fns+0x1c>
        grbl.on_report_handlers_init();
 801b5de:	4798      	blx	r3
}
 801b5e0:	bd38      	pop	{r3, r4, r5, pc}
 801b5e2:	bf00      	nop
 801b5e4:	2000343c 	.word	0x2000343c
 801b5e8:	080283bc 	.word	0x080283bc

0801b5ec <group_is_available>:
};

static bool group_is_available (const setting_group_detail_t *group)
{
    return true;
}
 801b5ec:	2001      	movs	r0, #1
 801b5ee:	4770      	bx	lr

0801b5f0 <restore_override_backup>:

static void restore_override_backup (void)
{
    uint_fast8_t idx = N_AXIS;

    if(override_backup.valid) do {
 801b5f0:	4b08      	ldr	r3, [pc, #32]	; (801b614 <restore_override_backup+0x24>)
 801b5f2:	781b      	ldrb	r3, [r3, #0]
 801b5f4:	b16b      	cbz	r3, 801b612 <restore_override_backup+0x22>
    uint_fast8_t idx = N_AXIS;
 801b5f6:	2303      	movs	r3, #3
        idx--;
 801b5f8:	3b01      	subs	r3, #1
        settings.axis[idx].acceleration = override_backup.acceleration[idx];
 801b5fa:	4a06      	ldr	r2, [pc, #24]	; (801b614 <restore_override_backup+0x24>)
 801b5fc:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 801b600:	6850      	ldr	r0, [r2, #4]
 801b602:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 801b606:	0091      	lsls	r1, r2, #2
 801b608:	4a03      	ldr	r2, [pc, #12]	; (801b618 <restore_override_backup+0x28>)
 801b60a:	440a      	add	r2, r1
 801b60c:	6390      	str	r0, [r2, #56]	; 0x38
    } while(idx);
 801b60e:	2b00      	cmp	r3, #0
 801b610:	d1f2      	bne.n	801b5f8 <restore_override_backup+0x8>
}
 801b612:	4770      	bx	lr
 801b614:	20003b04 	.word	0x20003b04
 801b618:	20003b14 	.word	0x20003b14

0801b61c <set_probe_invert>:
}

#endif

static status_code_t set_probe_invert (setting_id_t id, uint_fast16_t int_value)
{
 801b61c:	b508      	push	{r3, lr}
    if(!hal.probe.configure)
 801b61e:	4b0a      	ldr	r3, [pc, #40]	; (801b648 <set_probe_invert+0x2c>)
 801b620:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 801b624:	b173      	cbz	r3, 801b644 <set_probe_invert+0x28>
        return Status_SettingDisabled;

    settings.probe.invert_probe_pin = int_value != 0;
 801b626:	3900      	subs	r1, #0
 801b628:	bf18      	it	ne
 801b62a:	2101      	movne	r1, #1
 801b62c:	4a07      	ldr	r2, [pc, #28]	; (801b64c <set_probe_invert+0x30>)
 801b62e:	f892 0100 	ldrb.w	r0, [r2, #256]	; 0x100
 801b632:	f361 0000 	bfi	r0, r1, #0, #1
 801b636:	f882 0100 	strb.w	r0, [r2, #256]	; 0x100
    hal.probe.configure(false, false);
 801b63a:	2100      	movs	r1, #0
 801b63c:	4608      	mov	r0, r1
 801b63e:	4798      	blx	r3

    return Status_OK;
 801b640:	2000      	movs	r0, #0
}
 801b642:	bd08      	pop	{r3, pc}
        return Status_SettingDisabled;
 801b644:	2035      	movs	r0, #53	; 0x35
 801b646:	e7fc      	b.n	801b642 <set_probe_invert+0x26>
 801b648:	2000350c 	.word	0x2000350c
 801b64c:	20003b14 	.word	0x20003b14

0801b650 <set_ganged_dir_invert>:

static status_code_t set_ganged_dir_invert (setting_id_t id, uint_fast16_t int_value)
{
    if(!hal.stepper.get_ganged)
 801b650:	4b08      	ldr	r3, [pc, #32]	; (801b674 <set_ganged_dir_invert+0x24>)
 801b652:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 801b656:	b15b      	cbz	r3, 801b670 <set_ganged_dir_invert+0x20>
{
 801b658:	b510      	push	{r4, lr}
 801b65a:	460c      	mov	r4, r1
        return Status_SettingDisabled;

    settings.steppers.ganged_dir_invert.mask = int_value & hal.stepper.get_ganged(false).mask;
 801b65c:	2000      	movs	r0, #0
 801b65e:	4798      	blx	r3
 801b660:	b2c0      	uxtb	r0, r0
 801b662:	ea00 0104 	and.w	r1, r0, r4
 801b666:	4b04      	ldr	r3, [pc, #16]	; (801b678 <set_ganged_dir_invert+0x28>)
 801b668:	f883 10ea 	strb.w	r1, [r3, #234]	; 0xea

    return Status_OK;
 801b66c:	2000      	movs	r0, #0
}
 801b66e:	bd10      	pop	{r4, pc}
        return Status_SettingDisabled;
 801b670:	2035      	movs	r0, #53	; 0x35
}
 801b672:	4770      	bx	lr
 801b674:	2000350c 	.word	0x2000350c
 801b678:	20003b14 	.word	0x20003b14

0801b67c <set_stepper_deenergize_mask>:

static status_code_t set_stepper_deenergize_mask (setting_id_t id, uint_fast16_t int_value)
{
 801b67c:	b508      	push	{r3, lr}
    settings.steppers.deenergize.mask = int_value;
 801b67e:	4b05      	ldr	r3, [pc, #20]	; (801b694 <set_stepper_deenergize_mask+0x18>)
 801b680:	f883 10ec 	strb.w	r1, [r3, #236]	; 0xec

    hal.stepper.enable(settings.steppers.deenergize);
 801b684:	4a04      	ldr	r2, [pc, #16]	; (801b698 <set_stepper_deenergize_mask+0x1c>)
 801b686:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 801b68a:	b2c8      	uxtb	r0, r1
 801b68c:	4790      	blx	r2

    return Status_OK;
}
 801b68e:	2000      	movs	r0, #0
 801b690:	bd08      	pop	{r3, pc}
 801b692:	bf00      	nop
 801b694:	20003b14 	.word	0x20003b14
 801b698:	2000350c 	.word	0x2000350c

0801b69c <set_report_interval>:

static status_code_t set_report_interval (setting_id_t setting, uint_fast16_t int_value)
{
    if((settings.report_interval = int_value) == 0)
 801b69c:	b289      	uxth	r1, r1
 801b69e:	4b05      	ldr	r3, [pc, #20]	; (801b6b4 <set_report_interval+0x18>)
 801b6a0:	8299      	strh	r1, [r3, #20]
 801b6a2:	b921      	cbnz	r1, 801b6ae <set_report_interval+0x12>
        sys.flags.auto_reporting = Off;
 801b6a4:	4b04      	ldr	r3, [pc, #16]	; (801b6b8 <set_report_interval+0x1c>)
 801b6a6:	7dda      	ldrb	r2, [r3, #23]
 801b6a8:	f36f 0241 	bfc	r2, #1, #1
 801b6ac:	75da      	strb	r2, [r3, #23]

    return Status_OK;
}
 801b6ae:	2000      	movs	r0, #0
 801b6b0:	4770      	bx	lr
 801b6b2:	bf00      	nop
 801b6b4:	20003b14 	.word	0x20003b14
 801b6b8:	200036c4 	.word	0x200036c4

0801b6bc <set_report_mask>:

static status_code_t set_report_mask (setting_id_t id, uint_fast16_t int_value)
{
#if COMPATIBILITY_LEVEL <= 1
    settings.status_report.mask = int_value;
 801b6bc:	4b02      	ldr	r3, [pc, #8]	; (801b6c8 <set_report_mask+0xc>)
 801b6be:	f8a3 10fc 	strh.w	r1, [r3, #252]	; 0xfc
    int_value &= 0b11;
    settings.status_report.mask = (settings.status_report.mask & ~0b11) | int_value;
#endif

    return Status_OK;
}
 801b6c2:	2000      	movs	r0, #0
 801b6c4:	4770      	bx	lr
 801b6c6:	bf00      	nop
 801b6c8:	20003b14 	.word	0x20003b14

0801b6cc <set_control_invert>:

#endif

static status_code_t set_control_invert (setting_id_t id, uint_fast16_t int_value)
{
    settings.control_invert.mask = int_value & hal.signals_cap.mask;
 801b6cc:	4b04      	ldr	r3, [pc, #16]	; (801b6e0 <set_control_invert+0x14>)
 801b6ce:	f8b3 31a8 	ldrh.w	r3, [r3, #424]	; 0x1a8
 801b6d2:	400b      	ands	r3, r1
 801b6d4:	4a03      	ldr	r2, [pc, #12]	; (801b6e4 <set_control_invert+0x18>)
 801b6d6:	f8a2 306c 	strh.w	r3, [r2, #108]	; 0x6c

    return Status_OK;
}
 801b6da:	2000      	movs	r0, #0
 801b6dc:	4770      	bx	lr
 801b6de:	bf00      	nop
 801b6e0:	2000350c 	.word	0x2000350c
 801b6e4:	20003b14 	.word	0x20003b14

0801b6e8 <set_pwm_mode>:

static status_code_t set_pwm_mode (setting_id_t id, uint_fast16_t int_value)
{
    settings.spindle.flags.enable_rpm_controlled = int_value != 0;
 801b6e8:	3900      	subs	r1, #0
 801b6ea:	bf18      	it	ne
 801b6ec:	2101      	movne	r1, #1
 801b6ee:	4b04      	ldr	r3, [pc, #16]	; (801b700 <set_pwm_mode+0x18>)
 801b6f0:	f893 20e7 	ldrb.w	r2, [r3, #231]	; 0xe7
 801b6f4:	f361 0200 	bfi	r2, r1, #0, #1
 801b6f8:	f883 20e7 	strb.w	r2, [r3, #231]	; 0xe7

    return Status_OK;
}
 801b6fc:	2000      	movs	r0, #0
 801b6fe:	4770      	bx	lr
 801b700:	20003b14 	.word	0x20003b14

0801b704 <set_pwm_options>:

static status_code_t set_pwm_options (setting_id_t id, uint_fast16_t int_value)
{
    if(int_value & 0x01) {
 801b704:	f011 0f01 	tst.w	r1, #1
 801b708:	d011      	beq.n	801b72e <set_pwm_options+0x2a>
        if(int_value > 0b11)
 801b70a:	2903      	cmp	r1, #3
 801b70c:	d81d      	bhi.n	801b74a <set_pwm_options+0x46>
            return Status_SettingValueOutOfRange;
        settings.spindle.flags.pwm_disable = Off;
 801b70e:	4b10      	ldr	r3, [pc, #64]	; (801b750 <set_pwm_options+0x4c>)
 801b710:	f893 20e7 	ldrb.w	r2, [r3, #231]	; 0xe7
 801b714:	f36f 12c7 	bfc	r2, #7, #1
 801b718:	f883 20e7 	strb.w	r2, [r3, #231]	; 0xe7
        settings.spindle.flags.enable_rpm_controlled = (int_value & 0b10) >> 1;
 801b71c:	f3c1 0140 	ubfx	r1, r1, #1, #1
 801b720:	b2d2      	uxtb	r2, r2
 801b722:	f361 0200 	bfi	r2, r1, #0, #1
 801b726:	f883 20e7 	strb.w	r2, [r3, #231]	; 0xe7
    } else {
        settings.spindle.flags.pwm_disable = On;
        settings.spindle.flags.enable_rpm_controlled = Off;
    }

    return Status_OK;
 801b72a:	2000      	movs	r0, #0
 801b72c:	4770      	bx	lr
        settings.spindle.flags.pwm_disable = On;
 801b72e:	4b08      	ldr	r3, [pc, #32]	; (801b750 <set_pwm_options+0x4c>)
 801b730:	f893 20e7 	ldrb.w	r2, [r3, #231]	; 0xe7
 801b734:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 801b738:	f883 20e7 	strb.w	r2, [r3, #231]	; 0xe7
        settings.spindle.flags.enable_rpm_controlled = Off;
 801b73c:	b2d2      	uxtb	r2, r2
 801b73e:	f36f 0200 	bfc	r2, #0, #1
 801b742:	f883 20e7 	strb.w	r2, [r3, #231]	; 0xe7
    return Status_OK;
 801b746:	2000      	movs	r0, #0
 801b748:	4770      	bx	lr
            return Status_SettingValueOutOfRange;
 801b74a:	2034      	movs	r0, #52	; 0x34
}
 801b74c:	4770      	bx	lr
 801b74e:	bf00      	nop
 801b750:	20003b14 	.word	0x20003b14

0801b754 <set_control_disable_pullup>:
    return Status_OK;
}

static status_code_t set_control_disable_pullup (setting_id_t id, uint_fast16_t int_value)
{
    settings.control_disable_pullup.mask = int_value & hal.signals_cap.mask;
 801b754:	4b04      	ldr	r3, [pc, #16]	; (801b768 <set_control_disable_pullup+0x14>)
 801b756:	f8b3 31a8 	ldrh.w	r3, [r3, #424]	; 0x1a8
 801b75a:	400b      	ands	r3, r1
 801b75c:	4a03      	ldr	r2, [pc, #12]	; (801b76c <set_control_disable_pullup+0x18>)
 801b75e:	f8a2 306e 	strh.w	r3, [r2, #110]	; 0x6e

    return Status_OK;
}
 801b762:	2000      	movs	r0, #0
 801b764:	4770      	bx	lr
 801b766:	bf00      	nop
 801b768:	2000350c 	.word	0x2000350c
 801b76c:	20003b14 	.word	0x20003b14

0801b770 <set_probe_disable_pullup>:

static status_code_t set_probe_disable_pullup (setting_id_t id, uint_fast16_t int_value)
{
    if(!hal.probe.configure)
 801b770:	4b08      	ldr	r3, [pc, #32]	; (801b794 <set_probe_disable_pullup+0x24>)
 801b772:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 801b776:	b15b      	cbz	r3, 801b790 <set_probe_disable_pullup+0x20>
        return Status_SettingDisabled;

    settings.probe.disable_probe_pullup = int_value != 0;
 801b778:	3900      	subs	r1, #0
 801b77a:	bf18      	it	ne
 801b77c:	2101      	movne	r1, #1
 801b77e:	4b06      	ldr	r3, [pc, #24]	; (801b798 <set_probe_disable_pullup+0x28>)
 801b780:	f893 2100 	ldrb.w	r2, [r3, #256]	; 0x100
 801b784:	f361 0241 	bfi	r2, r1, #1, #1
 801b788:	f883 2100 	strb.w	r2, [r3, #256]	; 0x100

    return Status_OK;
 801b78c:	2000      	movs	r0, #0
 801b78e:	4770      	bx	lr
        return Status_SettingDisabled;
 801b790:	2035      	movs	r0, #53	; 0x35
}
 801b792:	4770      	bx	lr
 801b794:	2000350c 	.word	0x2000350c
 801b798:	20003b14 	.word	0x20003b14

0801b79c <set_soft_limits_enable>:

static status_code_t set_soft_limits_enable (setting_id_t id, uint_fast16_t int_value)
{
    if(int_value && !settings.homing.flags.enabled)
 801b79c:	460b      	mov	r3, r1
 801b79e:	b129      	cbz	r1, 801b7ac <set_soft_limits_enable+0x10>
 801b7a0:	4a09      	ldr	r2, [pc, #36]	; (801b7c8 <set_soft_limits_enable+0x2c>)
 801b7a2:	f892 2114 	ldrb.w	r2, [r2, #276]	; 0x114
 801b7a6:	f012 0f01 	tst.w	r2, #1
 801b7aa:	d00b      	beq.n	801b7c4 <set_soft_limits_enable+0x28>
        return Status_SoftLimitError;

    settings.limits.flags.soft_enabled = int_value != 0;
 801b7ac:	3b00      	subs	r3, #0
 801b7ae:	bf18      	it	ne
 801b7b0:	2301      	movne	r3, #1
 801b7b2:	4a05      	ldr	r2, [pc, #20]	; (801b7c8 <set_soft_limits_enable+0x2c>)
 801b7b4:	f892 1124 	ldrb.w	r1, [r2, #292]	; 0x124
 801b7b8:	f363 0141 	bfi	r1, r3, #1, #1
 801b7bc:	f882 1124 	strb.w	r1, [r2, #292]	; 0x124

    return Status_OK;
 801b7c0:	2000      	movs	r0, #0
 801b7c2:	4770      	bx	lr
        return Status_SoftLimitError;
 801b7c4:	200a      	movs	r0, #10
}
 801b7c6:	4770      	bx	lr
 801b7c8:	20003b14 	.word	0x20003b14

0801b7cc <set_estop_unlock>:

static status_code_t set_estop_unlock (setting_id_t id, uint_fast16_t int_value)
{
    if(!hal.signals_cap.e_stop)
 801b7cc:	4b09      	ldr	r3, [pc, #36]	; (801b7f4 <set_estop_unlock+0x28>)
 801b7ce:	f893 31a8 	ldrb.w	r3, [r3, #424]	; 0x1a8
 801b7d2:	f013 0f40 	tst.w	r3, #64	; 0x40
 801b7d6:	d00b      	beq.n	801b7f0 <set_estop_unlock+0x24>
        return Status_SettingDisabled;

    settings.flags.no_unlock_after_estop = int_value != 0;
 801b7d8:	3900      	subs	r1, #0
 801b7da:	bf18      	it	ne
 801b7dc:	2101      	movne	r1, #1
 801b7de:	4b06      	ldr	r3, [pc, #24]	; (801b7f8 <set_estop_unlock+0x2c>)
 801b7e0:	f893 20ff 	ldrb.w	r2, [r3, #255]	; 0xff
 801b7e4:	f361 12c7 	bfi	r2, r1, #7, #1
 801b7e8:	f883 20ff 	strb.w	r2, [r3, #255]	; 0xff

    return Status_OK;
 801b7ec:	2000      	movs	r0, #0
 801b7ee:	4770      	bx	lr
        return Status_SettingDisabled;
 801b7f0:	2035      	movs	r0, #53	; 0x35
}
 801b7f2:	4770      	bx	lr
 801b7f4:	2000350c 	.word	0x2000350c
 801b7f8:	20003b14 	.word	0x20003b14

0801b7fc <set_hard_limits_enable>:

static status_code_t set_hard_limits_enable (setting_id_t id, uint_fast16_t int_value)
{
 801b7fc:	b508      	push	{r3, lr}
    settings.limits.flags.hard_enabled = bit_istrue(int_value, bit(0));
 801b7fe:	f001 0001 	and.w	r0, r1, #1
 801b802:	4b0a      	ldr	r3, [pc, #40]	; (801b82c <set_hard_limits_enable+0x30>)
 801b804:	f893 2124 	ldrb.w	r2, [r3, #292]	; 0x124
 801b808:	f360 0200 	bfi	r2, r0, #0, #1
 801b80c:	f883 2124 	strb.w	r2, [r3, #292]	; 0x124
#if COMPATIBILITY_LEVEL <= 1
    settings.limits.flags.check_at_init = bit_istrue(int_value, bit(1));
 801b810:	f3c1 0140 	ubfx	r1, r1, #1, #1
 801b814:	b2d2      	uxtb	r2, r2
 801b816:	f361 0282 	bfi	r2, r1, #2, #1
 801b81a:	f883 2124 	strb.w	r2, [r3, #292]	; 0x124
#endif
    hal.limits.enable(settings.limits.flags.hard_enabled, false); // Change immediately. NOTE: Nice to have but could be problematic later.
 801b81e:	4b04      	ldr	r3, [pc, #16]	; (801b830 <set_hard_limits_enable+0x34>)
 801b820:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801b822:	2100      	movs	r1, #0
 801b824:	4798      	blx	r3

    return Status_OK;
}
 801b826:	2000      	movs	r0, #0
 801b828:	bd08      	pop	{r3, pc}
 801b82a:	bf00      	nop
 801b82c:	20003b14 	.word	0x20003b14
 801b830:	2000350c 	.word	0x2000350c

0801b834 <set_jog_soft_limited>:

static status_code_t set_jog_soft_limited (setting_id_t id, uint_fast16_t int_value)
{
    if (int_value && !settings.homing.flags.enabled)
 801b834:	460b      	mov	r3, r1
 801b836:	b129      	cbz	r1, 801b844 <set_jog_soft_limited+0x10>
 801b838:	4a09      	ldr	r2, [pc, #36]	; (801b860 <set_jog_soft_limited+0x2c>)
 801b83a:	f892 2114 	ldrb.w	r2, [r2, #276]	; 0x114
 801b83e:	f012 0f01 	tst.w	r2, #1
 801b842:	d00b      	beq.n	801b85c <set_jog_soft_limited+0x28>
        return Status_SoftLimitError;

    settings.limits.flags.jog_soft_limited = int_value != 0;
 801b844:	3b00      	subs	r3, #0
 801b846:	bf18      	it	ne
 801b848:	2301      	movne	r3, #1
 801b84a:	4a05      	ldr	r2, [pc, #20]	; (801b860 <set_jog_soft_limited+0x2c>)
 801b84c:	f892 1124 	ldrb.w	r1, [r2, #292]	; 0x124
 801b850:	f363 01c3 	bfi	r1, r3, #3, #1
 801b854:	f882 1124 	strb.w	r1, [r2, #292]	; 0x124

    return Status_OK;
 801b858:	2000      	movs	r0, #0
 801b85a:	4770      	bx	lr
        return Status_SoftLimitError;
 801b85c:	200a      	movs	r0, #10
}
 801b85e:	4770      	bx	lr
 801b860:	20003b14 	.word	0x20003b14

0801b864 <set_homing_enable>:

static status_code_t set_homing_enable (setting_id_t id, uint_fast16_t int_value)
{
    if (bit_istrue(int_value, bit(0))) {
 801b864:	f011 0f01 	tst.w	r1, #1
 801b868:	d024      	beq.n	801b8b4 <set_homing_enable+0x50>
        settings.homing.flags.manual = DEFAULT_HOMING_ALLOW_MANUAL;
        settings.homing.flags.override_locks = DEFAULT_HOMING_OVERRIDE_LOCKS;
        settings.homing.flags.keep_on_reset = DEFAULT_HOMING_KEEP_STATUS_ON_RESET;
        settings.limits.flags.two_switches = DEFAULT_LIMITS_TWO_SWITCHES_ON_AXES;
#else
        settings.homing.flags.value = int_value & 0x0F;
 801b86a:	f001 020f 	and.w	r2, r1, #15
 801b86e:	4b19      	ldr	r3, [pc, #100]	; (801b8d4 <set_homing_enable+0x70>)
 801b870:	f883 2114 	strb.w	r2, [r3, #276]	; 0x114
        settings.limits.flags.two_switches = bit_istrue(int_value, bit(4));
 801b874:	f3c1 1000 	ubfx	r0, r1, #4, #1
 801b878:	f893 2124 	ldrb.w	r2, [r3, #292]	; 0x124
 801b87c:	f360 1204 	bfi	r2, r0, #4, #1
 801b880:	f883 2124 	strb.w	r2, [r3, #292]	; 0x124
        settings.homing.flags.manual = bit_istrue(int_value, bit(5));
 801b884:	f3c1 1040 	ubfx	r0, r1, #5, #1
 801b888:	f893 2114 	ldrb.w	r2, [r3, #276]	; 0x114
 801b88c:	f360 1204 	bfi	r2, r0, #4, #1
 801b890:	f883 2114 	strb.w	r2, [r3, #276]	; 0x114
        settings.homing.flags.override_locks = bit_istrue(int_value, bit(6));
 801b894:	f3c1 1080 	ubfx	r0, r1, #6, #1
 801b898:	b2d2      	uxtb	r2, r2
 801b89a:	f360 1245 	bfi	r2, r0, #5, #1
 801b89e:	f883 2114 	strb.w	r2, [r3, #276]	; 0x114
        settings.homing.flags.keep_on_reset = bit_istrue(int_value, bit(7));
 801b8a2:	f3c1 11c0 	ubfx	r1, r1, #7, #1
 801b8a6:	b2d2      	uxtb	r2, r2
 801b8a8:	f361 1286 	bfi	r2, r1, #6, #1
 801b8ac:	f883 2114 	strb.w	r2, [r3, #276]	; 0x114
        settings.limits.flags.soft_enabled = Off; // Force disable soft-limits.
        settings.limits.flags.jog_soft_limited = Off;
    }

    return Status_OK;
}
 801b8b0:	2000      	movs	r0, #0
 801b8b2:	4770      	bx	lr
        settings.homing.flags.value = 0;
 801b8b4:	4b07      	ldr	r3, [pc, #28]	; (801b8d4 <set_homing_enable+0x70>)
 801b8b6:	2200      	movs	r2, #0
 801b8b8:	f883 2114 	strb.w	r2, [r3, #276]	; 0x114
        settings.limits.flags.soft_enabled = Off; // Force disable soft-limits.
 801b8bc:	f893 1124 	ldrb.w	r1, [r3, #292]	; 0x124
 801b8c0:	f362 0141 	bfi	r1, r2, #1, #1
 801b8c4:	f883 1124 	strb.w	r1, [r3, #292]	; 0x124
        settings.limits.flags.jog_soft_limited = Off;
 801b8c8:	b2c9      	uxtb	r1, r1
 801b8ca:	f362 01c3 	bfi	r1, r2, #3, #1
 801b8ce:	f883 1124 	strb.w	r1, [r3, #292]	; 0x124
 801b8d2:	e7ed      	b.n	801b8b0 <set_homing_enable+0x4c>
 801b8d4:	20003b14 	.word	0x20003b14

0801b8d8 <set_enable_legacy_rt_commands>:

static status_code_t set_enable_legacy_rt_commands (setting_id_t id, uint_fast16_t int_value)
{
    settings.flags.legacy_rt_commands = int_value != 0;
 801b8d8:	3900      	subs	r1, #0
 801b8da:	bf18      	it	ne
 801b8dc:	2101      	movne	r1, #1
 801b8de:	4b04      	ldr	r3, [pc, #16]	; (801b8f0 <set_enable_legacy_rt_commands+0x18>)
 801b8e0:	f893 20fe 	ldrb.w	r2, [r3, #254]	; 0xfe
 801b8e4:	f361 1286 	bfi	r2, r1, #6, #1
 801b8e8:	f883 20fe 	strb.w	r2, [r3, #254]	; 0xfe

    return Status_OK;
}
 801b8ec:	2000      	movs	r0, #0
 801b8ee:	4770      	bx	lr
 801b8f0:	20003b14 	.word	0x20003b14

0801b8f4 <set_parking_enable>:

#ifndef NO_SAFETY_DOOR_SUPPORT

static status_code_t set_parking_enable (setting_id_t id, uint_fast16_t int_value)
{
    settings.parking.flags.value = bit_istrue(int_value, bit(0)) ? (int_value & 0x07) : 0;
 801b8f4:	f011 0f01 	tst.w	r1, #1
 801b8f8:	d006      	beq.n	801b908 <set_parking_enable+0x14>
 801b8fa:	f001 0107 	and.w	r1, r1, #7
 801b8fe:	4b03      	ldr	r3, [pc, #12]	; (801b90c <set_parking_enable+0x18>)
 801b900:	f883 1128 	strb.w	r1, [r3, #296]	; 0x128

    return Status_OK;
}
 801b904:	2000      	movs	r0, #0
 801b906:	4770      	bx	lr
    settings.parking.flags.value = bit_istrue(int_value, bit(0)) ? (int_value & 0x07) : 0;
 801b908:	2100      	movs	r1, #0
 801b90a:	e7f8      	b.n	801b8fe <set_parking_enable+0xa>
 801b90c:	20003b14 	.word	0x20003b14

0801b910 <set_restore_overrides>:

static status_code_t set_restore_overrides (setting_id_t id, uint_fast16_t int_value)
{
    settings.flags.restore_overrides = int_value != 0;
 801b910:	3900      	subs	r1, #0
 801b912:	bf18      	it	ne
 801b914:	2101      	movne	r1, #1
 801b916:	4b04      	ldr	r3, [pc, #16]	; (801b928 <set_restore_overrides+0x18>)
 801b918:	f893 20fe 	ldrb.w	r2, [r3, #254]	; 0xfe
 801b91c:	f361 0241 	bfi	r2, r1, #1, #1
 801b920:	f883 20fe 	strb.w	r2, [r3, #254]	; 0xfe

    return Status_OK;
}
 801b924:	2000      	movs	r0, #0
 801b926:	4770      	bx	lr
 801b928:	20003b14 	.word	0x20003b14

0801b92c <set_sleep_enable>:

#endif

static status_code_t set_sleep_enable (setting_id_t id, uint_fast16_t int_value)
{
    settings.flags.sleep_enable = int_value != 0;
 801b92c:	3900      	subs	r1, #0
 801b92e:	bf18      	it	ne
 801b930:	2101      	movne	r1, #1
 801b932:	4b04      	ldr	r3, [pc, #16]	; (801b944 <set_sleep_enable+0x18>)
 801b934:	f893 20fe 	ldrb.w	r2, [r3, #254]	; 0xfe
 801b938:	f361 02c3 	bfi	r2, r1, #3, #1
 801b93c:	f883 20fe 	strb.w	r2, [r3, #254]	; 0xfe

    return Status_OK;
}
 801b940:	2000      	movs	r0, #0
 801b942:	4770      	bx	lr
 801b944:	20003b14 	.word	0x20003b14

0801b948 <set_hold_actions>:

static status_code_t set_hold_actions (setting_id_t id, uint_fast16_t int_value)
{
    settings.flags.disable_laser_during_hold = bit_istrue(int_value, bit(0));
 801b948:	4b07      	ldr	r3, [pc, #28]	; (801b968 <set_hold_actions+0x20>)
 801b94a:	f893 20fe 	ldrb.w	r2, [r3, #254]	; 0xfe
 801b94e:	f361 1204 	bfi	r2, r1, #4, #1
 801b952:	f883 20fe 	strb.w	r2, [r3, #254]	; 0xfe
    settings.flags.restore_after_feed_hold = bit_istrue(int_value, bit(1));
 801b956:	f3c1 0140 	ubfx	r1, r1, #1, #1
 801b95a:	b2d2      	uxtb	r2, r2
 801b95c:	f361 12c7 	bfi	r2, r1, #7, #1
 801b960:	f883 20fe 	strb.w	r2, [r3, #254]	; 0xfe

    return Status_OK;
}
 801b964:	2000      	movs	r0, #0
 801b966:	4770      	bx	lr
 801b968:	20003b14 	.word	0x20003b14

0801b96c <set_g92_disable_persistence>:

#if COMPATIBILITY_LEVEL <= 1
static status_code_t set_g92_disable_persistence (setting_id_t id, uint_fast16_t int_value)
{
    settings.flags.g92_is_volatile = int_value != 0;
 801b96c:	3900      	subs	r1, #0
 801b96e:	bf18      	it	ne
 801b970:	2101      	movne	r1, #1
 801b972:	4b04      	ldr	r3, [pc, #16]	; (801b984 <set_g92_disable_persistence+0x18>)
 801b974:	f893 20ff 	ldrb.w	r2, [r3, #255]	; 0xff
 801b978:	f361 0241 	bfi	r2, r1, #1, #1
 801b97c:	f883 20ff 	strb.w	r2, [r3, #255]	; 0xff

    return Status_OK;
}
 801b980:	2000      	movs	r0, #0
 801b982:	4770      	bx	lr
 801b984:	20003b14 	.word	0x20003b14

0801b988 <set_force_initialization_alarm>:
#endif

static status_code_t set_force_initialization_alarm (setting_id_t id, uint_fast16_t int_value)
{
    settings.flags.force_initialization_alarm = int_value != 0;
 801b988:	3900      	subs	r1, #0
 801b98a:	bf18      	it	ne
 801b98c:	2101      	movne	r1, #1
 801b98e:	4b04      	ldr	r3, [pc, #16]	; (801b9a0 <set_force_initialization_alarm+0x18>)
 801b990:	f893 20fe 	ldrb.w	r2, [r3, #254]	; 0xfe
 801b994:	f361 1245 	bfi	r2, r1, #5, #1
 801b998:	f883 20fe 	strb.w	r2, [r3, #254]	; 0xfe

    return Status_OK;
}
 801b99c:	2000      	movs	r0, #0
 801b99e:	4770      	bx	lr
 801b9a0:	20003b14 	.word	0x20003b14

0801b9a4 <set_probe_allow_feed_override>:

static status_code_t set_probe_allow_feed_override (setting_id_t id, uint_fast16_t int_value)
{
    settings.probe.allow_feed_override = int_value != 0;
 801b9a4:	3900      	subs	r1, #0
 801b9a6:	bf18      	it	ne
 801b9a8:	2101      	movne	r1, #1
 801b9aa:	4b04      	ldr	r3, [pc, #16]	; (801b9bc <set_probe_allow_feed_override+0x18>)
 801b9ac:	f893 2100 	ldrb.w	r2, [r3, #256]	; 0x100
 801b9b0:	f361 1204 	bfi	r2, r1, #4, #1
 801b9b4:	f883 2100 	strb.w	r2, [r3, #256]	; 0x100

    return Status_OK;
}
 801b9b8:	2000      	movs	r0, #0
 801b9ba:	4770      	bx	lr
 801b9bc:	20003b14 	.word	0x20003b14

0801b9c0 <set_tool_change_probing_distance>:
    return Status_OK;
}

static status_code_t set_tool_change_probing_distance (setting_id_t id, float value)
{
    if(hal.driver_cap.atc)
 801b9c0:	4b05      	ldr	r3, [pc, #20]	; (801b9d8 <set_tool_change_probing_distance+0x18>)
 801b9c2:	f893 01a6 	ldrb.w	r0, [r3, #422]	; 0x1a6
 801b9c6:	f010 0001 	ands.w	r0, r0, #1
 801b9ca:	d103      	bne.n	801b9d4 <set_tool_change_probing_distance+0x14>
        return Status_InvalidStatement;

    settings.tool_change.probing_distance = value;
 801b9cc:	4b03      	ldr	r3, [pc, #12]	; (801b9dc <set_tool_change_probing_distance+0x1c>)
 801b9ce:	ed83 0a0a 	vstr	s0, [r3, #40]	; 0x28

    return Status_OK;
 801b9d2:	4770      	bx	lr
        return Status_InvalidStatement;
 801b9d4:	2003      	movs	r0, #3
}
 801b9d6:	4770      	bx	lr
 801b9d8:	2000350c 	.word	0x2000350c
 801b9dc:	20003b14 	.word	0x20003b14

0801b9e0 <set_tool_restore_pos>:

static status_code_t set_tool_restore_pos (setting_id_t id, uint_fast16_t int_value)
{
    if(hal.driver_cap.atc)
 801b9e0:	4b09      	ldr	r3, [pc, #36]	; (801ba08 <set_tool_restore_pos+0x28>)
 801b9e2:	f893 01a6 	ldrb.w	r0, [r3, #422]	; 0x1a6
 801b9e6:	f010 0001 	ands.w	r0, r0, #1
 801b9ea:	d10a      	bne.n	801ba02 <set_tool_restore_pos+0x22>
        return Status_InvalidStatement;

    settings.flags.no_restore_position_after_M6 = int_value == 0;
 801b9ec:	fab1 f181 	clz	r1, r1
 801b9f0:	0949      	lsrs	r1, r1, #5
 801b9f2:	4b06      	ldr	r3, [pc, #24]	; (801ba0c <set_tool_restore_pos+0x2c>)
 801b9f4:	f893 20ff 	ldrb.w	r2, [r3, #255]	; 0xff
 801b9f8:	f361 1286 	bfi	r2, r1, #6, #1
 801b9fc:	f883 20ff 	strb.w	r2, [r3, #255]	; 0xff

    return Status_OK;
 801ba00:	4770      	bx	lr
        return Status_InvalidStatement;
 801ba02:	2003      	movs	r0, #3
}
 801ba04:	4770      	bx	lr
 801ba06:	bf00      	nop
 801ba08:	2000350c 	.word	0x2000350c
 801ba0c:	20003b14 	.word	0x20003b14

0801ba10 <get_int>:

static uint32_t get_int (setting_id_t id)
{
    uint32_t value = 0;

    switch(id) {
 801ba10:	2841      	cmp	r0, #65	; 0x41
 801ba12:	d844      	bhi.n	801ba9e <get_int+0x8e>
 801ba14:	2806      	cmp	r0, #6
 801ba16:	f0c0 8127 	bcc.w	801bc68 <get_int+0x258>
 801ba1a:	1f83      	subs	r3, r0, #6
 801ba1c:	2b3b      	cmp	r3, #59	; 0x3b
 801ba1e:	f200 8125 	bhi.w	801bc6c <get_int+0x25c>
 801ba22:	e8df f013 	tbh	[pc, r3, lsl #1]
 801ba26:	007e      	.short	0x007e
 801ba28:	00840123 	.word	0x00840123
 801ba2c:	0088006c 	.word	0x0088006c
 801ba30:	01230123 	.word	0x01230123
 801ba34:	0092008c 	.word	0x0092008c
 801ba38:	009a0123 	.word	0x009a0123
 801ba3c:	0123009e 	.word	0x0123009e
 801ba40:	00ac00a6 	.word	0x00ac00a6
 801ba44:	00c400b2 	.word	0x00c400b2
 801ba48:	01230123 	.word	0x01230123
 801ba4c:	01230123 	.word	0x01230123
 801ba50:	01230123 	.word	0x01230123
 801ba54:	01230123 	.word	0x01230123
 801ba58:	007b0123 	.word	0x007b0123
 801ba5c:	01230123 	.word	0x01230123
 801ba60:	01230123 	.word	0x01230123
 801ba64:	012300d9 	.word	0x012300d9
 801ba68:	00be00dd 	.word	0x00be00dd
 801ba6c:	012300e3 	.word	0x012300e3
 801ba70:	00e70123 	.word	0x00e70123
 801ba74:	00e700e7 	.word	0x00e700e7
 801ba78:	00e700e7 	.word	0x00e700e7
 801ba7c:	012300e7 	.word	0x012300e7
 801ba80:	01230123 	.word	0x01230123
 801ba84:	01230123 	.word	0x01230123
 801ba88:	01230123 	.word	0x01230123
 801ba8c:	01230123 	.word	0x01230123
 801ba90:	00ed0123 	.word	0x00ed0123
 801ba94:	00f30123 	.word	0x00f30123
 801ba98:	010300f9 	.word	0x010300f9
 801ba9c:	0109      	.short	0x0109
 801ba9e:	f240 138b 	movw	r3, #395	; 0x18b
 801baa2:	4298      	cmp	r0, r3
 801baa4:	f000 80d7 	beq.w	801bc56 <get_int+0x246>
 801baa8:	f5b0 7fc6 	cmp.w	r0, #396	; 0x18c
 801baac:	d30e      	bcc.n	801bacc <get_int+0xbc>
 801baae:	f240 13e1 	movw	r3, #481	; 0x1e1
 801bab2:	4298      	cmp	r0, r3
 801bab4:	f000 80d5 	beq.w	801bc62 <get_int+0x252>
 801bab8:	f5b0 7ff2 	cmp.w	r0, #484	; 0x1e4
 801babc:	d11d      	bne.n	801bafa <get_int+0xea>
            value = (settings.steppers.is_rotational.mask & AXES_BITMASK) >> 3;
            break;
#endif

        case Setting_UnlockAfterEStop:
            value = settings.flags.no_unlock_after_estop ? 0 : 1;
 801babe:	4b6e      	ldr	r3, [pc, #440]	; (801bc78 <get_int+0x268>)
 801bac0:	f893 00ff 	ldrb.w	r0, [r3, #255]	; 0xff
 801bac4:	43c0      	mvns	r0, r0
 801bac6:	f3c0 10c0 	ubfx	r0, r0, #7, #1
            break;
 801baca:	4770      	bx	lr
    switch(id) {
 801bacc:	f5b0 7fad 	cmp.w	r0, #346	; 0x15a
 801bad0:	f000 80b8 	beq.w	801bc44 <get_int+0x234>
 801bad4:	f5b0 7fc0 	cmp.w	r0, #384	; 0x180
 801bad8:	d105      	bne.n	801bae6 <get_int+0xd6>
            value = settings.flags.g92_is_volatile;
 801bada:	4b67      	ldr	r3, [pc, #412]	; (801bc78 <get_int+0x268>)
 801badc:	f893 00ff 	ldrb.w	r0, [r3, #255]	; 0xff
 801bae0:	f3c0 0040 	ubfx	r0, r0, #1, #1
            break;
 801bae4:	4770      	bx	lr
    switch(id) {
 801bae6:	f240 1355 	movw	r3, #341	; 0x155
 801baea:	4298      	cmp	r0, r3
 801baec:	d103      	bne.n	801baf6 <get_int+0xe6>
            value = settings.tool_change.mode;
 801baee:	4b62      	ldr	r3, [pc, #392]	; (801bc78 <get_int+0x268>)
 801baf0:	f893 002c 	ldrb.w	r0, [r3, #44]	; 0x2c
            break;
 801baf4:	4770      	bx	lr
    switch(id) {
 801baf6:	2000      	movs	r0, #0
 801baf8:	4770      	bx	lr
 801bafa:	2000      	movs	r0, #0
 801bafc:	4770      	bx	lr
            value = settings.spindle.flags.pwm_disable ? 0 : (settings.spindle.flags.enable_rpm_controlled ? 0b11 : 0b01);
 801bafe:	4b5e      	ldr	r3, [pc, #376]	; (801bc78 <get_int+0x268>)
 801bb00:	f893 20e7 	ldrb.w	r2, [r3, #231]	; 0xe7
 801bb04:	f993 30e7 	ldrsb.w	r3, [r3, #231]	; 0xe7
 801bb08:	2b00      	cmp	r3, #0
 801bb0a:	f2c0 80b1 	blt.w	801bc70 <get_int+0x260>
 801bb0e:	f012 0f01 	tst.w	r2, #1
 801bb12:	d101      	bne.n	801bb18 <get_int+0x108>
 801bb14:	2001      	movs	r0, #1
 801bb16:	4770      	bx	lr
 801bb18:	2003      	movs	r0, #3
 801bb1a:	4770      	bx	lr
            value = settings.mode;
 801bb1c:	4b56      	ldr	r3, [pc, #344]	; (801bc78 <get_int+0x268>)
 801bb1e:	7e18      	ldrb	r0, [r3, #24]
            break;
 801bb20:	4770      	bx	lr
            value = settings.probe.invert_probe_pin;
 801bb22:	4b55      	ldr	r3, [pc, #340]	; (801bc78 <get_int+0x268>)
 801bb24:	f893 0100 	ldrb.w	r0, [r3, #256]	; 0x100
 801bb28:	f000 0001 	and.w	r0, r0, #1
            break;
 801bb2c:	4770      	bx	lr
            value = settings.steppers.ganged_dir_invert.mask;
 801bb2e:	4b52      	ldr	r3, [pc, #328]	; (801bc78 <get_int+0x268>)
 801bb30:	f893 00ea 	ldrb.w	r0, [r3, #234]	; 0xea
            break;
 801bb34:	4770      	bx	lr
            value = settings.status_report.mask;
 801bb36:	4b50      	ldr	r3, [pc, #320]	; (801bc78 <get_int+0x268>)
 801bb38:	f8b3 00fc 	ldrh.w	r0, [r3, #252]	; 0xfc
            break;
 801bb3c:	4770      	bx	lr
            value = settings.flags.report_inches;
 801bb3e:	4b4e      	ldr	r3, [pc, #312]	; (801bc78 <get_int+0x268>)
 801bb40:	f893 00fe 	ldrb.w	r0, [r3, #254]	; 0xfe
 801bb44:	f000 0001 	and.w	r0, r0, #1
            break;
 801bb48:	4770      	bx	lr
            value = settings.control_invert.mask & hal.signals_cap.mask;
 801bb4a:	4b4b      	ldr	r3, [pc, #300]	; (801bc78 <get_int+0x268>)
 801bb4c:	f8b3 006c 	ldrh.w	r0, [r3, #108]	; 0x6c
 801bb50:	4b4a      	ldr	r3, [pc, #296]	; (801bc7c <get_int+0x26c>)
 801bb52:	f8b3 31a8 	ldrh.w	r3, [r3, #424]	; 0x1a8
 801bb56:	4018      	ands	r0, r3
            break;
 801bb58:	4770      	bx	lr
            value = settings.spindle.invert.mask;
 801bb5a:	4b47      	ldr	r3, [pc, #284]	; (801bc78 <get_int+0x268>)
 801bb5c:	f893 00e6 	ldrb.w	r0, [r3, #230]	; 0xe6
            break;
 801bb60:	4770      	bx	lr
            value = settings.control_disable_pullup.mask & hal.signals_cap.mask;
 801bb62:	4b45      	ldr	r3, [pc, #276]	; (801bc78 <get_int+0x268>)
 801bb64:	f8b3 006e 	ldrh.w	r0, [r3, #110]	; 0x6e
 801bb68:	4b44      	ldr	r3, [pc, #272]	; (801bc7c <get_int+0x26c>)
 801bb6a:	f8b3 31a8 	ldrh.w	r3, [r3, #424]	; 0x1a8
 801bb6e:	4018      	ands	r0, r3
            break;
 801bb70:	4770      	bx	lr
            value = settings.probe.disable_probe_pullup;
 801bb72:	4b41      	ldr	r3, [pc, #260]	; (801bc78 <get_int+0x268>)
 801bb74:	f893 0100 	ldrb.w	r0, [r3, #256]	; 0x100
 801bb78:	f3c0 0040 	ubfx	r0, r0, #1, #1
            break;
 801bb7c:	4770      	bx	lr
            value = settings.limits.flags.soft_enabled;
 801bb7e:	4b3e      	ldr	r3, [pc, #248]	; (801bc78 <get_int+0x268>)
 801bb80:	f893 0124 	ldrb.w	r0, [r3, #292]	; 0x124
 801bb84:	f3c0 0040 	ubfx	r0, r0, #1, #1
            break;
 801bb88:	4770      	bx	lr
            value = ((settings.limits.flags.hard_enabled & bit(0)) ? bit(0) | (settings.limits.flags.check_at_init ? bit(1) : 0) : 0);
 801bb8a:	4b3b      	ldr	r3, [pc, #236]	; (801bc78 <get_int+0x268>)
 801bb8c:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 801bb90:	f013 0f01 	tst.w	r3, #1
 801bb94:	d06e      	beq.n	801bc74 <get_int+0x264>
 801bb96:	0858      	lsrs	r0, r3, #1
 801bb98:	f000 0002 	and.w	r0, r0, #2
 801bb9c:	f040 0001 	orr.w	r0, r0, #1
 801bba0:	4770      	bx	lr
            value = settings.limits.flags.jog_soft_limited;
 801bba2:	4b35      	ldr	r3, [pc, #212]	; (801bc78 <get_int+0x268>)
 801bba4:	f893 0124 	ldrb.w	r0, [r3, #292]	; 0x124
 801bba8:	f3c0 00c0 	ubfx	r0, r0, #3, #1
            break;
 801bbac:	4770      	bx	lr
            value = (settings.homing.flags.value & 0x0F) |
 801bbae:	4a32      	ldr	r2, [pc, #200]	; (801bc78 <get_int+0x268>)
 801bbb0:	f892 3114 	ldrb.w	r3, [r2, #276]	; 0x114
                     (settings.limits.flags.two_switches ? bit(4) : 0) |
 801bbb4:	f892 2124 	ldrb.w	r2, [r2, #292]	; 0x124
            value = (settings.homing.flags.value & 0x0F) |
 801bbb8:	f003 000f 	and.w	r0, r3, #15
 801bbbc:	f002 0210 	and.w	r2, r2, #16
 801bbc0:	4310      	orrs	r0, r2
                      (settings.homing.flags.manual ? bit(5) : 0) |
 801bbc2:	005b      	lsls	r3, r3, #1
 801bbc4:	f003 0220 	and.w	r2, r3, #32
                     (settings.limits.flags.two_switches ? bit(4) : 0) |
 801bbc8:	4310      	orrs	r0, r2
                       (settings.homing.flags.override_locks ? bit(6) : 0) |
 801bbca:	f003 0240 	and.w	r2, r3, #64	; 0x40
                      (settings.homing.flags.manual ? bit(5) : 0) |
 801bbce:	4310      	orrs	r0, r2
                        (settings.homing.flags.keep_on_reset ? bit(7) : 0);
 801bbd0:	f003 0380 	and.w	r3, r3, #128	; 0x80
            value = (settings.homing.flags.value & 0x0F) |
 801bbd4:	4318      	orrs	r0, r3
            break;
 801bbd6:	4770      	bx	lr
            value = settings.steppers.deenergize.mask;
 801bbd8:	4b27      	ldr	r3, [pc, #156]	; (801bc78 <get_int+0x268>)
 801bbda:	f893 00ec 	ldrb.w	r0, [r3, #236]	; 0xec
            break;
 801bbde:	4770      	bx	lr
            value = settings.flags.legacy_rt_commands;
 801bbe0:	4b25      	ldr	r3, [pc, #148]	; (801bc78 <get_int+0x268>)
 801bbe2:	f893 00fe 	ldrb.w	r0, [r3, #254]	; 0xfe
 801bbe6:	f3c0 1080 	ubfx	r0, r0, #6, #1
            break;
 801bbea:	4770      	bx	lr
            value = settings.parking.flags.value;
 801bbec:	4b22      	ldr	r3, [pc, #136]	; (801bc78 <get_int+0x268>)
 801bbee:	f893 0128 	ldrb.w	r0, [r3, #296]	; 0x128
            break;
 801bbf2:	4770      	bx	lr
            value = settings.homing.cycle[id - Setting_HomingCycle_1].mask;
 801bbf4:	382c      	subs	r0, #44	; 0x2c
 801bbf6:	4b20      	ldr	r3, [pc, #128]	; (801bc78 <get_int+0x268>)
 801bbf8:	4403      	add	r3, r0
 801bbfa:	f893 0115 	ldrb.w	r0, [r3, #277]	; 0x115
            break;
 801bbfe:	4770      	bx	lr
            value = settings.flags.restore_overrides;
 801bc00:	4b1d      	ldr	r3, [pc, #116]	; (801bc78 <get_int+0x268>)
 801bc02:	f893 00fe 	ldrb.w	r0, [r3, #254]	; 0xfe
 801bc06:	f3c0 0040 	ubfx	r0, r0, #1, #1
            break;
 801bc0a:	4770      	bx	lr
            value = settings.flags.sleep_enable;
 801bc0c:	4b1a      	ldr	r3, [pc, #104]	; (801bc78 <get_int+0x268>)
 801bc0e:	f893 00fe 	ldrb.w	r0, [r3, #254]	; 0xfe
 801bc12:	f3c0 00c0 	ubfx	r0, r0, #3, #1
            break;
 801bc16:	4770      	bx	lr
            value = (settings.flags.disable_laser_during_hold ? bit(0) : 0) | (settings.flags.restore_after_feed_hold ? bit(1) : 0);
 801bc18:	4b17      	ldr	r3, [pc, #92]	; (801bc78 <get_int+0x268>)
 801bc1a:	f893 00fe 	ldrb.w	r0, [r3, #254]	; 0xfe
 801bc1e:	0983      	lsrs	r3, r0, #6
 801bc20:	f3c0 1000 	ubfx	r0, r0, #4, #1
 801bc24:	f003 0302 	and.w	r3, r3, #2
 801bc28:	4318      	orrs	r0, r3
            break;
 801bc2a:	4770      	bx	lr
            value = settings.flags.force_initialization_alarm;
 801bc2c:	4b12      	ldr	r3, [pc, #72]	; (801bc78 <get_int+0x268>)
 801bc2e:	f893 00fe 	ldrb.w	r0, [r3, #254]	; 0xfe
 801bc32:	f3c0 1040 	ubfx	r0, r0, #5, #1
            break;
 801bc36:	4770      	bx	lr
            value = settings.probe.allow_feed_override;
 801bc38:	4b0f      	ldr	r3, [pc, #60]	; (801bc78 <get_int+0x268>)
 801bc3a:	f893 0100 	ldrb.w	r0, [r3, #256]	; 0x100
 801bc3e:	f3c0 1000 	ubfx	r0, r0, #4, #1
            break;
 801bc42:	4770      	bx	lr
            value = settings.flags.no_restore_position_after_M6 ? 0 : 1;
 801bc44:	4b0c      	ldr	r3, [pc, #48]	; (801bc78 <get_int+0x268>)
 801bc46:	f893 00ff 	ldrb.w	r0, [r3, #255]	; 0xff
 801bc4a:	0980      	lsrs	r0, r0, #6
 801bc4c:	f080 0001 	eor.w	r0, r0, #1
 801bc50:	f000 0001 	and.w	r0, r0, #1
            break;
 801bc54:	4770      	bx	lr
            value = settings.spindle.flags.type;
 801bc56:	4b08      	ldr	r3, [pc, #32]	; (801bc78 <get_int+0x268>)
 801bc58:	f893 00e7 	ldrb.w	r0, [r3, #231]	; 0xe7
 801bc5c:	f3c0 0084 	ubfx	r0, r0, #2, #5
            break;
 801bc60:	4770      	bx	lr
            value = settings.report_interval;
 801bc62:	4b05      	ldr	r3, [pc, #20]	; (801bc78 <get_int+0x268>)
 801bc64:	8a98      	ldrh	r0, [r3, #20]
            break;
 801bc66:	4770      	bx	lr
    switch(id) {
 801bc68:	2000      	movs	r0, #0
 801bc6a:	4770      	bx	lr
 801bc6c:	2000      	movs	r0, #0
 801bc6e:	4770      	bx	lr
            value = settings.spindle.flags.pwm_disable ? 0 : (settings.spindle.flags.enable_rpm_controlled ? 0b11 : 0b01);
 801bc70:	2000      	movs	r0, #0
 801bc72:	4770      	bx	lr
            value = ((settings.limits.flags.hard_enabled & bit(0)) ? bit(0) | (settings.limits.flags.check_at_init ? bit(1) : 0) : 0);
 801bc74:	2000      	movs	r0, #0
        default:
            break;
    }

    return value;
}
 801bc76:	4770      	bx	lr
 801bc78:	20003b14 	.word	0x20003b14
 801bc7c:	2000350c 	.word	0x2000350c

0801bc80 <settings_write_global>:
}


// Write global settings to persistent storage
void settings_write_global (void)
{
 801bc80:	b510      	push	{r4, lr}
    if(override_backup.valid)
 801bc82:	4b0d      	ldr	r3, [pc, #52]	; (801bcb8 <settings_write_global+0x38>)
 801bc84:	781b      	ldrb	r3, [r3, #0]
 801bc86:	b9a3      	cbnz	r3, 801bcb2 <settings_write_global+0x32>
        restore_override_backup();

    settings.flags.compatibility_level = COMPATIBILITY_LEVEL;
 801bc88:	4b0c      	ldr	r3, [pc, #48]	; (801bcbc <settings_write_global+0x3c>)
 801bc8a:	f893 20ff 	ldrb.w	r2, [r3, #255]	; 0xff
 801bc8e:	f36f 0285 	bfc	r2, #2, #4
 801bc92:	f883 20ff 	strb.w	r2, [r3, #255]	; 0xff

    if(hal.nvs.type != NVS_None)
 801bc96:	4b0a      	ldr	r3, [pc, #40]	; (801bcc0 <settings_write_global+0x40>)
 801bc98:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 801bc9c:	b143      	cbz	r3, 801bcb0 <settings_write_global+0x30>
        hal.nvs.memcpy_to_nvs(NVS_ADDR_GLOBAL, (uint8_t *)&settings, sizeof(settings_t), true);
 801bc9e:	4b08      	ldr	r3, [pc, #32]	; (801bcc0 <settings_write_global+0x40>)
 801bca0:	f8d3 4160 	ldr.w	r4, [r3, #352]	; 0x160
 801bca4:	2301      	movs	r3, #1
 801bca6:	f44f 72b6 	mov.w	r2, #364	; 0x16c
 801bcaa:	4904      	ldr	r1, [pc, #16]	; (801bcbc <settings_write_global+0x3c>)
 801bcac:	4618      	mov	r0, r3
 801bcae:	47a0      	blx	r4
}
 801bcb0:	bd10      	pop	{r4, pc}
        restore_override_backup();
 801bcb2:	f7ff fc9d 	bl	801b5f0 <restore_override_backup>
 801bcb6:	e7e7      	b.n	801bc88 <settings_write_global+0x8>
 801bcb8:	20003b04 	.word	0x20003b04
 801bcbc:	20003b14 	.word	0x20003b14
 801bcc0:	2000350c 	.word	0x2000350c

0801bcc4 <remove_element>:
    return setting->datatype == Format_Integer || setting->datatype == Format_Int8 || setting->datatype == Format_Int16;
}

static char *remove_element (char *s, uint_fast8_t entry)
{
    while(entry && *s) {
 801bcc4:	e000      	b.n	801bcc8 <remove_element+0x4>
        if(*s == ',')
            entry--;
        s++;
 801bcc6:	3001      	adds	r0, #1
    while(entry && *s) {
 801bcc8:	b129      	cbz	r1, 801bcd6 <remove_element+0x12>
 801bcca:	7803      	ldrb	r3, [r0, #0]
 801bccc:	b11b      	cbz	r3, 801bcd6 <remove_element+0x12>
        if(*s == ',')
 801bcce:	2b2c      	cmp	r3, #44	; 0x2c
 801bcd0:	d1f9      	bne.n	801bcc6 <remove_element+0x2>
            entry--;
 801bcd2:	3901      	subs	r1, #1
 801bcd4:	e7f7      	b.n	801bcc6 <remove_element+0x2>
    }

    if(entry == 0) {
 801bcd6:	b9b9      	cbnz	r1, 801bd08 <remove_element+0x44>
        *s++ = 'N';
 801bcd8:	234e      	movs	r3, #78	; 0x4e
 801bcda:	7003      	strb	r3, [r0, #0]
        *s++ = '/';
 801bcdc:	232f      	movs	r3, #47	; 0x2f
 801bcde:	7043      	strb	r3, [r0, #1]
        *s++ = 'A';
 801bce0:	1cc3      	adds	r3, r0, #3
 801bce2:	2241      	movs	r2, #65	; 0x41
 801bce4:	7082      	strb	r2, [r0, #2]
        char *s2 = s;
 801bce6:	461a      	mov	r2, r3
        while(*s2 && *s2 != ',')
 801bce8:	e000      	b.n	801bcec <remove_element+0x28>
            s2++;
 801bcea:	3201      	adds	r2, #1
        while(*s2 && *s2 != ',')
 801bcec:	7811      	ldrb	r1, [r2, #0]
 801bcee:	b129      	cbz	r1, 801bcfc <remove_element+0x38>
 801bcf0:	292c      	cmp	r1, #44	; 0x2c
 801bcf2:	d1fa      	bne.n	801bcea <remove_element+0x26>
 801bcf4:	e002      	b.n	801bcfc <remove_element+0x38>
        while(*s2)
            *s++ = *s2++;
 801bcf6:	3201      	adds	r2, #1
 801bcf8:	f803 1b01 	strb.w	r1, [r3], #1
        while(*s2)
 801bcfc:	7811      	ldrb	r1, [r2, #0]
 801bcfe:	2900      	cmp	r1, #0
 801bd00:	d1f9      	bne.n	801bcf6 <remove_element+0x32>
        *s = '\0';
 801bd02:	2200      	movs	r2, #0
 801bd04:	701a      	strb	r2, [r3, #0]
 801bd06:	4618      	mov	r0, r3
    }

    return s;
}
 801bd08:	4770      	bx	lr
	...

0801bd0c <set_spindle_type>:
{
 801bd0c:	b510      	push	{r4, lr}
 801bd0e:	460c      	mov	r4, r1
    if(spindle_get_count() < 2)
 801bd10:	f001 fe7a 	bl	801da08 <spindle_get_count>
 801bd14:	2801      	cmp	r0, #1
 801bd16:	d910      	bls.n	801bd3a <set_spindle_type+0x2e>
    else if(int_value >= spindle_get_count())
 801bd18:	f001 fe76 	bl	801da08 <spindle_get_count>
 801bd1c:	42a0      	cmp	r0, r4
 801bd1e:	d90e      	bls.n	801bd3e <set_spindle_type+0x32>
    settings.spindle.flags.type = int_value;
 801bd20:	f004 001f 	and.w	r0, r4, #31
 801bd24:	4b07      	ldr	r3, [pc, #28]	; (801bd44 <set_spindle_type+0x38>)
 801bd26:	f893 20e7 	ldrb.w	r2, [r3, #231]	; 0xe7
 801bd2a:	f360 0286 	bfi	r2, r0, #2, #5
 801bd2e:	f883 20e7 	strb.w	r2, [r3, #231]	; 0xe7
    spindle_select(settings.spindle.flags.type);
 801bd32:	f001 fe49 	bl	801d9c8 <spindle_select>
    return Status_OK;
 801bd36:	2000      	movs	r0, #0
}
 801bd38:	bd10      	pop	{r4, pc}
        return Status_SettingDisabled;
 801bd3a:	2035      	movs	r0, #53	; 0x35
 801bd3c:	e7fc      	b.n	801bd38 <set_spindle_type+0x2c>
        return Status_SettingValueOutOfRange;
 801bd3e:	2034      	movs	r0, #52	; 0x34
 801bd40:	e7fa      	b.n	801bd38 <set_spindle_type+0x2c>
 801bd42:	bf00      	nop
 801bd44:	20003b14 	.word	0x20003b14

0801bd48 <set_tool_change_mode>:
{
 801bd48:	b510      	push	{r4, lr}
    if(!hal.driver_cap.atc && hal.stream.suspend_read && int_value <= ToolChange_Ignore) {
 801bd4a:	4b0c      	ldr	r3, [pc, #48]	; (801bd7c <set_tool_change_mode+0x34>)
 801bd4c:	f893 01a6 	ldrb.w	r0, [r3, #422]	; 0x1a6
 801bd50:	f010 0401 	ands.w	r4, r0, #1
 801bd54:	d10b      	bne.n	801bd6e <set_tool_change_mode+0x26>
 801bd56:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 801bd5a:	b153      	cbz	r3, 801bd72 <set_tool_change_mode+0x2a>
 801bd5c:	2904      	cmp	r1, #4
 801bd5e:	d80a      	bhi.n	801bd76 <set_tool_change_mode+0x2e>
        settings.tool_change.mode = (toolchange_mode_t)int_value;
 801bd60:	4b07      	ldr	r3, [pc, #28]	; (801bd80 <set_tool_change_mode+0x38>)
 801bd62:	f883 102c 	strb.w	r1, [r3, #44]	; 0x2c
        tc_init();
 801bd66:	f005 fea7 	bl	8021ab8 <tc_init>
}
 801bd6a:	4620      	mov	r0, r4
 801bd6c:	bd10      	pop	{r4, pc}
        return Status_InvalidStatement;
 801bd6e:	2403      	movs	r4, #3
 801bd70:	e7fb      	b.n	801bd6a <set_tool_change_mode+0x22>
 801bd72:	2403      	movs	r4, #3
 801bd74:	e7f9      	b.n	801bd6a <set_tool_change_mode+0x22>
 801bd76:	2403      	movs	r4, #3
 801bd78:	e7f7      	b.n	801bd6a <set_tool_change_mode+0x22>
 801bd7a:	bf00      	nop
 801bd7c:	2000350c 	.word	0x2000350c
 801bd80:	20003b14 	.word	0x20003b14

0801bd84 <set_homing_cycle>:
{
 801bd84:	b508      	push	{r3, lr}
    settings.homing.cycle[id - Setting_HomingCycle_1].mask = int_value;
 801bd86:	382c      	subs	r0, #44	; 0x2c
 801bd88:	4b03      	ldr	r3, [pc, #12]	; (801bd98 <set_homing_cycle+0x14>)
 801bd8a:	4403      	add	r3, r0
 801bd8c:	f883 1115 	strb.w	r1, [r3, #277]	; 0x115
    limits_set_homing_axes();
 801bd90:	f7f7 fec0 	bl	8013b14 <limits_set_homing_axes>
}
 801bd94:	2000      	movs	r0, #0
 801bd96:	bd08      	pop	{r3, pc}
 801bd98:	20003b14 	.word	0x20003b14

0801bd9c <set_mode>:
{
 801bd9c:	b510      	push	{r4, lr}
    switch((machine_mode_t)int_value) {
 801bd9e:	b2cc      	uxtb	r4, r1
 801bda0:	2c01      	cmp	r4, #1
 801bda2:	d00e      	beq.n	801bdc2 <set_mode+0x26>
 801bda4:	2c02      	cmp	r4, #2
 801bda6:	d005      	beq.n	801bdb4 <set_mode+0x18>
 801bda8:	b10c      	cbz	r4, 801bdae <set_mode+0x12>
 801bdaa:	2003      	movs	r0, #3
 801bdac:	e008      	b.n	801bdc0 <set_mode+0x24>
           gc_state.modal.diameter_mode = false;
 801bdae:	4b0b      	ldr	r3, [pc, #44]	; (801bddc <set_mode+0x40>)
 801bdb0:	2200      	movs	r2, #0
 801bdb2:	715a      	strb	r2, [r3, #5]
    machine_mode_changed = true;
 801bdb4:	4b0a      	ldr	r3, [pc, #40]	; (801bde0 <set_mode+0x44>)
 801bdb6:	2201      	movs	r2, #1
 801bdb8:	701a      	strb	r2, [r3, #0]
    settings.mode = (machine_mode_t)int_value;
 801bdba:	4b0a      	ldr	r3, [pc, #40]	; (801bde4 <set_mode+0x48>)
 801bdbc:	761c      	strb	r4, [r3, #24]
    return Status_OK;
 801bdbe:	2000      	movs	r0, #0
}
 801bdc0:	bd10      	pop	{r4, pc}
            if(!spindle_get_caps(false).laser)
 801bdc2:	2000      	movs	r0, #0
 801bdc4:	f001 fd0c 	bl	801d7e0 <spindle_get_caps>
 801bdc8:	f010 0f08 	tst.w	r0, #8
 801bdcc:	d003      	beq.n	801bdd6 <set_mode+0x3a>
            gc_state.modal.diameter_mode = false;
 801bdce:	4b03      	ldr	r3, [pc, #12]	; (801bddc <set_mode+0x40>)
 801bdd0:	2200      	movs	r2, #0
 801bdd2:	715a      	strb	r2, [r3, #5]
            break;
 801bdd4:	e7ee      	b.n	801bdb4 <set_mode+0x18>
                return Status_SettingDisabledLaser;
 801bdd6:	2011      	movs	r0, #17
 801bdd8:	e7f2      	b.n	801bdc0 <set_mode+0x24>
 801bdda:	bf00      	nop
 801bddc:	20003344 	.word	0x20003344
 801bde0:	20003b01 	.word	0x20003b01
 801bde4:	20003b14 	.word	0x20003b14

0801bde8 <set_spindle_invert>:
{
 801bde8:	b508      	push	{r3, lr}
    settings.spindle.invert.mask = int_value;
 801bdea:	b2c9      	uxtb	r1, r1
 801bdec:	4b0b      	ldr	r3, [pc, #44]	; (801be1c <set_spindle_invert+0x34>)
 801bdee:	f883 10e6 	strb.w	r1, [r3, #230]	; 0xe6
    if(settings.spindle.invert.pwm && !spindle_get_caps(false).pwm_invert) {
 801bdf2:	f011 0004 	ands.w	r0, r1, #4
 801bdf6:	d100      	bne.n	801bdfa <set_spindle_invert+0x12>
}
 801bdf8:	bd08      	pop	{r3, pc}
    if(settings.spindle.invert.pwm && !spindle_get_caps(false).pwm_invert) {
 801bdfa:	2000      	movs	r0, #0
 801bdfc:	f001 fcf0 	bl	801d7e0 <spindle_get_caps>
 801be00:	f010 0f10 	tst.w	r0, #16
 801be04:	d001      	beq.n	801be0a <set_spindle_invert+0x22>
    return Status_OK;
 801be06:	2000      	movs	r0, #0
 801be08:	e7f6      	b.n	801bdf8 <set_spindle_invert+0x10>
        settings.spindle.invert.pwm = Off;
 801be0a:	4b04      	ldr	r3, [pc, #16]	; (801be1c <set_spindle_invert+0x34>)
 801be0c:	f893 20e6 	ldrb.w	r2, [r3, #230]	; 0xe6
 801be10:	f36f 0282 	bfc	r2, #2, #1
 801be14:	f883 20e6 	strb.w	r2, [r3, #230]	; 0xe6
        return Status_SettingDisabled;
 801be18:	2035      	movs	r0, #53	; 0x35
 801be1a:	e7ed      	b.n	801bdf8 <set_spindle_invert+0x10>
 801be1c:	20003b14 	.word	0x20003b14

0801be20 <is_setting_available>:
    if(setting) switch(normalize_id(setting->id)) {
 801be20:	2800      	cmp	r0, #0
 801be22:	f000 8150 	beq.w	801c0c6 <is_setting_available+0x2a6>
{
 801be26:	b508      	push	{r3, lr}
    if(setting) switch(normalize_id(setting->id)) {
 801be28:	8803      	ldrh	r3, [r0, #0]
    if((id > Setting_AxisSettingsBase && id <= Setting_AxisSettingsMax) ||
 801be2a:	f1a3 0265 	sub.w	r2, r3, #101	; 0x65
 801be2e:	b292      	uxth	r2, r2
 801be30:	2a5c      	cmp	r2, #92	; 0x5c
 801be32:	d904      	bls.n	801be3e <is_setting_available+0x1e>
       (id > Setting_AxisSettingsBase2 && id <= Setting_AxisSettingsMax2))
 801be34:	f1a3 02c9 	sub.w	r2, r3, #201	; 0xc9
 801be38:	b292      	uxth	r2, r2
    if((id > Setting_AxisSettingsBase && id <= Setting_AxisSettingsMax) ||
 801be3a:	2a5c      	cmp	r2, #92	; 0x5c
 801be3c:	d852      	bhi.n	801bee4 <is_setting_available+0xc4>
        id -= id % AXIS_SETTINGS_INCREMENT;
 801be3e:	4a86      	ldr	r2, [pc, #536]	; (801c058 <is_setting_available+0x238>)
 801be40:	fba2 2303 	umull	r2, r3, r2, r3
 801be44:	08db      	lsrs	r3, r3, #3
 801be46:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801be4a:	005b      	lsls	r3, r3, #1
 801be4c:	b29b      	uxth	r3, r3
    if(setting) switch(normalize_id(setting->id)) {
 801be4e:	2baa      	cmp	r3, #170	; 0xaa
 801be50:	f000 80f6 	beq.w	801c040 <is_setting_available+0x220>
 801be54:	d96a      	bls.n	801bf2c <is_setting_available+0x10c>
 801be56:	f5b3 7fc6 	cmp.w	r3, #396	; 0x18c
 801be5a:	f080 8094 	bcs.w	801bf86 <is_setting_available+0x166>
 801be5e:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 801be62:	f0c0 808e 	bcc.w	801bf82 <is_setting_available+0x162>
 801be66:	f5a3 73aa 	sub.w	r3, r3, #340	; 0x154
 801be6a:	2b37      	cmp	r3, #55	; 0x37
 801be6c:	f200 812f 	bhi.w	801c0ce <is_setting_available+0x2ae>
 801be70:	e8df f013 	tbh	[pc, r3, lsl #1]
 801be74:	012d00fe 	.word	0x012d00fe
 801be78:	012d012d 	.word	0x012d012d
 801be7c:	012d012d 	.word	0x012d012d
 801be80:	00e6012d 	.word	0x00e6012d
 801be84:	00e600e6 	.word	0x00e600e6
 801be88:	012d012d 	.word	0x012d012d
 801be8c:	012d012d 	.word	0x012d012d
 801be90:	012d012d 	.word	0x012d012d
 801be94:	012d012d 	.word	0x012d012d
 801be98:	012d012d 	.word	0x012d012d
 801be9c:	012d012d 	.word	0x012d012d
 801bea0:	012d012d 	.word	0x012d012d
 801bea4:	012d012d 	.word	0x012d012d
 801bea8:	012d012d 	.word	0x012d012d
 801beac:	012d012d 	.word	0x012d012d
 801beb0:	012d012d 	.word	0x012d012d
 801beb4:	012d012d 	.word	0x012d012d
 801beb8:	012d012d 	.word	0x012d012d
 801bebc:	012d012d 	.word	0x012d012d
 801bec0:	012d012d 	.word	0x012d012d
 801bec4:	012d012d 	.word	0x012d012d
 801bec8:	012d012d 	.word	0x012d012d
 801becc:	012d012d 	.word	0x012d012d
 801bed0:	012d012d 	.word	0x012d012d
 801bed4:	012d012d 	.word	0x012d012d
 801bed8:	012d012d 	.word	0x012d012d
 801bedc:	00f800f8 	.word	0x00f800f8
 801bee0:	00d00110 	.word	0x00d00110
    else if(id > Setting_EncoderSettingsBase && id <= Setting_EncoderSettingsMax)
 801bee4:	f2a3 1291 	subw	r2, r3, #401	; 0x191
 801bee8:	b292      	uxth	r2, r2
 801beea:	2a30      	cmp	r2, #48	; 0x30
 801beec:	d80c      	bhi.n	801bf08 <is_setting_available+0xe8>
        id = (setting_id_t)(Setting_EncoderSettingsBase + (id % ENCODER_SETTINGS_INCREMENT));
 801beee:	4a5a      	ldr	r2, [pc, #360]	; (801c058 <is_setting_available+0x238>)
 801bef0:	fba2 1203 	umull	r1, r2, r2, r3
 801bef4:	08d2      	lsrs	r2, r2, #3
 801bef6:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 801befa:	eba3 0342 	sub.w	r3, r3, r2, lsl #1
 801befe:	b29b      	uxth	r3, r3
 801bf00:	f503 73c8 	add.w	r3, r3, #400	; 0x190
 801bf04:	b29b      	uxth	r3, r3
 801bf06:	e7a2      	b.n	801be4e <is_setting_available+0x2e>
    else if(id > Setting_ModbusTCPBase && id <= Setting_ModbusTCPMax)
 801bf08:	f2a3 2259 	subw	r2, r3, #601	; 0x259
 801bf0c:	b292      	uxth	r2, r2
 801bf0e:	2a26      	cmp	r2, #38	; 0x26
 801bf10:	d89d      	bhi.n	801be4e <is_setting_available+0x2e>
        id = (setting_id_t)(Setting_ModbusTCPBase + (id % MODBUS_TCP_SETTINGS_INCREMENT));
 801bf12:	4951      	ldr	r1, [pc, #324]	; (801c058 <is_setting_available+0x238>)
 801bf14:	fba1 2103 	umull	r2, r1, r1, r3
 801bf18:	f021 0203 	bic.w	r2, r1, #3
 801bf1c:	eb02 0291 	add.w	r2, r2, r1, lsr #2
 801bf20:	1a9b      	subs	r3, r3, r2
 801bf22:	b29b      	uxth	r3, r3
 801bf24:	f503 7316 	add.w	r3, r3, #600	; 0x258
 801bf28:	b29b      	uxth	r3, r3
 801bf2a:	e790      	b.n	801be4e <is_setting_available+0x2e>
    if(setting) switch(normalize_id(setting->id)) {
 801bf2c:	2b41      	cmp	r3, #65	; 0x41
 801bf2e:	f200 80cc 	bhi.w	801c0ca <is_setting_available+0x2aa>
 801bf32:	2b05      	cmp	r3, #5
 801bf34:	d923      	bls.n	801bf7e <is_setting_available+0x15e>
 801bf36:	3b06      	subs	r3, #6
 801bf38:	2b3b      	cmp	r3, #59	; 0x3b
 801bf3a:	f200 80ca 	bhi.w	801c0d2 <is_setting_available+0x2b2>
 801bf3e:	e8df f003 	tbb	[pc, r3]
 801bf42:	c84a      	.short	0xc84a
 801bf44:	c8c8513c 	.word	0xc8c8513c
 801bf48:	c8c8c8c8 	.word	0xc8c8c8c8
 801bf4c:	4ac8c8c8 	.word	0x4ac8c8c8
 801bf50:	c8c8c8c8 	.word	0xc8c8c8c8
 801bf54:	c8c8c8c8 	.word	0xc8c8c8c8
 801bf58:	7979c8c8 	.word	0x7979c8c8
 801bf5c:	636363c8 	.word	0x636363c8
 801bf60:	c870c863 	.word	0xc870c863
 801bf64:	c89191c8 	.word	0xc89191c8
 801bf68:	c8c8c8c8 	.word	0xc8c8c8c8
 801bf6c:	c8c8c8c8 	.word	0xc8c8c8c8
 801bf70:	c8c8c8c8 	.word	0xc8c8c8c8
 801bf74:	91919191 	.word	0x91919191
 801bf78:	c8c89191 	.word	0xc8c89191
 801bf7c:	4ac8      	.short	0x4ac8
 801bf7e:	2000      	movs	r0, #0
 801bf80:	e0a6      	b.n	801c0d0 <is_setting_available+0x2b0>
 801bf82:	2000      	movs	r0, #0
 801bf84:	e0a4      	b.n	801c0d0 <is_setting_available+0x2b0>
 801bf86:	f5b3 7ff1 	cmp.w	r3, #482	; 0x1e2
 801bf8a:	f000 8095 	beq.w	801c0b8 <is_setting_available+0x298>
 801bf8e:	f5b3 7ff2 	cmp.w	r3, #484	; 0x1e4
 801bf92:	d105      	bne.n	801bfa0 <is_setting_available+0x180>
            available = hal.signals_cap.e_stop;
 801bf94:	4b31      	ldr	r3, [pc, #196]	; (801c05c <is_setting_available+0x23c>)
 801bf96:	f893 01a8 	ldrb.w	r0, [r3, #424]	; 0x1a8
 801bf9a:	f3c0 1080 	ubfx	r0, r0, #6, #1
            break;
 801bf9e:	e097      	b.n	801c0d0 <is_setting_available+0x2b0>
    if(setting) switch(normalize_id(setting->id)) {
 801bfa0:	f240 12e1 	movw	r2, #481	; 0x1e1
 801bfa4:	4293      	cmp	r3, r2
 801bfa6:	d106      	bne.n	801bfb6 <is_setting_available+0x196>
            available = hal.get_elapsed_ticks != NULL;
 801bfa8:	4b2c      	ldr	r3, [pc, #176]	; (801c05c <is_setting_available+0x23c>)
 801bfaa:	f8d3 0178 	ldr.w	r0, [r3, #376]	; 0x178
 801bfae:	3800      	subs	r0, #0
 801bfb0:	bf18      	it	ne
 801bfb2:	2001      	movne	r0, #1
            break;
 801bfb4:	e08c      	b.n	801c0d0 <is_setting_available+0x2b0>
    if(setting) switch(normalize_id(setting->id)) {
 801bfb6:	2000      	movs	r0, #0
 801bfb8:	e08a      	b.n	801c0d0 <is_setting_available+0x2b0>
            available = hal.stepper.get_ganged && hal.stepper.get_ganged(false).mask != 0;
 801bfba:	4b28      	ldr	r3, [pc, #160]	; (801c05c <is_setting_available+0x23c>)
 801bfbc:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 801bfc0:	b12b      	cbz	r3, 801bfce <is_setting_available+0x1ae>
 801bfc2:	2000      	movs	r0, #0
 801bfc4:	4798      	blx	r3
 801bfc6:	b2c0      	uxtb	r0, r0
 801bfc8:	b118      	cbz	r0, 801bfd2 <is_setting_available+0x1b2>
 801bfca:	2001      	movs	r0, #1
 801bfcc:	e080      	b.n	801c0d0 <is_setting_available+0x2b0>
 801bfce:	2000      	movs	r0, #0
 801bfd0:	e07e      	b.n	801c0d0 <is_setting_available+0x2b0>
 801bfd2:	2000      	movs	r0, #0
            break;
 801bfd4:	e07c      	b.n	801c0d0 <is_setting_available+0x2b0>
            available = hal.probe.get_state != NULL;
 801bfd6:	4b21      	ldr	r3, [pc, #132]	; (801c05c <is_setting_available+0x23c>)
 801bfd8:	f8d3 00fc 	ldr.w	r0, [r3, #252]	; 0xfc
 801bfdc:	3800      	subs	r0, #0
 801bfde:	bf18      	it	ne
 801bfe0:	2001      	movne	r0, #1
            break;
 801bfe2:	e075      	b.n	801c0d0 <is_setting_available+0x2b0>
            available = hal.driver_cap.pwm_spindle && spindle_get_caps(false).laser;
 801bfe4:	4b1d      	ldr	r3, [pc, #116]	; (801c05c <is_setting_available+0x23c>)
 801bfe6:	f893 31a6 	ldrb.w	r3, [r3, #422]	; 0x1a6
 801bfea:	f013 0f08 	tst.w	r3, #8
 801bfee:	d101      	bne.n	801bff4 <is_setting_available+0x1d4>
 801bff0:	2000      	movs	r0, #0
 801bff2:	e06d      	b.n	801c0d0 <is_setting_available+0x2b0>
 801bff4:	2000      	movs	r0, #0
 801bff6:	f001 fbf3 	bl	801d7e0 <spindle_get_caps>
 801bffa:	f010 0f08 	tst.w	r0, #8
 801bffe:	d001      	beq.n	801c004 <is_setting_available+0x1e4>
 801c000:	2001      	movs	r0, #1
 801c002:	e065      	b.n	801c0d0 <is_setting_available+0x2b0>
 801c004:	2000      	movs	r0, #0
            break;
 801c006:	e063      	b.n	801c0d0 <is_setting_available+0x2b0>
            available = hal.driver_cap.pwm_spindle;
 801c008:	4b14      	ldr	r3, [pc, #80]	; (801c05c <is_setting_available+0x23c>)
 801c00a:	f893 01a6 	ldrb.w	r0, [r3, #422]	; 0x1a6
 801c00e:	f3c0 00c0 	ubfx	r0, r0, #3, #1
            break;
 801c012:	e05d      	b.n	801c0d0 <is_setting_available+0x2b0>
            available = spindle_get_count() > 1;
 801c014:	f001 fcf8 	bl	801da08 <spindle_get_count>
 801c018:	2801      	cmp	r0, #1
 801c01a:	bf94      	ite	ls
 801c01c:	2000      	movls	r0, #0
 801c01e:	2001      	movhi	r0, #1
            break;
 801c020:	e056      	b.n	801c0d0 <is_setting_available+0x2b0>
            available = hal.driver_cap.spindle_sync || hal.driver_cap.spindle_pid;
 801c022:	4b0e      	ldr	r3, [pc, #56]	; (801c05c <is_setting_available+0x23c>)
 801c024:	f893 31a5 	ldrb.w	r3, [r3, #421]	; 0x1a5
 801c028:	f013 0f21 	tst.w	r3, #33	; 0x21
 801c02c:	bf14      	ite	ne
 801c02e:	2001      	movne	r0, #1
 801c030:	2000      	moveq	r0, #0
            break;
 801c032:	e04d      	b.n	801c0d0 <is_setting_available+0x2b0>
            available = spindle_get_caps(false).variable;
 801c034:	2000      	movs	r0, #0
 801c036:	f001 fbd3 	bl	801d7e0 <spindle_get_caps>
 801c03a:	f000 0001 	and.w	r0, r0, #1
            break;
 801c03e:	e047      	b.n	801c0d0 <is_setting_available+0x2b0>
            available = hal.stepper.get_ganged && hal.stepper.get_ganged(true).mask != 0;
 801c040:	4b06      	ldr	r3, [pc, #24]	; (801c05c <is_setting_available+0x23c>)
 801c042:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 801c046:	b12b      	cbz	r3, 801c054 <is_setting_available+0x234>
 801c048:	2001      	movs	r0, #1
 801c04a:	4798      	blx	r3
 801c04c:	b2c0      	uxtb	r0, r0
 801c04e:	b138      	cbz	r0, 801c060 <is_setting_available+0x240>
 801c050:	2001      	movs	r0, #1
 801c052:	e03d      	b.n	801c0d0 <is_setting_available+0x2b0>
 801c054:	2000      	movs	r0, #0
 801c056:	e03b      	b.n	801c0d0 <is_setting_available+0x2b0>
 801c058:	cccccccd 	.word	0xcccccccd
 801c05c:	2000350c 	.word	0x2000350c
 801c060:	2000      	movs	r0, #0
            break;
 801c062:	e035      	b.n	801c0d0 <is_setting_available+0x2b0>
            available = hal.signals_cap.safety_door_ajar;
 801c064:	4b1c      	ldr	r3, [pc, #112]	; (801c0d8 <is_setting_available+0x2b8>)
 801c066:	f893 01a8 	ldrb.w	r0, [r3, #424]	; 0x1a8
 801c06a:	f3c0 00c0 	ubfx	r0, r0, #3, #1
            break;
 801c06e:	e02f      	b.n	801c0d0 <is_setting_available+0x2b0>
            available = spindle_get_caps(true).at_speed || hal.driver_cap.spindle_sync;
 801c070:	2001      	movs	r0, #1
 801c072:	f001 fbb5 	bl	801d7e0 <spindle_get_caps>
 801c076:	f010 0f04 	tst.w	r0, #4
 801c07a:	d107      	bne.n	801c08c <is_setting_available+0x26c>
 801c07c:	4b16      	ldr	r3, [pc, #88]	; (801c0d8 <is_setting_available+0x2b8>)
 801c07e:	f893 31a5 	ldrb.w	r3, [r3, #421]	; 0x1a5
 801c082:	f013 0f01 	tst.w	r3, #1
 801c086:	d003      	beq.n	801c090 <is_setting_available+0x270>
 801c088:	2001      	movs	r0, #1
 801c08a:	e021      	b.n	801c0d0 <is_setting_available+0x2b0>
 801c08c:	2001      	movs	r0, #1
 801c08e:	e01f      	b.n	801c0d0 <is_setting_available+0x2b0>
 801c090:	2000      	movs	r0, #0
            break;
 801c092:	e01d      	b.n	801c0d0 <is_setting_available+0x2b0>
            available = !hal.signals_cap.safety_door_ajar && spindle_get_caps(true).at_speed;
 801c094:	4b10      	ldr	r3, [pc, #64]	; (801c0d8 <is_setting_available+0x2b8>)
 801c096:	f893 31a8 	ldrb.w	r3, [r3, #424]	; 0x1a8
 801c09a:	f013 0f08 	tst.w	r3, #8
 801c09e:	d001      	beq.n	801c0a4 <is_setting_available+0x284>
 801c0a0:	2000      	movs	r0, #0
 801c0a2:	e015      	b.n	801c0d0 <is_setting_available+0x2b0>
 801c0a4:	2001      	movs	r0, #1
 801c0a6:	f001 fb9b 	bl	801d7e0 <spindle_get_caps>
 801c0aa:	f010 0f04 	tst.w	r0, #4
 801c0ae:	d001      	beq.n	801c0b4 <is_setting_available+0x294>
 801c0b0:	2001      	movs	r0, #1
 801c0b2:	e00d      	b.n	801c0d0 <is_setting_available+0x2b0>
 801c0b4:	2000      	movs	r0, #0
            break;
 801c0b6:	e00b      	b.n	801c0d0 <is_setting_available+0x2b0>
            available = hal.rtc.set_datetime != NULL;
 801c0b8:	4b07      	ldr	r3, [pc, #28]	; (801c0d8 <is_setting_available+0x2b8>)
 801c0ba:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
 801c0be:	3800      	subs	r0, #0
 801c0c0:	bf18      	it	ne
 801c0c2:	2001      	movne	r0, #1
            break;
 801c0c4:	e004      	b.n	801c0d0 <is_setting_available+0x2b0>
    bool available = false;
 801c0c6:	2000      	movs	r0, #0
}
 801c0c8:	4770      	bx	lr
    if(setting) switch(normalize_id(setting->id)) {
 801c0ca:	2000      	movs	r0, #0
 801c0cc:	e000      	b.n	801c0d0 <is_setting_available+0x2b0>
 801c0ce:	2000      	movs	r0, #0
}
 801c0d0:	bd08      	pop	{r3, pc}
    if(setting) switch(normalize_id(setting->id)) {
 801c0d2:	2000      	movs	r0, #0
 801c0d4:	e7fc      	b.n	801c0d0 <is_setting_available+0x2b0>
 801c0d6:	bf00      	nop
 801c0d8:	2000350c 	.word	0x2000350c

0801c0dc <set_report_inches>:
{
 801c0dc:	b508      	push	{r3, lr}
    settings.flags.report_inches = int_value != 0;
 801c0de:	3900      	subs	r1, #0
 801c0e0:	bf18      	it	ne
 801c0e2:	2101      	movne	r1, #1
 801c0e4:	4b06      	ldr	r3, [pc, #24]	; (801c100 <set_report_inches+0x24>)
 801c0e6:	f893 20fe 	ldrb.w	r2, [r3, #254]	; 0xfe
 801c0ea:	f361 0200 	bfi	r2, r1, #0, #1
 801c0ee:	f883 20fe 	strb.w	r2, [r3, #254]	; 0xfe
    report_init();
 801c0f2:	f7fd f86d 	bl	80191d0 <report_init>
    system_flag_wco_change(); // Make sure WCO is immediately updated.
 801c0f6:	f005 f901 	bl	80212fc <system_flag_wco_change>
}
 801c0fa:	2000      	movs	r0, #0
 801c0fc:	bd08      	pop	{r3, pc}
 801c0fe:	bf00      	nop
 801c100:	20003b14 	.word	0x20003b14

0801c104 <strnumentries>:
{
 801c104:	b538      	push	{r3, r4, r5, lr}
    if(s == NULL || *s == '\0')
 801c106:	b170      	cbz	r0, 801c126 <strnumentries+0x22>
 801c108:	460d      	mov	r5, r1
 801c10a:	7803      	ldrb	r3, [r0, #0]
 801c10c:	b16b      	cbz	r3, 801c12a <strnumentries+0x26>
    uint32_t entries = 1;
 801c10e:	2401      	movs	r4, #1
 801c110:	e001      	b.n	801c116 <strnumentries+0x12>
        p++;
 801c112:	1c58      	adds	r0, r3, #1
        entries++;
 801c114:	3401      	adds	r4, #1
    while((p = strchr(p, delimiter))) {
 801c116:	4629      	mov	r1, r5
 801c118:	f006 fd44 	bl	8022ba4 <strchr>
 801c11c:	4603      	mov	r3, r0
 801c11e:	2800      	cmp	r0, #0
 801c120:	d1f7      	bne.n	801c112 <strnumentries+0xe>
}
 801c122:	4620      	mov	r0, r4
 801c124:	bd38      	pop	{r3, r4, r5, pc}
        return 0;
 801c126:	2400      	movs	r4, #0
 801c128:	e7fb      	b.n	801c122 <strnumentries+0x1e>
 801c12a:	2400      	movs	r4, #0
 801c12c:	e7f9      	b.n	801c122 <strnumentries+0x1e>

0801c12e <validate_uint_value>:
{
 801c12e:	b530      	push	{r4, r5, lr}
 801c130:	b083      	sub	sp, #12
 801c132:	4604      	mov	r4, r0
 801c134:	460d      	mov	r5, r1
    uint_fast8_t set_idx = 0;
 801c136:	2300      	movs	r3, #0
 801c138:	9300      	str	r3, [sp, #0]
    if(setting->min_value) {
 801c13a:	6940      	ldr	r0, [r0, #20]
 801c13c:	b168      	cbz	r0, 801c15a <validate_uint_value+0x2c>
        if((status = read_uint((char *)setting->min_value, &set_idx, &val)) != Status_OK)
 801c13e:	aa01      	add	r2, sp, #4
 801c140:	4669      	mov	r1, sp
 801c142:	f7f9 fbb7 	bl	80158b4 <read_uint>
 801c146:	b9d8      	cbnz	r0, 801c180 <validate_uint_value+0x52>
        if(!(value >= val || (setting->flags.allow_null && value == 0)))
 801c148:	9b01      	ldr	r3, [sp, #4]
 801c14a:	42ab      	cmp	r3, r5
 801c14c:	d905      	bls.n	801c15a <validate_uint_value+0x2c>
 801c14e:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 801c152:	f013 0f02 	tst.w	r3, #2
 801c156:	d00e      	beq.n	801c176 <validate_uint_value+0x48>
 801c158:	b97d      	cbnz	r5, 801c17a <validate_uint_value+0x4c>
    if(setting->max_value) {
 801c15a:	69a0      	ldr	r0, [r4, #24]
 801c15c:	b178      	cbz	r0, 801c17e <validate_uint_value+0x50>
        set_idx = 0;
 801c15e:	2300      	movs	r3, #0
 801c160:	9300      	str	r3, [sp, #0]
        if((status = read_uint((char *)setting->max_value, &set_idx, &val)) != Status_OK)
 801c162:	aa01      	add	r2, sp, #4
 801c164:	4669      	mov	r1, sp
 801c166:	f7f9 fba5 	bl	80158b4 <read_uint>
 801c16a:	b958      	cbnz	r0, 801c184 <validate_uint_value+0x56>
        if(value > val)
 801c16c:	9b01      	ldr	r3, [sp, #4]
 801c16e:	42ab      	cmp	r3, r5
 801c170:	d206      	bcs.n	801c180 <validate_uint_value+0x52>
            return Status_SettingValueOutOfRange;
 801c172:	2034      	movs	r0, #52	; 0x34
 801c174:	e004      	b.n	801c180 <validate_uint_value+0x52>
            return Status_SettingValueOutOfRange;
 801c176:	2034      	movs	r0, #52	; 0x34
 801c178:	e002      	b.n	801c180 <validate_uint_value+0x52>
 801c17a:	2034      	movs	r0, #52	; 0x34
 801c17c:	e000      	b.n	801c180 <validate_uint_value+0x52>
    return Status_OK;
 801c17e:	2000      	movs	r0, #0
}
 801c180:	b003      	add	sp, #12
 801c182:	bd30      	pop	{r4, r5, pc}
            return Status_BadNumberFormat;
 801c184:	2002      	movs	r0, #2
 801c186:	e7fb      	b.n	801c180 <validate_uint_value+0x52>

0801c188 <setting_validate_me_uint>:
{
    return !(type == Setting_NonCore || type == Setting_NonCoreFn);
}

static status_code_t setting_validate_me_uint (const setting_detail_t *setting, char *svalue)
{
 801c188:	b530      	push	{r4, r5, lr}
 801c18a:	b083      	sub	sp, #12
 801c18c:	4604      	mov	r4, r0
 801c18e:	4608      	mov	r0, r1
    uint_fast8_t idx = 0;
 801c190:	2300      	movs	r3, #0
 801c192:	9301      	str	r3, [sp, #4]
    uint32_t value;
    status_code_t status;

    if((status = read_uint(svalue, &idx, &value)) != Status_OK)
 801c194:	466a      	mov	r2, sp
 801c196:	a901      	add	r1, sp, #4
 801c198:	f7f9 fb8c 	bl	80158b4 <read_uint>
 801c19c:	4605      	mov	r5, r0
 801c19e:	bb68      	cbnz	r0, 801c1fc <setting_validate_me_uint+0x74>
        return status;

    switch(setting->datatype) {
 801c1a0:	7b23      	ldrb	r3, [r4, #12]
 801c1a2:	2b0b      	cmp	r3, #11
 801c1a4:	d82a      	bhi.n	801c1fc <setting_validate_me_uint+0x74>
 801c1a6:	e8df f003 	tbb	[pc, r3]
 801c1aa:	0b06      	.short	0x0b06
 801c1ac:	241f160b 	.word	0x241f160b
 801c1b0:	29292929 	.word	0x29292929
 801c1b4:	2424      	.short	0x2424

        case Format_Bool:
            if(!(value == 0 || value == 1))
 801c1b6:	9b00      	ldr	r3, [sp, #0]
 801c1b8:	2b01      	cmp	r3, #1
 801c1ba:	d91f      	bls.n	801c1fc <setting_validate_me_uint+0x74>
                status = Status_SettingValueOutOfRange;
 801c1bc:	2534      	movs	r5, #52	; 0x34
 801c1be:	e01d      	b.n	801c1fc <setting_validate_me_uint+0x74>
            break;

        case Format_Bitfield:
        case Format_XBitfield:;
            if(value >= (1UL << strnumentries(setting->format, ',')))
 801c1c0:	212c      	movs	r1, #44	; 0x2c
 801c1c2:	6920      	ldr	r0, [r4, #16]
 801c1c4:	f7ff ff9e 	bl	801c104 <strnumentries>
 801c1c8:	2301      	movs	r3, #1
 801c1ca:	4083      	lsls	r3, r0
 801c1cc:	9a00      	ldr	r2, [sp, #0]
 801c1ce:	4293      	cmp	r3, r2
 801c1d0:	d814      	bhi.n	801c1fc <setting_validate_me_uint+0x74>
                status = Status_SettingValueOutOfRange;
 801c1d2:	2534      	movs	r5, #52	; 0x34
 801c1d4:	e012      	b.n	801c1fc <setting_validate_me_uint+0x74>
            break;

        case Format_RadioButtons:
            if(value >= strnumentries(setting->format, ','))
 801c1d6:	212c      	movs	r1, #44	; 0x2c
 801c1d8:	6920      	ldr	r0, [r4, #16]
 801c1da:	f7ff ff93 	bl	801c104 <strnumentries>
 801c1de:	9b00      	ldr	r3, [sp, #0]
 801c1e0:	4298      	cmp	r0, r3
 801c1e2:	d80b      	bhi.n	801c1fc <setting_validate_me_uint+0x74>
                status = Status_SettingValueOutOfRange;
 801c1e4:	2534      	movs	r5, #52	; 0x34
 801c1e6:	e009      	b.n	801c1fc <setting_validate_me_uint+0x74>
            break;

        case Format_AxisMask:
            if(value >= (1 << N_AXIS))
 801c1e8:	9b00      	ldr	r3, [sp, #0]
 801c1ea:	2b07      	cmp	r3, #7
 801c1ec:	d906      	bls.n	801c1fc <setting_validate_me_uint+0x74>
                status = Status_SettingValueOutOfRange;
 801c1ee:	2534      	movs	r5, #52	; 0x34
 801c1f0:	e004      	b.n	801c1fc <setting_validate_me_uint+0x74>
            break;

        case Format_Int8:
        case Format_Int16:
        case Format_Integer:
            status = validate_uint_value(setting, value);
 801c1f2:	9900      	ldr	r1, [sp, #0]
 801c1f4:	4620      	mov	r0, r4
 801c1f6:	f7ff ff9a 	bl	801c12e <validate_uint_value>
 801c1fa:	4605      	mov	r5, r0
        default:
            break;
    }

    return status;
}
 801c1fc:	4628      	mov	r0, r5
 801c1fe:	b003      	add	sp, #12
 801c200:	bd30      	pop	{r4, r5, pc}

0801c202 <validate_value>:
{
 801c202:	b510      	push	{r4, lr}
 801c204:	ed2d 8b02 	vpush	{d8}
 801c208:	b082      	sub	sp, #8
 801c20a:	4604      	mov	r4, r0
 801c20c:	eeb0 8a40 	vmov.f32	s16, s0
    uint_fast8_t set_idx = 0;
 801c210:	2300      	movs	r3, #0
 801c212:	9300      	str	r3, [sp, #0]
    if(setting->min_value) {
 801c214:	6940      	ldr	r0, [r0, #20]
 801c216:	b1b8      	cbz	r0, 801c248 <validate_value+0x46>
        if(!read_float((char *)setting->min_value, &set_idx, &val))
 801c218:	aa01      	add	r2, sp, #4
 801c21a:	4669      	mov	r1, sp
 801c21c:	f7f9 fb92 	bl	8015944 <read_float>
 801c220:	b348      	cbz	r0, 801c276 <validate_value+0x74>
        if(!(value >= val || (setting->flags.allow_null && value == 0.0f)))
 801c222:	eddd 7a01 	vldr	s15, [sp, #4]
 801c226:	eef4 7ac8 	vcmpe.f32	s15, s16
 801c22a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c22e:	d910      	bls.n	801c252 <validate_value+0x50>
 801c230:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 801c234:	f013 0f02 	tst.w	r3, #2
 801c238:	d01f      	beq.n	801c27a <validate_value+0x78>
 801c23a:	eeb5 8a40 	vcmp.f32	s16, #0.0
 801c23e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c242:	d006      	beq.n	801c252 <validate_value+0x50>
            return Status_SettingValueOutOfRange;
 801c244:	2034      	movs	r0, #52	; 0x34
 801c246:	e01d      	b.n	801c284 <validate_value+0x82>
    } else if(value < 0.0f)
 801c248:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 801c24c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c250:	d415      	bmi.n	801c27e <validate_value+0x7c>
    if(setting->max_value) {
 801c252:	69a0      	ldr	r0, [r4, #24]
 801c254:	b1a8      	cbz	r0, 801c282 <validate_value+0x80>
        set_idx = 0;
 801c256:	2300      	movs	r3, #0
 801c258:	9300      	str	r3, [sp, #0]
        if(!read_float((char *)setting->max_value, &set_idx, &val))
 801c25a:	aa01      	add	r2, sp, #4
 801c25c:	4669      	mov	r1, sp
 801c25e:	f7f9 fb71 	bl	8015944 <read_float>
 801c262:	b198      	cbz	r0, 801c28c <validate_value+0x8a>
        if(value > val)
 801c264:	eddd 7a01 	vldr	s15, [sp, #4]
 801c268:	eef4 7ac8 	vcmpe.f32	s15, s16
 801c26c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c270:	d40e      	bmi.n	801c290 <validate_value+0x8e>
    return Status_OK;
 801c272:	2000      	movs	r0, #0
 801c274:	e006      	b.n	801c284 <validate_value+0x82>
            return Status_BadNumberFormat;
 801c276:	2002      	movs	r0, #2
 801c278:	e004      	b.n	801c284 <validate_value+0x82>
            return Status_SettingValueOutOfRange;
 801c27a:	2034      	movs	r0, #52	; 0x34
 801c27c:	e002      	b.n	801c284 <validate_value+0x82>
        return Status_NegativeValue;
 801c27e:	2004      	movs	r0, #4
 801c280:	e000      	b.n	801c284 <validate_value+0x82>
    return Status_OK;
 801c282:	2000      	movs	r0, #0
}
 801c284:	b002      	add	sp, #8
 801c286:	ecbd 8b02 	vpop	{d8}
 801c28a:	bd10      	pop	{r4, pc}
            return Status_BadNumberFormat;
 801c28c:	2002      	movs	r0, #2
 801c28e:	e7f9      	b.n	801c284 <validate_value+0x82>
            return Status_SettingValueOutOfRange;
 801c290:	2034      	movs	r0, #52	; 0x34
 801c292:	e7f7      	b.n	801c284 <validate_value+0x82>

0801c294 <settings_changed_spindle>:
    // If no details available setting could nevertheless be a valid setting id.
    return setting == NULL ? Status_OK : setting_validate_me(setting, value, svalue);
}

static bool settings_changed_spindle (void)
{
 801c294:	b510      	push	{r4, lr}
    static spindle_settings_t spindle_settings = {0};

    bool changed;

    if((changed = memcmp(&spindle_settings, &settings.spindle, sizeof(spindle_settings_t))) != 0)
 801c296:	2274      	movs	r2, #116	; 0x74
 801c298:	4907      	ldr	r1, [pc, #28]	; (801c2b8 <settings_changed_spindle+0x24>)
 801c29a:	4808      	ldr	r0, [pc, #32]	; (801c2bc <settings_changed_spindle+0x28>)
 801c29c:	f006 fc5b 	bl	8022b56 <memcmp>
 801c2a0:	2800      	cmp	r0, #0
 801c2a2:	bf14      	ite	ne
 801c2a4:	2401      	movne	r4, #1
 801c2a6:	2400      	moveq	r4, #0
 801c2a8:	d004      	beq.n	801c2b4 <settings_changed_spindle+0x20>
        memcpy(&spindle_settings, &settings.spindle, sizeof(spindle_settings_t));
 801c2aa:	2274      	movs	r2, #116	; 0x74
 801c2ac:	4902      	ldr	r1, [pc, #8]	; (801c2b8 <settings_changed_spindle+0x24>)
 801c2ae:	4803      	ldr	r0, [pc, #12]	; (801c2bc <settings_changed_spindle+0x28>)
 801c2b0:	f006 fdbe 	bl	8022e30 <memcpy>

    return changed;
}
 801c2b4:	4620      	mov	r0, r4
 801c2b6:	bd10      	pop	{r4, pc}
 801c2b8:	20003b88 	.word	0x20003b88
 801c2bc:	20003c80 	.word	0x20003c80

0801c2c0 <settings_register>:
    settingsd->next = details;
 801c2c0:	4b02      	ldr	r3, [pc, #8]	; (801c2cc <settings_register+0xc>)
 801c2c2:	681a      	ldr	r2, [r3, #0]
 801c2c4:	6190      	str	r0, [r2, #24]
    settingsd = details;
 801c2c6:	6018      	str	r0, [r3, #0]
}
 801c2c8:	4770      	bx	lr
 801c2ca:	bf00      	nop
 801c2cc:	200004e4 	.word	0x200004e4

0801c2d0 <settings_get_details>:
}
 801c2d0:	4800      	ldr	r0, [pc, #0]	; (801c2d4 <settings_get_details+0x4>)
 801c2d2:	4770      	bx	lr
 801c2d4:	200004b4 	.word	0x200004b4

0801c2d8 <settings_get_axis_base>:
{
 801c2d8:	4602      	mov	r2, r0
    if((id > Setting_AxisSettingsBase && id <= Setting_AxisSettingsMax) ||
 801c2da:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 801c2de:	b29b      	uxth	r3, r3
 801c2e0:	2b5c      	cmp	r3, #92	; 0x5c
 801c2e2:	d904      	bls.n	801c2ee <settings_get_axis_base+0x16>
       (id > Setting_AxisSettingsBase2 && id <= Setting_AxisSettingsMax2))
 801c2e4:	f1a0 03c9 	sub.w	r3, r0, #201	; 0xc9
 801c2e8:	b29b      	uxth	r3, r3
    if((id > Setting_AxisSettingsBase && id <= Setting_AxisSettingsMax) ||
 801c2ea:	2b5c      	cmp	r3, #92	; 0x5c
 801c2ec:	d80c      	bhi.n	801c308 <settings_get_axis_base+0x30>
        id -= id % AXIS_SETTINGS_INCREMENT;
 801c2ee:	4b19      	ldr	r3, [pc, #100]	; (801c354 <settings_get_axis_base+0x7c>)
 801c2f0:	fba3 0302 	umull	r0, r3, r3, r2
 801c2f4:	08db      	lsrs	r3, r3, #3
 801c2f6:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801c2fa:	005b      	lsls	r3, r3, #1
 801c2fc:	b298      	uxth	r0, r3
    *idx = id - base;
 801c2fe:	1a12      	subs	r2, r2, r0
 801c300:	600a      	str	r2, [r1, #0]
    return *idx < N_AXIS ? base : Setting_SettingsMax;
 801c302:	2a02      	cmp	r2, #2
 801c304:	d823      	bhi.n	801c34e <settings_get_axis_base+0x76>
}
 801c306:	4770      	bx	lr
    else if(id > Setting_EncoderSettingsBase && id <= Setting_EncoderSettingsMax)
 801c308:	f2a0 1391 	subw	r3, r0, #401	; 0x191
 801c30c:	b29b      	uxth	r3, r3
 801c30e:	2b30      	cmp	r3, #48	; 0x30
 801c310:	d80c      	bhi.n	801c32c <settings_get_axis_base+0x54>
        id = (setting_id_t)(Setting_EncoderSettingsBase + (id % ENCODER_SETTINGS_INCREMENT));
 801c312:	4b10      	ldr	r3, [pc, #64]	; (801c354 <settings_get_axis_base+0x7c>)
 801c314:	fba3 0302 	umull	r0, r3, r3, r2
 801c318:	08db      	lsrs	r3, r3, #3
 801c31a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801c31e:	eba2 0343 	sub.w	r3, r2, r3, lsl #1
 801c322:	b29b      	uxth	r3, r3
 801c324:	f503 73c8 	add.w	r3, r3, #400	; 0x190
 801c328:	b298      	uxth	r0, r3
 801c32a:	e7e8      	b.n	801c2fe <settings_get_axis_base+0x26>
    else if(id > Setting_ModbusTCPBase && id <= Setting_ModbusTCPMax)
 801c32c:	f2a0 2359 	subw	r3, r0, #601	; 0x259
 801c330:	b29b      	uxth	r3, r3
 801c332:	2b26      	cmp	r3, #38	; 0x26
 801c334:	d8e3      	bhi.n	801c2fe <settings_get_axis_base+0x26>
        id = (setting_id_t)(Setting_ModbusTCPBase + (id % MODBUS_TCP_SETTINGS_INCREMENT));
 801c336:	4b07      	ldr	r3, [pc, #28]	; (801c354 <settings_get_axis_base+0x7c>)
 801c338:	fba3 0302 	umull	r0, r3, r3, r2
 801c33c:	089b      	lsrs	r3, r3, #2
 801c33e:	eb03 0083 	add.w	r0, r3, r3, lsl #2
 801c342:	1a10      	subs	r0, r2, r0
 801c344:	b280      	uxth	r0, r0
 801c346:	f500 7016 	add.w	r0, r0, #600	; 0x258
 801c34a:	b280      	uxth	r0, r0
 801c34c:	e7d7      	b.n	801c2fe <settings_get_axis_base+0x26>
    return *idx < N_AXIS ? base : Setting_SettingsMax;
 801c34e:	f240 208a 	movw	r0, #650	; 0x28a
 801c352:	e7d8      	b.n	801c306 <settings_get_axis_base+0x2e>
 801c354:	cccccccd 	.word	0xcccccccd

0801c358 <get_float>:
    if (setting >= Setting_AxisSettingsBase && setting <= Setting_AxisSettingsMax) {
 801c358:	f1a0 0364 	sub.w	r3, r0, #100	; 0x64
 801c35c:	b29b      	uxth	r3, r3
 801c35e:	2b5d      	cmp	r3, #93	; 0x5d
 801c360:	d905      	bls.n	801c36e <get_float+0x16>
    } else switch(setting) {
 801c362:	f5b0 7fab 	cmp.w	r0, #342	; 0x156
 801c366:	d060      	beq.n	801c42a <get_float+0xd2>
    float value = 0.0f;
 801c368:	ed9f 0a32 	vldr	s0, [pc, #200]	; 801c434 <get_float+0xdc>
}
 801c36c:	4770      	bx	lr
{
 801c36e:	b500      	push	{lr}
 801c370:	b083      	sub	sp, #12
        switch(settings_get_axis_base(setting, &idx)) {
 801c372:	a901      	add	r1, sp, #4
 801c374:	f7ff ffb0 	bl	801c2d8 <settings_get_axis_base>
 801c378:	2882      	cmp	r0, #130	; 0x82
 801c37a:	d816      	bhi.n	801c3aa <get_float+0x52>
 801c37c:	2864      	cmp	r0, #100	; 0x64
 801c37e:	d34c      	bcc.n	801c41a <get_float+0xc2>
 801c380:	3864      	subs	r0, #100	; 0x64
 801c382:	281e      	cmp	r0, #30
 801c384:	d84c      	bhi.n	801c420 <get_float+0xc8>
 801c386:	e8df f000 	tbb	[pc, r0]
 801c38a:	4b1e      	.short	0x4b1e
 801c38c:	4b4b4b4b 	.word	0x4b4b4b4b
 801c390:	4b4b4b4b 	.word	0x4b4b4b4b
 801c394:	4b4b4b27 	.word	0x4b4b4b27
 801c398:	4b4b4b4b 	.word	0x4b4b4b4b
 801c39c:	4b304b4b 	.word	0x4b304b4b
 801c3a0:	4b4b4b4b 	.word	0x4b4b4b4b
 801c3a4:	4b4b4b4b 	.word	0x4b4b4b4b
 801c3a8:	3d          	.byte	0x3d
 801c3a9:	00          	.byte	0x00
 801c3aa:	28aa      	cmp	r0, #170	; 0xaa
 801c3ac:	d108      	bne.n	801c3c0 <get_float+0x68>
                value = settings.axis[idx].dual_axis_offset;
 801c3ae:	9b01      	ldr	r3, [sp, #4]
 801c3b0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801c3b4:	4a20      	ldr	r2, [pc, #128]	; (801c438 <get_float+0xe0>)
 801c3b6:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 801c3ba:	ed93 0a10 	vldr	s0, [r3, #64]	; 0x40
                break;
 801c3be:	e031      	b.n	801c424 <get_float+0xcc>
        switch(settings_get_axis_base(setting, &idx)) {
 801c3c0:	ed9f 0a1c 	vldr	s0, [pc, #112]	; 801c434 <get_float+0xdc>
 801c3c4:	e02e      	b.n	801c424 <get_float+0xcc>
                value = settings.axis[idx].steps_per_mm;
 801c3c6:	9b01      	ldr	r3, [sp, #4]
 801c3c8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801c3cc:	4a1a      	ldr	r2, [pc, #104]	; (801c438 <get_float+0xe0>)
 801c3ce:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 801c3d2:	ed93 0a0c 	vldr	s0, [r3, #48]	; 0x30
                break;
 801c3d6:	e025      	b.n	801c424 <get_float+0xcc>
                value = settings.axis[idx].max_rate;
 801c3d8:	9b01      	ldr	r3, [sp, #4]
 801c3da:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801c3de:	4a16      	ldr	r2, [pc, #88]	; (801c438 <get_float+0xe0>)
 801c3e0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 801c3e4:	ed93 0a0d 	vldr	s0, [r3, #52]	; 0x34
                break;
 801c3e8:	e01c      	b.n	801c424 <get_float+0xcc>
                value = settings.axis[idx].acceleration  / (60.0f * 60.0f); // Convert to mm/min^2 for grbl internal use.
 801c3ea:	9b01      	ldr	r3, [sp, #4]
 801c3ec:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801c3f0:	4a11      	ldr	r2, [pc, #68]	; (801c438 <get_float+0xe0>)
 801c3f2:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 801c3f6:	ed93 7a0e 	vldr	s14, [r3, #56]	; 0x38
 801c3fa:	eddf 7a10 	vldr	s15, [pc, #64]	; 801c43c <get_float+0xe4>
 801c3fe:	ee87 0a27 	vdiv.f32	s0, s14, s15
                break;
 801c402:	e00f      	b.n	801c424 <get_float+0xcc>
                value = -settings.axis[idx].max_travel; // Store as negative for grbl internal use.
 801c404:	9b01      	ldr	r3, [sp, #4]
 801c406:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801c40a:	4a0b      	ldr	r2, [pc, #44]	; (801c438 <get_float+0xe0>)
 801c40c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 801c410:	ed93 0a0f 	vldr	s0, [r3, #60]	; 0x3c
 801c414:	eeb1 0a40 	vneg.f32	s0, s0
                break;
 801c418:	e004      	b.n	801c424 <get_float+0xcc>
        switch(settings_get_axis_base(setting, &idx)) {
 801c41a:	ed9f 0a06 	vldr	s0, [pc, #24]	; 801c434 <get_float+0xdc>
 801c41e:	e001      	b.n	801c424 <get_float+0xcc>
 801c420:	ed9f 0a04 	vldr	s0, [pc, #16]	; 801c434 <get_float+0xdc>
}
 801c424:	b003      	add	sp, #12
 801c426:	f85d fb04 	ldr.w	pc, [sp], #4
            value = settings.tool_change.probing_distance;
 801c42a:	4b03      	ldr	r3, [pc, #12]	; (801c438 <get_float+0xe0>)
 801c42c:	ed93 0a0a 	vldr	s0, [r3, #40]	; 0x28
            break;
 801c430:	4770      	bx	lr
 801c432:	bf00      	nop
 801c434:	00000000 	.word	0x00000000
 801c438:	20003b14 	.word	0x20003b14
 801c43c:	45610000 	.word	0x45610000

0801c440 <set_axis_setting>:
{
 801c440:	b510      	push	{r4, lr}
 801c442:	ed2d 8b02 	vpush	{d8}
 801c446:	b082      	sub	sp, #8
 801c448:	eeb0 8a40 	vmov.f32	s16, s0
    switch(settings_get_axis_base(setting, &idx)) {
 801c44c:	a901      	add	r1, sp, #4
 801c44e:	f7ff ff43 	bl	801c2d8 <settings_get_axis_base>
 801c452:	2882      	cmp	r0, #130	; 0x82
 801c454:	d827      	bhi.n	801c4a6 <set_axis_setting+0x66>
 801c456:	2864      	cmp	r0, #100	; 0x64
 801c458:	f0c0 8130 	bcc.w	801c6bc <set_axis_setting+0x27c>
 801c45c:	3864      	subs	r0, #100	; 0x64
 801c45e:	281e      	cmp	r0, #30
 801c460:	f200 812e 	bhi.w	801c6c0 <set_axis_setting+0x280>
 801c464:	e8df f010 	tbh	[pc, r0, lsl #1]
 801c468:	012c003b 	.word	0x012c003b
 801c46c:	012c012c 	.word	0x012c012c
 801c470:	012c012c 	.word	0x012c012c
 801c474:	012c012c 	.word	0x012c012c
 801c478:	012c012c 	.word	0x012c012c
 801c47c:	012c00b6 	.word	0x012c00b6
 801c480:	012c012c 	.word	0x012c012c
 801c484:	012c012c 	.word	0x012c012c
 801c488:	012c012c 	.word	0x012c012c
 801c48c:	012c012c 	.word	0x012c012c
 801c490:	012c00da 	.word	0x012c00da
 801c494:	012c012c 	.word	0x012c012c
 801c498:	012c012c 	.word	0x012c012c
 801c49c:	012c012c 	.word	0x012c012c
 801c4a0:	012c012c 	.word	0x012c012c
 801c4a4:	00ef      	.short	0x00ef
 801c4a6:	28aa      	cmp	r0, #170	; 0xaa
 801c4a8:	d117      	bne.n	801c4da <set_axis_setting+0x9a>
            if(hal.stepper.get_ganged && bit_istrue(hal.stepper.get_ganged(true).mask, bit(idx)))
 801c4aa:	4b8c      	ldr	r3, [pc, #560]	; (801c6dc <set_axis_setting+0x29c>)
 801c4ac:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 801c4b0:	2b00      	cmp	r3, #0
 801c4b2:	f000 810e 	beq.w	801c6d2 <set_axis_setting+0x292>
 801c4b6:	2001      	movs	r0, #1
 801c4b8:	4798      	blx	r3
 801c4ba:	b2c0      	uxtb	r0, r0
 801c4bc:	9b01      	ldr	r3, [sp, #4]
 801c4be:	40d8      	lsrs	r0, r3
 801c4c0:	f010 0f01 	tst.w	r0, #1
 801c4c4:	f000 8107 	beq.w	801c6d6 <set_axis_setting+0x296>
                settings.axis[idx].dual_axis_offset = value;
 801c4c8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801c4cc:	4a84      	ldr	r2, [pc, #528]	; (801c6e0 <set_axis_setting+0x2a0>)
 801c4ce:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 801c4d2:	ed83 8a10 	vstr	s16, [r3, #64]	; 0x40
    status_code_t status = Status_OK;
 801c4d6:	2000      	movs	r0, #0
                settings.axis[idx].dual_axis_offset = value;
 801c4d8:	e0f3      	b.n	801c6c2 <set_axis_setting+0x282>
    switch(settings_get_axis_base(setting, &idx)) {
 801c4da:	2035      	movs	r0, #53	; 0x35
 801c4dc:	e0f1      	b.n	801c6c2 <set_axis_setting+0x282>
            if (hal.max_step_rate && value * settings.axis[idx].max_rate > (float)hal.max_step_rate * 60.0f)
 801c4de:	4b7f      	ldr	r3, [pc, #508]	; (801c6dc <set_axis_setting+0x29c>)
 801c4e0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801c4e2:	b1bb      	cbz	r3, 801c514 <set_axis_setting+0xd4>
 801c4e4:	9a01      	ldr	r2, [sp, #4]
 801c4e6:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 801c4ea:	497d      	ldr	r1, [pc, #500]	; (801c6e0 <set_axis_setting+0x2a0>)
 801c4ec:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 801c4f0:	ed92 7a0d 	vldr	s14, [r2, #52]	; 0x34
 801c4f4:	ee27 7a08 	vmul.f32	s14, s14, s16
 801c4f8:	ee07 3a90 	vmov	s15, r3
 801c4fc:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801c500:	eddf 6a78 	vldr	s13, [pc, #480]	; 801c6e4 <set_axis_setting+0x2a4>
 801c504:	ee67 7aa6 	vmul.f32	s15, s15, s13
 801c508:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801c50c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c510:	f300 80db 	bgt.w	801c6ca <set_axis_setting+0x28a>
                if(settings.axis[idx].steps_per_mm > 0.0f && settings.axis[idx].steps_per_mm != value) {
 801c514:	9b01      	ldr	r3, [sp, #4]
 801c516:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 801c51a:	4a71      	ldr	r2, [pc, #452]	; (801c6e0 <set_axis_setting+0x2a0>)
 801c51c:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 801c520:	edd2 7a0c 	vldr	s15, [r2, #48]	; 0x30
 801c524:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801c528:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c52c:	dd04      	ble.n	801c538 <set_axis_setting+0xf8>
 801c52e:	eef4 7a48 	vcmp.f32	s15, s16
 801c532:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c536:	d109      	bne.n	801c54c <set_axis_setting+0x10c>
                settings.axis[idx].steps_per_mm = value;
 801c538:	9b01      	ldr	r3, [sp, #4]
 801c53a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801c53e:	4a68      	ldr	r2, [pc, #416]	; (801c6e0 <set_axis_setting+0x2a0>)
 801c540:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 801c544:	ed83 8a0c 	vstr	s16, [r3, #48]	; 0x30
    status_code_t status = Status_OK;
 801c548:	2000      	movs	r0, #0
 801c54a:	e0ba      	b.n	801c6c2 <set_axis_setting+0x282>
                    float comp = value / settings.axis[idx].steps_per_mm;
 801c54c:	ee88 7a27 	vdiv.f32	s14, s16, s15
                    sys.position[idx] *= comp;
 801c550:	4c65      	ldr	r4, [pc, #404]	; (801c6e8 <set_axis_setting+0x2a8>)
 801c552:	f103 0222 	add.w	r2, r3, #34	; 0x22
 801c556:	f854 1022 	ldr.w	r1, [r4, r2, lsl #2]
 801c55a:	ee07 1a90 	vmov	s15, r1
 801c55e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801c562:	ee67 7a87 	vmul.f32	s15, s15, s14
 801c566:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801c56a:	ee17 1a90 	vmov	r1, s15
 801c56e:	f844 1022 	str.w	r1, [r4, r2, lsl #2]
                    sys.home_position[idx] *= comp;
 801c572:	f103 0216 	add.w	r2, r3, #22
 801c576:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 801c57a:	edd2 7a00 	vldr	s15, [r2]
 801c57e:	ee67 7a87 	vmul.f32	s15, s15, s14
 801c582:	edc2 7a00 	vstr	s15, [r2]
                    sys.probe_position[idx] *= comp;
 801c586:	f103 020e 	add.w	r2, r3, #14
 801c58a:	f854 1022 	ldr.w	r1, [r4, r2, lsl #2]
 801c58e:	ee07 1a90 	vmov	s15, r1
 801c592:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801c596:	ee67 7a87 	vmul.f32	s15, s15, s14
 801c59a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801c59e:	ee17 1a90 	vmov	r1, s15
 801c5a2:	f844 1022 	str.w	r1, [r4, r2, lsl #2]
                    sys.tlo_reference[idx] *= comp;
 801c5a6:	3302      	adds	r3, #2
 801c5a8:	f854 2023 	ldr.w	r2, [r4, r3, lsl #2]
 801c5ac:	ee07 2a90 	vmov	s15, r2
 801c5b0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801c5b4:	ee67 7a87 	vmul.f32	s15, s15, s14
 801c5b8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801c5bc:	ee17 2a90 	vmov	r2, s15
 801c5c0:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
                    sync_position();
 801c5c4:	f7fa fb5c 	bl	8016c80 <plan_sync_position>
 801c5c8:	f104 0188 	add.w	r1, r4, #136	; 0x88
 801c5cc:	4847      	ldr	r0, [pc, #284]	; (801c6ec <set_axis_setting+0x2ac>)
 801c5ce:	f004 fd05 	bl	8020fdc <system_convert_array_steps_to_mpos>
 801c5d2:	e7b1      	b.n	801c538 <set_axis_setting+0xf8>
            if (hal.max_step_rate && value * settings.axis[idx].steps_per_mm > (float)hal.max_step_rate * 60.0f)
 801c5d4:	4b41      	ldr	r3, [pc, #260]	; (801c6dc <set_axis_setting+0x29c>)
 801c5d6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801c5d8:	b1b3      	cbz	r3, 801c608 <set_axis_setting+0x1c8>
 801c5da:	9a01      	ldr	r2, [sp, #4]
 801c5dc:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 801c5e0:	493f      	ldr	r1, [pc, #252]	; (801c6e0 <set_axis_setting+0x2a0>)
 801c5e2:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 801c5e6:	ed92 7a0c 	vldr	s14, [r2, #48]	; 0x30
 801c5ea:	ee27 7a08 	vmul.f32	s14, s14, s16
 801c5ee:	ee07 3a90 	vmov	s15, r3
 801c5f2:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801c5f6:	eddf 6a3b 	vldr	s13, [pc, #236]	; 801c6e4 <set_axis_setting+0x2a4>
 801c5fa:	ee67 7aa6 	vmul.f32	s15, s15, s13
 801c5fe:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801c602:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c606:	dc62      	bgt.n	801c6ce <set_axis_setting+0x28e>
                settings.axis[idx].max_rate = value;
 801c608:	9b01      	ldr	r3, [sp, #4]
 801c60a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801c60e:	4a34      	ldr	r2, [pc, #208]	; (801c6e0 <set_axis_setting+0x2a0>)
 801c610:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 801c614:	ed83 8a0d 	vstr	s16, [r3, #52]	; 0x34
    status_code_t status = Status_OK;
 801c618:	2000      	movs	r0, #0
 801c61a:	e052      	b.n	801c6c2 <set_axis_setting+0x282>
            settings.axis[idx].acceleration = override_backup.acceleration[idx] = value * 60.0f * 60.0f; // Convert to mm/sec^2 for grbl internal use.
 801c61c:	eddf 7a31 	vldr	s15, [pc, #196]	; 801c6e4 <set_axis_setting+0x2a4>
 801c620:	ee28 0a27 	vmul.f32	s0, s16, s15
 801c624:	9b01      	ldr	r3, [sp, #4]
 801c626:	ee20 0a27 	vmul.f32	s0, s0, s15
 801c62a:	4a31      	ldr	r2, [pc, #196]	; (801c6f0 <set_axis_setting+0x2b0>)
 801c62c:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 801c630:	ed82 0a01 	vstr	s0, [r2, #4]
 801c634:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801c638:	4a29      	ldr	r2, [pc, #164]	; (801c6e0 <set_axis_setting+0x2a0>)
 801c63a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 801c63e:	ed83 0a0e 	vstr	s0, [r3, #56]	; 0x38
    status_code_t status = Status_OK;
 801c642:	2000      	movs	r0, #0
            break;
 801c644:	e03d      	b.n	801c6c2 <set_axis_setting+0x282>
            if(settings.axis[idx].max_travel != -value) {
 801c646:	9a01      	ldr	r2, [sp, #4]
 801c648:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 801c64c:	4b24      	ldr	r3, [pc, #144]	; (801c6e0 <set_axis_setting+0x2a0>)
 801c64e:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 801c652:	edd3 7a0f 	vldr	s15, [r3, #60]	; 0x3c
 801c656:	eeb1 8a48 	vneg.f32	s16, s16
 801c65a:	eef4 7a48 	vcmp.f32	s15, s16
 801c65e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c662:	d114      	bne.n	801c68e <set_axis_setting+0x24e>
            settings.axis[idx].max_travel = -value; // Store as negative for grbl internal use.
 801c664:	9b01      	ldr	r3, [sp, #4]
 801c666:	4a1e      	ldr	r2, [pc, #120]	; (801c6e0 <set_axis_setting+0x2a0>)
 801c668:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801c66c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 801c670:	ed83 8a0f 	vstr	s16, [r3, #60]	; 0x3c
            if(settings.homing.flags.init_lock && (sys.homing.mask & sys.homed.mask) != sys.homing.mask) {
 801c674:	f892 0114 	ldrb.w	r0, [r2, #276]	; 0x114
 801c678:	f010 0004 	ands.w	r0, r0, #4
 801c67c:	d021      	beq.n	801c6c2 <set_axis_setting+0x282>
 801c67e:	4a1a      	ldr	r2, [pc, #104]	; (801c6e8 <set_axis_setting+0x2a8>)
 801c680:	7e93      	ldrb	r3, [r2, #26]
 801c682:	f892 2054 	ldrb.w	r2, [r2, #84]	; 0x54
 801c686:	4393      	bics	r3, r2
 801c688:	d10f      	bne.n	801c6aa <set_axis_setting+0x26a>
    status_code_t status = Status_OK;
 801c68a:	2000      	movs	r0, #0
 801c68c:	e019      	b.n	801c6c2 <set_axis_setting+0x282>
                bit_false(sys.homed.mask, bit(idx));
 801c68e:	2301      	movs	r3, #1
 801c690:	fa03 f202 	lsl.w	r2, r3, r2
 801c694:	4914      	ldr	r1, [pc, #80]	; (801c6e8 <set_axis_setting+0x2a8>)
 801c696:	f891 3054 	ldrb.w	r3, [r1, #84]	; 0x54
 801c69a:	ea23 0302 	bic.w	r3, r3, r2
 801c69e:	f881 3054 	strb.w	r3, [r1, #84]	; 0x54
                system_add_rt_report(Report_Homed);
 801c6a2:	2004      	movs	r0, #4
 801c6a4:	f004 fdcc 	bl	8021240 <system_add_rt_report>
 801c6a8:	e7dc      	b.n	801c664 <set_axis_setting+0x224>
                system_raise_alarm(Alarm_HomingRequired);
 801c6aa:	200b      	movs	r0, #11
 801c6ac:	f004 fd7a 	bl	80211a4 <system_raise_alarm>
                grbl.report.feedback_message(Message_HomingCycleRequired);
 801c6b0:	4b10      	ldr	r3, [pc, #64]	; (801c6f4 <set_axis_setting+0x2b4>)
 801c6b2:	68db      	ldr	r3, [r3, #12]
 801c6b4:	200d      	movs	r0, #13
 801c6b6:	4798      	blx	r3
    status_code_t status = Status_OK;
 801c6b8:	2000      	movs	r0, #0
 801c6ba:	e002      	b.n	801c6c2 <set_axis_setting+0x282>
    switch(settings_get_axis_base(setting, &idx)) {
 801c6bc:	2035      	movs	r0, #53	; 0x35
 801c6be:	e000      	b.n	801c6c2 <set_axis_setting+0x282>
 801c6c0:	2035      	movs	r0, #53	; 0x35
}
 801c6c2:	b002      	add	sp, #8
 801c6c4:	ecbd 8b02 	vpop	{d8}
 801c6c8:	bd10      	pop	{r4, pc}
                status = Status_MaxStepRateExceeded;
 801c6ca:	200c      	movs	r0, #12
 801c6cc:	e7f9      	b.n	801c6c2 <set_axis_setting+0x282>
                status = Status_MaxStepRateExceeded;
 801c6ce:	200c      	movs	r0, #12
 801c6d0:	e7f7      	b.n	801c6c2 <set_axis_setting+0x282>
                status = Status_SettingDisabled;
 801c6d2:	2035      	movs	r0, #53	; 0x35
 801c6d4:	e7f5      	b.n	801c6c2 <set_axis_setting+0x282>
 801c6d6:	2035      	movs	r0, #53	; 0x35
 801c6d8:	e7f3      	b.n	801c6c2 <set_axis_setting+0x282>
 801c6da:	bf00      	nop
 801c6dc:	2000350c 	.word	0x2000350c
 801c6e0:	20003b14 	.word	0x20003b14
 801c6e4:	42700000 	.word	0x42700000
 801c6e8:	200036c4 	.word	0x200036c4
 801c6ec:	200033a4 	.word	0x200033a4
 801c6f0:	20003b04 	.word	0x20003b04
 801c6f4:	2000343c 	.word	0x2000343c

0801c6f8 <setting_get_value>:
{
 801c6f8:	b538      	push	{r3, r4, r5, lr}
 801c6fa:	ed2d 8b02 	vpush	{d8}
    if(setting == NULL)
 801c6fe:	4604      	mov	r4, r0
 801c700:	2800      	cmp	r0, #0
 801c702:	f000 8087 	beq.w	801c814 <setting_get_value+0x11c>
    switch(setting->type) {
 801c706:	7f02      	ldrb	r2, [r0, #28]
 801c708:	2a07      	cmp	r2, #7
 801c70a:	f200 8082 	bhi.w	801c812 <setting_get_value+0x11a>
 801c70e:	2301      	movs	r3, #1
 801c710:	4093      	lsls	r3, r2
 801c712:	f013 0faa 	tst.w	r3, #170	; 0xaa
 801c716:	d142      	bne.n	801c79e <setting_get_value+0xa6>
 801c718:	f013 0f55 	tst.w	r3, #85	; 0x55
 801c71c:	d07d      	beq.n	801c81a <setting_get_value+0x122>
            switch(setting->datatype) {
 801c71e:	7b03      	ldrb	r3, [r0, #12]
 801c720:	2b0b      	cmp	r3, #11
 801c722:	d87c      	bhi.n	801c81e <setting_get_value+0x126>
 801c724:	e8df f003 	tbb	[pc, r3]
 801c728:	22222222 	.word	0x22222222
 801c72c:	39062c22 	.word	0x39062c22
 801c730:	27223931 	.word	0x27223931
                    value = ftoa(*((float *)(setting->value)), get_decimal_places(setting->format));
 801c734:	6a03      	ldr	r3, [r0, #32]
 801c736:	ed93 8a00 	vldr	s16, [r3]
 801c73a:	6904      	ldr	r4, [r0, #16]
    char *dp = format == NULL ? NULL : strchr(format, '.');
 801c73c:	b194      	cbz	r4, 801c764 <setting_get_value+0x6c>
 801c73e:	212e      	movs	r1, #46	; 0x2e
 801c740:	4620      	mov	r0, r4
 801c742:	f006 fa2f 	bl	8022ba4 <strchr>
    return dp ? strchr(format, '\0') - dp - 1 : 1;
 801c746:	4605      	mov	r5, r0
 801c748:	b170      	cbz	r0, 801c768 <setting_get_value+0x70>
 801c74a:	4620      	mov	r0, r4
 801c74c:	f7eb fc82 	bl	8008054 <strlen>
 801c750:	4420      	add	r0, r4
 801c752:	1b40      	subs	r0, r0, r5
 801c754:	b2c0      	uxtb	r0, r0
 801c756:	3801      	subs	r0, #1
 801c758:	b2c0      	uxtb	r0, r0
                    value = ftoa(*((float *)(setting->value)), get_decimal_places(setting->format));
 801c75a:	eeb0 0a48 	vmov.f32	s0, s16
 801c75e:	f7f9 f82d 	bl	80157bc <ftoa>
                    break;
 801c762:	e057      	b.n	801c814 <setting_get_value+0x11c>
    return dp ? strchr(format, '\0') - dp - 1 : 1;
 801c764:	2001      	movs	r0, #1
 801c766:	e7f8      	b.n	801c75a <setting_get_value+0x62>
 801c768:	2001      	movs	r0, #1
 801c76a:	e7f6      	b.n	801c75a <setting_get_value+0x62>
                    value = uitoa(*((uint8_t *)(setting->value)));
 801c76c:	6a03      	ldr	r3, [r0, #32]
 801c76e:	7818      	ldrb	r0, [r3, #0]
 801c770:	f7f9 f802 	bl	8015778 <uitoa>
                    break;
 801c774:	e04e      	b.n	801c814 <setting_get_value+0x11c>
                    value = uitoa(*((uint16_t *)(setting->value)));
 801c776:	6a03      	ldr	r3, [r0, #32]
 801c778:	8818      	ldrh	r0, [r3, #0]
 801c77a:	f7f8 fffd 	bl	8015778 <uitoa>
                    break;
 801c77e:	e049      	b.n	801c814 <setting_get_value+0x11c>
                    value = uitoa(*((uint32_t *)(setting->value)));
 801c780:	6a03      	ldr	r3, [r0, #32]
 801c782:	6818      	ldr	r0, [r3, #0]
 801c784:	f7f8 fff8 	bl	8015778 <uitoa>
                    break;
 801c788:	e044      	b.n	801c814 <setting_get_value+0x11c>
                    value = hal.stream.state.webui_connected ? PASSWORD_MASK : ((char *)(setting->value));
 801c78a:	4b28      	ldr	r3, [pc, #160]	; (801c82c <setting_get_value+0x134>)
 801c78c:	f893 30aa 	ldrb.w	r3, [r3, #170]	; 0xaa
 801c790:	f013 0f02 	tst.w	r3, #2
 801c794:	d145      	bne.n	801c822 <setting_get_value+0x12a>
 801c796:	6a00      	ldr	r0, [r0, #32]
 801c798:	e03c      	b.n	801c814 <setting_get_value+0x11c>
                    value = ((char *)(setting->value));
 801c79a:	6a00      	ldr	r0, [r0, #32]
                    break;
 801c79c:	e03a      	b.n	801c814 <setting_get_value+0x11c>
            setting_id_t id = (setting_id_t)(setting->id + offset);
 801c79e:	8803      	ldrh	r3, [r0, #0]
 801c7a0:	fa13 f181 	uxtah	r1, r3, r1
 801c7a4:	b288      	uxth	r0, r1
            switch(setting->datatype) {
 801c7a6:	7b23      	ldrb	r3, [r4, #12]
 801c7a8:	3b06      	subs	r3, #6
 801c7aa:	2b03      	cmp	r3, #3
 801c7ac:	d82c      	bhi.n	801c808 <setting_get_value+0x110>
 801c7ae:	e8df f003 	tbb	[pc, r3]
 801c7b2:	2802      	.short	0x2802
 801c7b4:	281f      	.short	0x281f
                    value = ftoa(((setting_get_float_ptr)(setting->get_value))(id), get_decimal_places(setting->format));
 801c7b6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801c7b8:	4798      	blx	r3
 801c7ba:	eeb0 8a40 	vmov.f32	s16, s0
 801c7be:	6924      	ldr	r4, [r4, #16]
    char *dp = format == NULL ? NULL : strchr(format, '.');
 801c7c0:	b194      	cbz	r4, 801c7e8 <setting_get_value+0xf0>
 801c7c2:	212e      	movs	r1, #46	; 0x2e
 801c7c4:	4620      	mov	r0, r4
 801c7c6:	f006 f9ed 	bl	8022ba4 <strchr>
    return dp ? strchr(format, '\0') - dp - 1 : 1;
 801c7ca:	4605      	mov	r5, r0
 801c7cc:	b170      	cbz	r0, 801c7ec <setting_get_value+0xf4>
 801c7ce:	4620      	mov	r0, r4
 801c7d0:	f7eb fc40 	bl	8008054 <strlen>
 801c7d4:	4420      	add	r0, r4
 801c7d6:	1b40      	subs	r0, r0, r5
 801c7d8:	b2c0      	uxtb	r0, r0
 801c7da:	3801      	subs	r0, #1
 801c7dc:	b2c0      	uxtb	r0, r0
                    value = ftoa(((setting_get_float_ptr)(setting->get_value))(id), get_decimal_places(setting->format));
 801c7de:	eeb0 0a48 	vmov.f32	s0, s16
 801c7e2:	f7f8 ffeb 	bl	80157bc <ftoa>
                    break;
 801c7e6:	e015      	b.n	801c814 <setting_get_value+0x11c>
    return dp ? strchr(format, '\0') - dp - 1 : 1;
 801c7e8:	2001      	movs	r0, #1
 801c7ea:	e7f8      	b.n	801c7de <setting_get_value+0xe6>
 801c7ec:	2001      	movs	r0, #1
 801c7ee:	e7f6      	b.n	801c7de <setting_get_value+0xe6>
                    value = hal.stream.state.webui_connected ? "********" : ((setting_get_string_ptr)(setting->get_value))(id);
 801c7f0:	4b0e      	ldr	r3, [pc, #56]	; (801c82c <setting_get_value+0x134>)
 801c7f2:	f893 30aa 	ldrb.w	r3, [r3, #170]	; 0xaa
 801c7f6:	f013 0f02 	tst.w	r3, #2
 801c7fa:	d114      	bne.n	801c826 <setting_get_value+0x12e>
 801c7fc:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801c7fe:	4798      	blx	r3
 801c800:	e008      	b.n	801c814 <setting_get_value+0x11c>
                    value = ((setting_get_string_ptr)(setting->get_value))(id);
 801c802:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801c804:	4798      	blx	r3
                    break;
 801c806:	e005      	b.n	801c814 <setting_get_value+0x11c>
                    value = uitoa(((setting_get_int_ptr)(setting->get_value))(id));
 801c808:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801c80a:	4798      	blx	r3
 801c80c:	f7f8 ffb4 	bl	8015778 <uitoa>
                    break;
 801c810:	e000      	b.n	801c814 <setting_get_value+0x11c>
    switch(setting->type) {
 801c812:	2000      	movs	r0, #0
}
 801c814:	ecbd 8b02 	vpop	{d8}
 801c818:	bd38      	pop	{r3, r4, r5, pc}
    switch(setting->type) {
 801c81a:	2000      	movs	r0, #0
 801c81c:	e7fa      	b.n	801c814 <setting_get_value+0x11c>
 801c81e:	2000      	movs	r0, #0
 801c820:	e7f8      	b.n	801c814 <setting_get_value+0x11c>
                    value = hal.stream.state.webui_connected ? PASSWORD_MASK : ((char *)(setting->value));
 801c822:	4803      	ldr	r0, [pc, #12]	; (801c830 <setting_get_value+0x138>)
 801c824:	e7f6      	b.n	801c814 <setting_get_value+0x11c>
                    value = hal.stream.state.webui_connected ? "********" : ((setting_get_string_ptr)(setting->get_value))(id);
 801c826:	4802      	ldr	r0, [pc, #8]	; (801c830 <setting_get_value+0x138>)
 801c828:	e7f4      	b.n	801c814 <setting_get_value+0x11c>
 801c82a:	bf00      	nop
 801c82c:	2000350c 	.word	0x2000350c
 801c830:	080283ec 	.word	0x080283ec

0801c834 <setting_get_int_value>:
    if(setting) switch(setting->type) {
 801c834:	b358      	cbz	r0, 801c88e <setting_get_int_value+0x5a>
{
 801c836:	b508      	push	{r3, lr}
 801c838:	4603      	mov	r3, r0
    if(setting) switch(setting->type) {
 801c83a:	7f00      	ldrb	r0, [r0, #28]
 801c83c:	2807      	cmp	r0, #7
 801c83e:	d828      	bhi.n	801c892 <setting_get_int_value+0x5e>
 801c840:	2201      	movs	r2, #1
 801c842:	4082      	lsls	r2, r0
 801c844:	f012 0faa 	tst.w	r2, #170	; 0xaa
 801c848:	d116      	bne.n	801c878 <setting_get_int_value+0x44>
 801c84a:	f012 0f55 	tst.w	r2, #85	; 0x55
 801c84e:	d022      	beq.n	801c896 <setting_get_int_value+0x62>
            switch(setting->datatype) {
 801c850:	7b1a      	ldrb	r2, [r3, #12]
 801c852:	2a0b      	cmp	r2, #11
 801c854:	d821      	bhi.n	801c89a <setting_get_int_value+0x66>
 801c856:	e8df f002 	tbb	[pc, r2]
 801c85a:	0606      	.short	0x0606
 801c85c:	0c060606 	.word	0x0c060606
 801c860:	20202020 	.word	0x20202020
 801c864:	0906      	.short	0x0906
                    value = *((uint8_t *)(setting->value));
 801c866:	6a1b      	ldr	r3, [r3, #32]
 801c868:	7818      	ldrb	r0, [r3, #0]
                    break;
 801c86a:	e013      	b.n	801c894 <setting_get_int_value+0x60>
                    value = *((uint16_t *)(setting->value));
 801c86c:	6a1b      	ldr	r3, [r3, #32]
 801c86e:	8818      	ldrh	r0, [r3, #0]
                    break;
 801c870:	e010      	b.n	801c894 <setting_get_int_value+0x60>
                    value = *((uint32_t *)(setting->value));
 801c872:	6a1b      	ldr	r3, [r3, #32]
 801c874:	6818      	ldr	r0, [r3, #0]
                    break;
 801c876:	e00d      	b.n	801c894 <setting_get_int_value+0x60>
            switch(setting->datatype) {
 801c878:	7b1a      	ldrb	r2, [r3, #12]
 801c87a:	3a06      	subs	r2, #6
 801c87c:	2a03      	cmp	r2, #3
 801c87e:	d90e      	bls.n	801c89e <setting_get_int_value+0x6a>
                    value = ((setting_get_int_ptr)(setting->get_value))((setting_id_t)(setting->id + offset));
 801c880:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 801c882:	881b      	ldrh	r3, [r3, #0]
 801c884:	fa13 f181 	uxtah	r1, r3, r1
 801c888:	b288      	uxth	r0, r1
 801c88a:	4790      	blx	r2
                    break;
 801c88c:	e002      	b.n	801c894 <setting_get_int_value+0x60>
    uint32_t value = 0;
 801c88e:	2000      	movs	r0, #0
}
 801c890:	4770      	bx	lr
    if(setting) switch(setting->type) {
 801c892:	2000      	movs	r0, #0
}
 801c894:	bd08      	pop	{r3, pc}
    if(setting) switch(setting->type) {
 801c896:	2000      	movs	r0, #0
 801c898:	e7fc      	b.n	801c894 <setting_get_int_value+0x60>
 801c89a:	2000      	movs	r0, #0
 801c89c:	e7fa      	b.n	801c894 <setting_get_int_value+0x60>
    uint32_t value = 0;
 801c89e:	2000      	movs	r0, #0
    return value;
 801c8a0:	e7f8      	b.n	801c894 <setting_get_int_value+0x60>
	...

0801c8a4 <settings_write_build_info>:
    if(hal.nvs.type != NVS_None)
 801c8a4:	4b07      	ldr	r3, [pc, #28]	; (801c8c4 <settings_write_build_info+0x20>)
 801c8a6:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 801c8aa:	b153      	cbz	r3, 801c8c2 <settings_write_build_info+0x1e>
{
 801c8ac:	b510      	push	{r4, lr}
 801c8ae:	4601      	mov	r1, r0
        hal.nvs.memcpy_to_nvs(NVS_ADDR_BUILD_INFO, (uint8_t *)line, sizeof(stored_line_t), true);
 801c8b0:	4b04      	ldr	r3, [pc, #16]	; (801c8c4 <settings_write_build_info+0x20>)
 801c8b2:	f8d3 4160 	ldr.w	r4, [r3, #352]	; 0x160
 801c8b6:	2301      	movs	r3, #1
 801c8b8:	2246      	movs	r2, #70	; 0x46
 801c8ba:	f240 30ae 	movw	r0, #942	; 0x3ae
 801c8be:	47a0      	blx	r4
}
 801c8c0:	bd10      	pop	{r4, pc}
 801c8c2:	4770      	bx	lr
 801c8c4:	2000350c 	.word	0x2000350c

0801c8c8 <settings_read_build_info>:
{
 801c8c8:	b538      	push	{r3, r4, r5, lr}
 801c8ca:	4604      	mov	r4, r0
    if (!(hal.nvs.type != NVS_None && hal.nvs.memcpy_from_nvs((uint8_t *)line, NVS_ADDR_BUILD_INFO, sizeof(stored_line_t), true) == NVS_TransferResult_OK)) {
 801c8cc:	4b0b      	ldr	r3, [pc, #44]	; (801c8fc <settings_read_build_info+0x34>)
 801c8ce:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 801c8d2:	b14b      	cbz	r3, 801c8e8 <settings_read_build_info+0x20>
 801c8d4:	4b09      	ldr	r3, [pc, #36]	; (801c8fc <settings_read_build_info+0x34>)
 801c8d6:	f8d3 5164 	ldr.w	r5, [r3, #356]	; 0x164
 801c8da:	2301      	movs	r3, #1
 801c8dc:	2246      	movs	r2, #70	; 0x46
 801c8de:	f240 31ae 	movw	r1, #942	; 0x3ae
 801c8e2:	47a8      	blx	r5
 801c8e4:	2802      	cmp	r0, #2
 801c8e6:	d006      	beq.n	801c8f6 <settings_read_build_info+0x2e>
        line[0] = 0; // Empty line
 801c8e8:	2500      	movs	r5, #0
 801c8ea:	7025      	strb	r5, [r4, #0]
        settings_write_build_info(line);
 801c8ec:	4620      	mov	r0, r4
 801c8ee:	f7ff ffd9 	bl	801c8a4 <settings_write_build_info>
        return false;
 801c8f2:	4628      	mov	r0, r5
}
 801c8f4:	bd38      	pop	{r3, r4, r5, pc}
    return true;
 801c8f6:	2001      	movs	r0, #1
 801c8f8:	e7fc      	b.n	801c8f4 <settings_read_build_info+0x2c>
 801c8fa:	bf00      	nop
 801c8fc:	2000350c 	.word	0x2000350c

0801c900 <settings_write_startup_line>:
{
 801c900:	b510      	push	{r4, lr}
    assert(idx < N_STARTUP_LINE);
 801c902:	2801      	cmp	r0, #1
 801c904:	d810      	bhi.n	801c928 <settings_write_startup_line+0x28>
    if(hal.nvs.type != NVS_None)
 801c906:	4b0c      	ldr	r3, [pc, #48]	; (801c938 <settings_write_startup_line+0x38>)
 801c908:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 801c90c:	b15b      	cbz	r3, 801c926 <settings_write_startup_line+0x26>
        hal.nvs.memcpy_to_nvs(NVS_ADDR_STARTUP_BLOCK + idx * (sizeof(stored_line_t) + NVS_CRC_BYTES), (uint8_t *)line, sizeof(stored_line_t), true);
 801c90e:	4b0a      	ldr	r3, [pc, #40]	; (801c938 <settings_write_startup_line+0x38>)
 801c910:	f8d3 4160 	ldr.w	r4, [r3, #352]	; 0x160
 801c914:	eb00 03c0 	add.w	r3, r0, r0, lsl #3
 801c918:	ebc0 00c3 	rsb	r0, r0, r3, lsl #3
 801c91c:	2301      	movs	r3, #1
 801c91e:	2246      	movs	r2, #70	; 0x46
 801c920:	f200 301f 	addw	r0, r0, #799	; 0x31f
 801c924:	47a0      	blx	r4
}
 801c926:	bd10      	pop	{r4, pc}
    assert(idx < N_STARTUP_LINE);
 801c928:	4b04      	ldr	r3, [pc, #16]	; (801c93c <settings_write_startup_line+0x3c>)
 801c92a:	4a05      	ldr	r2, [pc, #20]	; (801c940 <settings_write_startup_line+0x40>)
 801c92c:	f240 7175 	movw	r1, #1909	; 0x775
 801c930:	4804      	ldr	r0, [pc, #16]	; (801c944 <settings_write_startup_line+0x44>)
 801c932:	f005 fd81 	bl	8022438 <__assert_func>
 801c936:	bf00      	nop
 801c938:	2000350c 	.word	0x2000350c
 801c93c:	080283f8 	.word	0x080283f8
 801c940:	0802add0 	.word	0x0802add0
 801c944:	08028410 	.word	0x08028410

0801c948 <settings_read_startup_line>:
{
 801c948:	b570      	push	{r4, r5, r6, lr}
    assert(idx < N_STARTUP_LINE);
 801c94a:	2801      	cmp	r0, #1
 801c94c:	d81c      	bhi.n	801c988 <settings_read_startup_line+0x40>
 801c94e:	4604      	mov	r4, r0
 801c950:	460d      	mov	r5, r1
    if (!(hal.nvs.type != NVS_None && hal.nvs.memcpy_from_nvs((uint8_t *)line, NVS_ADDR_STARTUP_BLOCK + idx * (sizeof(stored_line_t) + NVS_CRC_BYTES), sizeof(stored_line_t), true) == NVS_TransferResult_OK)) {
 801c952:	4b12      	ldr	r3, [pc, #72]	; (801c99c <settings_read_startup_line+0x54>)
 801c954:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 801c958:	b173      	cbz	r3, 801c978 <settings_read_startup_line+0x30>
 801c95a:	4b10      	ldr	r3, [pc, #64]	; (801c99c <settings_read_startup_line+0x54>)
 801c95c:	f8d3 6164 	ldr.w	r6, [r3, #356]	; 0x164
 801c960:	eb00 01c0 	add.w	r1, r0, r0, lsl #3
 801c964:	ebc0 01c1 	rsb	r1, r0, r1, lsl #3
 801c968:	2301      	movs	r3, #1
 801c96a:	2246      	movs	r2, #70	; 0x46
 801c96c:	f201 311f 	addw	r1, r1, #799	; 0x31f
 801c970:	4628      	mov	r0, r5
 801c972:	47b0      	blx	r6
 801c974:	2802      	cmp	r0, #2
 801c976:	d00e      	beq.n	801c996 <settings_read_startup_line+0x4e>
        *line = '\0'; // Empty line
 801c978:	2600      	movs	r6, #0
 801c97a:	702e      	strb	r6, [r5, #0]
        settings_write_startup_line(idx, line);
 801c97c:	4629      	mov	r1, r5
 801c97e:	4620      	mov	r0, r4
 801c980:	f7ff ffbe 	bl	801c900 <settings_write_startup_line>
        return false;
 801c984:	4630      	mov	r0, r6
}
 801c986:	bd70      	pop	{r4, r5, r6, pc}
    assert(idx < N_STARTUP_LINE);
 801c988:	4b05      	ldr	r3, [pc, #20]	; (801c9a0 <settings_read_startup_line+0x58>)
 801c98a:	4a06      	ldr	r2, [pc, #24]	; (801c9a4 <settings_read_startup_line+0x5c>)
 801c98c:	f240 7182 	movw	r1, #1922	; 0x782
 801c990:	4805      	ldr	r0, [pc, #20]	; (801c9a8 <settings_read_startup_line+0x60>)
 801c992:	f005 fd51 	bl	8022438 <__assert_func>
    return true;
 801c996:	2001      	movs	r0, #1
 801c998:	e7f5      	b.n	801c986 <settings_read_startup_line+0x3e>
 801c99a:	bf00      	nop
 801c99c:	2000350c 	.word	0x2000350c
 801c9a0:	080283f8 	.word	0x080283f8
 801c9a4:	0802adb4 	.word	0x0802adb4
 801c9a8:	08028410 	.word	0x08028410

0801c9ac <settings_write_coord_data>:
{
 801c9ac:	b510      	push	{r4, lr}
    assert(id <= N_CoordinateSystems);
 801c9ae:	280c      	cmp	r0, #12
 801c9b0:	d810      	bhi.n	801c9d4 <settings_write_coord_data+0x28>
    if(hal.nvs.type != NVS_None)
 801c9b2:	4b0c      	ldr	r3, [pc, #48]	; (801c9e4 <settings_write_coord_data+0x38>)
 801c9b4:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 801c9b8:	b15b      	cbz	r3, 801c9d2 <settings_write_coord_data+0x26>
        hal.nvs.memcpy_to_nvs(NVS_ADDR_PARAMETERS + id * (sizeof(coord_data_t) + NVS_CRC_BYTES), (uint8_t *)coord_data, sizeof(coord_data_t), true);
 801c9ba:	4b0a      	ldr	r3, [pc, #40]	; (801c9e4 <settings_write_coord_data+0x38>)
 801c9bc:	f8d3 4160 	ldr.w	r4, [r3, #352]	; 0x160
 801c9c0:	eb00 0340 	add.w	r3, r0, r0, lsl #1
 801c9c4:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 801c9c8:	2301      	movs	r3, #1
 801c9ca:	220c      	movs	r2, #12
 801c9cc:	f500 7000 	add.w	r0, r0, #512	; 0x200
 801c9d0:	47a0      	blx	r4
}
 801c9d2:	bd10      	pop	{r4, pc}
    assert(id <= N_CoordinateSystems);
 801c9d4:	4b04      	ldr	r3, [pc, #16]	; (801c9e8 <settings_write_coord_data+0x3c>)
 801c9d6:	4a05      	ldr	r2, [pc, #20]	; (801c9ec <settings_write_coord_data+0x40>)
 801c9d8:	f44f 61f2 	mov.w	r1, #1936	; 0x790
 801c9dc:	4804      	ldr	r0, [pc, #16]	; (801c9f0 <settings_write_coord_data+0x44>)
 801c9de:	f005 fd2b 	bl	8022438 <__assert_func>
 801c9e2:	bf00      	nop
 801c9e4:	2000350c 	.word	0x2000350c
 801c9e8:	08028424 	.word	0x08028424
 801c9ec:	0802ad98 	.word	0x0802ad98
 801c9f0:	08028410 	.word	0x08028410

0801c9f4 <settings_read_coord_data>:
{
 801c9f4:	b570      	push	{r4, r5, r6, lr}
    assert(id <= N_CoordinateSystems);
 801c9f6:	280c      	cmp	r0, #12
 801c9f8:	d81e      	bhi.n	801ca38 <settings_read_coord_data+0x44>
 801c9fa:	4604      	mov	r4, r0
 801c9fc:	460d      	mov	r5, r1
    if (!(hal.nvs.type != NVS_None && hal.nvs.memcpy_from_nvs((uint8_t *)coord_data, NVS_ADDR_PARAMETERS + id * (sizeof(coord_data_t) + NVS_CRC_BYTES), sizeof(coord_data_t), true) == NVS_TransferResult_OK)) {
 801c9fe:	4b13      	ldr	r3, [pc, #76]	; (801ca4c <settings_read_coord_data+0x58>)
 801ca00:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 801ca04:	b173      	cbz	r3, 801ca24 <settings_read_coord_data+0x30>
 801ca06:	4b11      	ldr	r3, [pc, #68]	; (801ca4c <settings_read_coord_data+0x58>)
 801ca08:	f8d3 6164 	ldr.w	r6, [r3, #356]	; 0x164
 801ca0c:	eb00 0140 	add.w	r1, r0, r0, lsl #1
 801ca10:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 801ca14:	2301      	movs	r3, #1
 801ca16:	220c      	movs	r2, #12
 801ca18:	f501 7100 	add.w	r1, r1, #512	; 0x200
 801ca1c:	4628      	mov	r0, r5
 801ca1e:	47b0      	blx	r6
 801ca20:	2802      	cmp	r0, #2
 801ca22:	d010      	beq.n	801ca46 <settings_read_coord_data+0x52>
        memset(coord_data, 0, sizeof(coord_data_t));
 801ca24:	2600      	movs	r6, #0
 801ca26:	602e      	str	r6, [r5, #0]
 801ca28:	606e      	str	r6, [r5, #4]
 801ca2a:	60ae      	str	r6, [r5, #8]
        settings_write_coord_data(id, coord_data);
 801ca2c:	4629      	mov	r1, r5
 801ca2e:	4620      	mov	r0, r4
 801ca30:	f7ff ffbc 	bl	801c9ac <settings_write_coord_data>
        return false;
 801ca34:	4630      	mov	r0, r6
}
 801ca36:	bd70      	pop	{r4, r5, r6, pc}
    assert(id <= N_CoordinateSystems);
 801ca38:	4b05      	ldr	r3, [pc, #20]	; (801ca50 <settings_read_coord_data+0x5c>)
 801ca3a:	4a06      	ldr	r2, [pc, #24]	; (801ca54 <settings_read_coord_data+0x60>)
 801ca3c:	f240 719d 	movw	r1, #1949	; 0x79d
 801ca40:	4805      	ldr	r0, [pc, #20]	; (801ca58 <settings_read_coord_data+0x64>)
 801ca42:	f005 fcf9 	bl	8022438 <__assert_func>
    return true;
 801ca46:	2001      	movs	r0, #1
 801ca48:	e7f5      	b.n	801ca36 <settings_read_coord_data+0x42>
 801ca4a:	bf00      	nop
 801ca4c:	2000350c 	.word	0x2000350c
 801ca50:	08028424 	.word	0x08028424
 801ca54:	0802ad7c 	.word	0x0802ad7c
 801ca58:	08028410 	.word	0x08028410

0801ca5c <read_global_settings>:
{
 801ca5c:	b538      	push	{r3, r4, r5, lr}
    bool ok = hal.nvs.type != NVS_None && SETTINGS_VERSION == hal.nvs.get_byte(0) && hal.nvs.memcpy_from_nvs((uint8_t *)&settings, NVS_ADDR_GLOBAL, sizeof(settings_t), true) == NVS_TransferResult_OK;
 801ca5e:	4b2d      	ldr	r3, [pc, #180]	; (801cb14 <read_global_settings+0xb8>)
 801ca60:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 801ca64:	b1bb      	cbz	r3, 801ca96 <read_global_settings+0x3a>
 801ca66:	4b2b      	ldr	r3, [pc, #172]	; (801cb14 <read_global_settings+0xb8>)
 801ca68:	f8d3 3158 	ldr.w	r3, [r3, #344]	; 0x158
 801ca6c:	2000      	movs	r0, #0
 801ca6e:	4798      	blx	r3
 801ca70:	2816      	cmp	r0, #22
 801ca72:	d001      	beq.n	801ca78 <read_global_settings+0x1c>
 801ca74:	2500      	movs	r5, #0
 801ca76:	e00f      	b.n	801ca98 <read_global_settings+0x3c>
 801ca78:	4b26      	ldr	r3, [pc, #152]	; (801cb14 <read_global_settings+0xb8>)
 801ca7a:	f8d3 4164 	ldr.w	r4, [r3, #356]	; 0x164
 801ca7e:	2301      	movs	r3, #1
 801ca80:	f44f 72b6 	mov.w	r2, #364	; 0x16c
 801ca84:	4619      	mov	r1, r3
 801ca86:	4824      	ldr	r0, [pc, #144]	; (801cb18 <read_global_settings+0xbc>)
 801ca88:	47a0      	blx	r4
 801ca8a:	2802      	cmp	r0, #2
 801ca8c:	d001      	beq.n	801ca92 <read_global_settings+0x36>
 801ca8e:	2500      	movs	r5, #0
 801ca90:	e002      	b.n	801ca98 <read_global_settings+0x3c>
 801ca92:	2501      	movs	r5, #1
 801ca94:	e000      	b.n	801ca98 <read_global_settings+0x3c>
 801ca96:	2500      	movs	r5, #0
    if(settings.mode == Mode_Laser && !spindle_get_caps(false).laser)
 801ca98:	4b1f      	ldr	r3, [pc, #124]	; (801cb18 <read_global_settings+0xbc>)
 801ca9a:	7e1b      	ldrb	r3, [r3, #24]
 801ca9c:	2b01      	cmp	r3, #1
 801ca9e:	d02b      	beq.n	801caf8 <read_global_settings+0x9c>
    if(settings.spindle.flags.type >= spindle_get_count())
 801caa0:	4b1d      	ldr	r3, [pc, #116]	; (801cb18 <read_global_settings+0xbc>)
 801caa2:	f893 40e7 	ldrb.w	r4, [r3, #231]	; 0xe7
 801caa6:	f3c4 0484 	ubfx	r4, r4, #2, #5
 801caaa:	f000 ffad 	bl	801da08 <spindle_get_count>
 801caae:	4284      	cmp	r4, r0
 801cab0:	db06      	blt.n	801cac0 <read_global_settings+0x64>
        settings.spindle.flags.type = 0;
 801cab2:	4b19      	ldr	r3, [pc, #100]	; (801cb18 <read_global_settings+0xbc>)
 801cab4:	f893 20e7 	ldrb.w	r2, [r3, #231]	; 0xe7
 801cab8:	f36f 0286 	bfc	r2, #2, #5
 801cabc:	f883 20e7 	strb.w	r2, [r3, #231]	; 0xe7
    if(settings.planner_buffer_blocks < 30 || settings.planner_buffer_blocks > 1000)
 801cac0:	4b15      	ldr	r3, [pc, #84]	; (801cb18 <read_global_settings+0xbc>)
 801cac2:	8adb      	ldrh	r3, [r3, #22]
 801cac4:	3b1e      	subs	r3, #30
 801cac6:	b29b      	uxth	r3, r3
 801cac8:	f240 32ca 	movw	r2, #970	; 0x3ca
 801cacc:	4293      	cmp	r3, r2
 801cace:	d902      	bls.n	801cad6 <read_global_settings+0x7a>
        settings.planner_buffer_blocks = 35;
 801cad0:	4b11      	ldr	r3, [pc, #68]	; (801cb18 <read_global_settings+0xbc>)
 801cad2:	2223      	movs	r2, #35	; 0x23
 801cad4:	82da      	strh	r2, [r3, #22]
    if(!(hal.driver_cap.spindle_sync || hal.driver_cap.spindle_pid))
 801cad6:	4b0f      	ldr	r3, [pc, #60]	; (801cb14 <read_global_settings+0xb8>)
 801cad8:	f893 31a5 	ldrb.w	r3, [r3, #421]	; 0x1a5
 801cadc:	f013 0f21 	tst.w	r3, #33	; 0x21
 801cae0:	d103      	bne.n	801caea <read_global_settings+0x8e>
        settings.spindle.ppr = 0;
 801cae2:	4b0d      	ldr	r3, [pc, #52]	; (801cb18 <read_global_settings+0xbc>)
 801cae4:	2200      	movs	r2, #0
 801cae6:	f8a3 20e4 	strh.w	r2, [r3, #228]	; 0xe4
    return ok && settings.version == SETTINGS_VERSION;
 801caea:	b17d      	cbz	r5, 801cb0c <read_global_settings+0xb0>
 801caec:	4b0a      	ldr	r3, [pc, #40]	; (801cb18 <read_global_settings+0xbc>)
 801caee:	681b      	ldr	r3, [r3, #0]
 801caf0:	2b16      	cmp	r3, #22
 801caf2:	d00d      	beq.n	801cb10 <read_global_settings+0xb4>
 801caf4:	2000      	movs	r0, #0
 801caf6:	e00a      	b.n	801cb0e <read_global_settings+0xb2>
    if(settings.mode == Mode_Laser && !spindle_get_caps(false).laser)
 801caf8:	2000      	movs	r0, #0
 801cafa:	f000 fe71 	bl	801d7e0 <spindle_get_caps>
 801cafe:	f010 0f08 	tst.w	r0, #8
 801cb02:	d1cd      	bne.n	801caa0 <read_global_settings+0x44>
        settings.mode = Mode_Standard;
 801cb04:	4b04      	ldr	r3, [pc, #16]	; (801cb18 <read_global_settings+0xbc>)
 801cb06:	2200      	movs	r2, #0
 801cb08:	761a      	strb	r2, [r3, #24]
 801cb0a:	e7c9      	b.n	801caa0 <read_global_settings+0x44>
    return ok && settings.version == SETTINGS_VERSION;
 801cb0c:	2000      	movs	r0, #0
}
 801cb0e:	bd38      	pop	{r3, r4, r5, pc}
    return ok && settings.version == SETTINGS_VERSION;
 801cb10:	2001      	movs	r0, #1
 801cb12:	e7fc      	b.n	801cb0e <read_global_settings+0xb2>
 801cb14:	2000350c 	.word	0x2000350c
 801cb18:	20003b14 	.word	0x20003b14

0801cb1c <settings_restore>:
{
 801cb1c:	b530      	push	{r4, r5, lr}
 801cb1e:	b097      	sub	sp, #92	; 0x5c
 801cb20:	4604      	mov	r4, r0
    memset(empty_line, 0xFF, sizeof(stored_line_t));
 801cb22:	2246      	movs	r2, #70	; 0x46
 801cb24:	21ff      	movs	r1, #255	; 0xff
 801cb26:	a804      	add	r0, sp, #16
 801cb28:	f006 f825 	bl	8022b76 <memset>
    *empty_line = '\0';
 801cb2c:	2000      	movs	r0, #0
 801cb2e:	f88d 0010 	strb.w	r0, [sp, #16]
    hal.nvs.put_byte(0, SETTINGS_VERSION); // Forces write to physical storage
 801cb32:	4b33      	ldr	r3, [pc, #204]	; (801cc00 <settings_restore+0xe4>)
 801cb34:	f8d3 315c 	ldr.w	r3, [r3, #348]	; 0x15c
 801cb38:	2116      	movs	r1, #22
 801cb3a:	4798      	blx	r3
    if (restore.defaults) {
 801cb3c:	b2e5      	uxtb	r5, r4
 801cb3e:	f014 0f01 	tst.w	r4, #1
 801cb42:	d110      	bne.n	801cb66 <settings_restore+0x4a>
    if (restore.parameters) {
 801cb44:	f015 0f02 	tst.w	r5, #2
 801cb48:	d131      	bne.n	801cbae <settings_restore+0x92>
    if (restore.startup_lines) {
 801cb4a:	f015 0f04 	tst.w	r5, #4
 801cb4e:	d13f      	bne.n	801cbd0 <settings_restore+0xb4>
    if (restore.build_info) {
 801cb50:	f015 0f08 	tst.w	r5, #8
 801cb54:	d145      	bne.n	801cbe2 <settings_restore+0xc6>
    setting_details_t *details = setting_details.next;
 801cb56:	4b2b      	ldr	r3, [pc, #172]	; (801cc04 <settings_restore+0xe8>)
 801cb58:	699c      	ldr	r4, [r3, #24]
    if(details) do {
 801cb5a:	2c00      	cmp	r4, #0
 801cb5c:	d14c      	bne.n	801cbf8 <settings_restore+0xdc>
    nvs_buffer_sync_physical();
 801cb5e:	f7f9 fab7 	bl	80160d0 <nvs_buffer_sync_physical>
}
 801cb62:	b017      	add	sp, #92	; 0x5c
 801cb64:	bd30      	pop	{r4, r5, pc}
        memcpy(&settings, &defaults, sizeof(settings_t));
 801cb66:	4c28      	ldr	r4, [pc, #160]	; (801cc08 <settings_restore+0xec>)
 801cb68:	f44f 72b6 	mov.w	r2, #364	; 0x16c
 801cb6c:	4927      	ldr	r1, [pc, #156]	; (801cc0c <settings_restore+0xf0>)
 801cb6e:	4620      	mov	r0, r4
 801cb70:	f006 f95e 	bl	8022e30 <memcpy>
        settings.spindle.invert.ccw &= spindle_get_caps(false).direction;
 801cb74:	2000      	movs	r0, #0
 801cb76:	f000 fe33 	bl	801d7e0 <spindle_get_caps>
 801cb7a:	f894 30e6 	ldrb.w	r3, [r4, #230]	; 0xe6
 801cb7e:	f3c3 0240 	ubfx	r2, r3, #1, #1
 801cb82:	ea02 0250 	and.w	r2, r2, r0, lsr #1
 801cb86:	f362 0341 	bfi	r3, r2, #1, #1
 801cb8a:	f884 30e6 	strb.w	r3, [r4, #230]	; 0xe6
        settings.spindle.invert.pwm &= spindle_get_caps(false).pwm_invert;
 801cb8e:	2000      	movs	r0, #0
 801cb90:	f000 fe26 	bl	801d7e0 <spindle_get_caps>
 801cb94:	f894 30e6 	ldrb.w	r3, [r4, #230]	; 0xe6
 801cb98:	f3c3 0280 	ubfx	r2, r3, #2, #1
 801cb9c:	ea02 1210 	and.w	r2, r2, r0, lsr #4
 801cba0:	f362 0382 	bfi	r3, r2, #2, #1
 801cba4:	f884 30e6 	strb.w	r3, [r4, #230]	; 0xe6
        settings_write_global();
 801cba8:	f7ff f86a 	bl	801bc80 <settings_write_global>
 801cbac:	e7ca      	b.n	801cb44 <settings_restore+0x28>
        memset(coord_data, 0, sizeof(coord_data));
 801cbae:	2400      	movs	r4, #0
 801cbb0:	9401      	str	r4, [sp, #4]
 801cbb2:	9402      	str	r4, [sp, #8]
 801cbb4:	9403      	str	r4, [sp, #12]
        for (idx = 0; idx <= N_WorkCoordinateSystems; idx++)
 801cbb6:	e004      	b.n	801cbc2 <settings_restore+0xa6>
            settings_write_coord_data((coord_system_id_t)idx, &coord_data);
 801cbb8:	a901      	add	r1, sp, #4
 801cbba:	b2e0      	uxtb	r0, r4
 801cbbc:	f7ff fef6 	bl	801c9ac <settings_write_coord_data>
        for (idx = 0; idx <= N_WorkCoordinateSystems; idx++)
 801cbc0:	3401      	adds	r4, #1
 801cbc2:	2c09      	cmp	r4, #9
 801cbc4:	d9f8      	bls.n	801cbb8 <settings_restore+0x9c>
        settings_write_coord_data(CoordinateSystem_G92, &coord_data); // Clear G92 offsets
 801cbc6:	a901      	add	r1, sp, #4
 801cbc8:	200b      	movs	r0, #11
 801cbca:	f7ff feef 	bl	801c9ac <settings_write_coord_data>
 801cbce:	e7bc      	b.n	801cb4a <settings_restore+0x2e>
        for (idx = 0; idx < N_STARTUP_LINE; idx++)
 801cbd0:	2400      	movs	r4, #0
 801cbd2:	2c01      	cmp	r4, #1
 801cbd4:	d8bc      	bhi.n	801cb50 <settings_restore+0x34>
            settings_write_startup_line(idx, empty_line);
 801cbd6:	a904      	add	r1, sp, #16
 801cbd8:	b2e0      	uxtb	r0, r4
 801cbda:	f7ff fe91 	bl	801c900 <settings_write_startup_line>
        for (idx = 0; idx < N_STARTUP_LINE; idx++)
 801cbde:	3401      	adds	r4, #1
 801cbe0:	e7f7      	b.n	801cbd2 <settings_restore+0xb6>
        settings_write_build_info(empty_line);
 801cbe2:	a804      	add	r0, sp, #16
 801cbe4:	f7ff fe5e 	bl	801c8a4 <settings_write_build_info>
        settings_write_build_info(BUILD_INFO);
 801cbe8:	4809      	ldr	r0, [pc, #36]	; (801cc10 <settings_restore+0xf4>)
 801cbea:	f7ff fe5b 	bl	801c8a4 <settings_write_build_info>
 801cbee:	e7b2      	b.n	801cb56 <settings_restore+0x3a>
            details->restore();
 801cbf0:	4798      	blx	r3
    } while((details = details->next));
 801cbf2:	69a4      	ldr	r4, [r4, #24]
 801cbf4:	2c00      	cmp	r4, #0
 801cbf6:	d0b2      	beq.n	801cb5e <settings_restore+0x42>
        if(details->restore)
 801cbf8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 801cbfa:	2b00      	cmp	r3, #0
 801cbfc:	d1f8      	bne.n	801cbf0 <settings_restore+0xd4>
 801cbfe:	e7f8      	b.n	801cbf2 <settings_restore+0xd6>
 801cc00:	2000350c 	.word	0x2000350c
 801cc04:	200004b4 	.word	0x200004b4
 801cc08:	20003b14 	.word	0x20003b14
 801cc0c:	0802adec 	.word	0x0802adec
 801cc10:	080274a0 	.word	0x080274a0

0801cc14 <settings_normalize_group>:
    return (group > Group_Axis0 && group < Group_Axis0 + N_AXIS) ? Group_Axis0 : group;
 801cc14:	f1a0 032c 	sub.w	r3, r0, #44	; 0x2c
 801cc18:	b2db      	uxtb	r3, r3
 801cc1a:	2b01      	cmp	r3, #1
 801cc1c:	d900      	bls.n	801cc20 <settings_normalize_group+0xc>
}
 801cc1e:	4770      	bx	lr
    return (group > Group_Axis0 && group < Group_Axis0 + N_AXIS) ? Group_Axis0 : group;
 801cc20:	202b      	movs	r0, #43	; 0x2b
 801cc22:	e7fc      	b.n	801cc1e <settings_normalize_group+0xa>

0801cc24 <setting_get_details>:
{
 801cc24:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 801cc28:	4607      	mov	r7, r0
 801cc2a:	4688      	mov	r8, r1
    uint_fast16_t idx, offset = id - normalize_id(id);
 801cc2c:	4681      	mov	r9, r0
    if((id > Setting_AxisSettingsBase && id <= Setting_AxisSettingsMax) ||
 801cc2e:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 801cc32:	b29b      	uxth	r3, r3
 801cc34:	2b5c      	cmp	r3, #92	; 0x5c
 801cc36:	d904      	bls.n	801cc42 <setting_get_details+0x1e>
       (id > Setting_AxisSettingsBase2 && id <= Setting_AxisSettingsMax2))
 801cc38:	f1a0 03c9 	sub.w	r3, r0, #201	; 0xc9
 801cc3c:	b29b      	uxth	r3, r3
    if((id > Setting_AxisSettingsBase && id <= Setting_AxisSettingsMax) ||
 801cc3e:	2b5c      	cmp	r3, #92	; 0x5c
 801cc40:	d80d      	bhi.n	801cc5e <setting_get_details+0x3a>
        id -= id % AXIS_SETTINGS_INCREMENT;
 801cc42:	4b37      	ldr	r3, [pc, #220]	; (801cd20 <setting_get_details+0xfc>)
 801cc44:	fba3 7307 	umull	r7, r3, r3, r7
 801cc48:	08db      	lsrs	r3, r3, #3
 801cc4a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801cc4e:	005b      	lsls	r3, r3, #1
 801cc50:	b29f      	uxth	r7, r3
    uint_fast16_t idx, offset = id - normalize_id(id);
 801cc52:	eba9 0907 	sub.w	r9, r9, r7
    setting_details_t *details = settings_get_details();
 801cc56:	f7ff fb3b 	bl	801c2d0 <settings_get_details>
 801cc5a:	4605      	mov	r5, r0
    id -= offset;
 801cc5c:	e05e      	b.n	801cd1c <setting_get_details+0xf8>
    else if(id > Setting_EncoderSettingsBase && id <= Setting_EncoderSettingsMax)
 801cc5e:	f2a0 1391 	subw	r3, r0, #401	; 0x191
 801cc62:	b29b      	uxth	r3, r3
 801cc64:	2b30      	cmp	r3, #48	; 0x30
 801cc66:	d80c      	bhi.n	801cc82 <setting_get_details+0x5e>
        id = (setting_id_t)(Setting_EncoderSettingsBase + (id % ENCODER_SETTINGS_INCREMENT));
 801cc68:	4b2d      	ldr	r3, [pc, #180]	; (801cd20 <setting_get_details+0xfc>)
 801cc6a:	fba3 2300 	umull	r2, r3, r3, r0
 801cc6e:	08db      	lsrs	r3, r3, #3
 801cc70:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801cc74:	eba0 0343 	sub.w	r3, r0, r3, lsl #1
 801cc78:	b29b      	uxth	r3, r3
 801cc7a:	f503 73c8 	add.w	r3, r3, #400	; 0x190
 801cc7e:	b29f      	uxth	r7, r3
 801cc80:	e7e7      	b.n	801cc52 <setting_get_details+0x2e>
    else if(id > Setting_ModbusTCPBase && id <= Setting_ModbusTCPMax)
 801cc82:	f2a0 2359 	subw	r3, r0, #601	; 0x259
 801cc86:	b29b      	uxth	r3, r3
 801cc88:	2b26      	cmp	r3, #38	; 0x26
 801cc8a:	d8e2      	bhi.n	801cc52 <setting_get_details+0x2e>
        id = (setting_id_t)(Setting_ModbusTCPBase + (id % MODBUS_TCP_SETTINGS_INCREMENT));
 801cc8c:	4a24      	ldr	r2, [pc, #144]	; (801cd20 <setting_get_details+0xfc>)
 801cc8e:	fba2 3200 	umull	r3, r2, r2, r0
 801cc92:	f022 0303 	bic.w	r3, r2, #3
 801cc96:	eb03 0392 	add.w	r3, r3, r2, lsr #2
 801cc9a:	1ac3      	subs	r3, r0, r3
 801cc9c:	b29b      	uxth	r3, r3
 801cc9e:	f503 7316 	add.w	r3, r3, #600	; 0x258
 801cca2:	b29f      	uxth	r7, r3
 801cca4:	e7d5      	b.n	801cc52 <setting_get_details+0x2e>
    return setting->is_available == NULL || setting->is_available(setting);
 801cca6:	2301      	movs	r3, #1
 801cca8:	e000      	b.n	801ccac <setting_get_details+0x88>
 801ccaa:	2301      	movs	r3, #1
            if(details->settings[idx].id == id && is_available(&details->settings[idx])) {
 801ccac:	b9a3      	cbnz	r3, 801ccd8 <setting_get_details+0xb4>
        for(idx = 0; idx < details->n_settings; idx++) {
 801ccae:	3401      	adds	r4, #1
 801ccb0:	892b      	ldrh	r3, [r5, #8]
 801ccb2:	42a3      	cmp	r3, r4
 801ccb4:	d92f      	bls.n	801cd16 <setting_get_details+0xf2>
            if(details->settings[idx].id == id && is_available(&details->settings[idx])) {
 801ccb6:	68eb      	ldr	r3, [r5, #12]
 801ccb8:	eb04 0044 	add.w	r0, r4, r4, lsl #1
 801ccbc:	0106      	lsls	r6, r0, #4
 801ccbe:	eb03 1000 	add.w	r0, r3, r0, lsl #4
 801ccc2:	5b9b      	ldrh	r3, [r3, r6]
 801ccc4:	42bb      	cmp	r3, r7
 801ccc6:	d1f2      	bne.n	801ccae <setting_get_details+0x8a>
    return setting->is_available == NULL || setting->is_available(setting);
 801ccc8:	6a83      	ldr	r3, [r0, #40]	; 0x28
 801ccca:	2b00      	cmp	r3, #0
 801cccc:	d0eb      	beq.n	801cca6 <setting_get_details+0x82>
 801ccce:	4798      	blx	r3
 801ccd0:	2800      	cmp	r0, #0
 801ccd2:	d1ea      	bne.n	801ccaa <setting_get_details+0x86>
 801ccd4:	2300      	movs	r3, #0
 801ccd6:	e7e9      	b.n	801ccac <setting_get_details+0x88>
                if(offset && details->iterator == NULL && offset >= (details->settings[idx].group == Group_Encoder0 ? hal.encoder.get_n_encoders() : N_AXIS))
 801ccd8:	f1b9 0f00 	cmp.w	r9, #0
 801ccdc:	d001      	beq.n	801cce2 <setting_get_details+0xbe>
 801ccde:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 801cce0:	b14b      	cbz	r3, 801ccf6 <setting_get_details+0xd2>
                if(set)
 801cce2:	f1b8 0f00 	cmp.w	r8, #0
 801cce6:	d001      	beq.n	801ccec <setting_get_details+0xc8>
                    *set = details;
 801cce8:	f8c8 5000 	str.w	r5, [r8]
                return &details->settings[idx];
 801ccec:	68ed      	ldr	r5, [r5, #12]
 801ccee:	4435      	add	r5, r6
}
 801ccf0:	4628      	mov	r0, r5
 801ccf2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                if(offset && details->iterator == NULL && offset >= (details->settings[idx].group == Group_Encoder0 ? hal.encoder.get_n_encoders() : N_AXIS))
 801ccf6:	68eb      	ldr	r3, [r5, #12]
 801ccf8:	4433      	add	r3, r6
 801ccfa:	789b      	ldrb	r3, [r3, #2]
 801ccfc:	2b1d      	cmp	r3, #29
 801ccfe:	d004      	beq.n	801cd0a <setting_get_details+0xe6>
 801cd00:	2303      	movs	r3, #3
 801cd02:	454b      	cmp	r3, r9
 801cd04:	d8ed      	bhi.n	801cce2 <setting_get_details+0xbe>
                    return NULL;
 801cd06:	2500      	movs	r5, #0
 801cd08:	e7f2      	b.n	801ccf0 <setting_get_details+0xcc>
                if(offset && details->iterator == NULL && offset >= (details->settings[idx].group == Group_Encoder0 ? hal.encoder.get_n_encoders() : N_AXIS))
 801cd0a:	4b06      	ldr	r3, [pc, #24]	; (801cd24 <setting_get_details+0x100>)
 801cd0c:	f8d3 3190 	ldr.w	r3, [r3, #400]	; 0x190
 801cd10:	4798      	blx	r3
 801cd12:	4603      	mov	r3, r0
 801cd14:	e7f5      	b.n	801cd02 <setting_get_details+0xde>
    } while((details = details->next));
 801cd16:	69ad      	ldr	r5, [r5, #24]
 801cd18:	2d00      	cmp	r5, #0
 801cd1a:	d0e9      	beq.n	801ccf0 <setting_get_details+0xcc>
        for(idx = 0; idx < details->n_settings; idx++) {
 801cd1c:	2400      	movs	r4, #0
 801cd1e:	e7c7      	b.n	801ccb0 <setting_get_details+0x8c>
 801cd20:	cccccccd 	.word	0xcccccccd
 801cd24:	2000350c 	.word	0x2000350c

0801cd28 <settings_iterator>:
{
 801cd28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801cd2c:	b082      	sub	sp, #8
 801cd2e:	4604      	mov	r4, r0
 801cd30:	460e      	mov	r6, r1
 801cd32:	4617      	mov	r7, r2
    if(setting->group == Group_Axis0) {
 801cd34:	7883      	ldrb	r3, [r0, #2]
 801cd36:	2b2b      	cmp	r3, #43	; 0x2b
 801cd38:	d016      	beq.n	801cd68 <settings_iterator+0x40>
    } else if(setting->flags.increment) {
 801cd3a:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 801cd3e:	f013 0f78 	tst.w	r3, #120	; 0x78
 801cd42:	d114      	bne.n	801cd6e <settings_iterator+0x46>
        ok = callback(setting, 0, data);
 801cd44:	2100      	movs	r1, #0
 801cd46:	47b0      	blx	r6
 801cd48:	4680      	mov	r8, r0
}
 801cd4a:	4640      	mov	r0, r8
 801cd4c:	b002      	add	sp, #8
 801cd4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        for(axis_idx = 0; axis_idx < N_AXIS; axis_idx++) {
 801cd52:	3501      	adds	r5, #1
 801cd54:	2d02      	cmp	r5, #2
 801cd56:	d8f8      	bhi.n	801cd4a <settings_iterator+0x22>
            if(callback(setting, axis_idx, data))
 801cd58:	463a      	mov	r2, r7
 801cd5a:	4629      	mov	r1, r5
 801cd5c:	4620      	mov	r0, r4
 801cd5e:	47b0      	blx	r6
 801cd60:	2800      	cmp	r0, #0
 801cd62:	d0f6      	beq.n	801cd52 <settings_iterator+0x2a>
                ok = true;
 801cd64:	4680      	mov	r8, r0
 801cd66:	e7f4      	b.n	801cd52 <settings_iterator+0x2a>
        for(axis_idx = 0; axis_idx < N_AXIS; axis_idx++) {
 801cd68:	2500      	movs	r5, #0
    bool ok = false;
 801cd6a:	46a8      	mov	r8, r5
 801cd6c:	e7f2      	b.n	801cd54 <settings_iterator+0x2c>
        setting = setting_get_details(setting->id, &set);
 801cd6e:	a901      	add	r1, sp, #4
 801cd70:	8800      	ldrh	r0, [r0, #0]
 801cd72:	f7ff ff57 	bl	801cc24 <setting_get_details>
        if(set->iterator)
 801cd76:	9b01      	ldr	r3, [sp, #4]
 801cd78:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801cd7a:	b123      	cbz	r3, 801cd86 <settings_iterator+0x5e>
            ok = set->iterator(setting, callback, data);
 801cd7c:	463a      	mov	r2, r7
 801cd7e:	4631      	mov	r1, r6
 801cd80:	4798      	blx	r3
 801cd82:	4680      	mov	r8, r0
 801cd84:	e7e1      	b.n	801cd4a <settings_iterator+0x22>
    bool ok = false;
 801cd86:	f04f 0800 	mov.w	r8, #0
 801cd8a:	e7de      	b.n	801cd4a <settings_iterator+0x22>

0801cd8c <setting_get_description>:
{
 801cd8c:	b538      	push	{r3, r4, r5, lr}
 801cd8e:	4605      	mov	r5, r0
    setting_details_t *settings = settings_get_details();
 801cd90:	f7ff fa9e 	bl	801c2d0 <settings_get_details>
 801cd94:	4604      	mov	r4, r0
    const setting_detail_t *setting = setting_get_details(id, NULL);
 801cd96:	2100      	movs	r1, #0
 801cd98:	4628      	mov	r0, r5
 801cd9a:	f7ff ff43 	bl	801cc24 <setting_get_details>
    if(setting) do {
 801cd9e:	4605      	mov	r5, r0
 801cda0:	b1b0      	cbz	r0, 801cdd0 <setting_get_description+0x44>
    const char *description = NULL;
 801cda2:	2000      	movs	r0, #0
 801cda4:	e00f      	b.n	801cdc6 <setting_get_description+0x3a>
            } while(idx && description == NULL);
 801cda6:	b15b      	cbz	r3, 801cdc0 <setting_get_description+0x34>
 801cda8:	b950      	cbnz	r0, 801cdc0 <setting_get_description+0x34>
                if(settings->descriptions[--idx].id == setting->id) {
 801cdaa:	3b01      	subs	r3, #1
 801cdac:	eb02 0ec3 	add.w	lr, r2, r3, lsl #3
 801cdb0:	f832 c033 	ldrh.w	ip, [r2, r3, lsl #3]
 801cdb4:	8829      	ldrh	r1, [r5, #0]
 801cdb6:	458c      	cmp	ip, r1
 801cdb8:	d1f5      	bne.n	801cda6 <setting_get_description+0x1a>
                    description = settings->descriptions[idx].description;
 801cdba:	f8de 0004 	ldr.w	r0, [lr, #4]
 801cdbe:	e7f2      	b.n	801cda6 <setting_get_description+0x1a>
    } while(description == NULL && (settings = settings->next));
 801cdc0:	b930      	cbnz	r0, 801cdd0 <setting_get_description+0x44>
 801cdc2:	69a4      	ldr	r4, [r4, #24]
 801cdc4:	b124      	cbz	r4, 801cdd0 <setting_get_description+0x44>
        if(settings->descriptions) {
 801cdc6:	6962      	ldr	r2, [r4, #20]
 801cdc8:	2a00      	cmp	r2, #0
 801cdca:	d0f9      	beq.n	801cdc0 <setting_get_description+0x34>
            idx = settings->n_descriptions;
 801cdcc:	8a23      	ldrh	r3, [r4, #16]
 801cdce:	e7ec      	b.n	801cdaa <setting_get_description+0x1e>
}
 801cdd0:	bd38      	pop	{r3, r4, r5, pc}

0801cdd2 <setting_get_group_details>:
{
 801cdd2:	b510      	push	{r4, lr}
 801cdd4:	4604      	mov	r4, r0
    setting_details_t *details = settings_get_details();
 801cdd6:	f7ff fa7b 	bl	801c2d0 <settings_get_details>
 801cdda:	4601      	mov	r1, r0
    const setting_group_detail_t *detail = NULL;
 801cddc:	2000      	movs	r0, #0
 801cdde:	e011      	b.n	801ce04 <setting_get_group_details+0x32>
        for(idx = 0; idx < details->n_groups; idx++) {
 801cde0:	3301      	adds	r3, #1
 801cde2:	780a      	ldrb	r2, [r1, #0]
 801cde4:	429a      	cmp	r2, r3
 801cde6:	d90a      	bls.n	801cdfe <setting_get_group_details+0x2c>
            if(details->groups[idx].id == id)
 801cde8:	684a      	ldr	r2, [r1, #4]
 801cdea:	eb03 0c43 	add.w	ip, r3, r3, lsl #1
 801cdee:	eb02 028c 	add.w	r2, r2, ip, lsl #2
 801cdf2:	f892 c001 	ldrb.w	ip, [r2, #1]
 801cdf6:	45a4      	cmp	ip, r4
 801cdf8:	d1f2      	bne.n	801cde0 <setting_get_group_details+0xe>
                detail = &details->groups[idx];
 801cdfa:	4610      	mov	r0, r2
 801cdfc:	e7f0      	b.n	801cde0 <setting_get_group_details+0xe>
    } while(detail == NULL && (details = details->next));
 801cdfe:	b918      	cbnz	r0, 801ce08 <setting_get_group_details+0x36>
 801ce00:	6989      	ldr	r1, [r1, #24]
 801ce02:	b109      	cbz	r1, 801ce08 <setting_get_group_details+0x36>
        for(idx = 0; idx < details->n_groups; idx++) {
 801ce04:	2300      	movs	r3, #0
 801ce06:	e7ec      	b.n	801cde2 <setting_get_group_details+0x10>
}
 801ce08:	bd10      	pop	{r4, pc}
	...

0801ce0c <settings_is_group_available>:
{
 801ce0c:	b570      	push	{r4, r5, r6, lr}
 801ce0e:	4606      	mov	r6, r0
    const setting_group_detail_t *group = setting_get_group_details(id);
 801ce10:	f7ff ffdf 	bl	801cdd2 <setting_get_group_details>
    if(!group)
 801ce14:	2800      	cmp	r0, #0
 801ce16:	d058      	beq.n	801ceca <settings_is_group_available+0xbe>
 801ce18:	4604      	mov	r4, r0
    bool available = group->is_available ? group->is_available(group) : false;
 801ce1a:	6883      	ldr	r3, [r0, #8]
 801ce1c:	b113      	cbz	r3, 801ce24 <settings_is_group_available+0x18>
 801ce1e:	4798      	blx	r3
 801ce20:	2800      	cmp	r0, #0
 801ce22:	d155      	bne.n	801ced0 <settings_is_group_available+0xc4>
    if(!available) switch(group->id) {
 801ce24:	7863      	ldrb	r3, [r4, #1]
 801ce26:	3b02      	subs	r3, #2
 801ce28:	2b0c      	cmp	r3, #12
 801ce2a:	d829      	bhi.n	801ce80 <settings_is_group_available+0x74>
 801ce2c:	e8df f003 	tbb	[pc, r3]
 801ce30:	281a4f4f 	.word	0x281a4f4f
 801ce34:	28140e4f 	.word	0x28140e4f
 801ce38:	28074f28 	.word	0x28074f28
 801ce3c:	4f          	.byte	0x4f
 801ce3d:	00          	.byte	0x00
            available = hal.probe.get_state != NULL;
 801ce3e:	4b25      	ldr	r3, [pc, #148]	; (801ced4 <settings_is_group_available+0xc8>)
 801ce40:	f8d3 00fc 	ldr.w	r0, [r3, #252]	; 0xfc
 801ce44:	3800      	subs	r0, #0
 801ce46:	bf18      	it	ne
 801ce48:	2001      	movne	r0, #1
            break;
 801ce4a:	e041      	b.n	801ced0 <settings_is_group_available+0xc4>
            available = hal.driver_cap.spindle_sync;
 801ce4c:	4b21      	ldr	r3, [pc, #132]	; (801ced4 <settings_is_group_available+0xc8>)
 801ce4e:	f893 01a5 	ldrb.w	r0, [r3, #421]	; 0x1a5
 801ce52:	f000 0001 	and.w	r0, r0, #1
            break;
 801ce56:	e03b      	b.n	801ced0 <settings_is_group_available+0xc4>
            available = hal.driver_cap.spindle_pid;
 801ce58:	4b1e      	ldr	r3, [pc, #120]	; (801ced4 <settings_is_group_available+0xc8>)
 801ce5a:	f893 01a5 	ldrb.w	r0, [r3, #421]	; 0x1a5
 801ce5e:	f3c0 1040 	ubfx	r0, r0, #5, #1
            break;
 801ce62:	e035      	b.n	801ced0 <settings_is_group_available+0xc4>
            available = hal.stepper.get_ganged && hal.stepper.get_ganged(true).mask != 0;
 801ce64:	4b1b      	ldr	r3, [pc, #108]	; (801ced4 <settings_is_group_available+0xc8>)
 801ce66:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 801ce6a:	b12b      	cbz	r3, 801ce78 <settings_is_group_available+0x6c>
 801ce6c:	2001      	movs	r0, #1
 801ce6e:	4798      	blx	r3
 801ce70:	b2c0      	uxtb	r0, r0
 801ce72:	b118      	cbz	r0, 801ce7c <settings_is_group_available+0x70>
 801ce74:	2001      	movs	r0, #1
 801ce76:	e02b      	b.n	801ced0 <settings_is_group_available+0xc4>
 801ce78:	2000      	movs	r0, #0
 801ce7a:	e029      	b.n	801ced0 <settings_is_group_available+0xc4>
 801ce7c:	2000      	movs	r0, #0
            break;
 801ce7e:	e027      	b.n	801ced0 <settings_is_group_available+0xc4>
    if(!available) switch(group->id) {
 801ce80:	4d15      	ldr	r5, [pc, #84]	; (801ced8 <settings_is_group_available+0xcc>)
 801ce82:	2000      	movs	r0, #0
 801ce84:	e01c      	b.n	801cec0 <settings_is_group_available+0xb4>
    return setting->is_available == NULL || setting->is_available(setting);
 801ce86:	2301      	movs	r3, #1
 801ce88:	e000      	b.n	801ce8c <settings_is_group_available+0x80>
 801ce8a:	2301      	movs	r3, #1
                            if(details->settings[idx].group == id && (available = is_available(&details->settings[idx])))
 801ce8c:	4618      	mov	r0, r3
 801ce8e:	b9a3      	cbnz	r3, 801ceba <settings_is_group_available+0xae>
                        for(idx = 0; idx < details->n_settings; idx++) {
 801ce90:	3401      	adds	r4, #1
 801ce92:	892b      	ldrh	r3, [r5, #8]
 801ce94:	42a3      	cmp	r3, r4
 801ce96:	d910      	bls.n	801ceba <settings_is_group_available+0xae>
                            if(details->settings[idx].group == id && (available = is_available(&details->settings[idx])))
 801ce98:	68eb      	ldr	r3, [r5, #12]
 801ce9a:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 801ce9e:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801cea2:	789a      	ldrb	r2, [r3, #2]
 801cea4:	42b2      	cmp	r2, r6
 801cea6:	d1f3      	bne.n	801ce90 <settings_is_group_available+0x84>
    return setting->is_available == NULL || setting->is_available(setting);
 801cea8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 801ceaa:	2a00      	cmp	r2, #0
 801ceac:	d0eb      	beq.n	801ce86 <settings_is_group_available+0x7a>
 801ceae:	4618      	mov	r0, r3
 801ceb0:	4790      	blx	r2
 801ceb2:	2800      	cmp	r0, #0
 801ceb4:	d1e9      	bne.n	801ce8a <settings_is_group_available+0x7e>
 801ceb6:	2300      	movs	r3, #0
 801ceb8:	e7e8      	b.n	801ce8c <settings_is_group_available+0x80>
                } while(!available && (details = details->next));
 801ceba:	b948      	cbnz	r0, 801ced0 <settings_is_group_available+0xc4>
 801cebc:	69ad      	ldr	r5, [r5, #24]
 801cebe:	b13d      	cbz	r5, 801ced0 <settings_is_group_available+0xc4>
                    if(details->settings) {
 801cec0:	68eb      	ldr	r3, [r5, #12]
 801cec2:	2b00      	cmp	r3, #0
 801cec4:	d0f9      	beq.n	801ceba <settings_is_group_available+0xae>
                        for(idx = 0; idx < details->n_settings; idx++) {
 801cec6:	2400      	movs	r4, #0
 801cec8:	e7e3      	b.n	801ce92 <settings_is_group_available+0x86>
        return false;
 801ceca:	2000      	movs	r0, #0
 801cecc:	e000      	b.n	801ced0 <settings_is_group_available+0xc4>
    if(!available) switch(group->id) {
 801cece:	2001      	movs	r0, #1
}
 801ced0:	bd70      	pop	{r4, r5, r6, pc}
 801ced2:	bf00      	nop
 801ced4:	2000350c 	.word	0x2000350c
 801ced8:	200004b4 	.word	0x200004b4

0801cedc <is_group_available>:
{
 801cedc:	b508      	push	{r3, lr}
    return settings_is_group_available(setting->group);
 801cede:	7880      	ldrb	r0, [r0, #2]
 801cee0:	f7ff ff94 	bl	801ce0c <settings_is_group_available>
}
 801cee4:	bd08      	pop	{r3, pc}

0801cee6 <setting_datatype_to_external>:
    switch(datatype) {
 801cee6:	f1a0 030a 	sub.w	r3, r0, #10
 801ceea:	2b01      	cmp	r3, #1
 801ceec:	d900      	bls.n	801cef0 <setting_datatype_to_external+0xa>
}
 801ceee:	4770      	bx	lr
            datatype = Format_Integer;
 801cef0:	2005      	movs	r0, #5
 801cef2:	e7fc      	b.n	801ceee <setting_datatype_to_external+0x8>

0801cef4 <setting_is_list>:
    return setting->datatype == Format_Bitfield || setting->datatype == Format_XBitfield || setting->datatype == Format_RadioButtons;
 801cef4:	7b00      	ldrb	r0, [r0, #12]
 801cef6:	3801      	subs	r0, #1
 801cef8:	b2c0      	uxtb	r0, r0
}
 801cefa:	2802      	cmp	r0, #2
 801cefc:	bf8c      	ite	hi
 801cefe:	2000      	movhi	r0, #0
 801cf00:	2001      	movls	r0, #1
 801cf02:	4770      	bx	lr

0801cf04 <setting_remove_element>:
{
 801cf04:	b538      	push	{r3, r4, r5, lr}
 801cf06:	460c      	mov	r4, r1
    const setting_detail_t *setting = setting_get_details(id, NULL);
 801cf08:	2100      	movs	r1, #0
 801cf0a:	f7ff fe8b 	bl	801cc24 <setting_get_details>
    if(setting && setting_is_list(setting))
 801cf0e:	b118      	cbz	r0, 801cf18 <setting_remove_element+0x14>
 801cf10:	4605      	mov	r5, r0
 801cf12:	f7ff ffef 	bl	801cef4 <setting_is_list>
 801cf16:	b900      	cbnz	r0, 801cf1a <setting_remove_element+0x16>
}
 801cf18:	bd38      	pop	{r3, r4, r5, pc}
        remove_element((char *)setting->format, pos);
 801cf1a:	4621      	mov	r1, r4
 801cf1c:	6928      	ldr	r0, [r5, #16]
 801cf1e:	f7fe fed1 	bl	801bcc4 <remove_element>
}
 801cf22:	e7f9      	b.n	801cf18 <setting_remove_element+0x14>

0801cf24 <setting_remove_elements>:
{
 801cf24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801cf28:	4680      	mov	r8, r0
 801cf2a:	460d      	mov	r5, r1
    char *format = (char *)setting_get_details(id, NULL)->format, *s;
 801cf2c:	2100      	movs	r1, #0
 801cf2e:	f7ff fe79 	bl	801cc24 <setting_get_details>
 801cf32:	6907      	ldr	r7, [r0, #16]
    uint_fast8_t idx, entries = strnumentries(format, ',');
 801cf34:	212c      	movs	r1, #44	; 0x2c
 801cf36:	4638      	mov	r0, r7
 801cf38:	f7ff f8e4 	bl	801c104 <strnumentries>
 801cf3c:	4606      	mov	r6, r0
    for(idx = 0; idx < entries; idx++ ) {
 801cf3e:	2400      	movs	r4, #0
 801cf40:	e001      	b.n	801cf46 <setting_remove_elements+0x22>
        mask >>= 1;
 801cf42:	086d      	lsrs	r5, r5, #1
    for(idx = 0; idx < entries; idx++ ) {
 801cf44:	3401      	adds	r4, #1
 801cf46:	42b4      	cmp	r4, r6
 801cf48:	d209      	bcs.n	801cf5e <setting_remove_elements+0x3a>
        if(!(mask & 0x1))
 801cf4a:	f015 0f01 	tst.w	r5, #1
 801cf4e:	d1f8      	bne.n	801cf42 <setting_remove_elements+0x1e>
            setting_remove_element(id, idx);
 801cf50:	4621      	mov	r1, r4
 801cf52:	4640      	mov	r0, r8
 801cf54:	f7ff ffd6 	bl	801cf04 <setting_remove_element>
 801cf58:	e7f3      	b.n	801cf42 <setting_remove_elements+0x1e>
        *s = '\0';
 801cf5a:	2300      	movs	r3, #0
 801cf5c:	7023      	strb	r3, [r4, #0]
    while((s = strrchr(format, ','))) {
 801cf5e:	212c      	movs	r1, #44	; 0x2c
 801cf60:	4638      	mov	r0, r7
 801cf62:	f005 fe51 	bl	8022c08 <strrchr>
 801cf66:	4604      	mov	r4, r0
 801cf68:	b130      	cbz	r0, 801cf78 <setting_remove_elements+0x54>
        if(strncmp(s, ",N/A", 4))
 801cf6a:	2204      	movs	r2, #4
 801cf6c:	4903      	ldr	r1, [pc, #12]	; (801cf7c <setting_remove_elements+0x58>)
 801cf6e:	4620      	mov	r0, r4
 801cf70:	f005 fe25 	bl	8022bbe <strncmp>
 801cf74:	2800      	cmp	r0, #0
 801cf76:	d0f0      	beq.n	801cf5a <setting_remove_elements+0x36>
}
 801cf78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801cf7c:	08028440 	.word	0x08028440

0801cf80 <setting_validate_me>:
{
 801cf80:	b570      	push	{r4, r5, r6, lr}
 801cf82:	4604      	mov	r4, r0
 801cf84:	460d      	mov	r5, r1
    switch(setting->datatype) {
 801cf86:	7b03      	ldrb	r3, [r0, #12]
 801cf88:	2b0b      	cmp	r3, #11
 801cf8a:	d834      	bhi.n	801cff6 <setting_validate_me+0x76>
 801cf8c:	e8df f003 	tbb	[pc, r3]
 801cf90:	06060606 	.word	0x06060606
 801cf94:	28090606 	.word	0x28090606
 801cf98:	0606330c 	.word	0x0606330c
            status = setting_validate_me_uint(setting, svalue);
 801cf9c:	f7ff f8f4 	bl	801c188 <setting_validate_me_uint>
}
 801cfa0:	bd70      	pop	{r4, r5, r6, pc}
            status = validate_value(setting, value);
 801cfa2:	f7ff f92e 	bl	801c202 <validate_value>
            break;
 801cfa6:	e7fb      	b.n	801cfa0 <setting_validate_me+0x20>
                uint_fast16_t len = strlen(svalue);
 801cfa8:	4608      	mov	r0, r1
 801cfaa:	f7eb f853 	bl	8008054 <strlen>
 801cfae:	4606      	mov	r6, r0
                if(hal.stream.state.webui_connected && len == strlen(PASSWORD_MASK) && !strcmp(PASSWORD_MASK, svalue))
 801cfb0:	4b12      	ldr	r3, [pc, #72]	; (801cffc <setting_validate_me+0x7c>)
 801cfb2:	f893 30aa 	ldrb.w	r3, [r3, #170]	; 0xaa
 801cfb6:	f013 0f02 	tst.w	r3, #2
 801cfba:	d001      	beq.n	801cfc0 <setting_validate_me+0x40>
 801cfbc:	2808      	cmp	r0, #8
 801cfbe:	d007      	beq.n	801cfd0 <setting_validate_me+0x50>
                    status = validate_value(setting, (float)len);
 801cfc0:	ee07 6a90 	vmov	s15, r6
 801cfc4:	eeb8 0a67 	vcvt.f32.u32	s0, s15
 801cfc8:	4620      	mov	r0, r4
 801cfca:	f7ff f91a 	bl	801c202 <validate_value>
 801cfce:	e7e7      	b.n	801cfa0 <setting_validate_me+0x20>
                if(hal.stream.state.webui_connected && len == strlen(PASSWORD_MASK) && !strcmp(PASSWORD_MASK, svalue))
 801cfd0:	4629      	mov	r1, r5
 801cfd2:	480b      	ldr	r0, [pc, #44]	; (801d000 <setting_validate_me+0x80>)
 801cfd4:	f7eb f834 	bl	8008040 <strcmp>
 801cfd8:	2800      	cmp	r0, #0
 801cfda:	d1f1      	bne.n	801cfc0 <setting_validate_me+0x40>
                    status = Status_InvalidStatement;
 801cfdc:	2003      	movs	r0, #3
 801cfde:	e7df      	b.n	801cfa0 <setting_validate_me+0x20>
                uint_fast16_t len = strlen(svalue);
 801cfe0:	4608      	mov	r0, r1
 801cfe2:	f7eb f837 	bl	8008054 <strlen>
 801cfe6:	ee00 0a10 	vmov	s0, r0
                status = validate_value(setting, (float)len);
 801cfea:	eeb8 0a40 	vcvt.f32.u32	s0, s0
 801cfee:	4620      	mov	r0, r4
 801cff0:	f7ff f907 	bl	801c202 <validate_value>
            break;
 801cff4:	e7d4      	b.n	801cfa0 <setting_validate_me+0x20>
    switch(setting->datatype) {
 801cff6:	2000      	movs	r0, #0
 801cff8:	e7d2      	b.n	801cfa0 <setting_validate_me+0x20>
 801cffa:	bf00      	nop
 801cffc:	2000350c 	.word	0x2000350c
 801d000:	080283ec 	.word	0x080283ec

0801d004 <settings_store_setting>:

// A helper method to set settings from command line
status_code_t settings_store_setting (setting_id_t id, char *svalue)
{
 801d004:	b5f0      	push	{r4, r5, r6, r7, lr}
 801d006:	b085      	sub	sp, #20
 801d008:	4606      	mov	r6, r0
 801d00a:	460c      	mov	r4, r1
    uint_fast8_t set_idx = 0;
 801d00c:	2300      	movs	r3, #0
 801d00e:	9303      	str	r3, [sp, #12]
    uint32_t int_value = 0;
 801d010:	9302      	str	r3, [sp, #8]
    float value = NAN;
 801d012:	4b5b      	ldr	r3, [pc, #364]	; (801d180 <settings_store_setting+0x17c>)
 801d014:	9301      	str	r3, [sp, #4]
    status_code_t status = Status_OK;
    setting_details_t *set;
    const setting_detail_t *setting = setting_get_details(id, &set);
 801d016:	4669      	mov	r1, sp
 801d018:	f7ff fe04 	bl	801cc24 <setting_get_details>

    if(setting == NULL) {
 801d01c:	4605      	mov	r5, r0
 801d01e:	b938      	cbnz	r0, 801d030 <settings_store_setting+0x2c>
        if(id == Setting_SpindlePWMBehaviour) {
 801d020:	2e07      	cmp	r6, #7
 801d022:	f040 80a8 	bne.w	801d176 <settings_store_setting+0x172>
            set = &setting_details;
 801d026:	4b57      	ldr	r3, [pc, #348]	; (801d184 <settings_store_setting+0x180>)
 801d028:	9300      	str	r3, [sp, #0]
            setting = &setting_detail[Setting_SpindlePWMBehaviour];
 801d02a:	4d57      	ldr	r5, [pc, #348]	; (801d188 <settings_store_setting+0x184>)
 801d02c:	e000      	b.n	801d030 <settings_store_setting+0x2c>
            return Status_SettingDisabled;
    }

    // Trim leading spaces
    while(*svalue == ' ')
        svalue++;
 801d02e:	3401      	adds	r4, #1
    while(*svalue == ' ')
 801d030:	7823      	ldrb	r3, [r4, #0]
 801d032:	2b20      	cmp	r3, #32
 801d034:	d0fb      	beq.n	801d02e <settings_store_setting+0x2a>

    if(setting->datatype == Format_Decimal)  {
 801d036:	7b2b      	ldrb	r3, [r5, #12]
 801d038:	2b06      	cmp	r3, #6
 801d03a:	d022      	beq.n	801d082 <settings_store_setting+0x7e>
    return datatype == Format_String || datatype == Format_Password || datatype == Format_IPv4;
 801d03c:	3b07      	subs	r3, #7
 801d03e:	b2db      	uxtb	r3, r3
        if(!read_float(svalue, &set_idx, &value) && setting_is_core(setting->type))
            return Status_BadNumberFormat;
    } else if(!setting_is_string(setting->datatype) && read_uint(svalue, &set_idx, &int_value) != Status_OK && setting_is_core(setting->type))
 801d040:	2b02      	cmp	r3, #2
 801d042:	d82a      	bhi.n	801d09a <settings_store_setting+0x96>
        return Status_BadNumberFormat;

    if((status = setting_validate_me(setting, value, svalue)) != Status_OK) {
 801d044:	4621      	mov	r1, r4
 801d046:	ed9d 0a01 	vldr	s0, [sp, #4]
 801d04a:	4628      	mov	r0, r5
 801d04c:	f7ff ff98 	bl	801cf80 <setting_validate_me>
 801d050:	4607      	mov	r7, r0
 801d052:	bb70      	cbnz	r0, 801d0b2 <settings_store_setting+0xae>
            status =  Status_SettingStepPulseMin;

        return status;
    }

    switch(setting->type) {
 801d054:	7f2a      	ldrb	r2, [r5, #28]
 801d056:	2a07      	cmp	r2, #7
 801d058:	d865      	bhi.n	801d126 <settings_store_setting+0x122>
 801d05a:	2301      	movs	r3, #1
 801d05c:	4093      	lsls	r3, r2
 801d05e:	f013 0faa 	tst.w	r3, #170	; 0xaa
 801d062:	d14c      	bne.n	801d0fe <settings_store_setting+0xfa>
 801d064:	f013 0f55 	tst.w	r3, #85	; 0x55
 801d068:	d05d      	beq.n	801d126 <settings_store_setting+0x122>

        case Setting_NonCore:
        case Setting_IsExtended:
        case Setting_IsLegacy:
        case Setting_IsExpanded:
            switch(setting->datatype) {
 801d06a:	7b2b      	ldrb	r3, [r5, #12]
 801d06c:	2b0b      	cmp	r3, #11
 801d06e:	f200 8084 	bhi.w	801d17a <settings_store_setting+0x176>
 801d072:	e8df f003 	tbb	[pc, r3]
 801d076:	3636      	.short	0x3636
 801d078:	402f3636 	.word	0x402f3636
 801d07c:	822a2a26 	.word	0x822a2a26
 801d080:	3b36      	.short	0x3b36
        if(!read_float(svalue, &set_idx, &value) && setting_is_core(setting->type))
 801d082:	aa01      	add	r2, sp, #4
 801d084:	a903      	add	r1, sp, #12
 801d086:	4620      	mov	r0, r4
 801d088:	f7f8 fc5c 	bl	8015944 <read_float>
 801d08c:	2800      	cmp	r0, #0
 801d08e:	d1d9      	bne.n	801d044 <settings_store_setting+0x40>
 801d090:	7f2b      	ldrb	r3, [r5, #28]
 801d092:	2b01      	cmp	r3, #1
 801d094:	d9d6      	bls.n	801d044 <settings_store_setting+0x40>
            return Status_BadNumberFormat;
 801d096:	2702      	movs	r7, #2
 801d098:	e00c      	b.n	801d0b4 <settings_store_setting+0xb0>
    } else if(!setting_is_string(setting->datatype) && read_uint(svalue, &set_idx, &int_value) != Status_OK && setting_is_core(setting->type))
 801d09a:	aa02      	add	r2, sp, #8
 801d09c:	a903      	add	r1, sp, #12
 801d09e:	4620      	mov	r0, r4
 801d0a0:	f7f8 fc08 	bl	80158b4 <read_uint>
 801d0a4:	2800      	cmp	r0, #0
 801d0a6:	d0cd      	beq.n	801d044 <settings_store_setting+0x40>
 801d0a8:	7f2b      	ldrb	r3, [r5, #28]
 801d0aa:	2b01      	cmp	r3, #1
 801d0ac:	d9ca      	bls.n	801d044 <settings_store_setting+0x40>
        return Status_BadNumberFormat;
 801d0ae:	2702      	movs	r7, #2
 801d0b0:	e000      	b.n	801d0b4 <settings_store_setting+0xb0>
        if(setting == Setting_PulseMicroseconds && status == Status_SettingValueOutOfRange)
 801d0b2:	b115      	cbz	r5, 801d0ba <settings_store_setting+0xb6>
            set->on_changed(&settings, changed);
        }
    }

    return status;
}
 801d0b4:	4638      	mov	r0, r7
 801d0b6:	b005      	add	sp, #20
 801d0b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if(setting == Setting_PulseMicroseconds && status == Status_SettingValueOutOfRange)
 801d0ba:	2834      	cmp	r0, #52	; 0x34
 801d0bc:	d1fa      	bne.n	801d0b4 <settings_store_setting+0xb0>
            status =  Status_SettingStepPulseMin;
 801d0be:	2706      	movs	r7, #6
        return status;
 801d0c0:	e7f8      	b.n	801d0b4 <settings_store_setting+0xb0>
                    *((float *)(setting->value)) = value;
 801d0c2:	6a2b      	ldr	r3, [r5, #32]
 801d0c4:	9a01      	ldr	r2, [sp, #4]
 801d0c6:	601a      	str	r2, [r3, #0]
                    break;
 801d0c8:	e02d      	b.n	801d126 <settings_store_setting+0x122>
                    strcpy(((char *)(setting->value)), svalue);
 801d0ca:	4621      	mov	r1, r4
 801d0cc:	6a28      	ldr	r0, [r5, #32]
 801d0ce:	f005 fea7 	bl	8022e20 <strcpy>
                    break;
 801d0d2:	e028      	b.n	801d126 <settings_store_setting+0x122>
                    *((uint8_t *)(setting->value)) = (uint8_t)int_value & AXES_BITMASK;
 801d0d4:	f89d 3008 	ldrb.w	r3, [sp, #8]
 801d0d8:	6a2a      	ldr	r2, [r5, #32]
 801d0da:	f003 0307 	and.w	r3, r3, #7
 801d0de:	7013      	strb	r3, [r2, #0]
                    break;
 801d0e0:	e021      	b.n	801d126 <settings_store_setting+0x122>
                    *((uint8_t *)(setting->value)) = (uint8_t)int_value;
 801d0e2:	6a2b      	ldr	r3, [r5, #32]
 801d0e4:	f89d 2008 	ldrb.w	r2, [sp, #8]
 801d0e8:	701a      	strb	r2, [r3, #0]
                    break;
 801d0ea:	e01c      	b.n	801d126 <settings_store_setting+0x122>
                    *((uint16_t *)(setting->value)) = (uint16_t)int_value;
 801d0ec:	6a2b      	ldr	r3, [r5, #32]
 801d0ee:	f8bd 2008 	ldrh.w	r2, [sp, #8]
 801d0f2:	801a      	strh	r2, [r3, #0]
                    break;
 801d0f4:	e017      	b.n	801d126 <settings_store_setting+0x122>
                    *((uint32_t *)(setting->value)) = (uint32_t)int_value;
 801d0f6:	6a2b      	ldr	r3, [r5, #32]
 801d0f8:	9a02      	ldr	r2, [sp, #8]
 801d0fa:	601a      	str	r2, [r3, #0]
                    break;
 801d0fc:	e013      	b.n	801d126 <settings_store_setting+0x122>
            switch(setting->datatype) {
 801d0fe:	7b2b      	ldrb	r3, [r5, #12]
 801d100:	2b06      	cmp	r3, #6
 801d102:	d00a      	beq.n	801d11a <settings_store_setting+0x116>
 801d104:	d323      	bcc.n	801d14e <settings_store_setting+0x14a>
 801d106:	3b07      	subs	r3, #7
 801d108:	b2db      	uxtb	r3, r3
 801d10a:	2b02      	cmp	r3, #2
 801d10c:	d81f      	bhi.n	801d14e <settings_store_setting+0x14a>
                    status = ((setting_set_string_ptr)(setting->value))(id, svalue);
 801d10e:	6a2b      	ldr	r3, [r5, #32]
 801d110:	4621      	mov	r1, r4
 801d112:	4630      	mov	r0, r6
 801d114:	4798      	blx	r3
 801d116:	4607      	mov	r7, r0
                    break;
 801d118:	e005      	b.n	801d126 <settings_store_setting+0x122>
                    status = ((setting_set_float_ptr)(setting->value))(id, value);
 801d11a:	6a2b      	ldr	r3, [r5, #32]
 801d11c:	ed9d 0a01 	vldr	s0, [sp, #4]
 801d120:	4630      	mov	r0, r6
 801d122:	4798      	blx	r3
 801d124:	4607      	mov	r7, r0
    if(status == Status_OK) {
 801d126:	2f00      	cmp	r7, #0
 801d128:	d1c4      	bne.n	801d0b4 <settings_store_setting+0xb0>
        if(set->save)
 801d12a:	9b00      	ldr	r3, [sp, #0]
 801d12c:	6a1b      	ldr	r3, [r3, #32]
 801d12e:	b103      	cbz	r3, 801d132 <settings_store_setting+0x12e>
            set->save();
 801d130:	4798      	blx	r3
        if(set->on_changed) {
 801d132:	9b00      	ldr	r3, [sp, #0]
 801d134:	69db      	ldr	r3, [r3, #28]
 801d136:	2b00      	cmp	r3, #0
 801d138:	d0bc      	beq.n	801d0b4 <settings_store_setting+0xb0>
            settings_changed_flags_t changed = {0};
 801d13a:	f04f 0400 	mov.w	r4, #0
            changed.spindle = settings_changed_spindle() || machine_mode_changed;
 801d13e:	f7ff f8a9 	bl	801c294 <settings_changed_spindle>
 801d142:	b950      	cbnz	r0, 801d15a <settings_store_setting+0x156>
 801d144:	4b11      	ldr	r3, [pc, #68]	; (801d18c <settings_store_setting+0x188>)
 801d146:	781b      	ldrb	r3, [r3, #0]
 801d148:	b19b      	cbz	r3, 801d172 <settings_store_setting+0x16e>
 801d14a:	2301      	movs	r3, #1
 801d14c:	e006      	b.n	801d15c <settings_store_setting+0x158>
                    status = ((setting_set_int_ptr)(setting->value))(id, (uint_fast16_t)int_value);
 801d14e:	6a2b      	ldr	r3, [r5, #32]
 801d150:	9902      	ldr	r1, [sp, #8]
 801d152:	4630      	mov	r0, r6
 801d154:	4798      	blx	r3
 801d156:	4607      	mov	r7, r0
                    break;
 801d158:	e7e5      	b.n	801d126 <settings_store_setting+0x122>
            changed.spindle = settings_changed_spindle() || machine_mode_changed;
 801d15a:	2301      	movs	r3, #1
 801d15c:	f363 0400 	bfi	r4, r3, #0, #1
            machine_mode_changed = false;
 801d160:	4b0a      	ldr	r3, [pc, #40]	; (801d18c <settings_store_setting+0x188>)
 801d162:	2200      	movs	r2, #0
 801d164:	701a      	strb	r2, [r3, #0]
            set->on_changed(&settings, changed);
 801d166:	9b00      	ldr	r3, [sp, #0]
 801d168:	69db      	ldr	r3, [r3, #28]
 801d16a:	4621      	mov	r1, r4
 801d16c:	4808      	ldr	r0, [pc, #32]	; (801d190 <settings_store_setting+0x18c>)
 801d16e:	4798      	blx	r3
 801d170:	e7a0      	b.n	801d0b4 <settings_store_setting+0xb0>
            changed.spindle = settings_changed_spindle() || machine_mode_changed;
 801d172:	2300      	movs	r3, #0
 801d174:	e7f2      	b.n	801d15c <settings_store_setting+0x158>
            return Status_SettingDisabled;
 801d176:	2735      	movs	r7, #53	; 0x35
 801d178:	e79c      	b.n	801d0b4 <settings_store_setting+0xb0>
 801d17a:	2702      	movs	r7, #2
 801d17c:	e79a      	b.n	801d0b4 <settings_store_setting+0xb0>
 801d17e:	bf00      	nop
 801d180:	7fc00000 	.word	0x7fc00000
 801d184:	200004b4 	.word	0x200004b4
 801d188:	0802b3a0 	.word	0x0802b3a0
 801d18c:	20003b01 	.word	0x20003b01
 801d190:	20003b14 	.word	0x20003b14

0801d194 <settings_add_spindle_type>:

bool settings_add_spindle_type (const char *type)
{
 801d194:	b570      	push	{r4, r5, r6, lr}
 801d196:	4604      	mov	r4, r0
    bool ok;

    if((ok = strlen(spindle_types) + strlen(type) + 1 < sizeof(spindle_types))) {
 801d198:	480d      	ldr	r0, [pc, #52]	; (801d1d0 <settings_add_spindle_type+0x3c>)
 801d19a:	f7ea ff5b 	bl	8008054 <strlen>
 801d19e:	4605      	mov	r5, r0
 801d1a0:	4620      	mov	r0, r4
 801d1a2:	f7ea ff57 	bl	8008054 <strlen>
 801d1a6:	182b      	adds	r3, r5, r0
 801d1a8:	3301      	adds	r3, #1
 801d1aa:	2b63      	cmp	r3, #99	; 0x63
 801d1ac:	bf94      	ite	ls
 801d1ae:	2601      	movls	r6, #1
 801d1b0:	2600      	movhi	r6, #0
 801d1b2:	d806      	bhi.n	801d1c2 <settings_add_spindle_type+0x2e>
        if(*spindle_types != '\0')
 801d1b4:	4b06      	ldr	r3, [pc, #24]	; (801d1d0 <settings_add_spindle_type+0x3c>)
 801d1b6:	781b      	ldrb	r3, [r3, #0]
 801d1b8:	b92b      	cbnz	r3, 801d1c6 <settings_add_spindle_type+0x32>
            strcat(spindle_types, ",");
        strcat(spindle_types, type);
 801d1ba:	4621      	mov	r1, r4
 801d1bc:	4804      	ldr	r0, [pc, #16]	; (801d1d0 <settings_add_spindle_type+0x3c>)
 801d1be:	f005 fce2 	bl	8022b86 <strcat>
    }

    return ok;
}
 801d1c2:	4630      	mov	r0, r6
 801d1c4:	bd70      	pop	{r4, r5, r6, pc}
            strcat(spindle_types, ",");
 801d1c6:	4b03      	ldr	r3, [pc, #12]	; (801d1d4 <settings_add_spindle_type+0x40>)
 801d1c8:	881a      	ldrh	r2, [r3, #0]
 801d1ca:	4b01      	ldr	r3, [pc, #4]	; (801d1d0 <settings_add_spindle_type+0x3c>)
 801d1cc:	535a      	strh	r2, [r3, r5]
 801d1ce:	e7f4      	b.n	801d1ba <settings_add_spindle_type+0x26>
 801d1d0:	20003cf4 	.word	0x20003cf4
 801d1d4:	08027758 	.word	0x08027758

0801d1d8 <settings_clear>:

// Clear settings chain
void settings_clear (void)
{
    setting_details.next = NULL;
 801d1d8:	4b02      	ldr	r3, [pc, #8]	; (801d1e4 <settings_clear+0xc>)
 801d1da:	2200      	movs	r2, #0
 801d1dc:	619a      	str	r2, [r3, #24]
    settingsd = &setting_details;
 801d1de:	4a02      	ldr	r2, [pc, #8]	; (801d1e8 <settings_clear+0x10>)
 801d1e0:	6013      	str	r3, [r2, #0]
}
 801d1e2:	4770      	bx	lr
 801d1e4:	200004b4 	.word	0x200004b4
 801d1e8:	200004e4 	.word	0x200004e4

0801d1ec <settings_init>:

// Initialize the config subsystem
void settings_init (void)
{
 801d1ec:	b570      	push	{r4, r5, r6, lr}
    settings_changed_flags_t changed = {0};
 801d1ee:	f04f 0500 	mov.w	r5, #0

    if(!read_global_settings()) {
 801d1f2:	f7ff fc33 	bl	801ca5c <read_global_settings>
 801d1f6:	2800      	cmp	r0, #0
 801d1f8:	d14d      	bne.n	801d296 <settings_init+0xaa>

        settings_restore_t settings = settings_all;
        settings.defaults = 1; // Ensure global settings get restored

        if(hal.nvs.type != NVS_None)
 801d1fa:	4b3f      	ldr	r3, [pc, #252]	; (801d2f8 <settings_init+0x10c>)
 801d1fc:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 801d200:	b11b      	cbz	r3, 801d20a <settings_init+0x1e>
            grbl.report.status_message(Status_SettingReadFail);
 801d202:	4b3e      	ldr	r3, [pc, #248]	; (801d2fc <settings_init+0x110>)
 801d204:	689b      	ldr	r3, [r3, #8]
 801d206:	2007      	movs	r0, #7
 801d208:	4798      	blx	r3

        settings_restore(settings); // Force restore all non-volatile storage data.
 801d20a:	f04f 001f 	mov.w	r0, #31
 801d20e:	f7ff fc85 	bl	801cb1c <settings_restore>
        report_init();
 801d212:	f7fb ffdd 	bl	80191d0 <report_init>
#if COMPATIBILITY_LEVEL <= 1
        report_grbl_settings(true, NULL);
 801d216:	2100      	movs	r1, #0
 801d218:	2001      	movs	r0, #1
 801d21a:	f7fc f861 	bl	80192e0 <report_grbl_settings>
#else
        report_grbl_settings(false, NULL);
#endif
        changed.spindle = settings_changed_spindle();
 801d21e:	f7ff f839 	bl	801c294 <settings_changed_spindle>
 801d222:	f360 0500 	bfi	r5, r0, #0, #1

        if(hal.probe.configure) // Initialize probe invert mask.
            hal.probe.configure(false, false);
    }

    if(spindle_get_count() == 0)
 801d226:	f000 fbef 	bl	801da08 <spindle_get_count>
 801d22a:	2800      	cmp	r0, #0
 801d22c:	d04e      	beq.n	801d2cc <settings_init+0xe0>
        spindle_add_null();

    spindle_state_t spindle_cap = {
 801d22e:	2600      	movs	r6, #0
 801d230:	f04f 0401 	mov.w	r4, #1
        .on = On,
    };

    spindle_cap.ccw = spindle_get_caps(false).direction;
 801d234:	4630      	mov	r0, r6
 801d236:	f000 fad3 	bl	801d7e0 <spindle_get_caps>
 801d23a:	f3c0 0040 	ubfx	r0, r0, #1, #1
 801d23e:	f360 0441 	bfi	r4, r0, #1, #1
    spindle_cap.pwm = spindle_get_caps(false).pwm_invert;
 801d242:	4630      	mov	r0, r6
 801d244:	f000 facc 	bl	801d7e0 <spindle_get_caps>
 801d248:	f3c0 1000 	ubfx	r0, r0, #4, #1
 801d24c:	f360 0482 	bfi	r4, r0, #2, #1

    setting_remove_elements(Setting_SpindleInvertMask, spindle_cap.mask);
 801d250:	b2e1      	uxtb	r1, r4
 801d252:	2010      	movs	r0, #16
 801d254:	f7ff fe66 	bl	801cf24 <setting_remove_elements>
    setting_remove_elements(Setting_ControlInvertMask, hal.signals_cap.mask);
 801d258:	4c27      	ldr	r4, [pc, #156]	; (801d2f8 <settings_init+0x10c>)
 801d25a:	f8b4 11a8 	ldrh.w	r1, [r4, #424]	; 0x1a8
 801d25e:	200e      	movs	r0, #14
 801d260:	f7ff fe60 	bl	801cf24 <setting_remove_elements>

    if(hal.stepper.get_ganged)
 801d264:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
 801d268:	b12b      	cbz	r3, 801d276 <settings_init+0x8a>
        setting_remove_elements(Setting_GangedDirInvertMask, hal.stepper.get_ganged(false).mask);
 801d26a:	4630      	mov	r0, r6
 801d26c:	4798      	blx	r3
 801d26e:	b2c1      	uxtb	r1, r0
 801d270:	2008      	movs	r0, #8
 801d272:	f7ff fe57 	bl	801cf24 <setting_remove_elements>

    if(!hal.driver_cap.mist_control)
 801d276:	4b20      	ldr	r3, [pc, #128]	; (801d2f8 <settings_init+0x10c>)
 801d278:	f893 31a4 	ldrb.w	r3, [r3, #420]	; 0x1a4
 801d27c:	f013 0f01 	tst.w	r3, #1
 801d280:	d027      	beq.n	801d2d2 <settings_init+0xe6>
        setting_remove_element(Setting_CoolantInvertMask, 1);

    setting_details_t *details = setting_details.next;
 801d282:	4b1f      	ldr	r3, [pc, #124]	; (801d300 <settings_init+0x114>)
 801d284:	699c      	ldr	r4, [r3, #24]

    if(details) do {
 801d286:	2c00      	cmp	r4, #0
 801d288:	d12e      	bne.n	801d2e8 <settings_init+0xfc>
            details->load();
        if(details->on_changed)
            details->on_changed(&settings, changed);
    } while((details = details->next));

    setting_details.on_changed = hal.settings_changed;
 801d28a:	4b1b      	ldr	r3, [pc, #108]	; (801d2f8 <settings_init+0x10c>)
 801d28c:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
 801d290:	4b1b      	ldr	r3, [pc, #108]	; (801d300 <settings_init+0x114>)
 801d292:	61da      	str	r2, [r3, #28]
}
 801d294:	bd70      	pop	{r4, r5, r6, pc}
        memset(&tool_table, 0, sizeof(tool_data_t)); // First entry is for tools not in tool table
 801d296:	4b1b      	ldr	r3, [pc, #108]	; (801d304 <settings_init+0x118>)
 801d298:	2200      	movs	r2, #0
 801d29a:	601a      	str	r2, [r3, #0]
 801d29c:	605a      	str	r2, [r3, #4]
 801d29e:	609a      	str	r2, [r3, #8]
 801d2a0:	60da      	str	r2, [r3, #12]
 801d2a2:	611a      	str	r2, [r3, #16]
        report_init();
 801d2a4:	f7fb ff94 	bl	80191d0 <report_init>
        changed.spindle = settings_changed_spindle();
 801d2a8:	f7fe fff4 	bl	801c294 <settings_changed_spindle>
 801d2ac:	f360 0500 	bfi	r5, r0, #0, #1
        hal.settings_changed(&settings, changed);
 801d2b0:	4c11      	ldr	r4, [pc, #68]	; (801d2f8 <settings_init+0x10c>)
 801d2b2:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
 801d2b6:	4629      	mov	r1, r5
 801d2b8:	4813      	ldr	r0, [pc, #76]	; (801d308 <settings_init+0x11c>)
 801d2ba:	4798      	blx	r3
        if(hal.probe.configure) // Initialize probe invert mask.
 801d2bc:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 801d2c0:	2b00      	cmp	r3, #0
 801d2c2:	d0b0      	beq.n	801d226 <settings_init+0x3a>
            hal.probe.configure(false, false);
 801d2c4:	2100      	movs	r1, #0
 801d2c6:	4608      	mov	r0, r1
 801d2c8:	4798      	blx	r3
 801d2ca:	e7ac      	b.n	801d226 <settings_init+0x3a>
        spindle_add_null();
 801d2cc:	f000 fb58 	bl	801d980 <spindle_add_null>
 801d2d0:	e7ad      	b.n	801d22e <settings_init+0x42>
        setting_remove_element(Setting_CoolantInvertMask, 1);
 801d2d2:	2101      	movs	r1, #1
 801d2d4:	200f      	movs	r0, #15
 801d2d6:	f7ff fe15 	bl	801cf04 <setting_remove_element>
 801d2da:	e7d2      	b.n	801d282 <settings_init+0x96>
            details->on_changed(&settings, changed);
 801d2dc:	4629      	mov	r1, r5
 801d2de:	480a      	ldr	r0, [pc, #40]	; (801d308 <settings_init+0x11c>)
 801d2e0:	4798      	blx	r3
    } while((details = details->next));
 801d2e2:	69a4      	ldr	r4, [r4, #24]
 801d2e4:	2c00      	cmp	r4, #0
 801d2e6:	d0d0      	beq.n	801d28a <settings_init+0x9e>
        if(details->load)
 801d2e8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801d2ea:	b103      	cbz	r3, 801d2ee <settings_init+0x102>
            details->load();
 801d2ec:	4798      	blx	r3
        if(details->on_changed)
 801d2ee:	69e3      	ldr	r3, [r4, #28]
 801d2f0:	2b00      	cmp	r3, #0
 801d2f2:	d1f3      	bne.n	801d2dc <settings_init+0xf0>
 801d2f4:	e7f5      	b.n	801d2e2 <settings_init+0xf6>
 801d2f6:	bf00      	nop
 801d2f8:	2000350c 	.word	0x2000350c
 801d2fc:	2000343c 	.word	0x2000343c
 801d300:	200004b4 	.word	0x200004b4
 801d304:	20003424 	.word	0x20003424
 801d308:	20003b14 	.word	0x20003b14

0801d30c <fall_asleep>:

static volatile bool slumber;

static void fall_asleep()
{
    slumber = false;
 801d30c:	4b01      	ldr	r3, [pc, #4]	; (801d314 <fall_asleep+0x8>)
 801d30e:	2200      	movs	r2, #0
 801d310:	701a      	strb	r2, [r3, #0]
}
 801d312:	4770      	bx	lr
 801d314:	20003d58 	.word	0x20003d58

0801d318 <sleep_execute>:

// Starts sleep timer if running conditions are satisfied. When elapsed, sleep mode is executed.
static void sleep_execute()
{
 801d318:	b538      	push	{r3, r4, r5, lr}
    // Enable sleep timeout
    slumber = true;
 801d31a:	4b17      	ldr	r3, [pc, #92]	; (801d378 <sleep_execute+0x60>)
 801d31c:	2201      	movs	r2, #1
 801d31e:	701a      	strb	r2, [r3, #0]
    hal.delay_ms((uint32_t)(SLEEP_DURATION * 1000.0f * 60.0f), fall_asleep);
 801d320:	4c16      	ldr	r4, [pc, #88]	; (801d37c <sleep_execute+0x64>)
 801d322:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 801d324:	4916      	ldr	r1, [pc, #88]	; (801d380 <sleep_execute+0x68>)
 801d326:	4817      	ldr	r0, [pc, #92]	; (801d384 <sleep_execute+0x6c>)
 801d328:	4798      	blx	r3

    // Fetch current number of buffered characters in input stream buffer.
    uint16_t rx_initial = hal.stream.get_rx_buffer_free();
 801d32a:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
 801d32e:	4798      	blx	r3
 801d330:	4605      	mov	r5, r0

    do {
        grbl.on_execute_realtime(state_get());
 801d332:	4b15      	ldr	r3, [pc, #84]	; (801d388 <sleep_execute+0x70>)
 801d334:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 801d336:	f001 f955 	bl	801e5e4 <state_get>
 801d33a:	47a0      	blx	r4
        // Monitor for any new input stream data or external events (queries, buttons, alarms) to exit.
        if ((hal.stream.get_rx_buffer_free() != rx_initial) || sys.rt_exec_state || sys.rt_exec_alarm ) {
 801d33c:	4b0f      	ldr	r3, [pc, #60]	; (801d37c <sleep_execute+0x64>)
 801d33e:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 801d342:	4798      	blx	r3
 801d344:	42a8      	cmp	r0, r5
 801d346:	d110      	bne.n	801d36a <sleep_execute+0x52>
 801d348:	4b10      	ldr	r3, [pc, #64]	; (801d38c <sleep_execute+0x74>)
 801d34a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d34c:	b96b      	cbnz	r3, 801d36a <sleep_execute+0x52>
 801d34e:	4b0f      	ldr	r3, [pc, #60]	; (801d38c <sleep_execute+0x74>)
 801d350:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801d352:	b953      	cbnz	r3, 801d36a <sleep_execute+0x52>
            // Disable sleep timeout and return to normal operation.
            hal.delay_ms(0, NULL);
            return;
        }
    } while(slumber);
 801d354:	4b08      	ldr	r3, [pc, #32]	; (801d378 <sleep_execute+0x60>)
 801d356:	781b      	ldrb	r3, [r3, #0]
 801d358:	2b00      	cmp	r3, #0
 801d35a:	d1ea      	bne.n	801d332 <sleep_execute+0x1a>

    // If reached, sleep counter has expired. Execute sleep procedures.
    // Notify user that Grbl has timed out and will be parking.
    // To exit sleep, resume or reset. Either way, the job will not be recoverable.
    system_set_exec_state_flag(EXEC_SLEEP);
 801d35c:	4b07      	ldr	r3, [pc, #28]	; (801d37c <sleep_execute+0x64>)
 801d35e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801d360:	f44f 7180 	mov.w	r1, #256	; 0x100
 801d364:	480a      	ldr	r0, [pc, #40]	; (801d390 <sleep_execute+0x78>)
 801d366:	4798      	blx	r3
 801d368:	e004      	b.n	801d374 <sleep_execute+0x5c>
            hal.delay_ms(0, NULL);
 801d36a:	4b04      	ldr	r3, [pc, #16]	; (801d37c <sleep_execute+0x64>)
 801d36c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801d36e:	2100      	movs	r1, #0
 801d370:	4608      	mov	r0, r1
 801d372:	4798      	blx	r3
}
 801d374:	bd38      	pop	{r3, r4, r5, pc}
 801d376:	bf00      	nop
 801d378:	20003d58 	.word	0x20003d58
 801d37c:	2000350c 	.word	0x2000350c
 801d380:	0801d30d 	.word	0x0801d30d
 801d384:	000493e0 	.word	0x000493e0
 801d388:	2000343c 	.word	0x2000343c
 801d38c:	200036c4 	.word	0x200036c4
 801d390:	2000370c 	.word	0x2000370c

0801d394 <sleep_check>:
// Checks running conditions for sleep. If satisfied, enables sleep timeout and executes
// sleep mode upon elapse.
// NOTE: Sleep procedures can be blocking, since Grbl isn't receiving any commands, nor moving.
// Hence, make sure any valid running state that executes the sleep timer is not one that is moving.
void sleep_check()
{
 801d394:	b508      	push	{r3, lr}
    // The sleep execution feature will continue only if the machine is in an IDLE or HOLD state and
    // has any powered components enabled.
    // NOTE: With overrides or in laser mode, modal spindle and coolant state are not guaranteed. Need
    // to directly monitor and record running state during parking to ensure proper function.
    if (!sys.steppers_deenergize && (gc_state.modal.spindle.state.value || gc_state.modal.coolant.value)) {
 801d396:	4b13      	ldr	r3, [pc, #76]	; (801d3e4 <sleep_check+0x50>)
 801d398:	799b      	ldrb	r3, [r3, #6]
 801d39a:	b933      	cbnz	r3, 801d3aa <sleep_check+0x16>
 801d39c:	4b12      	ldr	r3, [pc, #72]	; (801d3e8 <sleep_check+0x54>)
 801d39e:	699b      	ldr	r3, [r3, #24]
 801d3a0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 801d3a4:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 801d3a8:	b903      	cbnz	r3, 801d3ac <sleep_check+0x18>
                if(sys.parking_state == Parking_DoorAjar)
                    sleep_execute();
                break;
        }
    }
}
 801d3aa:	bd08      	pop	{r3, pc}
        switch(state_get()) {
 801d3ac:	f001 f91a 	bl	801e5e4 <state_get>
 801d3b0:	2810      	cmp	r0, #16
 801d3b2:	d006      	beq.n	801d3c2 <sleep_check+0x2e>
 801d3b4:	2840      	cmp	r0, #64	; 0x40
 801d3b6:	d00c      	beq.n	801d3d2 <sleep_check+0x3e>
 801d3b8:	2800      	cmp	r0, #0
 801d3ba:	d1f6      	bne.n	801d3aa <sleep_check+0x16>
                sleep_execute();
 801d3bc:	f7ff ffac 	bl	801d318 <sleep_execute>
                break;
 801d3c0:	e7f3      	b.n	801d3aa <sleep_check+0x16>
                if(sys.holding_state == Hold_Complete)
 801d3c2:	4b08      	ldr	r3, [pc, #32]	; (801d3e4 <sleep_check+0x50>)
 801d3c4:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 801d3c8:	2b01      	cmp	r3, #1
 801d3ca:	d1ee      	bne.n	801d3aa <sleep_check+0x16>
                    sleep_execute();
 801d3cc:	f7ff ffa4 	bl	801d318 <sleep_execute>
 801d3d0:	e7eb      	b.n	801d3aa <sleep_check+0x16>
                if(sys.parking_state == Parking_DoorAjar)
 801d3d2:	4b04      	ldr	r3, [pc, #16]	; (801d3e4 <sleep_check+0x50>)
 801d3d4:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 801d3d8:	2b01      	cmp	r3, #1
 801d3da:	d1e6      	bne.n	801d3aa <sleep_check+0x16>
                    sleep_execute();
 801d3dc:	f7ff ff9c 	bl	801d318 <sleep_execute>
}
 801d3e0:	e7e3      	b.n	801d3aa <sleep_check+0x16>
 801d3e2:	bf00      	nop
 801d3e4:	200036c4 	.word	0x200036c4
 801d3e8:	20003344 	.word	0x20003344

0801d3ec <null_set_state>:

static void null_set_state (spindle_state_t state, float rpm)
{
    UNUSED(state);
    UNUSED(rpm);
}
 801d3ec:	4770      	bx	lr

0801d3ee <null_get_state>:

static spindle_state_t null_get_state (void)
{
    return (spindle_state_t){0};
}
 801d3ee:	f04f 0000 	mov.w	r0, #0
 801d3f2:	4770      	bx	lr

0801d3f4 <null_update_pwm>:

// Sets spindle speed
static void null_update_pwm (uint_fast16_t pwm_value)
{
    UNUSED(pwm_value);
}
 801d3f4:	4770      	bx	lr

0801d3f6 <null_get_pwm>:
static uint_fast16_t null_get_pwm (float rpm)
{
    UNUSED(rpm);

    return 0;
}
 801d3f6:	2000      	movs	r0, #0
 801d3f8:	4770      	bx	lr

0801d3fa <null_update_rpm>:

static void null_update_rpm (float rpm)
{
    UNUSED(rpm);
}
 801d3fa:	4770      	bx	lr

0801d3fc <spindle_activate>:
{
 801d3fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801d400:	b090      	sub	sp, #64	; 0x40
 801d402:	4604      	mov	r4, r0
 801d404:	460d      	mov	r5, r1
    if(pwm_spindle && pwm_spindle->cfg->config && pwm_spindle != &spindles[spindle_id]) {
 801d406:	4b89      	ldr	r3, [pc, #548]	; (801d62c <spindle_activate+0x230>)
 801d408:	6818      	ldr	r0, [r3, #0]
 801d40a:	b318      	cbz	r0, 801d454 <spindle_activate+0x58>
 801d40c:	6803      	ldr	r3, [r0, #0]
 801d40e:	699b      	ldr	r3, [r3, #24]
 801d410:	b303      	cbz	r3, 801d454 <spindle_activate+0x58>
 801d412:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
 801d416:	4b86      	ldr	r3, [pc, #536]	; (801d630 <spindle_activate+0x234>)
 801d418:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801d41c:	4298      	cmp	r0, r3
 801d41e:	d019      	beq.n	801d454 <spindle_activate+0x58>
        if(!pwm_spindle->hal.cap.rpm_range_locked) {
 801d420:	f990 300d 	ldrsb.w	r3, [r0, #13]
 801d424:	2b00      	cmp	r3, #0
 801d426:	db04      	blt.n	801d432 <spindle_activate+0x36>
            pwm_spindle->hal.rpm_min = settings.spindle.rpm_min;
 801d428:	4b82      	ldr	r3, [pc, #520]	; (801d634 <spindle_activate+0x238>)
 801d42a:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 801d42c:	6142      	str	r2, [r0, #20]
            pwm_spindle->hal.rpm_max = settings.spindle.rpm_max;
 801d42e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801d430:	6183      	str	r3, [r0, #24]
        if((pwm_spindle->init_ok = pwm_spindle->hal.config == NULL || pwm_spindle->hal.config(&pwm_spindle->hal)))
 801d432:	69c3      	ldr	r3, [r0, #28]
 801d434:	b1fb      	cbz	r3, 801d476 <spindle_activate+0x7a>
 801d436:	3004      	adds	r0, #4
 801d438:	4798      	blx	r3
 801d43a:	b9f0      	cbnz	r0, 801d47a <spindle_activate+0x7e>
 801d43c:	2300      	movs	r3, #0
 801d43e:	4a7b      	ldr	r2, [pc, #492]	; (801d62c <spindle_activate+0x230>)
 801d440:	6812      	ldr	r2, [r2, #0]
 801d442:	f882 3044 	strb.w	r3, [r2, #68]	; 0x44
 801d446:	b12b      	cbz	r3, 801d454 <spindle_activate+0x58>
            pwm_spindle->hal.set_state((spindle_state_t){0}, 0.0f);
 801d448:	6a13      	ldr	r3, [r2, #32]
 801d44a:	ed9f 0a7b 	vldr	s0, [pc, #492]	; 801d638 <spindle_activate+0x23c>
 801d44e:	f04f 0000 	mov.w	r0, #0
 801d452:	4798      	blx	r3
    pwm_spindle = NULL;
 801d454:	4b75      	ldr	r3, [pc, #468]	; (801d62c <spindle_activate+0x230>)
 801d456:	2200      	movs	r2, #0
 801d458:	601a      	str	r2, [r3, #0]
    if((ok = spindle_id >= 0 && spindle_id < n_spindle && !!spindles[spindle_id].cfg)) {
 801d45a:	4294      	cmp	r4, r2
 801d45c:	db0f      	blt.n	801d47e <spindle_activate+0x82>
 801d45e:	4b77      	ldr	r3, [pc, #476]	; (801d63c <spindle_activate+0x240>)
 801d460:	781b      	ldrb	r3, [r3, #0]
 801d462:	429c      	cmp	r4, r3
 801d464:	da57      	bge.n	801d516 <spindle_activate+0x11a>
 801d466:	eb04 03c4 	add.w	r3, r4, r4, lsl #3
 801d46a:	4a71      	ldr	r2, [pc, #452]	; (801d630 <spindle_activate+0x234>)
 801d46c:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 801d470:	b133      	cbz	r3, 801d480 <spindle_activate+0x84>
 801d472:	2301      	movs	r3, #1
 801d474:	e004      	b.n	801d480 <spindle_activate+0x84>
        if((pwm_spindle->init_ok = pwm_spindle->hal.config == NULL || pwm_spindle->hal.config(&pwm_spindle->hal)))
 801d476:	2301      	movs	r3, #1
 801d478:	e7e1      	b.n	801d43e <spindle_activate+0x42>
 801d47a:	2301      	movs	r3, #1
 801d47c:	e7df      	b.n	801d43e <spindle_activate+0x42>
    if((ok = spindle_id >= 0 && spindle_id < n_spindle && !!spindles[spindle_id].cfg)) {
 801d47e:	2300      	movs	r3, #0
 801d480:	461e      	mov	r6, r3
 801d482:	2b00      	cmp	r3, #0
 801d484:	d043      	beq.n	801d50e <spindle_activate+0x112>
        if(sys_spindle[spindle_num].enabled && sys_spindle[spindle_num].hal.id != spindle_id && sys_spindle[spindle_num].hal.set_state)
 801d486:	4b6e      	ldr	r3, [pc, #440]	; (801d640 <spindle_activate+0x244>)
 801d488:	226c      	movs	r2, #108	; 0x6c
 801d48a:	fb02 3305 	mla	r3, r2, r5, r3
 801d48e:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
 801d492:	b16b      	cbz	r3, 801d4b0 <spindle_activate+0xb4>
 801d494:	4b6a      	ldr	r3, [pc, #424]	; (801d640 <spindle_activate+0x244>)
 801d496:	fb02 3305 	mla	r3, r2, r5, r3
 801d49a:	f993 302c 	ldrsb.w	r3, [r3, #44]	; 0x2c
 801d49e:	42a3      	cmp	r3, r4
 801d4a0:	d006      	beq.n	801d4b0 <spindle_activate+0xb4>
 801d4a2:	4b67      	ldr	r3, [pc, #412]	; (801d640 <spindle_activate+0x244>)
 801d4a4:	fb02 3305 	mla	r3, r2, r5, r3
 801d4a8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d4aa:	b10b      	cbz	r3, 801d4b0 <spindle_activate+0xb4>
            gc_spindle_off(); // TODO: switch off only the default spindle?
 801d4ac:	f7f1 fed2 	bl	800f254 <gc_spindle_off>
        if(!spindle->hal.cap.rpm_range_locked) {
 801d4b0:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
 801d4b4:	4b5e      	ldr	r3, [pc, #376]	; (801d630 <spindle_activate+0x234>)
 801d4b6:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801d4ba:	f993 300d 	ldrsb.w	r3, [r3, #13]
 801d4be:	2b00      	cmp	r3, #0
 801d4c0:	db07      	blt.n	801d4d2 <spindle_activate+0xd6>
            spindle->hal.rpm_min = settings.spindle.rpm_min;
 801d4c2:	495c      	ldr	r1, [pc, #368]	; (801d634 <spindle_activate+0x238>)
 801d4c4:	6f88      	ldr	r0, [r1, #120]	; 0x78
 801d4c6:	4b5a      	ldr	r3, [pc, #360]	; (801d630 <spindle_activate+0x234>)
 801d4c8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801d4cc:	6158      	str	r0, [r3, #20]
            spindle->hal.rpm_max = settings.spindle.rpm_max;
 801d4ce:	6f4a      	ldr	r2, [r1, #116]	; 0x74
 801d4d0:	619a      	str	r2, [r3, #24]
        if(!spindle->init_ok)
 801d4d2:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
 801d4d6:	4b56      	ldr	r3, [pc, #344]	; (801d630 <spindle_activate+0x234>)
 801d4d8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801d4dc:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 801d4e0:	b9a3      	cbnz	r3, 801d50c <spindle_activate+0x110>
            ok = spindle->init_ok = spindle->hal.config == NULL || spindle->hal.config(&spindle->hal);
 801d4e2:	4b53      	ldr	r3, [pc, #332]	; (801d630 <spindle_activate+0x234>)
 801d4e4:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801d4e8:	69da      	ldr	r2, [r3, #28]
 801d4ea:	b1b2      	cbz	r2, 801d51a <spindle_activate+0x11e>
 801d4ec:	eb04 03c4 	add.w	r3, r4, r4, lsl #3
 801d4f0:	484f      	ldr	r0, [pc, #316]	; (801d630 <spindle_activate+0x234>)
 801d4f2:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
 801d4f6:	3004      	adds	r0, #4
 801d4f8:	4790      	blx	r2
 801d4fa:	b980      	cbnz	r0, 801d51e <spindle_activate+0x122>
 801d4fc:	2600      	movs	r6, #0
 801d4fe:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
 801d502:	4b4b      	ldr	r3, [pc, #300]	; (801d630 <spindle_activate+0x234>)
 801d504:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801d508:	f883 6044 	strb.w	r6, [r3, #68]	; 0x44
        if(ok) {
 801d50c:	b94e      	cbnz	r6, 801d522 <spindle_activate+0x126>
}
 801d50e:	4630      	mov	r0, r6
 801d510:	b010      	add	sp, #64	; 0x40
 801d512:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if((ok = spindle_id >= 0 && spindle_id < n_spindle && !!spindles[spindle_id].cfg)) {
 801d516:	2300      	movs	r3, #0
 801d518:	e7b2      	b.n	801d480 <spindle_activate+0x84>
            ok = spindle->init_ok = spindle->hal.config == NULL || spindle->hal.config(&spindle->hal);
 801d51a:	2601      	movs	r6, #1
 801d51c:	e7ef      	b.n	801d4fe <spindle_activate+0x102>
 801d51e:	2601      	movs	r6, #1
 801d520:	e7ed      	b.n	801d4fe <spindle_activate+0x102>
            memcpy(&spindle_hal, &spindle->hal, sizeof(spindle_ptrs_t));
 801d522:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
 801d526:	4b42      	ldr	r3, [pc, #264]	; (801d630 <spindle_activate+0x234>)
 801d528:	eb03 08c2 	add.w	r8, r3, r2, lsl #3
 801d52c:	f108 0c04 	add.w	ip, r8, #4
 801d530:	af01      	add	r7, sp, #4
 801d532:	f108 0834 	add.w	r8, r8, #52	; 0x34
 801d536:	46be      	mov	lr, r7
 801d538:	f8dc 0000 	ldr.w	r0, [ip]
 801d53c:	f8dc 1004 	ldr.w	r1, [ip, #4]
 801d540:	f8dc 2008 	ldr.w	r2, [ip, #8]
 801d544:	f8dc 300c 	ldr.w	r3, [ip, #12]
 801d548:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 801d54c:	f10c 0c10 	add.w	ip, ip, #16
 801d550:	4677      	mov	r7, lr
 801d552:	45c4      	cmp	ip, r8
 801d554:	d1ef      	bne.n	801d536 <spindle_activate+0x13a>
 801d556:	f8dc 0000 	ldr.w	r0, [ip]
 801d55a:	f8dc 1004 	ldr.w	r1, [ip, #4]
 801d55e:	f8dc 2008 	ldr.w	r2, [ip, #8]
 801d562:	c707      	stmia	r7!, {r0, r1, r2}
            if(spindle->cfg->get_data == NULL) {
 801d564:	eb04 04c4 	add.w	r4, r4, r4, lsl #3
 801d568:	4b31      	ldr	r3, [pc, #196]	; (801d630 <spindle_activate+0x234>)
 801d56a:	f853 3034 	ldr.w	r3, [r3, r4, lsl #3]
 801d56e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 801d570:	2a00      	cmp	r2, #0
 801d572:	d048      	beq.n	801d606 <spindle_activate+0x20a>
            spindle_hal.cap.laser &= settings.mode == Mode_Laser;
 801d574:	f89d 300d 	ldrb.w	r3, [sp, #13]
 801d578:	4a2e      	ldr	r2, [pc, #184]	; (801d634 <spindle_activate+0x238>)
 801d57a:	7e12      	ldrb	r2, [r2, #24]
 801d57c:	2a01      	cmp	r2, #1
 801d57e:	bf14      	ite	ne
 801d580:	2200      	movne	r2, #0
 801d582:	2201      	moveq	r2, #1
 801d584:	ea02 02d3 	and.w	r2, r2, r3, lsr #3
 801d588:	f362 03c3 	bfi	r3, r2, #3, #1
 801d58c:	f88d 300d 	strb.w	r3, [sp, #13]
            if(grbl.on_spindle_select)
 801d590:	4b2c      	ldr	r3, [pc, #176]	; (801d644 <spindle_activate+0x248>)
 801d592:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 801d596:	b113      	cbz	r3, 801d59e <spindle_activate+0x1a2>
                ok = grbl.on_spindle_select(&spindle_hal);
 801d598:	a801      	add	r0, sp, #4
 801d59a:	4798      	blx	r3
 801d59c:	4606      	mov	r6, r0
            if(ok) {
 801d59e:	2e00      	cmp	r6, #0
 801d5a0:	d0b5      	beq.n	801d50e <spindle_activate+0x112>
                sys_spindle[spindle_num].enabled = true;
 801d5a2:	4a27      	ldr	r2, [pc, #156]	; (801d640 <spindle_activate+0x244>)
 801d5a4:	236c      	movs	r3, #108	; 0x6c
 801d5a6:	fb05 f303 	mul.w	r3, r5, r3
 801d5aa:	18d1      	adds	r1, r2, r3
 801d5ac:	2001      	movs	r0, #1
 801d5ae:	f881 0068 	strb.w	r0, [r1, #104]	; 0x68
                sys_spindle[spindle_num].param.hal = &sys_spindle[spindle_num].hal;
 801d5b2:	3328      	adds	r3, #40	; 0x28
 801d5b4:	eb02 0c03 	add.w	ip, r2, r3
 801d5b8:	f10c 0c04 	add.w	ip, ip, #4
 801d5bc:	f8c1 c028 	str.w	ip, [r1, #40]	; 0x28
                if(sys_spindle[spindle_num].param.override_pct == 0)
 801d5c0:	68cb      	ldr	r3, [r1, #12]
 801d5c2:	b90b      	cbnz	r3, 801d5c8 <spindle_activate+0x1cc>
                    sys_spindle[spindle_num].param.override_pct = DEFAULT_SPINDLE_RPM_OVERRIDE;
 801d5c4:	2264      	movs	r2, #100	; 0x64
 801d5c6:	60ca      	str	r2, [r1, #12]
                spindle_hal.param = &sys_spindle[spindle_num].param;
 801d5c8:	4b1d      	ldr	r3, [pc, #116]	; (801d640 <spindle_activate+0x244>)
 801d5ca:	226c      	movs	r2, #108	; 0x6c
 801d5cc:	fb02 3305 	mla	r3, r2, r5, r3
 801d5d0:	9302      	str	r3, [sp, #8]
                memcpy(&sys_spindle[spindle_num].hal, &spindle_hal, sizeof(spindle_ptrs_t));
 801d5d2:	af01      	add	r7, sp, #4
 801d5d4:	4664      	mov	r4, ip
 801d5d6:	f10d 0e34 	add.w	lr, sp, #52	; 0x34
 801d5da:	463d      	mov	r5, r7
 801d5dc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801d5de:	6020      	str	r0, [r4, #0]
 801d5e0:	6061      	str	r1, [r4, #4]
 801d5e2:	60a2      	str	r2, [r4, #8]
 801d5e4:	60e3      	str	r3, [r4, #12]
 801d5e6:	462f      	mov	r7, r5
 801d5e8:	3410      	adds	r4, #16
 801d5ea:	4575      	cmp	r5, lr
 801d5ec:	d1f5      	bne.n	801d5da <spindle_activate+0x1de>
 801d5ee:	cf07      	ldmia	r7!, {r0, r1, r2}
 801d5f0:	6020      	str	r0, [r4, #0]
 801d5f2:	6061      	str	r1, [r4, #4]
 801d5f4:	60a2      	str	r2, [r4, #8]
                if(grbl.on_spindle_selected)
 801d5f6:	4b13      	ldr	r3, [pc, #76]	; (801d644 <spindle_activate+0x248>)
 801d5f8:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 801d5fc:	2b00      	cmp	r3, #0
 801d5fe:	d086      	beq.n	801d50e <spindle_activate+0x112>
                    grbl.on_spindle_selected(&sys_spindle[spindle_num].hal);
 801d600:	4660      	mov	r0, ip
 801d602:	4798      	blx	r3
 801d604:	e783      	b.n	801d50e <spindle_activate+0x112>
                spindle_hal.get_data = hal.spindle_data.get;
 801d606:	4910      	ldr	r1, [pc, #64]	; (801d648 <spindle_activate+0x24c>)
 801d608:	6f8a      	ldr	r2, [r1, #120]	; 0x78
 801d60a:	920e      	str	r2, [sp, #56]	; 0x38
                spindle_hal.reset_data = hal.spindle_data.reset;
 801d60c:	6fc9      	ldr	r1, [r1, #124]	; 0x7c
 801d60e:	910f      	str	r1, [sp, #60]	; 0x3c
                if(!spindle->cfg->cap.at_speed)
 801d610:	7a5b      	ldrb	r3, [r3, #9]
 801d612:	f013 0f04 	tst.w	r3, #4
 801d616:	d1ad      	bne.n	801d574 <spindle_activate+0x178>
                    spindle_hal.cap.at_speed = !!spindle_hal.get_data;
 801d618:	3a00      	subs	r2, #0
 801d61a:	bf18      	it	ne
 801d61c:	2201      	movne	r2, #1
 801d61e:	f89d 300d 	ldrb.w	r3, [sp, #13]
 801d622:	f362 0382 	bfi	r3, r2, #2, #1
 801d626:	f88d 300d 	strb.w	r3, [sp, #13]
 801d62a:	e7a3      	b.n	801d574 <spindle_activate+0x178>
 801d62c:	20003d5c 	.word	0x20003d5c
 801d630:	20003d60 	.word	0x20003d60
 801d634:	20003b14 	.word	0x20003b14
 801d638:	00000000 	.word	0x00000000
 801d63c:	20003d59 	.word	0x20003d59
 801d640:	20003da8 	.word	0x20003da8
 801d644:	2000343c 	.word	0x2000343c
 801d648:	2000350c 	.word	0x2000350c

0801d64c <spindle_get_num>:
{
 801d64c:	b510      	push	{r4, lr}
 801d64e:	4604      	mov	r4, r0
        if((setting = setting_get_details(idx == 0 ? Setting_SpindleType : (setting_id_t)(Setting_SpindleEnable0 + idx), NULL))) {
 801d650:	2100      	movs	r1, #0
 801d652:	f240 108b 	movw	r0, #395	; 0x18b
 801d656:	f7ff fae5 	bl	801cc24 <setting_get_details>
 801d65a:	b148      	cbz	r0, 801d670 <spindle_get_num+0x24>
            if(setting_get_int_value(setting, 0) == spindle_id)
 801d65c:	2100      	movs	r1, #0
 801d65e:	f7ff f8e9 	bl	801c834 <setting_get_int_value>
 801d662:	42a0      	cmp	r0, r4
 801d664:	d101      	bne.n	801d66a <spindle_get_num+0x1e>
                spindle_num = idx;
 801d666:	2000      	movs	r0, #0
}
 801d668:	bd10      	pop	{r4, pc}
            if(setting_get_int_value(setting, 0) == spindle_id)
 801d66a:	f04f 30ff 	mov.w	r0, #4294967295
 801d66e:	e7fb      	b.n	801d668 <spindle_get_num+0x1c>
 801d670:	f04f 30ff 	mov.w	r0, #4294967295
 801d674:	e7f8      	b.n	801d668 <spindle_get_num+0x1c>
	...

0801d678 <spindle_register>:
{
 801d678:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if(n_spindle < N_SPINDLE && settings_add_spindle_type(name)) {
 801d67a:	4b35      	ldr	r3, [pc, #212]	; (801d750 <spindle_register+0xd8>)
 801d67c:	781b      	ldrb	r3, [r3, #0]
 801d67e:	2b00      	cmp	r3, #0
 801d680:	d160      	bne.n	801d744 <spindle_register+0xcc>
 801d682:	4605      	mov	r5, r0
 801d684:	460e      	mov	r6, r1
 801d686:	4608      	mov	r0, r1
 801d688:	f7ff fd84 	bl	801d194 <settings_add_spindle_type>
 801d68c:	2800      	cmp	r0, #0
 801d68e:	d05c      	beq.n	801d74a <spindle_register+0xd2>
        spindles[n_spindle].cfg = spindle;
 801d690:	4b2f      	ldr	r3, [pc, #188]	; (801d750 <spindle_register+0xd8>)
 801d692:	781c      	ldrb	r4, [r3, #0]
 801d694:	4a2f      	ldr	r2, [pc, #188]	; (801d754 <spindle_register+0xdc>)
 801d696:	eb04 01c4 	add.w	r1, r4, r4, lsl #3
 801d69a:	eb02 03c1 	add.w	r3, r2, r1, lsl #3
 801d69e:	f842 5031 	str.w	r5, [r2, r1, lsl #3]
        spindles[n_spindle].name = name;
 801d6a2:	641e      	str	r6, [r3, #64]	; 0x40
        memcpy(&spindles[n_spindle].hal, spindles[n_spindle].cfg, sizeof(spindle_ptrs_t));
 801d6a4:	462a      	mov	r2, r5
 801d6a6:	3304      	adds	r3, #4
 801d6a8:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 801d6ac:	6817      	ldr	r7, [r2, #0]
 801d6ae:	6856      	ldr	r6, [r2, #4]
 801d6b0:	6890      	ldr	r0, [r2, #8]
 801d6b2:	68d1      	ldr	r1, [r2, #12]
 801d6b4:	601f      	str	r7, [r3, #0]
 801d6b6:	605e      	str	r6, [r3, #4]
 801d6b8:	6098      	str	r0, [r3, #8]
 801d6ba:	60d9      	str	r1, [r3, #12]
 801d6bc:	3210      	adds	r2, #16
 801d6be:	3310      	adds	r3, #16
 801d6c0:	4562      	cmp	r2, ip
 801d6c2:	d1f3      	bne.n	801d6ac <spindle_register+0x34>
 801d6c4:	6810      	ldr	r0, [r2, #0]
 801d6c6:	6851      	ldr	r1, [r2, #4]
 801d6c8:	6892      	ldr	r2, [r2, #8]
 801d6ca:	6018      	str	r0, [r3, #0]
 801d6cc:	6059      	str	r1, [r3, #4]
 801d6ce:	609a      	str	r2, [r3, #8]
        spindles[n_spindle].hal.id = n_spindle;
 801d6d0:	b267      	sxtb	r7, r4
 801d6d2:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
 801d6d6:	4b1f      	ldr	r3, [pc, #124]	; (801d754 <spindle_register+0xdc>)
 801d6d8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801d6dc:	711f      	strb	r7, [r3, #4]
        if(spindle->type == SpindleType_PWM && pwm_spindle == NULL) {
 801d6de:	7a2b      	ldrb	r3, [r5, #8]
 801d6e0:	b913      	cbnz	r3, 801d6e8 <spindle_register+0x70>
 801d6e2:	4b1d      	ldr	r3, [pc, #116]	; (801d758 <spindle_register+0xe0>)
 801d6e4:	681b      	ldr	r3, [r3, #0]
 801d6e6:	b12b      	cbz	r3, 801d6f4 <spindle_register+0x7c>
        if(n_spindle == 0)
 801d6e8:	b18c      	cbz	r4, 801d70e <spindle_register+0x96>
        return n_spindle++;
 801d6ea:	3401      	adds	r4, #1
 801d6ec:	4b18      	ldr	r3, [pc, #96]	; (801d750 <spindle_register+0xd8>)
 801d6ee:	701c      	strb	r4, [r3, #0]
}
 801d6f0:	4638      	mov	r0, r7
 801d6f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            pwm_spindle = &spindles[n_spindle];
 801d6f4:	4b17      	ldr	r3, [pc, #92]	; (801d754 <spindle_register+0xdc>)
 801d6f6:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801d6fa:	4a17      	ldr	r2, [pc, #92]	; (801d758 <spindle_register+0xe0>)
 801d6fc:	6013      	str	r3, [r2, #0]
            hal.driver_cap.pwm_spindle = On;
 801d6fe:	4a17      	ldr	r2, [pc, #92]	; (801d75c <spindle_register+0xe4>)
 801d700:	f892 31a6 	ldrb.w	r3, [r2, #422]	; 0x1a6
 801d704:	f043 0308 	orr.w	r3, r3, #8
 801d708:	f882 31a6 	strb.w	r3, [r2, #422]	; 0x1a6
 801d70c:	e7ec      	b.n	801d6e8 <spindle_register+0x70>
            memcpy(&sys_spindle[0].hal, spindle, sizeof(spindle_ptrs_t));
 801d70e:	46ac      	mov	ip, r5
 801d710:	4e13      	ldr	r6, [pc, #76]	; (801d760 <spindle_register+0xe8>)
 801d712:	3530      	adds	r5, #48	; 0x30
 801d714:	46b6      	mov	lr, r6
 801d716:	f8dc 0000 	ldr.w	r0, [ip]
 801d71a:	f8dc 1004 	ldr.w	r1, [ip, #4]
 801d71e:	f8dc 2008 	ldr.w	r2, [ip, #8]
 801d722:	f8dc 300c 	ldr.w	r3, [ip, #12]
 801d726:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 801d72a:	f10c 0c10 	add.w	ip, ip, #16
 801d72e:	4676      	mov	r6, lr
 801d730:	45ac      	cmp	ip, r5
 801d732:	d1ef      	bne.n	801d714 <spindle_register+0x9c>
 801d734:	f8dc 0000 	ldr.w	r0, [ip]
 801d738:	f8dc 1004 	ldr.w	r1, [ip, #4]
 801d73c:	f8dc 2008 	ldr.w	r2, [ip, #8]
 801d740:	c607      	stmia	r6!, {r0, r1, r2}
 801d742:	e7d2      	b.n	801d6ea <spindle_register+0x72>
    return -1;
 801d744:	f04f 37ff 	mov.w	r7, #4294967295
 801d748:	e7d2      	b.n	801d6f0 <spindle_register+0x78>
 801d74a:	f04f 37ff 	mov.w	r7, #4294967295
 801d74e:	e7cf      	b.n	801d6f0 <spindle_register+0x78>
 801d750:	20003d59 	.word	0x20003d59
 801d754:	20003d60 	.word	0x20003d60
 801d758:	20003d5c 	.word	0x20003d5c
 801d75c:	2000350c 	.word	0x2000350c
 801d760:	20003dd4 	.word	0x20003dd4

0801d764 <spindle_get_hal>:
    if(hal == SpindleHAL_Active) {
 801d764:	2902      	cmp	r1, #2
 801d766:	d011      	beq.n	801d78c <spindle_get_hal+0x28>
    } else if(spindle_id >= 0 && spindle_id < n_spindle && spindles[spindle_id].cfg)
 801d768:	2800      	cmp	r0, #0
 801d76a:	db1e      	blt.n	801d7aa <spindle_get_hal+0x46>
 801d76c:	4a11      	ldr	r2, [pc, #68]	; (801d7b4 <spindle_get_hal+0x50>)
 801d76e:	7812      	ldrb	r2, [r2, #0]
 801d770:	4290      	cmp	r0, r2
 801d772:	da1c      	bge.n	801d7ae <spindle_get_hal+0x4a>
 801d774:	eb00 02c0 	add.w	r2, r0, r0, lsl #3
 801d778:	480f      	ldr	r0, [pc, #60]	; (801d7b8 <spindle_get_hal+0x54>)
 801d77a:	f850 0032 	ldr.w	r0, [r0, r2, lsl #3]
 801d77e:	b1b8      	cbz	r0, 801d7b0 <spindle_get_hal+0x4c>
        spindle = hal == SpindleHAL_Raw ? (spindle_ptrs_t *)spindles[spindle_id].cfg : &spindles[spindle_id].hal;
 801d780:	b1b1      	cbz	r1, 801d7b0 <spindle_get_hal+0x4c>
 801d782:	480d      	ldr	r0, [pc, #52]	; (801d7b8 <spindle_get_hal+0x54>)
 801d784:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
 801d788:	3004      	adds	r0, #4
 801d78a:	4770      	bx	lr
            if(sys_spindle[idx].hal.id == spindle_id && sys_spindle[idx].enabled)
 801d78c:	4a0b      	ldr	r2, [pc, #44]	; (801d7bc <spindle_get_hal+0x58>)
 801d78e:	f992 202c 	ldrsb.w	r2, [r2, #44]	; 0x2c
 801d792:	4282      	cmp	r2, r0
 801d794:	d107      	bne.n	801d7a6 <spindle_get_hal+0x42>
 801d796:	4b09      	ldr	r3, [pc, #36]	; (801d7bc <spindle_get_hal+0x58>)
 801d798:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
 801d79c:	b10b      	cbz	r3, 801d7a2 <spindle_get_hal+0x3e>
                spindle = &sys_spindle[idx].hal;
 801d79e:	4808      	ldr	r0, [pc, #32]	; (801d7c0 <spindle_get_hal+0x5c>)
 801d7a0:	4770      	bx	lr
            if(sys_spindle[idx].hal.id == spindle_id && sys_spindle[idx].enabled)
 801d7a2:	2000      	movs	r0, #0
 801d7a4:	4770      	bx	lr
 801d7a6:	2000      	movs	r0, #0
 801d7a8:	4770      	bx	lr
    spindle_ptrs_t *spindle = NULL;
 801d7aa:	2000      	movs	r0, #0
 801d7ac:	4770      	bx	lr
 801d7ae:	2000      	movs	r0, #0
}
 801d7b0:	4770      	bx	lr
 801d7b2:	bf00      	nop
 801d7b4:	20003d59 	.word	0x20003d59
 801d7b8:	20003d60 	.word	0x20003d60
 801d7bc:	20003da8 	.word	0x20003da8
 801d7c0:	20003dd4 	.word	0x20003dd4

0801d7c4 <spindle_get_default>:
    return sys_spindle[0].enabled ? sys_spindle[0].hal.id : -2;
 801d7c4:	4b05      	ldr	r3, [pc, #20]	; (801d7dc <spindle_get_default+0x18>)
 801d7c6:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
 801d7ca:	b11b      	cbz	r3, 801d7d4 <spindle_get_default+0x10>
 801d7cc:	4b03      	ldr	r3, [pc, #12]	; (801d7dc <spindle_get_default+0x18>)
 801d7ce:	f993 002c 	ldrsb.w	r0, [r3, #44]	; 0x2c
 801d7d2:	4770      	bx	lr
 801d7d4:	f06f 0001 	mvn.w	r0, #1
}
 801d7d8:	4770      	bx	lr
 801d7da:	bf00      	nop
 801d7dc:	20003da8 	.word	0x20003da8

0801d7e0 <spindle_get_caps>:
{
 801d7e0:	b410      	push	{r4}
 801d7e2:	4604      	mov	r4, r0
    spindle_cap_t caps = {0};
 801d7e4:	f04f 0000 	mov.w	r0, #0
    uint_fast8_t idx = n_spindle;
 801d7e8:	4b0d      	ldr	r3, [pc, #52]	; (801d820 <spindle_get_caps+0x40>)
 801d7ea:	781b      	ldrb	r3, [r3, #0]
 801d7ec:	e008      	b.n	801d800 <spindle_get_caps+0x20>
        caps.value |= (active ? spindles[idx].hal.cap.value : spindles[idx].cfg->cap.value);
 801d7ee:	eb03 01c3 	add.w	r1, r3, r3, lsl #3
 801d7f2:	4a0c      	ldr	r2, [pc, #48]	; (801d824 <spindle_get_caps+0x44>)
 801d7f4:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 801d7f8:	f992 200d 	ldrsb.w	r2, [r2, #13]
 801d7fc:	4310      	orrs	r0, r2
    } while(idx);
 801d7fe:	b15b      	cbz	r3, 801d818 <spindle_get_caps+0x38>
        --idx;
 801d800:	3b01      	subs	r3, #1
        caps.value |= (active ? spindles[idx].hal.cap.value : spindles[idx].cfg->cap.value);
 801d802:	b2c0      	uxtb	r0, r0
 801d804:	2c00      	cmp	r4, #0
 801d806:	d1f2      	bne.n	801d7ee <spindle_get_caps+0xe>
 801d808:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
 801d80c:	4905      	ldr	r1, [pc, #20]	; (801d824 <spindle_get_caps+0x44>)
 801d80e:	f851 2032 	ldr.w	r2, [r1, r2, lsl #3]
 801d812:	f992 2009 	ldrsb.w	r2, [r2, #9]
 801d816:	e7f1      	b.n	801d7fc <spindle_get_caps+0x1c>
}
 801d818:	f85d 4b04 	ldr.w	r4, [sp], #4
 801d81c:	4770      	bx	lr
 801d81e:	bf00      	nop
 801d820:	20003d59 	.word	0x20003d59
 801d824:	20003d60 	.word	0x20003d60

0801d828 <spindle_update_caps>:
    spindle->type = pwm_caps ? SpindleType_PWM : SpindleType_Basic;
 801d828:	2900      	cmp	r1, #0
 801d82a:	bf0c      	ite	eq
 801d82c:	2201      	moveq	r2, #1
 801d82e:	2200      	movne	r2, #0
 801d830:	7202      	strb	r2, [r0, #8]
    spindle->cap.laser = !!pwm_caps && !!spindle->update_pwm && settings.mode == Mode_Laser;
 801d832:	d01a      	beq.n	801d86a <spindle_update_caps+0x42>
 801d834:	6a83      	ldr	r3, [r0, #40]	; 0x28
 801d836:	b1db      	cbz	r3, 801d870 <spindle_update_caps+0x48>
 801d838:	4b19      	ldr	r3, [pc, #100]	; (801d8a0 <spindle_update_caps+0x78>)
 801d83a:	7e1b      	ldrb	r3, [r3, #24]
 801d83c:	2b01      	cmp	r3, #1
 801d83e:	d01a      	beq.n	801d876 <spindle_update_caps+0x4e>
 801d840:	f04f 0c00 	mov.w	ip, #0
 801d844:	7a43      	ldrb	r3, [r0, #9]
 801d846:	f36c 03c3 	bfi	r3, ip, #3, #1
 801d84a:	7243      	strb	r3, [r0, #9]
    spindle->pwm_off_value = pwm_caps ? pwm_caps->off_value : 0;
 801d84c:	b1b1      	cbz	r1, 801d87c <spindle_update_caps+0x54>
 801d84e:	684b      	ldr	r3, [r1, #4]
 801d850:	60c3      	str	r3, [r0, #12]
        if(sys_spindle[idx].enabled && spindle->id == sys_spindle[idx].hal.id) {
 801d852:	4b14      	ldr	r3, [pc, #80]	; (801d8a4 <spindle_update_caps+0x7c>)
 801d854:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
 801d858:	b133      	cbz	r3, 801d868 <spindle_update_caps+0x40>
 801d85a:	f990 1000 	ldrsb.w	r1, [r0]
 801d85e:	4b11      	ldr	r3, [pc, #68]	; (801d8a4 <spindle_update_caps+0x7c>)
 801d860:	f993 302c 	ldrsb.w	r3, [r3, #44]	; 0x2c
 801d864:	4299      	cmp	r1, r3
 801d866:	d00b      	beq.n	801d880 <spindle_update_caps+0x58>
}
 801d868:	4770      	bx	lr
    spindle->cap.laser = !!pwm_caps && !!spindle->update_pwm && settings.mode == Mode_Laser;
 801d86a:	f04f 0c00 	mov.w	ip, #0
 801d86e:	e7e9      	b.n	801d844 <spindle_update_caps+0x1c>
 801d870:	f04f 0c00 	mov.w	ip, #0
 801d874:	e7e6      	b.n	801d844 <spindle_update_caps+0x1c>
 801d876:	f04f 0c01 	mov.w	ip, #1
 801d87a:	e7e3      	b.n	801d844 <spindle_update_caps+0x1c>
    spindle->pwm_off_value = pwm_caps ? pwm_caps->off_value : 0;
 801d87c:	2300      	movs	r3, #0
 801d87e:	e7e7      	b.n	801d850 <spindle_update_caps+0x28>
            sys_spindle[idx].hal.type = spindle->type;
 801d880:	4b08      	ldr	r3, [pc, #32]	; (801d8a4 <spindle_update_caps+0x7c>)
 801d882:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
            sys_spindle[idx].hal.cap.laser = spindle->cap.laser;
 801d886:	7a42      	ldrb	r2, [r0, #9]
 801d888:	f3c2 02c0 	ubfx	r2, r2, #3, #1
 801d88c:	f893 1035 	ldrb.w	r1, [r3, #53]	; 0x35
 801d890:	f362 01c3 	bfi	r1, r2, #3, #1
 801d894:	f883 1035 	strb.w	r1, [r3, #53]	; 0x35
            sys_spindle[idx].hal.pwm_off_value =  spindle->pwm_off_value;
 801d898:	68c2      	ldr	r2, [r0, #12]
 801d89a:	639a      	str	r2, [r3, #56]	; 0x38
}
 801d89c:	e7e4      	b.n	801d868 <spindle_update_caps+0x40>
 801d89e:	bf00      	nop
 801d8a0:	20003b14 	.word	0x20003b14
 801d8a4:	20003da8 	.word	0x20003da8

0801d8a8 <spindle_enumerate_spindles>:
    if(callback == NULL || n_spindle == 0)
 801d8a8:	2800      	cmp	r0, #0
 801d8aa:	d035      	beq.n	801d918 <spindle_enumerate_spindles+0x70>
{
 801d8ac:	b570      	push	{r4, r5, r6, lr}
 801d8ae:	b084      	sub	sp, #16
 801d8b0:	460d      	mov	r5, r1
 801d8b2:	4606      	mov	r6, r0
    if(callback == NULL || n_spindle == 0)
 801d8b4:	4b1a      	ldr	r3, [pc, #104]	; (801d920 <spindle_enumerate_spindles+0x78>)
 801d8b6:	781b      	ldrb	r3, [r3, #0]
 801d8b8:	b383      	cbz	r3, 801d91c <spindle_enumerate_spindles+0x74>
    for(idx = 0; idx < n_spindle; idx++) {
 801d8ba:	2400      	movs	r4, #0
 801d8bc:	e023      	b.n	801d906 <spindle_enumerate_spindles+0x5e>
        spindle.id = idx;
 801d8be:	b260      	sxtb	r0, r4
 801d8c0:	f88d 0000 	strb.w	r0, [sp]
        spindle.name = spindles[idx].name;
 801d8c4:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
 801d8c8:	4b16      	ldr	r3, [pc, #88]	; (801d924 <spindle_enumerate_spindles+0x7c>)
 801d8ca:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801d8ce:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 801d8d0:	9201      	str	r2, [sp, #4]
        spindle.hal = &spindles[idx].hal;
 801d8d2:	3304      	adds	r3, #4
 801d8d4:	9303      	str	r3, [sp, #12]
        spindle.num = spindle_get_num(idx);
 801d8d6:	f7ff feb9 	bl	801d64c <spindle_get_num>
 801d8da:	f88d 0001 	strb.w	r0, [sp, #1]
        spindle.enabled = spindle.num != -1;
 801d8de:	3001      	adds	r0, #1
 801d8e0:	bf18      	it	ne
 801d8e2:	2001      	movne	r0, #1
 801d8e4:	f88d 0008 	strb.w	r0, [sp, #8]
        spindle.is_current = spindle.enabled && sys_spindle[0].hal.id == idx;
 801d8e8:	b130      	cbz	r0, 801d8f8 <spindle_enumerate_spindles+0x50>
 801d8ea:	4b0f      	ldr	r3, [pc, #60]	; (801d928 <spindle_enumerate_spindles+0x80>)
 801d8ec:	f993 302c 	ldrsb.w	r3, [r3, #44]	; 0x2c
 801d8f0:	42a3      	cmp	r3, r4
 801d8f2:	d00f      	beq.n	801d914 <spindle_enumerate_spindles+0x6c>
 801d8f4:	2300      	movs	r3, #0
 801d8f6:	e000      	b.n	801d8fa <spindle_enumerate_spindles+0x52>
 801d8f8:	2300      	movs	r3, #0
 801d8fa:	f88d 3009 	strb.w	r3, [sp, #9]
        callback(&spindle, data);
 801d8fe:	4629      	mov	r1, r5
 801d900:	4668      	mov	r0, sp
 801d902:	47b0      	blx	r6
    for(idx = 0; idx < n_spindle; idx++) {
 801d904:	3401      	adds	r4, #1
 801d906:	4b06      	ldr	r3, [pc, #24]	; (801d920 <spindle_enumerate_spindles+0x78>)
 801d908:	781b      	ldrb	r3, [r3, #0]
 801d90a:	42a3      	cmp	r3, r4
 801d90c:	d8d7      	bhi.n	801d8be <spindle_enumerate_spindles+0x16>
    return true;
 801d90e:	2001      	movs	r0, #1
}
 801d910:	b004      	add	sp, #16
 801d912:	bd70      	pop	{r4, r5, r6, pc}
        spindle.is_current = spindle.enabled && sys_spindle[0].hal.id == idx;
 801d914:	2301      	movs	r3, #1
 801d916:	e7f0      	b.n	801d8fa <spindle_enumerate_spindles+0x52>
        return false;
 801d918:	2000      	movs	r0, #0
}
 801d91a:	4770      	bx	lr
        return false;
 801d91c:	2000      	movs	r0, #0
 801d91e:	e7f7      	b.n	801d910 <spindle_enumerate_spindles+0x68>
 801d920:	20003d59 	.word	0x20003d59
 801d924:	20003d60 	.word	0x20003d60
 801d928:	20003da8 	.word	0x20003da8

0801d92c <spindle_is_enabled>:
    if(spindle_num == -1)
 801d92c:	f1b0 3fff 	cmp.w	r0, #4294967295
 801d930:	d002      	beq.n	801d938 <spindle_is_enabled+0xc>
    return spindle_num >= 0 && spindle_num < N_SYS_SPINDLE && sys_spindle[spindle_num].enabled;
 801d932:	b110      	cbz	r0, 801d93a <spindle_is_enabled+0xe>
 801d934:	2000      	movs	r0, #0
 801d936:	4770      	bx	lr
        spindle_num = 0;
 801d938:	2000      	movs	r0, #0
    return spindle_num >= 0 && spindle_num < N_SYS_SPINDLE && sys_spindle[spindle_num].enabled;
 801d93a:	4b05      	ldr	r3, [pc, #20]	; (801d950 <spindle_is_enabled+0x24>)
 801d93c:	226c      	movs	r2, #108	; 0x6c
 801d93e:	fb02 3300 	mla	r3, r2, r0, r3
 801d942:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
 801d946:	b90b      	cbnz	r3, 801d94c <spindle_is_enabled+0x20>
 801d948:	2000      	movs	r0, #0
 801d94a:	4770      	bx	lr
 801d94c:	2001      	movs	r0, #1
}
 801d94e:	4770      	bx	lr
 801d950:	20003da8 	.word	0x20003da8

0801d954 <spindle_get>:
    return spindle_num >= 0 && spindle_num < N_SYS_SPINDLE && sys_spindle[spindle_num].enabled ? &sys_spindle[spindle_num].hal : NULL;
 801d954:	4603      	mov	r3, r0
 801d956:	b968      	cbnz	r0, 801d974 <spindle_get+0x20>
 801d958:	4a08      	ldr	r2, [pc, #32]	; (801d97c <spindle_get+0x28>)
 801d95a:	216c      	movs	r1, #108	; 0x6c
 801d95c:	fb01 2200 	mla	r2, r1, r0, r2
 801d960:	f892 2068 	ldrb.w	r2, [r2, #104]	; 0x68
 801d964:	b142      	cbz	r2, 801d978 <spindle_get+0x24>
 801d966:	fb01 f303 	mul.w	r3, r1, r3
 801d96a:	3328      	adds	r3, #40	; 0x28
 801d96c:	4803      	ldr	r0, [pc, #12]	; (801d97c <spindle_get+0x28>)
 801d96e:	4418      	add	r0, r3
 801d970:	3004      	adds	r0, #4
 801d972:	4770      	bx	lr
 801d974:	2000      	movs	r0, #0
 801d976:	4770      	bx	lr
 801d978:	2000      	movs	r0, #0
}
 801d97a:	4770      	bx	lr
 801d97c:	20003da8 	.word	0x20003da8

0801d980 <spindle_add_null>:
/*! \brief Register a null spindle that has no connection to the outside world.
This is done automatically on startup if no spindle can be succesfully enabled.
\returns assigned spindle id as a \ref spindle_id_t if successful, \a -1 if not.
*/
spindle_id_t spindle_add_null (void)
{
 801d980:	b508      	push	{r3, lr}
        .update_pwm = null_update_pwm,
        .update_rpm = null_update_rpm
    };

    bool registered = false;
    uint_fast8_t idx = n_spindle;
 801d982:	4b0d      	ldr	r3, [pc, #52]	; (801d9b8 <spindle_add_null+0x38>)
 801d984:	7818      	ldrb	r0, [r3, #0]

    if(idx) do {
 801d986:	b170      	cbz	r0, 801d9a6 <spindle_add_null+0x26>
        if((registered = spindles[--idx].hal.type == SpindleType_Null))
 801d988:	3801      	subs	r0, #1
 801d98a:	eb00 02c0 	add.w	r2, r0, r0, lsl #3
 801d98e:	4b0b      	ldr	r3, [pc, #44]	; (801d9bc <spindle_add_null+0x3c>)
 801d990:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801d994:	7b1b      	ldrb	r3, [r3, #12]
 801d996:	2b04      	cmp	r3, #4
 801d998:	bf0c      	ite	eq
 801d99a:	2301      	moveq	r3, #1
 801d99c:	2300      	movne	r3, #0
 801d99e:	d003      	beq.n	801d9a8 <spindle_add_null+0x28>
            break;
    } while(idx);
 801d9a0:	2800      	cmp	r0, #0
 801d9a2:	d1f1      	bne.n	801d988 <spindle_add_null+0x8>
 801d9a4:	e000      	b.n	801d9a8 <spindle_add_null+0x28>
    bool registered = false;
 801d9a6:	2300      	movs	r3, #0

    if(!registered)
 801d9a8:	b10b      	cbz	r3, 801d9ae <spindle_add_null+0x2e>
        return spindle_register(&spindle, "NULL");

    return idx;
 801d9aa:	b240      	sxtb	r0, r0
}
 801d9ac:	bd08      	pop	{r3, pc}
        return spindle_register(&spindle, "NULL");
 801d9ae:	4904      	ldr	r1, [pc, #16]	; (801d9c0 <spindle_add_null+0x40>)
 801d9b0:	4804      	ldr	r0, [pc, #16]	; (801d9c4 <spindle_add_null+0x44>)
 801d9b2:	f7ff fe61 	bl	801d678 <spindle_register>
 801d9b6:	e7f9      	b.n	801d9ac <spindle_add_null+0x2c>
 801d9b8:	20003d59 	.word	0x20003d59
 801d9bc:	20003d60 	.word	0x20003d60
 801d9c0:	0802c3e8 	.word	0x0802c3e8
 801d9c4:	0802c3f0 	.word	0x0802c3f0

0801d9c8 <spindle_select>:
{
 801d9c8:	b508      	push	{r3, lr}
    if(n_spindle == 0 && spindle_id >= 0) {
 801d9ca:	4b0d      	ldr	r3, [pc, #52]	; (801da00 <spindle_select+0x38>)
 801d9cc:	781b      	ldrb	r3, [r3, #0]
 801d9ce:	b90b      	cbnz	r3, 801d9d4 <spindle_select+0xc>
 801d9d0:	2800      	cmp	r0, #0
 801d9d2:	da0d      	bge.n	801d9f0 <spindle_select+0x28>
    return (sys_spindle[0].enabled && sys_spindle[0].hal.id == spindle_id) || spindle_activate(spindle_id, 0);
 801d9d4:	4b0b      	ldr	r3, [pc, #44]	; (801da04 <spindle_select+0x3c>)
 801d9d6:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
 801d9da:	b123      	cbz	r3, 801d9e6 <spindle_select+0x1e>
 801d9dc:	4b09      	ldr	r3, [pc, #36]	; (801da04 <spindle_select+0x3c>)
 801d9de:	f993 302c 	ldrsb.w	r3, [r3, #44]	; 0x2c
 801d9e2:	4283      	cmp	r3, r0
 801d9e4:	d008      	beq.n	801d9f8 <spindle_select+0x30>
 801d9e6:	2100      	movs	r1, #0
 801d9e8:	f7ff fd08 	bl	801d3fc <spindle_activate>
 801d9ec:	b930      	cbnz	r0, 801d9fc <spindle_select+0x34>
}
 801d9ee:	bd08      	pop	{r3, pc}
        spindle_add_null();
 801d9f0:	f7ff ffc6 	bl	801d980 <spindle_add_null>
        spindle_id = 0;
 801d9f4:	2000      	movs	r0, #0
 801d9f6:	e7ed      	b.n	801d9d4 <spindle_select+0xc>
    return (sys_spindle[0].enabled && sys_spindle[0].hal.id == spindle_id) || spindle_activate(spindle_id, 0);
 801d9f8:	2001      	movs	r0, #1
 801d9fa:	e7f8      	b.n	801d9ee <spindle_select+0x26>
 801d9fc:	2001      	movs	r0, #1
 801d9fe:	e7f6      	b.n	801d9ee <spindle_select+0x26>
 801da00:	20003d59 	.word	0x20003d59
 801da04:	20003da8 	.word	0x20003da8

0801da08 <spindle_get_count>:
{
 801da08:	b508      	push	{r3, lr}
    if(n_spindle == 0)
 801da0a:	4b05      	ldr	r3, [pc, #20]	; (801da20 <spindle_get_count+0x18>)
 801da0c:	781b      	ldrb	r3, [r3, #0]
 801da0e:	b113      	cbz	r3, 801da16 <spindle_get_count+0xe>
}
 801da10:	4b03      	ldr	r3, [pc, #12]	; (801da20 <spindle_get_count+0x18>)
 801da12:	7818      	ldrb	r0, [r3, #0]
 801da14:	bd08      	pop	{r3, pc}
        spindle_select(0);
 801da16:	2000      	movs	r0, #0
 801da18:	f7ff ffd6 	bl	801d9c8 <spindle_select>
 801da1c:	e7f8      	b.n	801da10 <spindle_get_count+0x8>
 801da1e:	bf00      	nop
 801da20:	20003d59 	.word	0x20003d59

0801da24 <spindle_set_rpm>:
\param rpm the programmed RPM.
\param override_pct override value in percent.
\returns the calulated RPM.
*/
float spindle_set_rpm (spindle_ptrs_t *spindle, float rpm, override_t override_pct)
{
 801da24:	eef0 7a40 	vmov.f32	s15, s0
    if(override_pct != 100)
 801da28:	2964      	cmp	r1, #100	; 0x64
 801da2a:	d009      	beq.n	801da40 <spindle_set_rpm+0x1c>
        rpm *= 0.01f * (float)override_pct; // Scale RPM by override value.
 801da2c:	ee07 1a10 	vmov	s14, r1
 801da30:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 801da34:	eddf 6a11 	vldr	s13, [pc, #68]	; 801da7c <spindle_set_rpm+0x58>
 801da38:	ee27 7a26 	vmul.f32	s14, s14, s13
 801da3c:	ee60 7a07 	vmul.f32	s15, s0, s14

    // Apply RPM limits
    if (rpm <= 0.0f) // TODO: remove this test?
 801da40:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801da44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801da48:	d910      	bls.n	801da6c <spindle_set_rpm+0x48>
        rpm = 0.0f;
    else if (rpm > spindle->rpm_max)
 801da4a:	ed90 0a05 	vldr	s0, [r0, #20]
 801da4e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 801da52:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801da56:	d40b      	bmi.n	801da70 <spindle_set_rpm+0x4c>
        rpm = spindle->rpm_max;
    else if (rpm < spindle->rpm_min)
 801da58:	ed90 0a04 	vldr	s0, [r0, #16]
 801da5c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 801da60:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801da64:	dc04      	bgt.n	801da70 <spindle_set_rpm+0x4c>
 801da66:	eeb0 0a67 	vmov.f32	s0, s15
 801da6a:	e001      	b.n	801da70 <spindle_set_rpm+0x4c>
        rpm = 0.0f;
 801da6c:	ed9f 0a04 	vldr	s0, [pc, #16]	; 801da80 <spindle_set_rpm+0x5c>
        rpm = spindle->rpm_min;

    spindle->param->rpm_overridden = rpm;
 801da70:	6843      	ldr	r3, [r0, #4]
 801da72:	ed83 0a01 	vstr	s0, [r3, #4]
    spindle->param->override_pct = override_pct;
 801da76:	6843      	ldr	r3, [r0, #4]
 801da78:	60d9      	str	r1, [r3, #12]

    return rpm;
}
 801da7a:	4770      	bx	lr
 801da7c:	3c23d70a 	.word	0x3c23d70a
 801da80:	00000000 	.word	0x00000000

0801da84 <set_state>:
{
 801da84:	b538      	push	{r3, r4, r5, lr}
 801da86:	ed2d 8b02 	vpush	{d8}
    if (!ABORTED) { // Block during abort.
 801da8a:	4b20      	ldr	r3, [pc, #128]	; (801db0c <set_state+0x88>)
 801da8c:	781b      	ldrb	r3, [r3, #0]
 801da8e:	b9db      	cbnz	r3, 801dac8 <set_state+0x44>
 801da90:	460c      	mov	r4, r1
 801da92:	eeb0 8a40 	vmov.f32	s16, s0
 801da96:	4b1d      	ldr	r3, [pc, #116]	; (801db0c <set_state+0x88>)
 801da98:	785b      	ldrb	r3, [r3, #1]
 801da9a:	b9ab      	cbnz	r3, 801dac8 <set_state+0x44>
        if (!state.on) { // Halt or set spindle direction and rpm.
 801da9c:	b2cb      	uxtb	r3, r1
 801da9e:	f014 0f01 	tst.w	r4, #1
 801daa2:	d119      	bne.n	801dad8 <set_state+0x54>
            spindle->param->rpm = rpm = 0.0f;
 801daa4:	6843      	ldr	r3, [r0, #4]
 801daa6:	ed9f 8a1a 	vldr	s16, [pc, #104]	; 801db10 <set_state+0x8c>
 801daaa:	ed83 8a00 	vstr	s16, [r3]
            spindle->set_state((spindle_state_t){0}, 0.0f);
 801daae:	69c3      	ldr	r3, [r0, #28]
 801dab0:	eeb0 0a48 	vmov.f32	s0, s16
 801dab4:	f04f 0000 	mov.w	r0, #0
 801dab8:	4798      	blx	r3
        system_add_rt_report(Report_Spindle); // Set to report change immediately
 801daba:	2010      	movs	r0, #16
 801dabc:	f003 fbc0 	bl	8021240 <system_add_rt_report>
        st_rpm_changed(rpm);
 801dac0:	eeb0 0a48 	vmov.f32	s0, s16
 801dac4:	f001 fbe2 	bl	801f28c <st_rpm_changed>
    return !ABORTED;
 801dac8:	4b10      	ldr	r3, [pc, #64]	; (801db0c <set_state+0x88>)
 801daca:	781b      	ldrb	r3, [r3, #0]
 801dacc:	b9bb      	cbnz	r3, 801dafe <set_state+0x7a>
 801dace:	4b0f      	ldr	r3, [pc, #60]	; (801db0c <set_state+0x88>)
 801dad0:	785b      	ldrb	r3, [r3, #1]
 801dad2:	b1c3      	cbz	r3, 801db06 <set_state+0x82>
 801dad4:	2000      	movs	r0, #0
 801dad6:	e013      	b.n	801db00 <set_state+0x7c>
            if (spindle->cap.laser && state.ccw)
 801dad8:	7a42      	ldrb	r2, [r0, #9]
 801dada:	f012 0f08 	tst.w	r2, #8
 801dade:	d004      	beq.n	801daea <set_state+0x66>
 801dae0:	f013 0f02 	tst.w	r3, #2
 801dae4:	d001      	beq.n	801daea <set_state+0x66>
                rpm = 0.0f; // TODO: May need to be rpm_min*(100/MAX_SPINDLE_RPM_OVERRIDE);
 801dae6:	ed9f 8a0a 	vldr	s16, [pc, #40]	; 801db10 <set_state+0x8c>
            spindle->set_state(state, spindle_set_rpm(spindle, rpm, spindle->param->override_pct));
 801daea:	69c5      	ldr	r5, [r0, #28]
 801daec:	6843      	ldr	r3, [r0, #4]
 801daee:	68d9      	ldr	r1, [r3, #12]
 801daf0:	eeb0 0a48 	vmov.f32	s0, s16
 801daf4:	f7ff ff96 	bl	801da24 <spindle_set_rpm>
 801daf8:	4620      	mov	r0, r4
 801dafa:	47a8      	blx	r5
 801dafc:	e7dd      	b.n	801daba <set_state+0x36>
    return !ABORTED;
 801dafe:	2000      	movs	r0, #0
}
 801db00:	ecbd 8b02 	vpop	{d8}
 801db04:	bd38      	pop	{r3, r4, r5, pc}
    return !ABORTED;
 801db06:	2001      	movs	r0, #1
 801db08:	e7fa      	b.n	801db00 <set_state+0x7c>
 801db0a:	bf00      	nop
 801db0c:	200036c4 	.word	0x200036c4
 801db10:	00000000 	.word	0x00000000

0801db14 <spindle_set_state>:
{
 801db14:	b508      	push	{r3, lr}
    return set_state(spindle, state, rpm);
 801db16:	f7ff ffb5 	bl	801da84 <set_state>
}
 801db1a:	bd08      	pop	{r3, pc}

0801db1c <spindle_restore>:
{
 801db1c:	b538      	push	{r3, r4, r5, lr}
 801db1e:	ed2d 8b02 	vpush	{d8}
    if(spindle->cap.laser) // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
 801db22:	7a43      	ldrb	r3, [r0, #9]
 801db24:	f013 0f08 	tst.w	r3, #8
 801db28:	d009      	beq.n	801db3e <spindle_restore+0x22>
        sys.step_control.update_spindle_rpm = On;
 801db2a:	4a28      	ldr	r2, [pc, #160]	; (801dbcc <spindle_restore+0xb0>)
 801db2c:	7e13      	ldrb	r3, [r2, #24]
 801db2e:	f043 0308 	orr.w	r3, r3, #8
 801db32:	7613      	strb	r3, [r2, #24]
    bool ok = true;
 801db34:	2501      	movs	r5, #1
}
 801db36:	4628      	mov	r0, r5
 801db38:	ecbd 8b02 	vpop	{d8}
 801db3c:	bd38      	pop	{r3, r4, r5, pc}
 801db3e:	4604      	mov	r4, r0
 801db40:	460d      	mov	r5, r1
        spindle_set_state(spindle, state, rpm);
 801db42:	f7ff ffe7 	bl	801db14 <spindle_set_state>
        if(state.on) {
 801db46:	f015 0f01 	tst.w	r5, #1
 801db4a:	d03c      	beq.n	801dbc6 <spindle_restore+0xaa>
            if((ok = !spindle->cap.at_speed))
 801db4c:	7a63      	ldrb	r3, [r4, #9]
 801db4e:	f003 0304 	and.w	r3, r3, #4
 801db52:	2b00      	cmp	r3, #0
 801db54:	bf0c      	ite	eq
 801db56:	2501      	moveq	r5, #1
 801db58:	2500      	movne	r5, #0
 801db5a:	d02d      	beq.n	801dbb8 <spindle_restore+0x9c>
            else if((ok == (settings.spindle.at_speed_tolerance <= 0.0f))) {
 801db5c:	4b1c      	ldr	r3, [pc, #112]	; (801dbd0 <spindle_restore+0xb4>)
 801db5e:	edd3 7a24 	vldr	s15, [r3, #144]	; 0x90
 801db62:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801db66:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801db6a:	bf94      	ite	ls
 801db6c:	2301      	movls	r3, #1
 801db6e:	2300      	movhi	r3, #0
 801db70:	42ab      	cmp	r3, r5
 801db72:	d1e0      	bne.n	801db36 <spindle_restore+0x1a>
                float delay = 0.0f;
 801db74:	ed9f 8a17 	vldr	s16, [pc, #92]	; 801dbd4 <spindle_restore+0xb8>
                while(!(ok = spindle->get_state().at_speed)) {
 801db78:	6a23      	ldr	r3, [r4, #32]
 801db7a:	4798      	blx	r3
 801db7c:	f3c0 1580 	ubfx	r5, r0, #6, #1
 801db80:	f010 0f40 	tst.w	r0, #64	; 0x40
 801db84:	d1d7      	bne.n	801db36 <spindle_restore+0x1a>
                    delay_sec(0.1f, DelayMode_SysSuspend);
 801db86:	eddf 8a14 	vldr	s17, [pc, #80]	; 801dbd8 <spindle_restore+0xbc>
 801db8a:	2001      	movs	r0, #1
 801db8c:	eeb0 0a68 	vmov.f32	s0, s17
 801db90:	f7f7 ff68 	bl	8015a64 <delay_sec>
                    delay += 0.1f;
 801db94:	ee38 8a28 	vadd.f32	s16, s16, s17
                    if(ABORTED)
 801db98:	4b0c      	ldr	r3, [pc, #48]	; (801dbcc <spindle_restore+0xb0>)
 801db9a:	881b      	ldrh	r3, [r3, #0]
 801db9c:	2b00      	cmp	r3, #0
 801db9e:	d1ca      	bne.n	801db36 <spindle_restore+0x1a>
                    if(delay >= settings.safety_door.spindle_on_delay) {
 801dba0:	4b0b      	ldr	r3, [pc, #44]	; (801dbd0 <spindle_restore+0xb4>)
 801dba2:	edd3 7a50 	vldr	s15, [r3, #320]	; 0x140
 801dba6:	eef4 7ac8 	vcmpe.f32	s15, s16
 801dbaa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801dbae:	d8e3      	bhi.n	801db78 <spindle_restore+0x5c>
                        system_raise_alarm(Alarm_Spindle);
 801dbb0:	200e      	movs	r0, #14
 801dbb2:	f003 faf7 	bl	80211a4 <system_raise_alarm>
                        break;
 801dbb6:	e7be      	b.n	801db36 <spindle_restore+0x1a>
                delay_sec(settings.safety_door.spindle_on_delay, DelayMode_SysSuspend);
 801dbb8:	2001      	movs	r0, #1
 801dbba:	4b05      	ldr	r3, [pc, #20]	; (801dbd0 <spindle_restore+0xb4>)
 801dbbc:	ed93 0a50 	vldr	s0, [r3, #320]	; 0x140
 801dbc0:	f7f7 ff50 	bl	8015a64 <delay_sec>
 801dbc4:	e7b7      	b.n	801db36 <spindle_restore+0x1a>
    bool ok = true;
 801dbc6:	2501      	movs	r5, #1
 801dbc8:	e7b5      	b.n	801db36 <spindle_restore+0x1a>
 801dbca:	bf00      	nop
 801dbcc:	200036c4 	.word	0x200036c4
 801dbd0:	20003b14 	.word	0x20003b14
 801dbd4:	00000000 	.word	0x00000000
 801dbd8:	3dcccccd 	.word	0x3dcccccd

0801dbdc <spindle_sync>:
{
 801dbdc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801dbde:	ed2d 8b02 	vpush	{d8}
 801dbe2:	4605      	mov	r5, r0
 801dbe4:	460e      	mov	r6, r1
 801dbe6:	eeb0 8a40 	vmov.f32	s16, s0
    if (!(ok = state_get() == STATE_CHECK_MODE)) {
 801dbea:	f000 fcfb 	bl	801e5e4 <state_get>
 801dbee:	2802      	cmp	r0, #2
 801dbf0:	bf0c      	ite	eq
 801dbf2:	2001      	moveq	r0, #1
 801dbf4:	2000      	movne	r0, #0
 801dbf6:	d01a      	beq.n	801dc2e <spindle_sync+0x52>
        bool at_speed = !state.on || !spindle->cap.at_speed || settings.spindle.at_speed_tolerance <= 0.0f;
 801dbf8:	f016 0f01 	tst.w	r6, #1
 801dbfc:	d00f      	beq.n	801dc1e <spindle_sync+0x42>
 801dbfe:	7a6b      	ldrb	r3, [r5, #9]
 801dc00:	f013 0f04 	tst.w	r3, #4
 801dc04:	d016      	beq.n	801dc34 <spindle_sync+0x58>
 801dc06:	4b23      	ldr	r3, [pc, #140]	; (801dc94 <spindle_sync+0xb8>)
 801dc08:	edd3 7a24 	vldr	s15, [r3, #144]	; 0x90
 801dc0c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801dc10:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801dc14:	d901      	bls.n	801dc1a <spindle_sync+0x3e>
 801dc16:	2000      	movs	r0, #0
 801dc18:	e002      	b.n	801dc20 <spindle_sync+0x44>
 801dc1a:	2001      	movs	r0, #1
 801dc1c:	e000      	b.n	801dc20 <spindle_sync+0x44>
 801dc1e:	2001      	movs	r0, #1
 801dc20:	4604      	mov	r4, r0
        if((ok = protocol_buffer_synchronize()) && set_state(spindle, state, rpm) && !at_speed) {
 801dc22:	f7f9 ffd9 	bl	8017bd8 <protocol_buffer_synchronize>
 801dc26:	4607      	mov	r7, r0
 801dc28:	b930      	cbnz	r0, 801dc38 <spindle_sync+0x5c>
        ok &= at_speed;
 801dc2a:	ea04 0007 	and.w	r0, r4, r7
}
 801dc2e:	ecbd 8b02 	vpop	{d8}
 801dc32:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        bool at_speed = !state.on || !spindle->cap.at_speed || settings.spindle.at_speed_tolerance <= 0.0f;
 801dc34:	2001      	movs	r0, #1
 801dc36:	e7f3      	b.n	801dc20 <spindle_sync+0x44>
        if((ok = protocol_buffer_synchronize()) && set_state(spindle, state, rpm) && !at_speed) {
 801dc38:	eeb0 0a48 	vmov.f32	s0, s16
 801dc3c:	4631      	mov	r1, r6
 801dc3e:	4628      	mov	r0, r5
 801dc40:	f7ff ff20 	bl	801da84 <set_state>
 801dc44:	2800      	cmp	r0, #0
 801dc46:	d0f0      	beq.n	801dc2a <spindle_sync+0x4e>
 801dc48:	2c00      	cmp	r4, #0
 801dc4a:	d1ee      	bne.n	801dc2a <spindle_sync+0x4e>
            float on_delay = 0.0f;
 801dc4c:	ed9f 8a12 	vldr	s16, [pc, #72]	; 801dc98 <spindle_sync+0xbc>
            while(!(at_speed = spindle->get_state().at_speed)) {
 801dc50:	6a2b      	ldr	r3, [r5, #32]
 801dc52:	4798      	blx	r3
 801dc54:	f3c0 1480 	ubfx	r4, r0, #6, #1
 801dc58:	f010 0f40 	tst.w	r0, #64	; 0x40
 801dc5c:	d1e5      	bne.n	801dc2a <spindle_sync+0x4e>
                delay_sec(0.2f, DelayMode_Dwell);
 801dc5e:	eddf 8a0f 	vldr	s17, [pc, #60]	; 801dc9c <spindle_sync+0xc0>
 801dc62:	2000      	movs	r0, #0
 801dc64:	eeb0 0a68 	vmov.f32	s0, s17
 801dc68:	f7f7 fefc 	bl	8015a64 <delay_sec>
                on_delay += 0.2f;
 801dc6c:	ee38 8a28 	vadd.f32	s16, s16, s17
                if(ABORTED)
 801dc70:	4b0b      	ldr	r3, [pc, #44]	; (801dca0 <spindle_sync+0xc4>)
 801dc72:	881b      	ldrh	r3, [r3, #0]
 801dc74:	2b00      	cmp	r3, #0
 801dc76:	d1d8      	bne.n	801dc2a <spindle_sync+0x4e>
                if(on_delay >= settings.safety_door.spindle_on_delay) {
 801dc78:	4b06      	ldr	r3, [pc, #24]	; (801dc94 <spindle_sync+0xb8>)
 801dc7a:	edd3 7a50 	vldr	s15, [r3, #320]	; 0x140
 801dc7e:	eef4 7ac8 	vcmpe.f32	s15, s16
 801dc82:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801dc86:	d8e3      	bhi.n	801dc50 <spindle_sync+0x74>
                    gc_spindle_off();
 801dc88:	f7f1 fae4 	bl	800f254 <gc_spindle_off>
                    system_raise_alarm(Alarm_Spindle);
 801dc8c:	200e      	movs	r0, #14
 801dc8e:	f003 fa89 	bl	80211a4 <system_raise_alarm>
                    break;
 801dc92:	e7ca      	b.n	801dc2a <spindle_sync+0x4e>
 801dc94:	20003b14 	.word	0x20003b14
 801dc98:	00000000 	.word	0x00000000
 801dc9c:	3e4ccccd 	.word	0x3e4ccccd
 801dca0:	200036c4 	.word	0x200036c4

0801dca4 <spindle_set_override>:
{
 801dca4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801dca6:	4605      	mov	r5, r0
    if(speed_override != 100 && spindle->param->state.override_disable)
 801dca8:	2964      	cmp	r1, #100	; 0x64
 801dcaa:	d004      	beq.n	801dcb6 <spindle_set_override+0x12>
 801dcac:	6843      	ldr	r3, [r0, #4]
 801dcae:	7a1b      	ldrb	r3, [r3, #8]
 801dcb0:	f013 0f10 	tst.w	r3, #16
 801dcb4:	d10c      	bne.n	801dcd0 <spindle_set_override+0x2c>
    speed_override = constrain(speed_override, MIN_SPINDLE_RPM_OVERRIDE, MAX_SPINDLE_RPM_OVERRIDE);
 801dcb6:	2909      	cmp	r1, #9
 801dcb8:	d904      	bls.n	801dcc4 <spindle_set_override+0x20>
 801dcba:	29c8      	cmp	r1, #200	; 0xc8
 801dcbc:	bf28      	it	cs
 801dcbe:	21c8      	movcs	r1, #200	; 0xc8
 801dcc0:	460c      	mov	r4, r1
 801dcc2:	e000      	b.n	801dcc6 <spindle_set_override+0x22>
 801dcc4:	240a      	movs	r4, #10
    if ((uint8_t)speed_override != spindle->param->override_pct) {
 801dcc6:	686b      	ldr	r3, [r5, #4]
 801dcc8:	68d9      	ldr	r1, [r3, #12]
 801dcca:	b2e2      	uxtb	r2, r4
 801dccc:	4291      	cmp	r1, r2
 801dcce:	d100      	bne.n	801dcd2 <spindle_set_override+0x2e>
}
 801dcd0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        spindle->param->override_pct = speed_override;
 801dcd2:	60dc      	str	r4, [r3, #12]
        if(state_get() == STATE_IDLE)
 801dcd4:	f000 fc86 	bl	801e5e4 <state_get>
 801dcd8:	b1e0      	cbz	r0, 801dd14 <spindle_set_override+0x70>
            sys.step_control.update_spindle_rpm = On;
 801dcda:	4a12      	ldr	r2, [pc, #72]	; (801dd24 <spindle_set_override+0x80>)
 801dcdc:	7e13      	ldrb	r3, [r2, #24]
 801dcde:	f043 0308 	orr.w	r3, r3, #8
 801dce2:	7613      	strb	r3, [r2, #24]
        system_add_rt_report(Report_Overrides); // Set to report change immediately
 801dce4:	2040      	movs	r0, #64	; 0x40
 801dce6:	f003 faab 	bl	8021240 <system_add_rt_report>
       if(grbl.on_spindle_programmed)
 801dcea:	4b0f      	ldr	r3, [pc, #60]	; (801dd28 <spindle_set_override+0x84>)
 801dcec:	6a9e      	ldr	r6, [r3, #40]	; 0x28
 801dcee:	b156      	cbz	r6, 801dd06 <spindle_set_override+0x62>
           grbl.on_spindle_programmed(spindle, gc_state.modal.spindle.state, spindle_set_rpm(spindle, gc_state.spindle.rpm, speed_override), gc_state.modal.spindle.rpm_mode);
 801dcf0:	4f0e      	ldr	r7, [pc, #56]	; (801dd2c <spindle_set_override+0x88>)
 801dcf2:	4621      	mov	r1, r4
 801dcf4:	ed97 0a12 	vldr	s0, [r7, #72]	; 0x48
 801dcf8:	4628      	mov	r0, r5
 801dcfa:	f7ff fe93 	bl	801da24 <spindle_set_rpm>
 801dcfe:	7efa      	ldrb	r2, [r7, #27]
 801dd00:	7eb9      	ldrb	r1, [r7, #26]
 801dd02:	4628      	mov	r0, r5
 801dd04:	47b0      	blx	r6
       if(grbl.on_override_changed)
 801dd06:	4b08      	ldr	r3, [pc, #32]	; (801dd28 <spindle_set_override+0x84>)
 801dd08:	6a1b      	ldr	r3, [r3, #32]
 801dd0a:	2b00      	cmp	r3, #0
 801dd0c:	d0e0      	beq.n	801dcd0 <spindle_set_override+0x2c>
           grbl.on_override_changed(OverrideChanged_SpindleRPM);
 801dd0e:	2000      	movs	r0, #0
 801dd10:	4798      	blx	r3
 801dd12:	e7dd      	b.n	801dcd0 <spindle_set_override+0x2c>
            spindle_set_state(spindle, gc_state.modal.spindle.state, gc_state.spindle.rpm);
 801dd14:	4b05      	ldr	r3, [pc, #20]	; (801dd2c <spindle_set_override+0x88>)
 801dd16:	ed93 0a12 	vldr	s0, [r3, #72]	; 0x48
 801dd1a:	7e99      	ldrb	r1, [r3, #26]
 801dd1c:	4628      	mov	r0, r5
 801dd1e:	f7ff fef9 	bl	801db14 <spindle_set_state>
 801dd22:	e7df      	b.n	801dce4 <spindle_set_override+0x40>
 801dd24:	200036c4 	.word	0x200036c4
 801dd28:	2000343c 	.word	0x2000343c
 801dd2c:	20003344 	.word	0x20003344

0801dd30 <spindle_all_off>:

/*! \brief Turn off all enabled spindles.
*/
void spindle_all_off (void)
{
 801dd30:	b508      	push	{r3, lr}
    spindle_ptrs_t *spindle;
    uint_fast8_t spindle_num = N_SYS_SPINDLE;
    do {
        if((spindle = spindle_get(--spindle_num))) {
 801dd32:	2000      	movs	r0, #0
 801dd34:	f7ff fe0e 	bl	801d954 <spindle_get>
 801dd38:	b168      	cbz	r0, 801dd56 <spindle_all_off+0x26>
 801dd3a:	4603      	mov	r3, r0
            spindle->param->rpm = spindle->param->rpm_overridden = 0.0f;
 801dd3c:	6842      	ldr	r2, [r0, #4]
 801dd3e:	ed9f 0a06 	vldr	s0, [pc, #24]	; 801dd58 <spindle_all_off+0x28>
 801dd42:	ed82 0a01 	vstr	s0, [r2, #4]
 801dd46:	6842      	ldr	r2, [r0, #4]
 801dd48:	ed82 0a00 	vstr	s0, [r2]
            spindle->param->state.value = 0;
 801dd4c:	6842      	ldr	r2, [r0, #4]
 801dd4e:	2000      	movs	r0, #0
 801dd50:	7210      	strb	r0, [r2, #8]
#ifdef GRBL_ESP32
            spindle->esp32_off();
#else
            spindle->set_state((spindle_state_t){0}, 0.0f);
 801dd52:	69db      	ldr	r3, [r3, #28]
 801dd54:	4798      	blx	r3
#endif
        }
    } while(spindle_num);
}
 801dd56:	bd08      	pop	{r3, pc}
 801dd58:	00000000 	.word	0x00000000

0801dd5c <spindle_is_on>:

/*! \brief Check if any of the enabled spindles is running.
\returns \a true if a spindle is running, \a false otherwise.
*/
bool spindle_is_on (void)
{
 801dd5c:	b508      	push	{r3, lr}
    bool on = false;

    spindle_ptrs_t *spindle;
    uint_fast8_t spindle_num = N_SYS_SPINDLE;
    do {
        if((spindle = spindle_get(--spindle_num)))
 801dd5e:	2000      	movs	r0, #0
 801dd60:	f7ff fdf8 	bl	801d954 <spindle_get>
 801dd64:	b120      	cbz	r0, 801dd70 <spindle_is_on+0x14>
            on = spindle->get_state().on;
 801dd66:	6a03      	ldr	r3, [r0, #32]
 801dd68:	4798      	blx	r3
 801dd6a:	f000 0001 	and.w	r0, r0, #1
    } while(spindle_num && !on);

    return on;
}
 801dd6e:	bd08      	pop	{r3, pc}
 801dd70:	2000      	movs	r0, #0
 801dd72:	e7fc      	b.n	801dd6e <spindle_is_on+0x12>

0801dd74 <spindle_precompute_pwm_values>:
\param pwm_data pointer to a \a spindle_pwm_t structure, to hold the precomputed values.
\param clock_hz timer clock frequency used for PWM generation.
\returns \a true if successful, \a false if no PWM range possible - driver should then revert to simple on/off spindle control.
*/
bool spindle_precompute_pwm_values (spindle_ptrs_t *spindle, spindle_pwm_t *pwm_data, uint32_t clock_hz)
{
 801dd74:	b430      	push	{r4, r5}
 801dd76:	b082      	sub	sp, #8
 801dd78:	9201      	str	r2, [sp, #4]
    if(spindle->rpm_max > spindle->rpm_min) {
 801dd7a:	ed90 7a05 	vldr	s14, [r0, #20]
 801dd7e:	edd0 7a04 	vldr	s15, [r0, #16]
 801dd82:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801dd86:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801dd8a:	dd51      	ble.n	801de30 <spindle_precompute_pwm_values+0xbc>
        pwm_data->rpm_min = spindle->rpm_min;
 801dd8c:	edc1 7a04 	vstr	s15, [r1, #16]
        pwm_data->period = (uint_fast16_t)((float)clock_hz / settings.spindle.pwm_freq);
 801dd90:	ee07 2a90 	vmov	s15, r2
 801dd94:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 801dd98:	4b36      	ldr	r3, [pc, #216]	; (801de74 <spindle_precompute_pwm_values+0x100>)
 801dd9a:	edd3 6a1f 	vldr	s13, [r3, #124]	; 0x7c
 801dd9e:	eec7 7a26 	vdiv.f32	s15, s14, s13
 801dda2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801dda6:	edc1 7a00 	vstr	s15, [r1]
        if(settings.spindle.pwm_off_value == 0.0f)
 801ddaa:	ed93 7a21 	vldr	s14, [r3, #132]	; 0x84
 801ddae:	eeb5 7a40 	vcmp.f32	s14, #0.0
 801ddb2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ddb6:	d149      	bne.n	801de4c <spindle_precompute_pwm_values+0xd8>
            pwm_data->off_value = pwm_data->invert_pwm ? pwm_data->period : 0;
 801ddb8:	7e0b      	ldrb	r3, [r1, #24]
 801ddba:	b10b      	cbz	r3, 801ddc0 <spindle_precompute_pwm_values+0x4c>
 801ddbc:	ee17 3a90 	vmov	r3, s15
 801ddc0:	604b      	str	r3, [r1, #4]
        else
            pwm_data->off_value = invert_pwm(pwm_data, (uint_fast16_t)(pwm_data->period * settings.spindle.pwm_off_value / 100.0f));
        pwm_data->min_value = (uint_fast16_t)(pwm_data->period * settings.spindle.pwm_min_value / 100.0f);
 801ddc2:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801ddc6:	4c2b      	ldr	r4, [pc, #172]	; (801de74 <spindle_precompute_pwm_values+0x100>)
 801ddc8:	edd4 6a22 	vldr	s13, [r4, #136]	; 0x88
 801ddcc:	ee67 6aa6 	vmul.f32	s13, s15, s13
 801ddd0:	ed9f 6a29 	vldr	s12, [pc, #164]	; 801de78 <spindle_precompute_pwm_values+0x104>
 801ddd4:	ee86 7a86 	vdiv.f32	s14, s13, s12
 801ddd8:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 801dddc:	ee17 2a10 	vmov	r2, s14
 801dde0:	ed81 7a02 	vstr	s14, [r1, #8]
        pwm_data->max_value = (uint_fast16_t)(pwm_data->period * settings.spindle.pwm_max_value / 100.0f) + pwm_data->offset;
 801dde4:	ed94 7a23 	vldr	s14, [r4, #140]	; 0x8c
 801dde8:	ee67 7a87 	vmul.f32	s15, s15, s14
 801ddec:	ee87 7a86 	vdiv.f32	s14, s15, s12
 801ddf0:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 801ddf4:	ee17 3a90 	vmov	r3, s15
 801ddf8:	69cd      	ldr	r5, [r1, #28]
 801ddfa:	442b      	add	r3, r5
 801ddfc:	60cb      	str	r3, [r1, #12]
        pwm_data->pwm_gradient = (float)(pwm_data->max_value - pwm_data->min_value) / (spindle->rpm_max - spindle->rpm_min);
 801ddfe:	1a9b      	subs	r3, r3, r2
 801de00:	ee07 3a90 	vmov	s15, r3
 801de04:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801de08:	ed90 7a05 	vldr	s14, [r0, #20]
 801de0c:	edd0 6a04 	vldr	s13, [r0, #16]
 801de10:	ee37 7a66 	vsub.f32	s14, s14, s13
 801de14:	eec7 6a87 	vdiv.f32	s13, s15, s14
 801de18:	edc1 6a05 	vstr	s13, [r1, #20]
        pwm_data->always_on = settings.spindle.pwm_off_value != 0.0f;
 801de1c:	edd4 7a21 	vldr	s15, [r4, #132]	; 0x84
 801de20:	eef5 7a40 	vcmp.f32	s15, #0.0
 801de24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801de28:	bf14      	ite	ne
 801de2a:	2301      	movne	r3, #1
 801de2c:	2300      	moveq	r3, #0
 801de2e:	764b      	strb	r3, [r1, #25]
    }

    spindle->cap.pwm_linearization = pwm_data->n_pieces > 0;
#endif

    return spindle->rpm_max > spindle->rpm_min;
 801de30:	ed90 7a05 	vldr	s14, [r0, #20]
 801de34:	edd0 7a04 	vldr	s15, [r0, #16]
 801de38:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801de3c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
}
 801de40:	bfcc      	ite	gt
 801de42:	2001      	movgt	r0, #1
 801de44:	2000      	movle	r0, #0
 801de46:	b002      	add	sp, #8
 801de48:	bc30      	pop	{r4, r5}
 801de4a:	4770      	bx	lr
            pwm_data->off_value = invert_pwm(pwm_data, (uint_fast16_t)(pwm_data->period * settings.spindle.pwm_off_value / 100.0f));
 801de4c:	eef8 6a67 	vcvt.f32.u32	s13, s15
 801de50:	ee66 6a87 	vmul.f32	s13, s13, s14
 801de54:	ed9f 6a08 	vldr	s12, [pc, #32]	; 801de78 <spindle_precompute_pwm_values+0x104>
 801de58:	ee86 7a86 	vdiv.f32	s14, s13, s12
 801de5c:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 801de60:	ee17 3a10 	vmov	r3, s14
    return pwm_data->invert_pwm ? pwm_data->period - pwm_value - 1 : pwm_value;
 801de64:	7e0a      	ldrb	r2, [r1, #24]
 801de66:	b11a      	cbz	r2, 801de70 <spindle_precompute_pwm_values+0xfc>
 801de68:	ee17 2a90 	vmov	r2, s15
 801de6c:	1ad3      	subs	r3, r2, r3
 801de6e:	3b01      	subs	r3, #1
            pwm_data->off_value = invert_pwm(pwm_data, (uint_fast16_t)(pwm_data->period * settings.spindle.pwm_off_value / 100.0f));
 801de70:	604b      	str	r3, [r1, #4]
 801de72:	e7a6      	b.n	801ddc2 <spindle_precompute_pwm_values+0x4e>
 801de74:	20003b14 	.word	0x20003b14
 801de78:	42c80000 	.word	0x42c80000

0801de7c <spindle_compute_pwm_value>:

__NOTE:__ \a spindle_precompute_pwm_values() must be called to precompute values before this function is called.
Typically this is done by the spindle initialization code.
*/
uint_fast16_t spindle_compute_pwm_value (spindle_pwm_t *pwm_data, float rpm, bool pid_limit)
{
 801de7c:	b538      	push	{r3, r4, r5, lr}
 801de7e:	4604      	mov	r4, r0
    uint_fast16_t pwm_value;

    if(rpm > pwm_data->rpm_min) {
 801de80:	edd0 7a04 	vldr	s15, [r0, #16]
 801de84:	eef4 7ac0 	vcmpe.f32	s15, s0
 801de88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801de8c:	d523      	bpl.n	801ded6 <spindle_compute_pwm_value+0x5a>
 801de8e:	460d      	mov	r5, r1
                }
            } while(idx);
        } else
      #endif
        // Compute intermediate PWM value with linear spindle speed model.
        pwm_value = (uint_fast16_t)floorf((rpm - pwm_data->rpm_min) * pwm_data->pwm_gradient) + pwm_data->min_value;
 801de90:	ee30 0a67 	vsub.f32	s0, s0, s15
 801de94:	edd0 7a05 	vldr	s15, [r0, #20]
 801de98:	ee20 0a27 	vmul.f32	s0, s0, s15
 801de9c:	f005 feec 	bl	8023c78 <floorf>
 801dea0:	eebc 0ac0 	vcvt.u32.f32	s0, s0
 801dea4:	68a0      	ldr	r0, [r4, #8]
 801dea6:	ee10 3a10 	vmov	r3, s0
 801deaa:	4403      	add	r3, r0

        if(pwm_value >= (pid_limit ? pwm_data->period : pwm_data->max_value))
 801deac:	b15d      	cbz	r5, 801dec6 <spindle_compute_pwm_value+0x4a>
 801deae:	6822      	ldr	r2, [r4, #0]
 801deb0:	429a      	cmp	r2, r3
 801deb2:	d80c      	bhi.n	801dece <spindle_compute_pwm_value+0x52>
            pwm_value = pid_limit ? pwm_data->period - 1 : pwm_data->max_value;
 801deb4:	b14d      	cbz	r5, 801deca <spindle_compute_pwm_value+0x4e>
 801deb6:	6820      	ldr	r0, [r4, #0]
 801deb8:	3801      	subs	r0, #1
    return pwm_data->invert_pwm ? pwm_data->period - pwm_value - 1 : pwm_value;
 801deba:	7e23      	ldrb	r3, [r4, #24]
 801debc:	b113      	cbz	r3, 801dec4 <spindle_compute_pwm_value+0x48>
 801debe:	6823      	ldr	r3, [r4, #0]
 801dec0:	1a18      	subs	r0, r3, r0
 801dec2:	3801      	subs	r0, #1
        pwm_value = invert_pwm(pwm_data, pwm_value);
    } else
        pwm_value = rpm == 0.0f ? pwm_data->off_value : invert_pwm(pwm_data, pwm_data->min_value);

    return pwm_value;
}
 801dec4:	bd38      	pop	{r3, r4, r5, pc}
        if(pwm_value >= (pid_limit ? pwm_data->period : pwm_data->max_value))
 801dec6:	68e2      	ldr	r2, [r4, #12]
 801dec8:	e7f2      	b.n	801deb0 <spindle_compute_pwm_value+0x34>
            pwm_value = pid_limit ? pwm_data->period - 1 : pwm_data->max_value;
 801deca:	68e0      	ldr	r0, [r4, #12]
 801decc:	e7f5      	b.n	801deba <spindle_compute_pwm_value+0x3e>
        else if(pwm_value < pwm_data->min_value)
 801dece:	4298      	cmp	r0, r3
 801ded0:	d8f3      	bhi.n	801deba <spindle_compute_pwm_value+0x3e>
        pwm_value = (uint_fast16_t)floorf((rpm - pwm_data->rpm_min) * pwm_data->pwm_gradient) + pwm_data->min_value;
 801ded2:	4618      	mov	r0, r3
 801ded4:	e7f1      	b.n	801deba <spindle_compute_pwm_value+0x3e>
        pwm_value = rpm == 0.0f ? pwm_data->off_value : invert_pwm(pwm_data, pwm_data->min_value);
 801ded6:	eeb5 0a40 	vcmp.f32	s0, #0.0
 801deda:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801dede:	d101      	bne.n	801dee4 <spindle_compute_pwm_value+0x68>
 801dee0:	6840      	ldr	r0, [r0, #4]
 801dee2:	e7ef      	b.n	801dec4 <spindle_compute_pwm_value+0x48>
 801dee4:	6880      	ldr	r0, [r0, #8]
    return pwm_data->invert_pwm ? pwm_data->period - pwm_value - 1 : pwm_value;
 801dee6:	7e23      	ldrb	r3, [r4, #24]
 801dee8:	2b00      	cmp	r3, #0
 801deea:	d0eb      	beq.n	801dec4 <spindle_compute_pwm_value+0x48>
 801deec:	6823      	ldr	r3, [r4, #0]
 801deee:	1a18      	subs	r0, r3, r0
 801def0:	3801      	subs	r0, #1
    return pwm_value;
 801def2:	e7e7      	b.n	801dec4 <spindle_compute_pwm_value+0x48>

0801def4 <state_noop>:
/*! /brief No operation handler.
 */
static void state_noop (uint_fast16_t rt_exec)
{
    // Do nothing - state change requests are handled elsewhere or ignored.
}
 801def4:	4770      	bx	lr
	...

0801def8 <state_await_restart_retract>:
/*! /brief Waits until plunge motion abort is completed then calls state_await_hold() to restart retraction.
state_await_hold() is set to handle the cycle complete event.
 */
static void state_await_restart_retract (uint_fast16_t rt_exec)
{
    if (rt_exec & EXEC_CYCLE_COMPLETE) {
 801def8:	f010 0f04 	tst.w	r0, #4
 801defc:	d014      	beq.n	801df28 <state_await_restart_retract+0x30>
{
 801defe:	b508      	push	{r3, lr}

        if (sys.step_control.execute_sys_motion) {
 801df00:	4b0a      	ldr	r3, [pc, #40]	; (801df2c <state_await_restart_retract+0x34>)
 801df02:	7e1b      	ldrb	r3, [r3, #24]
 801df04:	f013 0f04 	tst.w	r3, #4
 801df08:	d106      	bne.n	801df18 <state_await_restart_retract+0x20>
            sys.step_control.execute_sys_motion = Off;
            st_parking_restore_buffer(); // Restore step segment buffer to normal run state.
        }

        stateHandler = state_await_hold;
 801df0a:	4b09      	ldr	r3, [pc, #36]	; (801df30 <state_await_restart_retract+0x38>)
 801df0c:	4a09      	ldr	r2, [pc, #36]	; (801df34 <state_await_restart_retract+0x3c>)
 801df0e:	601a      	str	r2, [r3, #0]
        stateHandler(EXEC_CYCLE_COMPLETE);
 801df10:	681b      	ldr	r3, [r3, #0]
 801df12:	2004      	movs	r0, #4
 801df14:	4798      	blx	r3
    }
}
 801df16:	bd08      	pop	{r3, pc}
            sys.step_control.execute_sys_motion = Off;
 801df18:	4b04      	ldr	r3, [pc, #16]	; (801df2c <state_await_restart_retract+0x34>)
 801df1a:	7e1a      	ldrb	r2, [r3, #24]
 801df1c:	f36f 0282 	bfc	r2, #2, #1
 801df20:	761a      	strb	r2, [r3, #24]
            st_parking_restore_buffer(); // Restore step segment buffer to normal run state.
 801df22:	f001 fa0f 	bl	801f344 <st_parking_restore_buffer>
 801df26:	e7f0      	b.n	801df0a <state_await_restart_retract+0x12>
 801df28:	4770      	bx	lr
 801df2a:	bf00      	nop
 801df2c:	200036c4 	.word	0x200036c4
 801df30:	20000510 	.word	0x20000510
 801df34:	0801e339 	.word	0x0801e339

0801df38 <state_await_waypoint_retract>:
/*! /brief Waits until slow plunge motion is completed then deenergize spindle and coolant and execute fast retract motion.
state_await_resume() is set to handle the cycle complete event.
 */
static void state_await_waypoint_retract (uint_fast16_t rt_exec)
{
    if (rt_exec & EXEC_CYCLE_COMPLETE) {
 801df38:	f010 0f04 	tst.w	r0, #4
 801df3c:	d05c      	beq.n	801dff8 <state_await_waypoint_retract+0xc0>
{
 801df3e:	b500      	push	{lr}
 801df40:	b085      	sub	sp, #20

        bool await_motion = false;

        if (sys.step_control.execute_sys_motion) {
 801df42:	4b2e      	ldr	r3, [pc, #184]	; (801dffc <state_await_waypoint_retract+0xc4>)
 801df44:	7e1b      	ldrb	r3, [r3, #24]
 801df46:	f013 0f04 	tst.w	r3, #4
 801df4a:	d135      	bne.n	801dfb8 <state_await_waypoint_retract+0x80>
            sys.step_control.execute_sys_motion = Off;
            st_parking_restore_buffer(); // Restore step segment buffer to normal run state.
        }

        // NOTE: Clear accessory state after retract and after an aborted restore motion.
        park.plan_data.spindle.state.value = 0;
 801df4c:	4b2c      	ldr	r3, [pc, #176]	; (801e000 <state_await_waypoint_retract+0xc8>)
 801df4e:	2000      	movs	r0, #0
 801df50:	f883 0028 	strb.w	r0, [r3, #40]	; 0x28
        park.plan_data.spindle.rpm = 0.0f;
 801df54:	ed9f 0a2b 	vldr	s0, [pc, #172]	; 801e004 <state_await_waypoint_retract+0xcc>
 801df58:	ed83 0a09 	vstr	s0, [r3, #36]	; 0x24
        park.plan_data.spindle.hal->set_state(park.plan_data.spindle.state, 0.0f); // De-energize
 801df5c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801df5e:	69db      	ldr	r3, [r3, #28]
 801df60:	4798      	blx	r3

        if (!settings.safety_door.flags.keep_coolant_on) {
 801df62:	4b29      	ldr	r3, [pc, #164]	; (801e008 <state_await_waypoint_retract+0xd0>)
 801df64:	f893 313c 	ldrb.w	r3, [r3, #316]	; 0x13c
 801df68:	f013 0f02 	tst.w	r3, #2
 801df6c:	d106      	bne.n	801df7c <state_await_waypoint_retract+0x44>
            park.plan_data.condition.coolant.value = 0;
 801df6e:	2000      	movs	r0, #0
 801df70:	4b23      	ldr	r3, [pc, #140]	; (801e000 <state_await_waypoint_retract+0xc8>)
 801df72:	f883 0036 	strb.w	r0, [r3, #54]	; 0x36
            hal.coolant.set_state(park.plan_data.condition.coolant); // De-energize
 801df76:	4b25      	ldr	r3, [pc, #148]	; (801e00c <state_await_waypoint_retract+0xd4>)
 801df78:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801df7a:	4798      	blx	r3
        }

        stateHandler = state_await_resume;
 801df7c:	4b24      	ldr	r3, [pc, #144]	; (801e010 <state_await_waypoint_retract+0xd8>)
 801df7e:	4a25      	ldr	r2, [pc, #148]	; (801e014 <state_await_waypoint_retract+0xdc>)
 801df80:	601a      	str	r2, [r3, #0]

        // Execute fast parking retract motion to parking target location.
        if (park.flags.motion && park.target[settings.parking.axis] < settings.parking.target) {
 801df82:	4b1f      	ldr	r3, [pc, #124]	; (801e000 <state_await_waypoint_retract+0xc8>)
 801df84:	7f1b      	ldrb	r3, [r3, #28]
 801df86:	f013 0f02 	tst.w	r3, #2
 801df8a:	d00e      	beq.n	801dfaa <state_await_waypoint_retract+0x72>
 801df8c:	4a1e      	ldr	r2, [pc, #120]	; (801e008 <state_await_waypoint_retract+0xd0>)
 801df8e:	f892 c129 	ldrb.w	ip, [r2, #297]	; 0x129
 801df92:	4b1b      	ldr	r3, [pc, #108]	; (801e000 <state_await_waypoint_retract+0xc8>)
 801df94:	eb03 038c 	add.w	r3, r3, ip, lsl #2
 801df98:	ed93 7a00 	vldr	s14, [r3]
 801df9c:	edd2 7a4b 	vldr	s15, [r2, #300]	; 0x12c
 801dfa0:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801dfa4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801dfa8:	d40e      	bmi.n	801dfc8 <state_await_waypoint_retract+0x90>
            park.plan_data.feed_rate = settings.parking.rate;
            await_motion = mc_parking_motion(target, &park.plan_data);
        }

        if (!await_motion)
            stateHandler(EXEC_CYCLE_COMPLETE);
 801dfaa:	4b19      	ldr	r3, [pc, #100]	; (801e010 <state_await_waypoint_retract+0xd8>)
 801dfac:	681b      	ldr	r3, [r3, #0]
 801dfae:	2004      	movs	r0, #4
 801dfb0:	4798      	blx	r3
    }
}
 801dfb2:	b005      	add	sp, #20
 801dfb4:	f85d fb04 	ldr.w	pc, [sp], #4
            sys.step_control.execute_sys_motion = Off;
 801dfb8:	4b10      	ldr	r3, [pc, #64]	; (801dffc <state_await_waypoint_retract+0xc4>)
 801dfba:	7e1a      	ldrb	r2, [r3, #24]
 801dfbc:	f36f 0282 	bfc	r2, #2, #1
 801dfc0:	761a      	strb	r2, [r3, #24]
            st_parking_restore_buffer(); // Restore step segment buffer to normal run state.
 801dfc2:	f001 f9bf 	bl	801f344 <st_parking_restore_buffer>
 801dfc6:	e7c1      	b.n	801df4c <state_await_waypoint_retract+0x14>
            memcpy(target, park.target, sizeof(target));
 801dfc8:	4b0d      	ldr	r3, [pc, #52]	; (801e000 <state_await_waypoint_retract+0xc8>)
 801dfca:	f10d 0e04 	add.w	lr, sp, #4
 801dfce:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 801dfd2:	e88e 0007 	stmia.w	lr, {r0, r1, r2}
            target[settings.parking.axis] = settings.parking.target;
 801dfd6:	aa04      	add	r2, sp, #16
 801dfd8:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
 801dfdc:	ed4c 7a03 	vstr	s15, [ip, #-12]
            park.plan_data.feed_rate = settings.parking.rate;
 801dfe0:	4a09      	ldr	r2, [pc, #36]	; (801e008 <state_await_waypoint_retract+0xd0>)
 801dfe2:	f8d2 2130 	ldr.w	r2, [r2, #304]	; 0x130
 801dfe6:	4619      	mov	r1, r3
 801dfe8:	f841 2f20 	str.w	r2, [r1, #32]!
            await_motion = mc_parking_motion(target, &park.plan_data);
 801dfec:	4670      	mov	r0, lr
 801dfee:	f7f6 fe67 	bl	8014cc0 <mc_parking_motion>
        if (!await_motion)
 801dff2:	2800      	cmp	r0, #0
 801dff4:	d1dd      	bne.n	801dfb2 <state_await_waypoint_retract+0x7a>
 801dff6:	e7d8      	b.n	801dfaa <state_await_waypoint_retract+0x72>
 801dff8:	4770      	bx	lr
 801dffa:	bf00      	nop
 801dffc:	200036c4 	.word	0x200036c4
 801e000:	20003e14 	.word	0x20003e14
 801e004:	00000000 	.word	0x00000000
 801e008:	20003b14 	.word	0x20003b14
 801e00c:	2000350c 	.word	0x2000350c
 801e010:	20000510 	.word	0x20000510
 801e014:	0801e8cd 	.word	0x0801e8cd

0801e018 <restart_retract>:
{
 801e018:	b508      	push	{r3, lr}
    grbl.report.feedback_message(Message_SafetyDoorAjar);
 801e01a:	4b12      	ldr	r3, [pc, #72]	; (801e064 <restart_retract+0x4c>)
 801e01c:	68db      	ldr	r3, [r3, #12]
 801e01e:	2006      	movs	r0, #6
 801e020:	4798      	blx	r3
    stateHandler = state_await_restart_retract;
 801e022:	4b11      	ldr	r3, [pc, #68]	; (801e068 <restart_retract+0x50>)
 801e024:	4a11      	ldr	r2, [pc, #68]	; (801e06c <restart_retract+0x54>)
 801e026:	601a      	str	r2, [r3, #0]
    park.flags.restart = On;
 801e028:	4a11      	ldr	r2, [pc, #68]	; (801e070 <restart_retract+0x58>)
 801e02a:	7f13      	ldrb	r3, [r2, #28]
 801e02c:	f043 0304 	orr.w	r3, r3, #4
 801e030:	7713      	strb	r3, [r2, #28]
    sys.parking_state = Parking_Retracting;
 801e032:	4b10      	ldr	r3, [pc, #64]	; (801e074 <restart_retract+0x5c>)
 801e034:	2202      	movs	r2, #2
 801e036:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    if (sys.step_control.execute_sys_motion) {
 801e03a:	7e1b      	ldrb	r3, [r3, #24]
 801e03c:	f013 0f04 	tst.w	r3, #4
 801e040:	d104      	bne.n	801e04c <restart_retract+0x34>
        stateHandler(EXEC_CYCLE_COMPLETE);
 801e042:	4b09      	ldr	r3, [pc, #36]	; (801e068 <restart_retract+0x50>)
 801e044:	681b      	ldr	r3, [r3, #0]
 801e046:	2004      	movs	r0, #4
 801e048:	4798      	blx	r3
}
 801e04a:	bd08      	pop	{r3, pc}
        st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
 801e04c:	f001 f924 	bl	801f298 <st_update_plan_block_parameters>
        sys.step_control.execute_hold = On;
 801e050:	4b08      	ldr	r3, [pc, #32]	; (801e074 <restart_retract+0x5c>)
 801e052:	7e1a      	ldrb	r2, [r3, #24]
 801e054:	f042 0202 	orr.w	r2, r2, #2
 801e058:	761a      	strb	r2, [r3, #24]
        sys.step_control.execute_sys_motion = On;
 801e05a:	b2d2      	uxtb	r2, r2
 801e05c:	f042 0204 	orr.w	r2, r2, #4
 801e060:	761a      	strb	r2, [r3, #24]
 801e062:	e7f2      	b.n	801e04a <restart_retract+0x32>
 801e064:	2000343c 	.word	0x2000343c
 801e068:	20000510 	.word	0x20000510
 801e06c:	0801def9 	.word	0x0801def9
 801e070:	20003e14 	.word	0x20003e14
 801e074:	200036c4 	.word	0x200036c4

0801e078 <state_spindle_restore>:
{
 801e078:	b508      	push	{r3, lr}
 801e07a:	4603      	mov	r3, r0
    if(spindle->hal)
 801e07c:	68c0      	ldr	r0, [r0, #12]
 801e07e:	b120      	cbz	r0, 801e08a <state_spindle_restore+0x12>
        spindle_restore(spindle->hal, spindle->state, spindle->rpm);
 801e080:	ed93 0a00 	vldr	s0, [r3]
 801e084:	7919      	ldrb	r1, [r3, #4]
 801e086:	f7ff fd49 	bl	801db1c <spindle_restore>
}
 801e08a:	bd08      	pop	{r3, pc}

0801e08c <state_restore_conditions>:
{
 801e08c:	b538      	push	{r3, r4, r5, lr}
 801e08e:	4604      	mov	r4, r0
    if (!settings.parking.flags.enabled || !park.flags.restart) {
 801e090:	4b17      	ldr	r3, [pc, #92]	; (801e0f0 <state_restore_conditions+0x64>)
 801e092:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 801e096:	f013 0f01 	tst.w	r3, #1
 801e09a:	d004      	beq.n	801e0a6 <state_restore_conditions+0x1a>
 801e09c:	4b15      	ldr	r3, [pc, #84]	; (801e0f4 <state_restore_conditions+0x68>)
 801e09e:	7f1b      	ldrb	r3, [r3, #28]
 801e0a0:	f013 0f04 	tst.w	r3, #4
 801e0a4:	d118      	bne.n	801e0d8 <state_restore_conditions+0x4c>
        park.flags.restoring = On; //
 801e0a6:	4a13      	ldr	r2, [pc, #76]	; (801e0f4 <state_restore_conditions+0x68>)
 801e0a8:	7f13      	ldrb	r3, [r2, #28]
 801e0aa:	f043 0308 	orr.w	r3, r3, #8
 801e0ae:	7713      	strb	r3, [r2, #28]
            state_spindle_restore(&condition->spindle[--spindle_num]);
 801e0b0:	1d20      	adds	r0, r4, #4
 801e0b2:	f7ff ffe1 	bl	801e078 <state_spindle_restore>
        if (gc_state.modal.coolant.value != hal.coolant.get_state().value) {
 801e0b6:	4b10      	ldr	r3, [pc, #64]	; (801e0f8 <state_restore_conditions+0x6c>)
 801e0b8:	7e5d      	ldrb	r5, [r3, #25]
 801e0ba:	4b10      	ldr	r3, [pc, #64]	; (801e0fc <state_restore_conditions+0x70>)
 801e0bc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801e0be:	4798      	blx	r3
 801e0c0:	b2c3      	uxtb	r3, r0
 801e0c2:	429d      	cmp	r5, r3
 801e0c4:	d109      	bne.n	801e0da <state_restore_conditions+0x4e>
        park.flags.restoring = Off;
 801e0c6:	4a0b      	ldr	r2, [pc, #44]	; (801e0f4 <state_restore_conditions+0x68>)
 801e0c8:	7f13      	ldrb	r3, [r2, #28]
 801e0ca:	f36f 03c3 	bfc	r3, #3, #1
 801e0ce:	7713      	strb	r3, [r2, #28]
        sys.override.spindle_stop.value = 0; // Clear spindle stop override states
 801e0d0:	4b0b      	ldr	r3, [pc, #44]	; (801e100 <state_restore_conditions+0x74>)
 801e0d2:	2200      	movs	r2, #0
 801e0d4:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
}
 801e0d8:	bd38      	pop	{r3, r4, r5, pc}
            coolant_set_state(condition->coolant);
 801e0da:	7820      	ldrb	r0, [r4, #0]
 801e0dc:	f7f0 fe7e 	bl	800eddc <coolant_set_state>
            delay_sec(settings.safety_door.coolant_on_delay, DelayMode_SysSuspend);
 801e0e0:	2001      	movs	r0, #1
 801e0e2:	4b03      	ldr	r3, [pc, #12]	; (801e0f0 <state_restore_conditions+0x64>)
 801e0e4:	ed93 0a51 	vldr	s0, [r3, #324]	; 0x144
 801e0e8:	f7f7 fcbc 	bl	8015a64 <delay_sec>
 801e0ec:	e7eb      	b.n	801e0c6 <state_restore_conditions+0x3a>
 801e0ee:	bf00      	nop
 801e0f0:	20003b14 	.word	0x20003b14
 801e0f4:	20003e14 	.word	0x20003e14
 801e0f8:	20003344 	.word	0x20003344
 801e0fc:	2000350c 	.word	0x2000350c
 801e100:	200036c4 	.word	0x200036c4

0801e104 <state_restore>:
/*! /brief Waits until fast plunge motion is completed then restore spindle and coolant and execute slow plunge motion.
state_await_resumed() is set to handle the cycle complete event.
Note: A safety door event during restoration or motion will halt it and restart the retract sequence.
 */
static void state_restore (uint_fast16_t rt_exec)
{
 801e104:	b510      	push	{r4, lr}
    if (rt_exec & EXEC_SAFETY_DOOR) {
 801e106:	f010 0f40 	tst.w	r0, #64	; 0x40
 801e10a:	d00d      	beq.n	801e128 <state_restore+0x24>
        if(park.flags.restoring)
 801e10c:	4b2b      	ldr	r3, [pc, #172]	; (801e1bc <state_restore+0xb8>)
 801e10e:	7f1b      	ldrb	r3, [r3, #28]
 801e110:	f013 0f08 	tst.w	r3, #8
 801e114:	d005      	beq.n	801e122 <state_restore+0x1e>
            park.flags.restart = On;
 801e116:	4a29      	ldr	r2, [pc, #164]	; (801e1bc <state_restore+0xb8>)
 801e118:	7f13      	ldrb	r3, [r2, #28]
 801e11a:	f043 0304 	orr.w	r3, r3, #4
 801e11e:	7713      	strb	r3, [r2, #28]
        }

        if (!await_motion)
            stateHandler(EXEC_CYCLE_COMPLETE); // No motion, proceed to next step immediately.
    }
}
 801e120:	bd10      	pop	{r4, pc}
            restart_retract();
 801e122:	f7ff ff79 	bl	801e018 <restart_retract>
 801e126:	e7fb      	b.n	801e120 <state_restore+0x1c>
    else if (rt_exec & EXEC_CYCLE_COMPLETE) {
 801e128:	f010 0f04 	tst.w	r0, #4
 801e12c:	d0f8      	beq.n	801e120 <state_restore+0x1c>
        if (sys.step_control.execute_sys_motion) {
 801e12e:	4b24      	ldr	r3, [pc, #144]	; (801e1c0 <state_restore+0xbc>)
 801e130:	7e1b      	ldrb	r3, [r3, #24]
 801e132:	f013 0f04 	tst.w	r3, #4
 801e136:	d118      	bne.n	801e16a <state_restore+0x66>
        park.flags.restart = Off;
 801e138:	4c20      	ldr	r4, [pc, #128]	; (801e1bc <state_restore+0xb8>)
 801e13a:	7f23      	ldrb	r3, [r4, #28]
 801e13c:	f36f 0382 	bfc	r3, #2, #1
 801e140:	7723      	strb	r3, [r4, #28]
        stateHandler = state_await_resumed;
 801e142:	4b20      	ldr	r3, [pc, #128]	; (801e1c4 <state_restore+0xc0>)
 801e144:	4a20      	ldr	r2, [pc, #128]	; (801e1c8 <state_restore+0xc4>)
 801e146:	601a      	str	r2, [r3, #0]
        state_restore_conditions(&restore_condition);
 801e148:	4820      	ldr	r0, [pc, #128]	; (801e1cc <state_restore+0xc8>)
 801e14a:	f7ff ff9f 	bl	801e08c <state_restore_conditions>
        if(park.flags.restart) {
 801e14e:	7f23      	ldrb	r3, [r4, #28]
 801e150:	f013 0f04 	tst.w	r3, #4
 801e154:	d111      	bne.n	801e17a <state_restore+0x76>
        if (park.flags.motion) {
 801e156:	4b19      	ldr	r3, [pc, #100]	; (801e1bc <state_restore+0xb8>)
 801e158:	7f1b      	ldrb	r3, [r3, #28]
 801e15a:	f013 0f02 	tst.w	r3, #2
 801e15e:	d10f      	bne.n	801e180 <state_restore+0x7c>
            stateHandler(EXEC_CYCLE_COMPLETE); // No motion, proceed to next step immediately.
 801e160:	4b18      	ldr	r3, [pc, #96]	; (801e1c4 <state_restore+0xc0>)
 801e162:	681b      	ldr	r3, [r3, #0]
 801e164:	2004      	movs	r0, #4
 801e166:	4798      	blx	r3
 801e168:	e7da      	b.n	801e120 <state_restore+0x1c>
            sys.step_control.execute_sys_motion = Off;
 801e16a:	4b15      	ldr	r3, [pc, #84]	; (801e1c0 <state_restore+0xbc>)
 801e16c:	7e1a      	ldrb	r2, [r3, #24]
 801e16e:	f36f 0282 	bfc	r2, #2, #1
 801e172:	761a      	strb	r2, [r3, #24]
            st_parking_restore_buffer(); // Restore step segment buffer to normal run state.
 801e174:	f001 f8e6 	bl	801f344 <st_parking_restore_buffer>
 801e178:	e7de      	b.n	801e138 <state_restore+0x34>
            restart_retract();
 801e17a:	f7ff ff4d 	bl	801e018 <restart_retract>
            return;
 801e17e:	e7cf      	b.n	801e120 <state_restore+0x1c>
            sys.parking_state = Parking_Resuming;
 801e180:	4b0f      	ldr	r3, [pc, #60]	; (801e1c0 <state_restore+0xbc>)
 801e182:	2204      	movs	r2, #4
 801e184:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
            park.plan_data.feed_rate = settings.parking.pullout_rate;
 801e188:	4b11      	ldr	r3, [pc, #68]	; (801e1d0 <state_restore+0xcc>)
 801e18a:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
 801e18e:	480b      	ldr	r0, [pc, #44]	; (801e1bc <state_restore+0xb8>)
 801e190:	6203      	str	r3, [r0, #32]
            park.plan_data.condition.coolant = restore_condition.coolant;
 801e192:	4b0e      	ldr	r3, [pc, #56]	; (801e1cc <state_restore+0xc8>)
 801e194:	781a      	ldrb	r2, [r3, #0]
 801e196:	f880 2036 	strb.w	r2, [r0, #54]	; 0x36
            park.plan_data.spindle.state = restore_condition.spindle[restore_condition.spindle_num].state;
 801e19a:	f993 2001 	ldrsb.w	r2, [r3, #1]
 801e19e:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801e1a2:	7a1a      	ldrb	r2, [r3, #8]
 801e1a4:	f880 2028 	strb.w	r2, [r0, #40]	; 0x28
            park.plan_data.spindle.rpm = restore_condition.spindle[restore_condition.spindle_num].rpm;
 801e1a8:	685b      	ldr	r3, [r3, #4]
 801e1aa:	6243      	str	r3, [r0, #36]	; 0x24
            await_motion = mc_parking_motion(park.restore_target, &park.plan_data);
 801e1ac:	f100 0120 	add.w	r1, r0, #32
 801e1b0:	300c      	adds	r0, #12
 801e1b2:	f7f6 fd85 	bl	8014cc0 <mc_parking_motion>
        if (!await_motion)
 801e1b6:	2800      	cmp	r0, #0
 801e1b8:	d1b2      	bne.n	801e120 <state_restore+0x1c>
 801e1ba:	e7d1      	b.n	801e160 <state_restore+0x5c>
 801e1bc:	20003e14 	.word	0x20003e14
 801e1c0:	200036c4 	.word	0x200036c4
 801e1c4:	20000510 	.word	0x20000510
 801e1c8:	0801eb09 	.word	0x0801eb09
 801e1cc:	20003e60 	.word	0x20003e60
 801e1d0:	20003b14 	.word	0x20003b14

0801e1d4 <initiate_hold>:
{
 801e1d4:	b538      	push	{r3, r4, r5, lr}
 801e1d6:	4605      	mov	r5, r0
    if (settings.parking.flags.enabled) {
 801e1d8:	4b4d      	ldr	r3, [pc, #308]	; (801e310 <initiate_hold+0x13c>)
 801e1da:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 801e1de:	f013 0f01 	tst.w	r3, #1
 801e1e2:	d14c      	bne.n	801e27e <initiate_hold+0xaa>
    plan_block_t *block = plan_get_current_block();
 801e1e4:	f7f8 fa66 	bl	80166b4 <plan_get_current_block>
 801e1e8:	4604      	mov	r4, r0
    restore_condition.spindle_num = 0;
 801e1ea:	2000      	movs	r0, #0
 801e1ec:	4b49      	ldr	r3, [pc, #292]	; (801e314 <initiate_hold+0x140>)
 801e1ee:	7058      	strb	r0, [r3, #1]
        if((spindle = spindle_get(--spindle_num))) {
 801e1f0:	f7ff fbb0 	bl	801d954 <spindle_get>
 801e1f4:	4603      	mov	r3, r0
 801e1f6:	2800      	cmp	r0, #0
 801e1f8:	d068      	beq.n	801e2cc <initiate_hold+0xf8>
            if(block && block->spindle.hal == spindle) {
 801e1fa:	b114      	cbz	r4, 801e202 <initiate_hold+0x2e>
 801e1fc:	6c62      	ldr	r2, [r4, #68]	; 0x44
 801e1fe:	4282      	cmp	r2, r0
 801e200:	d050      	beq.n	801e2a4 <initiate_hold+0xd0>
            } else if(gc_state.spindle.hal == spindle) {
 801e202:	4a45      	ldr	r2, [pc, #276]	; (801e318 <initiate_hold+0x144>)
 801e204:	6d52      	ldr	r2, [r2, #84]	; 0x54
 801e206:	429a      	cmp	r2, r3
 801e208:	d056      	beq.n	801e2b8 <initiate_hold+0xe4>
                restore_condition.spindle[spindle_num].hal = spindle;
 801e20a:	4a42      	ldr	r2, [pc, #264]	; (801e314 <initiate_hold+0x140>)
 801e20c:	6113      	str	r3, [r2, #16]
                restore_condition.spindle[spindle_num].rpm = spindle->param->rpm;
 801e20e:	6859      	ldr	r1, [r3, #4]
 801e210:	6809      	ldr	r1, [r1, #0]
 801e212:	6051      	str	r1, [r2, #4]
                restore_condition.spindle[spindle_num].state = spindle->param->state;
 801e214:	685b      	ldr	r3, [r3, #4]
 801e216:	7a1b      	ldrb	r3, [r3, #8]
 801e218:	7213      	strb	r3, [r2, #8]
    if (block)
 801e21a:	2c00      	cmp	r4, #0
 801e21c:	d05a      	beq.n	801e2d4 <initiate_hold+0x100>
        restore_condition.coolant.mask = block->condition.coolant.mask;
 801e21e:	7da2      	ldrb	r2, [r4, #22]
 801e220:	4b3c      	ldr	r3, [pc, #240]	; (801e314 <initiate_hold+0x140>)
 801e222:	701a      	strb	r2, [r3, #0]
    if (restore_condition.spindle[restore_condition.spindle_num].hal->cap.laser && settings.flags.disable_laser_during_hold)
 801e224:	4b3b      	ldr	r3, [pc, #236]	; (801e314 <initiate_hold+0x140>)
 801e226:	f993 2001 	ldrsb.w	r2, [r3, #1]
 801e22a:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801e22e:	691b      	ldr	r3, [r3, #16]
 801e230:	7a5b      	ldrb	r3, [r3, #9]
 801e232:	f013 0f08 	tst.w	r3, #8
 801e236:	d005      	beq.n	801e244 <initiate_hold+0x70>
 801e238:	4b35      	ldr	r3, [pc, #212]	; (801e310 <initiate_hold+0x13c>)
 801e23a:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 801e23e:	f013 0f10 	tst.w	r3, #16
 801e242:	d151      	bne.n	801e2e8 <initiate_hold+0x114>
    if (sys_state & (STATE_CYCLE|STATE_JOG)) {
 801e244:	4b35      	ldr	r3, [pc, #212]	; (801e31c <initiate_hold+0x148>)
 801e246:	681b      	ldr	r3, [r3, #0]
 801e248:	f013 0f28 	tst.w	r3, #40	; 0x28
 801e24c:	d150      	bne.n	801e2f0 <initiate_hold+0x11c>
    if (new_state == STATE_HOLD)
 801e24e:	2d10      	cmp	r5, #16
 801e250:	d059      	beq.n	801e306 <initiate_hold+0x132>
        sys.parking_state = Parking_Retracting;
 801e252:	4b33      	ldr	r3, [pc, #204]	; (801e320 <initiate_hold+0x14c>)
 801e254:	2202      	movs	r2, #2
 801e256:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        park.flags.value = 0;
 801e25a:	4b32      	ldr	r3, [pc, #200]	; (801e324 <initiate_hold+0x150>)
 801e25c:	2200      	movs	r2, #0
 801e25e:	771a      	strb	r2, [r3, #28]
    sys.suspend = true;
 801e260:	4b2f      	ldr	r3, [pc, #188]	; (801e320 <initiate_hold+0x14c>)
 801e262:	2201      	movs	r2, #1
 801e264:	709a      	strb	r2, [r3, #2]
    pending_state = sys_state == STATE_JOG ? new_state : STATE_IDLE;
 801e266:	4b2d      	ldr	r3, [pc, #180]	; (801e31c <initiate_hold+0x148>)
 801e268:	6818      	ldr	r0, [r3, #0]
 801e26a:	2820      	cmp	r0, #32
 801e26c:	d000      	beq.n	801e270 <initiate_hold+0x9c>
 801e26e:	2500      	movs	r5, #0
 801e270:	4b2d      	ldr	r3, [pc, #180]	; (801e328 <initiate_hold+0x154>)
 801e272:	601d      	str	r5, [r3, #0]
}
 801e274:	2808      	cmp	r0, #8
 801e276:	bf14      	ite	ne
 801e278:	2000      	movne	r0, #0
 801e27a:	2001      	moveq	r0, #1
 801e27c:	bd38      	pop	{r3, r4, r5, pc}
        plan_data_init(&park.plan_data);
 801e27e:	4c29      	ldr	r4, [pc, #164]	; (801e324 <initiate_hold+0x150>)
 801e280:	f104 0020 	add.w	r0, r4, #32
 801e284:	f7f8 fd6c 	bl	8016d60 <plan_data_init>
        park.plan_data.condition.system_motion = On;
 801e288:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 801e28c:	f043 0302 	orr.w	r3, r3, #2
 801e290:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        park.plan_data.condition.no_feed_override = On;
 801e294:	b2db      	uxtb	r3, r3
 801e296:	f043 0310 	orr.w	r3, r3, #16
 801e29a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        park.plan_data.line_number = PARKING_MOTION_LINE_NUMBER;
 801e29e:	2300      	movs	r3, #0
 801e2a0:	63e3      	str	r3, [r4, #60]	; 0x3c
 801e2a2:	e79f      	b.n	801e1e4 <initiate_hold+0x10>
                restore_condition.spindle_num = spindle_num;
 801e2a4:	4b1b      	ldr	r3, [pc, #108]	; (801e314 <initiate_hold+0x140>)
 801e2a6:	2100      	movs	r1, #0
 801e2a8:	7059      	strb	r1, [r3, #1]
                restore_condition.spindle[spindle_num].hal = block->spindle.hal;
 801e2aa:	611a      	str	r2, [r3, #16]
                restore_condition.spindle[spindle_num].rpm = block->spindle.rpm;
 801e2ac:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 801e2ae:	605a      	str	r2, [r3, #4]
                restore_condition.spindle[spindle_num].state = block->spindle.state;
 801e2b0:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
 801e2b4:	721a      	strb	r2, [r3, #8]
 801e2b6:	e7b0      	b.n	801e21a <initiate_hold+0x46>
                restore_condition.spindle_num = spindle_num;
 801e2b8:	4b16      	ldr	r3, [pc, #88]	; (801e314 <initiate_hold+0x140>)
 801e2ba:	2100      	movs	r1, #0
 801e2bc:	7059      	strb	r1, [r3, #1]
                restore_condition.spindle[spindle_num].hal = gc_state.spindle.hal;
 801e2be:	611a      	str	r2, [r3, #16]
                restore_condition.spindle[spindle_num].rpm = gc_state.spindle.rpm;
 801e2c0:	4a15      	ldr	r2, [pc, #84]	; (801e318 <initiate_hold+0x144>)
 801e2c2:	6c91      	ldr	r1, [r2, #72]	; 0x48
 801e2c4:	6059      	str	r1, [r3, #4]
                restore_condition.spindle[spindle_num].state = gc_state.modal.spindle.state;
 801e2c6:	7e92      	ldrb	r2, [r2, #26]
 801e2c8:	721a      	strb	r2, [r3, #8]
 801e2ca:	e7a6      	b.n	801e21a <initiate_hold+0x46>
            restore_condition.spindle[spindle_num].hal = NULL;
 801e2cc:	4b11      	ldr	r3, [pc, #68]	; (801e314 <initiate_hold+0x140>)
 801e2ce:	2200      	movs	r2, #0
 801e2d0:	611a      	str	r2, [r3, #16]
 801e2d2:	e7a2      	b.n	801e21a <initiate_hold+0x46>
        restore_condition.coolant.mask = gc_state.modal.coolant.mask | hal.coolant.get_state().mask;
 801e2d4:	4b10      	ldr	r3, [pc, #64]	; (801e318 <initiate_hold+0x144>)
 801e2d6:	7e5c      	ldrb	r4, [r3, #25]
 801e2d8:	4b14      	ldr	r3, [pc, #80]	; (801e32c <initiate_hold+0x158>)
 801e2da:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801e2dc:	4798      	blx	r3
 801e2de:	b2c0      	uxtb	r0, r0
 801e2e0:	4304      	orrs	r4, r0
 801e2e2:	4b0c      	ldr	r3, [pc, #48]	; (801e314 <initiate_hold+0x140>)
 801e2e4:	701c      	strb	r4, [r3, #0]
 801e2e6:	e79d      	b.n	801e224 <initiate_hold+0x50>
        enqueue_spindle_override(CMD_OVERRIDE_SPINDLE_STOP);
 801e2e8:	209e      	movs	r0, #158	; 0x9e
 801e2ea:	f7f8 f80f 	bl	801630c <enqueue_spindle_override>
 801e2ee:	e7a9      	b.n	801e244 <initiate_hold+0x70>
        st_update_plan_block_parameters();  // Notify stepper module to recompute for hold deceleration.
 801e2f0:	f000 ffd2 	bl	801f298 <st_update_plan_block_parameters>
        sys.step_control.execute_hold = On; // Initiate suspend state with active flag.
 801e2f4:	4a0a      	ldr	r2, [pc, #40]	; (801e320 <initiate_hold+0x14c>)
 801e2f6:	7e13      	ldrb	r3, [r2, #24]
 801e2f8:	f043 0302 	orr.w	r3, r3, #2
 801e2fc:	7613      	strb	r3, [r2, #24]
        stateHandler = state_await_hold;
 801e2fe:	4b0c      	ldr	r3, [pc, #48]	; (801e330 <initiate_hold+0x15c>)
 801e300:	4a0c      	ldr	r2, [pc, #48]	; (801e334 <initiate_hold+0x160>)
 801e302:	601a      	str	r2, [r3, #0]
 801e304:	e7a3      	b.n	801e24e <initiate_hold+0x7a>
        sys.holding_state = Hold_Pending;
 801e306:	4b06      	ldr	r3, [pc, #24]	; (801e320 <initiate_hold+0x14c>)
 801e308:	2202      	movs	r2, #2
 801e30a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 801e30e:	e7a7      	b.n	801e260 <initiate_hold+0x8c>
 801e310:	20003b14 	.word	0x20003b14
 801e314:	20003e60 	.word	0x20003e60
 801e318:	20003344 	.word	0x20003344
 801e31c:	20003e74 	.word	0x20003e74
 801e320:	200036c4 	.word	0x200036c4
 801e324:	20003e14 	.word	0x20003e14
 801e328:	20003e5c 	.word	0x20003e5c
 801e32c:	2000350c 	.word	0x2000350c
 801e330:	20000510 	.word	0x20000510
 801e334:	0801e339 	.word	0x0801e339

0801e338 <state_await_hold>:
    if (rt_exec & EXEC_CYCLE_COMPLETE) {
 801e338:	f010 0f04 	tst.w	r0, #4
 801e33c:	d100      	bne.n	801e340 <state_await_hold+0x8>
 801e33e:	4770      	bx	lr
{
 801e340:	b510      	push	{r4, lr}
        plan_cycle_reinitialize();
 801e342:	f7f8 fcc5 	bl	8016cd0 <plan_cycle_reinitialize>
        sys.step_control.flags = 0;
 801e346:	4b7f      	ldr	r3, [pc, #508]	; (801e544 <state_await_hold+0x20c>)
 801e348:	2200      	movs	r2, #0
 801e34a:	761a      	strb	r2, [r3, #24]
        if (sys.alarm_pending) {
 801e34c:	7d19      	ldrb	r1, [r3, #20]
 801e34e:	b139      	cbz	r1, 801e360 <state_await_hold+0x28>
            system_set_exec_alarm(sys.alarm_pending);
 801e350:	4b7d      	ldr	r3, [pc, #500]	; (801e548 <state_await_hold+0x210>)
 801e352:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801e354:	4c7d      	ldr	r4, [pc, #500]	; (801e54c <state_await_hold+0x214>)
 801e356:	4620      	mov	r0, r4
 801e358:	4798      	blx	r3
            sys.alarm_pending = Alarm_None;
 801e35a:	2300      	movs	r3, #0
 801e35c:	f804 3c38 	strb.w	r3, [r4, #-56]
        switch (sys_state) {
 801e360:	4b7b      	ldr	r3, [pc, #492]	; (801e550 <state_await_hold+0x218>)
 801e362:	681b      	ldr	r3, [r3, #0]
 801e364:	2b80      	cmp	r3, #128	; 0x80
 801e366:	d014      	beq.n	801e392 <state_await_hold+0x5a>
 801e368:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 801e36c:	d009      	beq.n	801e382 <state_await_hold+0x4a>
 801e36e:	2b40      	cmp	r3, #64	; 0x40
 801e370:	d00f      	beq.n	801e392 <state_await_hold+0x5a>
            sys.holding_state = Hold_Complete;
 801e372:	4b74      	ldr	r3, [pc, #464]	; (801e544 <state_await_hold+0x20c>)
 801e374:	2201      	movs	r2, #1
 801e376:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
            stateHandler = state_await_resume;
 801e37a:	4b76      	ldr	r3, [pc, #472]	; (801e554 <state_await_hold+0x21c>)
 801e37c:	4a76      	ldr	r2, [pc, #472]	; (801e558 <state_await_hold+0x220>)
 801e37e:	601a      	str	r2, [r3, #0]
}
 801e380:	bd10      	pop	{r4, pc}
                spindle_all_off(); // De-energize
 801e382:	f7ff fcd5 	bl	801dd30 <spindle_all_off>
                hal.coolant.set_state((coolant_state_t){0}); // De-energize
 801e386:	4b70      	ldr	r3, [pc, #448]	; (801e548 <state_await_hold+0x210>)
 801e388:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801e38a:	f04f 0000 	mov.w	r0, #0
 801e38e:	4798      	blx	r3
        if (!handler_changed) {
 801e390:	e7ef      	b.n	801e372 <state_await_hold+0x3a>
                sys.override.spindle_stop.value = 0;
 801e392:	4b6c      	ldr	r3, [pc, #432]	; (801e544 <state_await_hold+0x20c>)
 801e394:	2200      	movs	r2, #0
 801e396:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
                if (settings.parking.flags.enabled && !sys.override.control.parking_disable && settings.mode != Mode_Laser) {
 801e39a:	4b70      	ldr	r3, [pc, #448]	; (801e55c <state_await_hold+0x224>)
 801e39c:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 801e3a0:	f013 0f01 	tst.w	r3, #1
 801e3a4:	f000 80b3 	beq.w	801e50e <state_await_hold+0x1d6>
 801e3a8:	4b66      	ldr	r3, [pc, #408]	; (801e544 <state_await_hold+0x20c>)
 801e3aa:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 801e3ae:	f013 0f08 	tst.w	r3, #8
 801e3b2:	f040 80ac 	bne.w	801e50e <state_await_hold+0x1d6>
 801e3b6:	4b69      	ldr	r3, [pc, #420]	; (801e55c <state_await_hold+0x224>)
 801e3b8:	7e1b      	ldrb	r3, [r3, #24]
 801e3ba:	2b01      	cmp	r3, #1
 801e3bc:	f000 80a7 	beq.w	801e50e <state_await_hold+0x1d6>
                    if (!park.flags.active) {
 801e3c0:	4b67      	ldr	r3, [pc, #412]	; (801e560 <state_await_hold+0x228>)
 801e3c2:	7f1b      	ldrb	r3, [r3, #28]
 801e3c4:	f013 0f01 	tst.w	r3, #1
 801e3c8:	d05d      	beq.n	801e486 <state_await_hold+0x14e>
                    if (bit_istrue(sys.homed.mask, bit(settings.parking.axis)) && (park.restore_target[settings.parking.axis] < settings.parking.target)) {
 801e3ca:	4b5e      	ldr	r3, [pc, #376]	; (801e544 <state_await_hold+0x20c>)
 801e3cc:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 801e3d0:	4a62      	ldr	r2, [pc, #392]	; (801e55c <state_await_hold+0x224>)
 801e3d2:	f892 4129 	ldrb.w	r4, [r2, #297]	; 0x129
 801e3d6:	40e3      	lsrs	r3, r4
 801e3d8:	f013 0f01 	tst.w	r3, #1
 801e3dc:	d07d      	beq.n	801e4da <state_await_hold+0x1a2>
 801e3de:	1ca2      	adds	r2, r4, #2
 801e3e0:	4b5f      	ldr	r3, [pc, #380]	; (801e560 <state_await_hold+0x228>)
 801e3e2:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 801e3e6:	ed93 7a01 	vldr	s14, [r3, #4]
 801e3ea:	4b5c      	ldr	r3, [pc, #368]	; (801e55c <state_await_hold+0x224>)
 801e3ec:	edd3 7a4b 	vldr	s15, [r3, #300]	; 0x12c
 801e3f0:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801e3f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e3f8:	d56f      	bpl.n	801e4da <state_await_hold+0x1a2>
                        stateHandler = state_await_waypoint_retract;
 801e3fa:	4b56      	ldr	r3, [pc, #344]	; (801e554 <state_await_hold+0x21c>)
 801e3fc:	4a59      	ldr	r2, [pc, #356]	; (801e564 <state_await_hold+0x22c>)
 801e3fe:	601a      	str	r2, [r3, #0]
                        if(park.flags.restart)
 801e400:	4b57      	ldr	r3, [pc, #348]	; (801e560 <state_await_hold+0x228>)
 801e402:	7f1b      	ldrb	r3, [r3, #28]
 801e404:	f013 0f04 	tst.w	r3, #4
 801e408:	d147      	bne.n	801e49a <state_await_hold+0x162>
                            memcpy(park.target, park.restore_target, sizeof(park.target));
 801e40a:	4b55      	ldr	r3, [pc, #340]	; (801e560 <state_await_hold+0x228>)
 801e40c:	f103 020c 	add.w	r2, r3, #12
 801e410:	ca07      	ldmia	r2, {r0, r1, r2}
 801e412:	e883 0007 	stmia.w	r3, {r0, r1, r2}
                            park.retract_waypoint = settings.parking.pullout_increment + park.target[settings.parking.axis];
 801e416:	4a51      	ldr	r2, [pc, #324]	; (801e55c <state_await_hold+0x224>)
 801e418:	ed92 7a4e 	vldr	s14, [r2, #312]	; 0x138
 801e41c:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 801e420:	edd4 6a00 	vldr	s13, [r4]
 801e424:	ee37 7a26 	vadd.f32	s14, s14, s13
 801e428:	ed83 7a06 	vstr	s14, [r3, #24]
                            park.retract_waypoint = min(park.retract_waypoint, settings.parking.target);
 801e42c:	eef4 7ac7 	vcmpe.f32	s15, s14
 801e430:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e434:	dd01      	ble.n	801e43a <state_await_hold+0x102>
 801e436:	eef0 7a47 	vmov.f32	s15, s14
 801e43a:	4b49      	ldr	r3, [pc, #292]	; (801e560 <state_await_hold+0x228>)
 801e43c:	edc3 7a06 	vstr	s15, [r3, #24]
                        if ((await_motion = park.target[settings.parking.axis] < park.retract_waypoint)) {
 801e440:	4b46      	ldr	r3, [pc, #280]	; (801e55c <state_await_hold+0x224>)
 801e442:	f893 2129 	ldrb.w	r2, [r3, #297]	; 0x129
 801e446:	4b46      	ldr	r3, [pc, #280]	; (801e560 <state_await_hold+0x228>)
 801e448:	eb03 0182 	add.w	r1, r3, r2, lsl #2
 801e44c:	ed91 7a00 	vldr	s14, [r1]
 801e450:	edd3 7a06 	vldr	s15, [r3, #24]
 801e454:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801e458:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e45c:	bf4c      	ite	mi
 801e45e:	2001      	movmi	r0, #1
 801e460:	2000      	movpl	r0, #0
 801e462:	d41f      	bmi.n	801e4a4 <state_await_hold+0x16c>
                        if(!park.flags.restart)
 801e464:	4b3e      	ldr	r3, [pc, #248]	; (801e560 <state_await_hold+0x228>)
 801e466:	7f1b      	ldrb	r3, [r3, #28]
 801e468:	f013 0f04 	tst.w	r3, #4
 801e46c:	d104      	bne.n	801e478 <state_await_hold+0x140>
                            park.flags.motion = await_motion;
 801e46e:	4a3c      	ldr	r2, [pc, #240]	; (801e560 <state_await_hold+0x228>)
 801e470:	7f13      	ldrb	r3, [r2, #28]
 801e472:	f360 0341 	bfi	r3, r0, #1, #1
 801e476:	7713      	strb	r3, [r2, #28]
                        if (!await_motion)
 801e478:	2800      	cmp	r0, #0
 801e47a:	d181      	bne.n	801e380 <state_await_hold+0x48>
                            stateHandler(EXEC_CYCLE_COMPLETE); // No motion, proceed to next step immediately.
 801e47c:	4b35      	ldr	r3, [pc, #212]	; (801e554 <state_await_hold+0x21c>)
 801e47e:	681b      	ldr	r3, [r3, #0]
 801e480:	2004      	movs	r0, #4
 801e482:	4798      	blx	r3
        if (!handler_changed) {
 801e484:	e77c      	b.n	801e380 <state_await_hold+0x48>
                        park.flags.active = On;
 801e486:	4836      	ldr	r0, [pc, #216]	; (801e560 <state_await_hold+0x228>)
 801e488:	7f03      	ldrb	r3, [r0, #28]
 801e48a:	f043 0301 	orr.w	r3, r3, #1
 801e48e:	7703      	strb	r3, [r0, #28]
                        system_convert_array_steps_to_mpos(park.restore_target, sys.position);
 801e490:	4935      	ldr	r1, [pc, #212]	; (801e568 <state_await_hold+0x230>)
 801e492:	300c      	adds	r0, #12
 801e494:	f002 fda2 	bl	8020fdc <system_convert_array_steps_to_mpos>
 801e498:	e797      	b.n	801e3ca <state_await_hold+0x92>
                            system_convert_array_steps_to_mpos(park.target, sys.position);
 801e49a:	4933      	ldr	r1, [pc, #204]	; (801e568 <state_await_hold+0x230>)
 801e49c:	4830      	ldr	r0, [pc, #192]	; (801e560 <state_await_hold+0x228>)
 801e49e:	f002 fd9d 	bl	8020fdc <system_convert_array_steps_to_mpos>
 801e4a2:	e7cd      	b.n	801e440 <state_await_hold+0x108>
                            park.target[settings.parking.axis] = park.retract_waypoint;
 801e4a4:	4618      	mov	r0, r3
 801e4a6:	edc1 7a00 	vstr	s15, [r1]
                            park.plan_data.feed_rate = settings.parking.pullout_rate;
 801e4aa:	4b2c      	ldr	r3, [pc, #176]	; (801e55c <state_await_hold+0x224>)
 801e4ac:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
 801e4b0:	6203      	str	r3, [r0, #32]
                            park.plan_data.condition.coolant = restore_condition.coolant; // Retain coolant state
 801e4b2:	4b2e      	ldr	r3, [pc, #184]	; (801e56c <state_await_hold+0x234>)
 801e4b4:	781a      	ldrb	r2, [r3, #0]
 801e4b6:	f880 2036 	strb.w	r2, [r0, #54]	; 0x36
                            park.plan_data.spindle.state = restore_condition.spindle[restore_condition.spindle_num].state; // Retain spindle state
 801e4ba:	f993 2001 	ldrsb.w	r2, [r3, #1]
 801e4be:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801e4c2:	7a1a      	ldrb	r2, [r3, #8]
 801e4c4:	f880 2028 	strb.w	r2, [r0, #40]	; 0x28
                            park.plan_data.spindle.hal = restore_condition.spindle[restore_condition.spindle_num].hal;
 801e4c8:	691a      	ldr	r2, [r3, #16]
 801e4ca:	6302      	str	r2, [r0, #48]	; 0x30
                            park.plan_data.spindle.rpm = restore_condition.spindle[restore_condition.spindle_num].rpm;
 801e4cc:	685b      	ldr	r3, [r3, #4]
 801e4ce:	6243      	str	r3, [r0, #36]	; 0x24
                            await_motion = mc_parking_motion(park.target, &park.plan_data);
 801e4d0:	f100 0120 	add.w	r1, r0, #32
 801e4d4:	f7f6 fbf4 	bl	8014cc0 <mc_parking_motion>
 801e4d8:	e7c4      	b.n	801e464 <state_await_hold+0x12c>
                        spindle_all_off(); // De-energize
 801e4da:	f7ff fc29 	bl	801dd30 <spindle_all_off>
                        if (!settings.safety_door.flags.keep_coolant_on || sys_state == STATE_SLEEP)
 801e4de:	4b1f      	ldr	r3, [pc, #124]	; (801e55c <state_await_hold+0x224>)
 801e4e0:	f893 313c 	ldrb.w	r3, [r3, #316]	; 0x13c
 801e4e4:	f013 0f02 	tst.w	r3, #2
 801e4e8:	d003      	beq.n	801e4f2 <state_await_hold+0x1ba>
 801e4ea:	4b19      	ldr	r3, [pc, #100]	; (801e550 <state_await_hold+0x218>)
 801e4ec:	681b      	ldr	r3, [r3, #0]
 801e4ee:	2b80      	cmp	r3, #128	; 0x80
 801e4f0:	d104      	bne.n	801e4fc <state_await_hold+0x1c4>
                            hal.coolant.set_state((coolant_state_t){0}); // De-energize
 801e4f2:	4b15      	ldr	r3, [pc, #84]	; (801e548 <state_await_hold+0x210>)
 801e4f4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801e4f6:	f04f 0000 	mov.w	r0, #0
 801e4fa:	4798      	blx	r3
                        sys.parking_state = hal.control.get_state().safety_door_ajar ? Parking_DoorAjar : Parking_DoorClosed;
 801e4fc:	4b12      	ldr	r3, [pc, #72]	; (801e548 <state_await_hold+0x210>)
 801e4fe:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801e500:	4798      	blx	r3
 801e502:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 801e506:	4b0f      	ldr	r3, [pc, #60]	; (801e544 <state_await_hold+0x20c>)
 801e508:	f883 0034 	strb.w	r0, [r3, #52]	; 0x34
        if (!handler_changed) {
 801e50c:	e731      	b.n	801e372 <state_await_hold+0x3a>
                    spindle_all_off(); // De-energize
 801e50e:	f7ff fc0f 	bl	801dd30 <spindle_all_off>
                    if (!settings.safety_door.flags.keep_coolant_on || sys_state == STATE_SLEEP)
 801e512:	4b12      	ldr	r3, [pc, #72]	; (801e55c <state_await_hold+0x224>)
 801e514:	f893 313c 	ldrb.w	r3, [r3, #316]	; 0x13c
 801e518:	f013 0f02 	tst.w	r3, #2
 801e51c:	d003      	beq.n	801e526 <state_await_hold+0x1ee>
 801e51e:	4b0c      	ldr	r3, [pc, #48]	; (801e550 <state_await_hold+0x218>)
 801e520:	681b      	ldr	r3, [r3, #0]
 801e522:	2b80      	cmp	r3, #128	; 0x80
 801e524:	d104      	bne.n	801e530 <state_await_hold+0x1f8>
                        hal.coolant.set_state((coolant_state_t){0}); // De-energize
 801e526:	4b08      	ldr	r3, [pc, #32]	; (801e548 <state_await_hold+0x210>)
 801e528:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801e52a:	f04f 0000 	mov.w	r0, #0
 801e52e:	4798      	blx	r3
                    sys.parking_state = hal.control.get_state().safety_door_ajar ? Parking_DoorAjar : Parking_DoorClosed;
 801e530:	4b05      	ldr	r3, [pc, #20]	; (801e548 <state_await_hold+0x210>)
 801e532:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801e534:	4798      	blx	r3
 801e536:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 801e53a:	4b02      	ldr	r3, [pc, #8]	; (801e544 <state_await_hold+0x20c>)
 801e53c:	f883 0034 	strb.w	r0, [r3, #52]	; 0x34
        if (!handler_changed) {
 801e540:	e717      	b.n	801e372 <state_await_hold+0x3a>
 801e542:	bf00      	nop
 801e544:	200036c4 	.word	0x200036c4
 801e548:	2000350c 	.word	0x2000350c
 801e54c:	20003710 	.word	0x20003710
 801e550:	20003e74 	.word	0x20003e74
 801e554:	20000510 	.word	0x20000510
 801e558:	0801e8cd 	.word	0x0801e8cd
 801e55c:	20003b14 	.word	0x20003b14
 801e560:	20003e14 	.word	0x20003e14
 801e564:	0801df39 	.word	0x0801df39
 801e568:	2000374c 	.word	0x2000374c
 801e56c:	20003e60 	.word	0x20003e60

0801e570 <enter_sleep>:
{
 801e570:	b508      	push	{r3, lr}
    st_go_idle();
 801e572:	f000 fc5b 	bl	801ee2c <st_go_idle>
    spindle_all_off();
 801e576:	f7ff fbdb 	bl	801dd30 <spindle_all_off>
    hal.coolant.set_state((coolant_state_t){0});
 801e57a:	4b06      	ldr	r3, [pc, #24]	; (801e594 <enter_sleep+0x24>)
 801e57c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801e57e:	f04f 0000 	mov.w	r0, #0
 801e582:	4798      	blx	r3
    grbl.report.feedback_message(Message_SleepMode);
 801e584:	4b04      	ldr	r3, [pc, #16]	; (801e598 <enter_sleep+0x28>)
 801e586:	68db      	ldr	r3, [r3, #12]
 801e588:	200b      	movs	r0, #11
 801e58a:	4798      	blx	r3
    stateHandler = state_noop;
 801e58c:	4b03      	ldr	r3, [pc, #12]	; (801e59c <enter_sleep+0x2c>)
 801e58e:	4a04      	ldr	r2, [pc, #16]	; (801e5a0 <enter_sleep+0x30>)
 801e590:	601a      	str	r2, [r3, #0]
}
 801e592:	bd08      	pop	{r3, pc}
 801e594:	2000350c 	.word	0x2000350c
 801e598:	2000343c 	.word	0x2000343c
 801e59c:	20000510 	.word	0x20000510
 801e5a0:	0801def5 	.word	0x0801def5

0801e5a4 <state_spindle_set_state>:
{
 801e5a4:	b508      	push	{r3, lr}
 801e5a6:	4603      	mov	r3, r0
    if(spindle->hal)
 801e5a8:	68c0      	ldr	r0, [r0, #12]
 801e5aa:	b120      	cbz	r0, 801e5b6 <state_spindle_set_state+0x12>
        spindle_set_state(spindle->hal, spindle->state, spindle->rpm);
 801e5ac:	ed93 0a00 	vldr	s0, [r3]
 801e5b0:	7919      	ldrb	r1, [r3, #4]
 801e5b2:	f7ff faaf 	bl	801db14 <spindle_set_state>
}
 801e5b6:	bd08      	pop	{r3, pc}

0801e5b8 <state_door_reopened>:
    return settings.parking.flags.enabled && park.flags.restart;
 801e5b8:	4b08      	ldr	r3, [pc, #32]	; (801e5dc <state_door_reopened+0x24>)
 801e5ba:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 801e5be:	f013 0f01 	tst.w	r3, #1
 801e5c2:	d006      	beq.n	801e5d2 <state_door_reopened+0x1a>
 801e5c4:	4b06      	ldr	r3, [pc, #24]	; (801e5e0 <state_door_reopened+0x28>)
 801e5c6:	7f1b      	ldrb	r3, [r3, #28]
 801e5c8:	f013 0f04 	tst.w	r3, #4
 801e5cc:	d103      	bne.n	801e5d6 <state_door_reopened+0x1e>
 801e5ce:	2000      	movs	r0, #0
 801e5d0:	4770      	bx	lr
 801e5d2:	2000      	movs	r0, #0
 801e5d4:	4770      	bx	lr
 801e5d6:	2001      	movs	r0, #1
}
 801e5d8:	4770      	bx	lr
 801e5da:	bf00      	nop
 801e5dc:	20003b14 	.word	0x20003b14
 801e5e0:	20003e14 	.word	0x20003e14

0801e5e4 <state_get>:
}
 801e5e4:	4b01      	ldr	r3, [pc, #4]	; (801e5ec <state_get+0x8>)
 801e5e6:	6818      	ldr	r0, [r3, #0]
 801e5e8:	4770      	bx	lr
 801e5ea:	bf00      	nop
 801e5ec:	20003e74 	.word	0x20003e74

0801e5f0 <state_set>:
{
 801e5f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if(new_state != sys_state) {
 801e5f2:	4b8a      	ldr	r3, [pc, #552]	; (801e81c <state_set+0x22c>)
 801e5f4:	681d      	ldr	r5, [r3, #0]
 801e5f6:	4285      	cmp	r5, r0
 801e5f8:	f000 80fd 	beq.w	801e7f6 <state_set+0x206>
 801e5fc:	4604      	mov	r4, r0
        switch(new_state) {    // Set up new state and handler
 801e5fe:	2820      	cmp	r0, #32
 801e600:	d825      	bhi.n	801e64e <state_set+0x5e>
 801e602:	2820      	cmp	r0, #32
 801e604:	f200 80e7 	bhi.w	801e7d6 <state_set+0x1e6>
 801e608:	e8df f010 	tbh	[pc, r0, lsl #1]
 801e60c:	00fe0053 	.word	0x00fe0053
 801e610:	00e500fe 	.word	0x00e500fe
 801e614:	00e500fe 	.word	0x00e500fe
 801e618:	00e500e5 	.word	0x00e500e5
 801e61c:	00e50065 	.word	0x00e50065
 801e620:	00e500e5 	.word	0x00e500e5
 801e624:	00e500e5 	.word	0x00e500e5
 801e628:	00e500e5 	.word	0x00e500e5
 801e62c:	00e500b9 	.word	0x00e500b9
 801e630:	00e500e5 	.word	0x00e500e5
 801e634:	00e500e5 	.word	0x00e500e5
 801e638:	00e500e5 	.word	0x00e500e5
 801e63c:	00e500e5 	.word	0x00e500e5
 801e640:	00e500e5 	.word	0x00e500e5
 801e644:	00e500e5 	.word	0x00e500e5
 801e648:	00e500e5 	.word	0x00e500e5
 801e64c:	00ab      	.short	0x00ab
 801e64e:	2880      	cmp	r0, #128	; 0x80
 801e650:	d01a      	beq.n	801e688 <state_set+0x98>
 801e652:	d90d      	bls.n	801e670 <state_set+0x80>
 801e654:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 801e658:	f000 80d6 	beq.w	801e808 <state_set+0x218>
 801e65c:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 801e660:	f040 80b9 	bne.w	801e7d6 <state_set+0x1e6>
                sys_state = new_state;
 801e664:	4b6d      	ldr	r3, [pc, #436]	; (801e81c <state_set+0x22c>)
 801e666:	6018      	str	r0, [r3, #0]
                stateHandler = state_await_toolchanged;
 801e668:	4b6d      	ldr	r3, [pc, #436]	; (801e820 <state_set+0x230>)
 801e66a:	4a6e      	ldr	r2, [pc, #440]	; (801e824 <state_set+0x234>)
 801e66c:	601a      	str	r2, [r3, #0]
                break;
 801e66e:	e0b2      	b.n	801e7d6 <state_set+0x1e6>
        switch(new_state) {    // Set up new state and handler
 801e670:	2840      	cmp	r0, #64	; 0x40
 801e672:	f040 80b0 	bne.w	801e7d6 <state_set+0x1e6>
                if ((sys_state & (STATE_ALARM|STATE_ESTOP|STATE_SLEEP|STATE_CHECK_MODE)))
 801e676:	f240 1383 	movw	r3, #387	; 0x183
 801e67a:	421d      	tst	r5, r3
 801e67c:	f040 80bb 	bne.w	801e7f6 <state_set+0x206>
                grbl.report.feedback_message(Message_SafetyDoorAjar);
 801e680:	4b69      	ldr	r3, [pc, #420]	; (801e828 <state_set+0x238>)
 801e682:	68db      	ldr	r3, [r3, #12]
 801e684:	2006      	movs	r0, #6
 801e686:	4798      	blx	r3
                sys.parking_state = Parking_Retracting;
 801e688:	4b68      	ldr	r3, [pc, #416]	; (801e82c <state_set+0x23c>)
 801e68a:	2202      	movs	r2, #2
 801e68c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
                if (!initiate_hold(new_state)) {
 801e690:	4620      	mov	r0, r4
 801e692:	f7ff fd9f 	bl	801e1d4 <initiate_hold>
 801e696:	2800      	cmp	r0, #0
 801e698:	f040 8097 	bne.w	801e7ca <state_set+0x1da>
                    if (pending_state != new_state) {
 801e69c:	4b64      	ldr	r3, [pc, #400]	; (801e830 <state_set+0x240>)
 801e69e:	681b      	ldr	r3, [r3, #0]
 801e6a0:	42a3      	cmp	r3, r4
 801e6a2:	f000 8094 	beq.w	801e7ce <state_set+0x1de>
                        sys_state = new_state;
 801e6a6:	4b5d      	ldr	r3, [pc, #372]	; (801e81c <state_set+0x22c>)
 801e6a8:	601c      	str	r4, [r3, #0]
                        state_await_hold(EXEC_CYCLE_COMPLETE); // "Simulate" a cycle stop
 801e6aa:	2004      	movs	r0, #4
 801e6ac:	f7ff fe44 	bl	801e338 <state_await_hold>
 801e6b0:	e08d      	b.n	801e7ce <state_set+0x1de>
                sys.suspend = false;        // Break suspend state.
 801e6b2:	4a5e      	ldr	r2, [pc, #376]	; (801e82c <state_set+0x23c>)
 801e6b4:	2300      	movs	r3, #0
 801e6b6:	7093      	strb	r3, [r2, #2]
                sys.step_control.flags = 0; // Restore step control to normal operation.
 801e6b8:	7613      	strb	r3, [r2, #24]
                sys.parking_state = Parking_DoorClosed;
 801e6ba:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
                sys.holding_state = Hold_NotHolding;
 801e6be:	f882 3035 	strb.w	r3, [r2, #53]	; 0x35
                sys_state = pending_state = new_state;
 801e6c2:	4a5b      	ldr	r2, [pc, #364]	; (801e830 <state_set+0x240>)
 801e6c4:	6010      	str	r0, [r2, #0]
 801e6c6:	4a55      	ldr	r2, [pc, #340]	; (801e81c <state_set+0x22c>)
 801e6c8:	6010      	str	r0, [r2, #0]
                park.flags.value = 0;
 801e6ca:	4a5a      	ldr	r2, [pc, #360]	; (801e834 <state_set+0x244>)
 801e6cc:	7713      	strb	r3, [r2, #28]
                stateHandler = state_idle;
 801e6ce:	4b54      	ldr	r3, [pc, #336]	; (801e820 <state_set+0x230>)
 801e6d0:	4a59      	ldr	r2, [pc, #356]	; (801e838 <state_set+0x248>)
 801e6d2:	601a      	str	r2, [r3, #0]
                break;
 801e6d4:	e07f      	b.n	801e7d6 <state_set+0x1e6>
                if (sys_state == STATE_IDLE) {
 801e6d6:	2d00      	cmp	r5, #0
 801e6d8:	d17d      	bne.n	801e7d6 <state_set+0x1e6>
                    if ((block = plan_get_current_block())) {
 801e6da:	f7f7 ffeb 	bl	80166b4 <plan_get_current_block>
 801e6de:	4606      	mov	r6, r0
 801e6e0:	2800      	cmp	r0, #0
 801e6e2:	d078      	beq.n	801e7d6 <state_set+0x1e6>
                        sys_state = new_state;
 801e6e4:	4b4d      	ldr	r3, [pc, #308]	; (801e81c <state_set+0x22c>)
 801e6e6:	601c      	str	r4, [r3, #0]
                        sys.steppers_deenergize = false;    // Cancel stepper deenergize if pending.
 801e6e8:	4b50      	ldr	r3, [pc, #320]	; (801e82c <state_set+0x23c>)
 801e6ea:	2200      	movs	r2, #0
 801e6ec:	719a      	strb	r2, [r3, #6]
                        st_prep_buffer();                   // Initialize step segment buffer before beginning cycle.
 801e6ee:	f000 fe6f 	bl	801f3d0 <st_prep_buffer>
                        if (block->spindle.state.synchronized) {
 801e6f2:	f996 303c 	ldrsb.w	r3, [r6, #60]	; 0x3c
 801e6f6:	2b00      	cmp	r3, #0
 801e6f8:	da2d      	bge.n	801e756 <state_set+0x166>
                            uint32_t ms = hal.get_elapsed_ticks();
 801e6fa:	4b50      	ldr	r3, [pc, #320]	; (801e83c <state_set+0x24c>)
 801e6fc:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 801e700:	4798      	blx	r3
 801e702:	4607      	mov	r7, r0
                            if (block->spindle.hal->reset_data)
 801e704:	6c73      	ldr	r3, [r6, #68]	; 0x44
 801e706:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801e708:	b103      	cbz	r3, 801e70c <state_set+0x11c>
                                block->spindle.hal->reset_data();
 801e70a:	4798      	blx	r3
                            uint32_t index = block->spindle.hal->get_data(SpindleData_Counters)->index_count + 2;
 801e70c:	6c73      	ldr	r3, [r6, #68]	; 0x44
 801e70e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801e710:	2000      	movs	r0, #0
 801e712:	4798      	blx	r3
 801e714:	6944      	ldr	r4, [r0, #20]
 801e716:	3402      	adds	r4, #2
                            while(index != block->spindle.hal->get_data(SpindleData_Counters)->index_count) {
 801e718:	6c73      	ldr	r3, [r6, #68]	; 0x44
 801e71a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801e71c:	2000      	movs	r0, #0
 801e71e:	4798      	blx	r3
 801e720:	6943      	ldr	r3, [r0, #20]
 801e722:	42a3      	cmp	r3, r4
 801e724:	d017      	beq.n	801e756 <state_set+0x166>
                                if(hal.get_elapsed_ticks() - ms > 5000) {
 801e726:	4b45      	ldr	r3, [pc, #276]	; (801e83c <state_set+0x24c>)
 801e728:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 801e72c:	4798      	blx	r3
 801e72e:	1bc0      	subs	r0, r0, r7
 801e730:	f241 3388 	movw	r3, #5000	; 0x1388
 801e734:	4298      	cmp	r0, r3
 801e736:	d80a      	bhi.n	801e74e <state_set+0x15e>
                                if(sys.rt_exec_state & (EXEC_RESET|EXEC_STOP)) {
 801e738:	4b3c      	ldr	r3, [pc, #240]	; (801e82c <state_set+0x23c>)
 801e73a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801e73c:	f013 0f30 	tst.w	r3, #48	; 0x30
 801e740:	d0ea      	beq.n	801e718 <state_set+0x128>
                                    system_set_exec_state_flag(EXEC_RESET);
 801e742:	4b3e      	ldr	r3, [pc, #248]	; (801e83c <state_set+0x24c>)
 801e744:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801e746:	2120      	movs	r1, #32
 801e748:	483d      	ldr	r0, [pc, #244]	; (801e840 <state_set+0x250>)
 801e74a:	4798      	blx	r3
                                    return;
 801e74c:	e053      	b.n	801e7f6 <state_set+0x206>
                                    system_raise_alarm(Alarm_Spindle);
 801e74e:	200e      	movs	r0, #14
 801e750:	f002 fd28 	bl	80211a4 <system_raise_alarm>
                                    return;
 801e754:	e04f      	b.n	801e7f6 <state_set+0x206>
                        st_wake_up();
 801e756:	f000 fb59 	bl	801ee0c <st_wake_up>
                        stateHandler = state_cycle;
 801e75a:	4b31      	ldr	r3, [pc, #196]	; (801e820 <state_set+0x230>)
 801e75c:	4a39      	ldr	r2, [pc, #228]	; (801e844 <state_set+0x254>)
 801e75e:	601a      	str	r2, [r3, #0]
 801e760:	e039      	b.n	801e7d6 <state_set+0x1e6>
                if (sys_state == STATE_TOOL_CHANGE)
 801e762:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
 801e766:	d005      	beq.n	801e774 <state_set+0x184>
                sys_state = new_state;
 801e768:	4b2c      	ldr	r3, [pc, #176]	; (801e81c <state_set+0x22c>)
 801e76a:	601c      	str	r4, [r3, #0]
                stateHandler = state_cycle;
 801e76c:	4b2c      	ldr	r3, [pc, #176]	; (801e820 <state_set+0x230>)
 801e76e:	4a35      	ldr	r2, [pc, #212]	; (801e844 <state_set+0x254>)
 801e770:	601a      	str	r2, [r3, #0]
                break;
 801e772:	e030      	b.n	801e7d6 <state_set+0x1e6>
                    pending_state = STATE_TOOL_CHANGE;
 801e774:	4b2e      	ldr	r3, [pc, #184]	; (801e830 <state_set+0x240>)
 801e776:	f44f 7200 	mov.w	r2, #512	; 0x200
 801e77a:	601a      	str	r2, [r3, #0]
 801e77c:	e7f4      	b.n	801e768 <state_set+0x178>
                if (sys.override.control.sync && sys.override.control.feed_hold_disable)
 801e77e:	4b2b      	ldr	r3, [pc, #172]	; (801e82c <state_set+0x23c>)
 801e780:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 801e784:	f003 0282 	and.w	r2, r3, #130	; 0x82
 801e788:	2a82      	cmp	r2, #130	; 0x82
 801e78a:	d018      	beq.n	801e7be <state_set+0x1ce>
                if (!((sys_state & STATE_JOG) || sys.override.control.feed_hold_disable)) {
 801e78c:	f015 0f20 	tst.w	r5, #32
 801e790:	d121      	bne.n	801e7d6 <state_set+0x1e6>
 801e792:	f013 0f02 	tst.w	r3, #2
 801e796:	d11e      	bne.n	801e7d6 <state_set+0x1e6>
                    if (!initiate_hold(new_state)) {
 801e798:	4620      	mov	r0, r4
 801e79a:	f7ff fd1b 	bl	801e1d4 <initiate_hold>
 801e79e:	b930      	cbnz	r0, 801e7ae <state_set+0x1be>
                        sys.holding_state = Hold_Complete;
 801e7a0:	4b22      	ldr	r3, [pc, #136]	; (801e82c <state_set+0x23c>)
 801e7a2:	2201      	movs	r2, #1
 801e7a4:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
                        stateHandler = state_await_resume;
 801e7a8:	4b1d      	ldr	r3, [pc, #116]	; (801e820 <state_set+0x230>)
 801e7aa:	4a27      	ldr	r2, [pc, #156]	; (801e848 <state_set+0x258>)
 801e7ac:	601a      	str	r2, [r3, #0]
                    sys_state = new_state;
 801e7ae:	4b1b      	ldr	r3, [pc, #108]	; (801e81c <state_set+0x22c>)
 801e7b0:	601c      	str	r4, [r3, #0]
                    sys.flags.feed_hold_pending = Off;
 801e7b2:	4b1e      	ldr	r3, [pc, #120]	; (801e82c <state_set+0x23c>)
 801e7b4:	7d9a      	ldrb	r2, [r3, #22]
 801e7b6:	f36f 1245 	bfc	r2, #5, #1
 801e7ba:	759a      	strb	r2, [r3, #22]
 801e7bc:	e00b      	b.n	801e7d6 <state_set+0x1e6>
                    sys.flags.feed_hold_pending = On;
 801e7be:	491b      	ldr	r1, [pc, #108]	; (801e82c <state_set+0x23c>)
 801e7c0:	7d8a      	ldrb	r2, [r1, #22]
 801e7c2:	f042 0220 	orr.w	r2, r2, #32
 801e7c6:	758a      	strb	r2, [r1, #22]
 801e7c8:	e7e0      	b.n	801e78c <state_set+0x19c>
                    sys_state = new_state;
 801e7ca:	4b14      	ldr	r3, [pc, #80]	; (801e81c <state_set+0x22c>)
 801e7cc:	601c      	str	r4, [r3, #0]
                if(sys_state == STATE_SLEEP && stateHandler != state_await_waypoint_retract)
 801e7ce:	4b13      	ldr	r3, [pc, #76]	; (801e81c <state_set+0x22c>)
 801e7d0:	681b      	ldr	r3, [r3, #0]
 801e7d2:	2b80      	cmp	r3, #128	; 0x80
 801e7d4:	d010      	beq.n	801e7f8 <state_set+0x208>
        if(!(sys_state & (STATE_ALARM|STATE_ESTOP)))
 801e7d6:	4b11      	ldr	r3, [pc, #68]	; (801e81c <state_set+0x22c>)
 801e7d8:	6818      	ldr	r0, [r3, #0]
 801e7da:	f240 1301 	movw	r3, #257	; 0x101
 801e7de:	4218      	tst	r0, r3
 801e7e0:	d103      	bne.n	801e7ea <state_set+0x1fa>
            sys.alarm = Alarm_None;
 801e7e2:	4b12      	ldr	r3, [pc, #72]	; (801e82c <state_set+0x23c>)
 801e7e4:	2200      	movs	r2, #0
 801e7e6:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c
        if(sys_state != org_state && grbl.on_state_change)
 801e7ea:	4285      	cmp	r5, r0
 801e7ec:	d003      	beq.n	801e7f6 <state_set+0x206>
 801e7ee:	4b0e      	ldr	r3, [pc, #56]	; (801e828 <state_set+0x238>)
 801e7f0:	69db      	ldr	r3, [r3, #28]
 801e7f2:	b103      	cbz	r3, 801e7f6 <state_set+0x206>
            grbl.on_state_change(sys_state);
 801e7f4:	4798      	blx	r3
}
 801e7f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                if(sys_state == STATE_SLEEP && stateHandler != state_await_waypoint_retract)
 801e7f8:	4b09      	ldr	r3, [pc, #36]	; (801e820 <state_set+0x230>)
 801e7fa:	681a      	ldr	r2, [r3, #0]
 801e7fc:	4b13      	ldr	r3, [pc, #76]	; (801e84c <state_set+0x25c>)
 801e7fe:	429a      	cmp	r2, r3
 801e800:	d0e9      	beq.n	801e7d6 <state_set+0x1e6>
                    enter_sleep();
 801e802:	f7ff feb5 	bl	801e570 <enter_sleep>
 801e806:	e7e6      	b.n	801e7d6 <state_set+0x1e6>
                sys_state = new_state;
 801e808:	4b04      	ldr	r3, [pc, #16]	; (801e81c <state_set+0x22c>)
 801e80a:	601c      	str	r4, [r3, #0]
                sys.suspend = false;
 801e80c:	4b07      	ldr	r3, [pc, #28]	; (801e82c <state_set+0x23c>)
 801e80e:	2200      	movs	r2, #0
 801e810:	709a      	strb	r2, [r3, #2]
                stateHandler = state_noop;
 801e812:	4b03      	ldr	r3, [pc, #12]	; (801e820 <state_set+0x230>)
 801e814:	4a0e      	ldr	r2, [pc, #56]	; (801e850 <state_set+0x260>)
 801e816:	601a      	str	r2, [r3, #0]
                break;
 801e818:	e7dd      	b.n	801e7d6 <state_set+0x1e6>
 801e81a:	bf00      	nop
 801e81c:	20003e74 	.word	0x20003e74
 801e820:	20000510 	.word	0x20000510
 801e824:	0801eb51 	.word	0x0801eb51
 801e828:	2000343c 	.word	0x2000343c
 801e82c:	200036c4 	.word	0x200036c4
 801e830:	20003e5c 	.word	0x20003e5c
 801e834:	20003e14 	.word	0x20003e14
 801e838:	0801e855 	.word	0x0801e855
 801e83c:	2000350c 	.word	0x2000350c
 801e840:	2000370c 	.word	0x2000370c
 801e844:	0801ebc5 	.word	0x0801ebc5
 801e848:	0801e8cd 	.word	0x0801e8cd
 801e84c:	0801df39 	.word	0x0801df39
 801e850:	0801def5 	.word	0x0801def5

0801e854 <state_idle>:
{
 801e854:	b510      	push	{r4, lr}
 801e856:	4604      	mov	r4, r0
    if ((rt_exec & EXEC_CYCLE_START))
 801e858:	f010 0f02 	tst.w	r0, #2
 801e85c:	d112      	bne.n	801e884 <state_idle+0x30>
    if (rt_exec & EXEC_FEED_HOLD)
 801e85e:	f014 0f08 	tst.w	r4, #8
 801e862:	d113      	bne.n	801e88c <state_idle+0x38>
    if ((rt_exec & EXEC_TOOL_CHANGE)) {
 801e864:	f414 7f00 	tst.w	r4, #512	; 0x200
 801e868:	d008      	beq.n	801e87c <state_idle+0x28>
        hal.stream.suspend_read(true); // Block reading from input stream until tool change state is acknowledged
 801e86a:	4b0c      	ldr	r3, [pc, #48]	; (801e89c <state_idle+0x48>)
 801e86c:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 801e870:	2001      	movs	r0, #1
 801e872:	4798      	blx	r3
        state_set(STATE_TOOL_CHANGE);
 801e874:	f44f 7000 	mov.w	r0, #512	; 0x200
 801e878:	f7ff feba 	bl	801e5f0 <state_set>
    if (rt_exec & EXEC_SLEEP)
 801e87c:	f414 7f80 	tst.w	r4, #256	; 0x100
 801e880:	d108      	bne.n	801e894 <state_idle+0x40>
}
 801e882:	bd10      	pop	{r4, pc}
        state_set(STATE_CYCLE);
 801e884:	2008      	movs	r0, #8
 801e886:	f7ff feb3 	bl	801e5f0 <state_set>
 801e88a:	e7e8      	b.n	801e85e <state_idle+0xa>
        state_set(STATE_HOLD);
 801e88c:	2010      	movs	r0, #16
 801e88e:	f7ff feaf 	bl	801e5f0 <state_set>
 801e892:	e7e7      	b.n	801e864 <state_idle+0x10>
        state_set(STATE_SLEEP);
 801e894:	2080      	movs	r0, #128	; 0x80
 801e896:	f7ff feab 	bl	801e5f0 <state_set>
}
 801e89a:	e7f2      	b.n	801e882 <state_idle+0x2e>
 801e89c:	2000350c 	.word	0x2000350c

0801e8a0 <state_update>:
{
 801e8a0:	b510      	push	{r4, lr}
 801e8a2:	4604      	mov	r4, r0
    if((rt_exec & EXEC_SAFETY_DOOR) && sys_state != STATE_SAFETY_DOOR)
 801e8a4:	f010 0f40 	tst.w	r0, #64	; 0x40
 801e8a8:	d003      	beq.n	801e8b2 <state_update+0x12>
 801e8aa:	4b06      	ldr	r3, [pc, #24]	; (801e8c4 <state_update+0x24>)
 801e8ac:	681b      	ldr	r3, [r3, #0]
 801e8ae:	2b40      	cmp	r3, #64	; 0x40
 801e8b0:	d104      	bne.n	801e8bc <state_update+0x1c>
    stateHandler(rt_exec);
 801e8b2:	4b05      	ldr	r3, [pc, #20]	; (801e8c8 <state_update+0x28>)
 801e8b4:	681b      	ldr	r3, [r3, #0]
 801e8b6:	4620      	mov	r0, r4
 801e8b8:	4798      	blx	r3
}
 801e8ba:	bd10      	pop	{r4, pc}
        state_set(STATE_SAFETY_DOOR);
 801e8bc:	2040      	movs	r0, #64	; 0x40
 801e8be:	f7ff fe97 	bl	801e5f0 <state_set>
 801e8c2:	e7f6      	b.n	801e8b2 <state_update+0x12>
 801e8c4:	20003e74 	.word	0x20003e74
 801e8c8:	20000510 	.word	0x20000510

0801e8cc <state_await_resume>:
{
 801e8cc:	b530      	push	{r4, r5, lr}
 801e8ce:	b085      	sub	sp, #20
 801e8d0:	4604      	mov	r4, r0
    if ((rt_exec & EXEC_CYCLE_COMPLETE) && settings.parking.flags.enabled) {
 801e8d2:	f010 0f04 	tst.w	r0, #4
 801e8d6:	d016      	beq.n	801e906 <state_await_resume+0x3a>
 801e8d8:	4b82      	ldr	r3, [pc, #520]	; (801eae4 <state_await_resume+0x218>)
 801e8da:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 801e8de:	f013 0f01 	tst.w	r3, #1
 801e8e2:	d010      	beq.n	801e906 <state_await_resume+0x3a>
        if (sys.step_control.execute_sys_motion) {
 801e8e4:	4b80      	ldr	r3, [pc, #512]	; (801eae8 <state_await_resume+0x21c>)
 801e8e6:	7e1b      	ldrb	r3, [r3, #24]
 801e8e8:	f013 0f04 	tst.w	r3, #4
 801e8ec:	d11b      	bne.n	801e926 <state_await_resume+0x5a>
        sys.parking_state = hal.control.get_state().safety_door_ajar ? Parking_DoorAjar : Parking_DoorClosed;
 801e8ee:	4b7f      	ldr	r3, [pc, #508]	; (801eaec <state_await_resume+0x220>)
 801e8f0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801e8f2:	4798      	blx	r3
 801e8f4:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 801e8f8:	4b7b      	ldr	r3, [pc, #492]	; (801eae8 <state_await_resume+0x21c>)
 801e8fa:	f883 0034 	strb.w	r0, [r3, #52]	; 0x34
        if(sys_state == STATE_SLEEP) {
 801e8fe:	4b7c      	ldr	r3, [pc, #496]	; (801eaf0 <state_await_resume+0x224>)
 801e900:	681b      	ldr	r3, [r3, #0]
 801e902:	2b80      	cmp	r3, #128	; 0x80
 801e904:	d017      	beq.n	801e936 <state_await_resume+0x6a>
    if (rt_exec & EXEC_SLEEP)
 801e906:	f414 7f80 	tst.w	r4, #256	; 0x100
 801e90a:	d117      	bne.n	801e93c <state_await_resume+0x70>
    if (rt_exec & EXEC_SAFETY_DOOR)
 801e90c:	f014 0f40 	tst.w	r4, #64	; 0x40
 801e910:	d018      	beq.n	801e944 <state_await_resume+0x78>
        sys.parking_state = hal.control.get_state().safety_door_ajar ? Parking_DoorAjar : Parking_DoorClosed;
 801e912:	4b76      	ldr	r3, [pc, #472]	; (801eaec <state_await_resume+0x220>)
 801e914:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801e916:	4798      	blx	r3
 801e918:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 801e91c:	4b72      	ldr	r3, [pc, #456]	; (801eae8 <state_await_resume+0x21c>)
 801e91e:	f883 0034 	strb.w	r0, [r3, #52]	; 0x34
}
 801e922:	b005      	add	sp, #20
 801e924:	bd30      	pop	{r4, r5, pc}
            sys.step_control.execute_sys_motion = Off;
 801e926:	4b70      	ldr	r3, [pc, #448]	; (801eae8 <state_await_resume+0x21c>)
 801e928:	7e1a      	ldrb	r2, [r3, #24]
 801e92a:	f36f 0282 	bfc	r2, #2, #1
 801e92e:	761a      	strb	r2, [r3, #24]
            st_parking_restore_buffer(); // Restore step segment buffer to normal run state.
 801e930:	f000 fd08 	bl	801f344 <st_parking_restore_buffer>
 801e934:	e7db      	b.n	801e8ee <state_await_resume+0x22>
            enter_sleep();
 801e936:	f7ff fe1b 	bl	801e570 <enter_sleep>
            return;
 801e93a:	e7f2      	b.n	801e922 <state_await_resume+0x56>
        state_set(STATE_SLEEP);
 801e93c:	2080      	movs	r0, #128	; 0x80
 801e93e:	f7ff fe57 	bl	801e5f0 <state_set>
 801e942:	e7e3      	b.n	801e90c <state_await_resume+0x40>
    else if (rt_exec & EXEC_CYCLE_START) {
 801e944:	f014 0f02 	tst.w	r4, #2
 801e948:	f000 80bb 	beq.w	801eac2 <state_await_resume+0x1f6>
        if (sys_state == STATE_HOLD && !sys.override.spindle_stop.value)
 801e94c:	4b68      	ldr	r3, [pc, #416]	; (801eaf0 <state_await_resume+0x224>)
 801e94e:	681b      	ldr	r3, [r3, #0]
 801e950:	2b10      	cmp	r3, #16
 801e952:	d01b      	beq.n	801e98c <state_await_resume+0xc0>
        switch (sys_state) {
 801e954:	2b80      	cmp	r3, #128	; 0x80
 801e956:	d053      	beq.n	801ea00 <state_await_resume+0x134>
 801e958:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 801e95c:	d050      	beq.n	801ea00 <state_await_resume+0x134>
 801e95e:	2b40      	cmp	r3, #64	; 0x40
 801e960:	d01f      	beq.n	801e9a2 <state_await_resume+0xd6>
                if (!settings.flags.restore_after_feed_hold) {
 801e962:	4b60      	ldr	r3, [pc, #384]	; (801eae4 <state_await_resume+0x218>)
 801e964:	f993 30fe 	ldrsb.w	r3, [r3, #254]	; 0xfe
 801e968:	2b00      	cmp	r3, #0
 801e96a:	db74      	blt.n	801ea56 <state_await_resume+0x18a>
                    if (!restore_condition.spindle[restore_condition.spindle_num].hal->get_state().on)
 801e96c:	4b61      	ldr	r3, [pc, #388]	; (801eaf4 <state_await_resume+0x228>)
 801e96e:	f993 2001 	ldrsb.w	r2, [r3, #1]
 801e972:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801e976:	691b      	ldr	r3, [r3, #16]
 801e978:	6a1b      	ldr	r3, [r3, #32]
 801e97a:	4798      	blx	r3
 801e97c:	f010 0f01 	tst.w	r0, #1
 801e980:	d066      	beq.n	801ea50 <state_await_resume+0x184>
                    sys.override.spindle_stop.value = 0; // Clear spindle stop override states
 801e982:	4b59      	ldr	r3, [pc, #356]	; (801eae8 <state_await_resume+0x21c>)
 801e984:	2200      	movs	r2, #0
 801e986:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
 801e98a:	e039      	b.n	801ea00 <state_await_resume+0x134>
        if (sys_state == STATE_HOLD && !sys.override.spindle_stop.value)
 801e98c:	4a56      	ldr	r2, [pc, #344]	; (801eae8 <state_await_resume+0x21c>)
 801e98e:	f892 2028 	ldrb.w	r2, [r2, #40]	; 0x28
 801e992:	2a00      	cmp	r2, #0
 801e994:	d1de      	bne.n	801e954 <state_await_resume+0x88>
            sys.override.spindle_stop.restore_cycle = On;
 801e996:	4954      	ldr	r1, [pc, #336]	; (801eae8 <state_await_resume+0x21c>)
 801e998:	f042 0208 	orr.w	r2, r2, #8
 801e99c:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28
 801e9a0:	e7d8      	b.n	801e954 <state_await_resume+0x88>
                if (park.flags.restart || !hal.control.get_state().safety_door_ajar) {
 801e9a2:	4b55      	ldr	r3, [pc, #340]	; (801eaf8 <state_await_resume+0x22c>)
 801e9a4:	7f1b      	ldrb	r3, [r3, #28]
 801e9a6:	f013 0f04 	tst.w	r3, #4
 801e9aa:	d105      	bne.n	801e9b8 <state_await_resume+0xec>
 801e9ac:	4b4f      	ldr	r3, [pc, #316]	; (801eaec <state_await_resume+0x220>)
 801e9ae:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801e9b0:	4798      	blx	r3
 801e9b2:	f010 0f08 	tst.w	r0, #8
 801e9b6:	d123      	bne.n	801ea00 <state_await_resume+0x134>
                    stateHandler = state_restore;
 801e9b8:	4b50      	ldr	r3, [pc, #320]	; (801eafc <state_await_resume+0x230>)
 801e9ba:	4a51      	ldr	r2, [pc, #324]	; (801eb00 <state_await_resume+0x234>)
 801e9bc:	601a      	str	r2, [r3, #0]
                    sys.parking_state = Parking_Resuming;
 801e9be:	4b4a      	ldr	r3, [pc, #296]	; (801eae8 <state_await_resume+0x21c>)
 801e9c0:	2204      	movs	r2, #4
 801e9c2:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
                    if (park.flags.motion) {
 801e9c6:	4b4c      	ldr	r3, [pc, #304]	; (801eaf8 <state_await_resume+0x22c>)
 801e9c8:	7f1b      	ldrb	r3, [r3, #28]
 801e9ca:	f013 0f02 	tst.w	r3, #2
 801e9ce:	d013      	beq.n	801e9f8 <state_await_resume+0x12c>
                        park.flags.restart = Off;
 801e9d0:	4b49      	ldr	r3, [pc, #292]	; (801eaf8 <state_await_resume+0x22c>)
 801e9d2:	7f1a      	ldrb	r2, [r3, #28]
 801e9d4:	f36f 0282 	bfc	r2, #2, #1
 801e9d8:	771a      	strb	r2, [r3, #28]
                        if (park.restore_target[settings.parking.axis] <= settings.parking.target) {
 801e9da:	4a42      	ldr	r2, [pc, #264]	; (801eae4 <state_await_resume+0x218>)
 801e9dc:	f892 4129 	ldrb.w	r4, [r2, #297]	; 0x129
 801e9e0:	1ca1      	adds	r1, r4, #2
 801e9e2:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 801e9e6:	ed93 7a01 	vldr	s14, [r3, #4]
 801e9ea:	edd2 7a4b 	vldr	s15, [r2, #300]	; 0x12c
 801e9ee:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801e9f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e9f6:	d912      	bls.n	801ea1e <state_await_resume+0x152>
                        stateHandler(EXEC_CYCLE_COMPLETE);
 801e9f8:	4b40      	ldr	r3, [pc, #256]	; (801eafc <state_await_resume+0x230>)
 801e9fa:	681b      	ldr	r3, [r3, #0]
 801e9fc:	2004      	movs	r0, #4
 801e9fe:	4798      	blx	r3
        if (!(sys_state & (STATE_SLEEP|STATE_SAFETY_DOOR))) {
 801ea00:	4b3b      	ldr	r3, [pc, #236]	; (801eaf0 <state_await_resume+0x224>)
 801ea02:	681b      	ldr	r3, [r3, #0]
 801ea04:	f013 0fc0 	tst.w	r3, #192	; 0xc0
 801ea08:	d18b      	bne.n	801e922 <state_await_resume+0x56>
            step_control_t step_control = sys.step_control;
 801ea0a:	4c37      	ldr	r4, [pc, #220]	; (801eae8 <state_await_resume+0x21c>)
 801ea0c:	7e25      	ldrb	r5, [r4, #24]
            state_set(STATE_IDLE);
 801ea0e:	2000      	movs	r0, #0
 801ea10:	f7ff fdee 	bl	801e5f0 <state_set>
            sys.step_control = step_control;
 801ea14:	7625      	strb	r5, [r4, #24]
            state_set(STATE_CYCLE);
 801ea16:	2008      	movs	r0, #8
 801ea18:	f7ff fdea 	bl	801e5f0 <state_set>
 801ea1c:	e781      	b.n	801e922 <state_await_resume+0x56>
                            memcpy(target, park.restore_target, sizeof(target));
 801ea1e:	4b36      	ldr	r3, [pc, #216]	; (801eaf8 <state_await_resume+0x22c>)
 801ea20:	ad01      	add	r5, sp, #4
 801ea22:	f103 020c 	add.w	r2, r3, #12
 801ea26:	ca07      	ldmia	r2, {r0, r1, r2}
 801ea28:	e885 0007 	stmia.w	r5, {r0, r1, r2}
                            target[settings.parking.axis] = park.retract_waypoint;
 801ea2c:	699a      	ldr	r2, [r3, #24]
 801ea2e:	a904      	add	r1, sp, #16
 801ea30:	eb01 0484 	add.w	r4, r1, r4, lsl #2
 801ea34:	f844 2c0c 	str.w	r2, [r4, #-12]
                            park.plan_data.feed_rate = settings.parking.rate;
 801ea38:	4a2a      	ldr	r2, [pc, #168]	; (801eae4 <state_await_resume+0x218>)
 801ea3a:	f8d2 2130 	ldr.w	r2, [r2, #304]	; 0x130
 801ea3e:	4619      	mov	r1, r3
 801ea40:	f841 2f20 	str.w	r2, [r1, #32]!
                            await_motion = mc_parking_motion(target, &park.plan_data);
 801ea44:	4628      	mov	r0, r5
 801ea46:	f7f6 f93b 	bl	8014cc0 <mc_parking_motion>
                    if (!await_motion) // No motion, proceed to next step immediately.
 801ea4a:	2800      	cmp	r0, #0
 801ea4c:	d1d8      	bne.n	801ea00 <state_await_resume+0x134>
 801ea4e:	e7d3      	b.n	801e9f8 <state_await_resume+0x12c>
                        gc_spindle_off();
 801ea50:	f7f0 fc00 	bl	800f254 <gc_spindle_off>
 801ea54:	e795      	b.n	801e982 <state_await_resume+0xb6>
                    if (restore_condition.spindle[restore_condition.spindle_num].state.on != restore_condition.spindle[restore_condition.spindle_num].hal->get_state().on) {
 801ea56:	4b27      	ldr	r3, [pc, #156]	; (801eaf4 <state_await_resume+0x228>)
 801ea58:	f993 2001 	ldrsb.w	r2, [r3, #1]
 801ea5c:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801ea60:	7a1c      	ldrb	r4, [r3, #8]
 801ea62:	f004 0401 	and.w	r4, r4, #1
 801ea66:	691b      	ldr	r3, [r3, #16]
 801ea68:	6a1b      	ldr	r3, [r3, #32]
 801ea6a:	4798      	blx	r3
 801ea6c:	f000 0001 	and.w	r0, r0, #1
 801ea70:	4284      	cmp	r4, r0
 801ea72:	d00b      	beq.n	801ea8c <state_await_resume+0x1c0>
                        grbl.report.feedback_message(Message_SpindleRestore);
 801ea74:	4b23      	ldr	r3, [pc, #140]	; (801eb04 <state_await_resume+0x238>)
 801ea76:	68db      	ldr	r3, [r3, #12]
 801ea78:	200a      	movs	r0, #10
 801ea7a:	4798      	blx	r3
                        state_spindle_restore(&restore_condition.spindle[restore_condition.spindle_num]);
 801ea7c:	481d      	ldr	r0, [pc, #116]	; (801eaf4 <state_await_resume+0x228>)
 801ea7e:	f990 3001 	ldrsb.w	r3, [r0, #1]
 801ea82:	eb00 1003 	add.w	r0, r0, r3, lsl #4
 801ea86:	3004      	adds	r0, #4
 801ea88:	f7ff faf6 	bl	801e078 <state_spindle_restore>
                    if (restore_condition.coolant.value != hal.coolant.get_state().value) {
 801ea8c:	4b19      	ldr	r3, [pc, #100]	; (801eaf4 <state_await_resume+0x228>)
 801ea8e:	781c      	ldrb	r4, [r3, #0]
 801ea90:	4b16      	ldr	r3, [pc, #88]	; (801eaec <state_await_resume+0x220>)
 801ea92:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801ea94:	4798      	blx	r3
 801ea96:	b2c0      	uxtb	r0, r0
 801ea98:	4284      	cmp	r4, r0
 801ea9a:	d107      	bne.n	801eaac <state_await_resume+0x1e0>
                    sys.override.spindle_stop.value = 0; // Clear spindle stop override states
 801ea9c:	2000      	movs	r0, #0
 801ea9e:	4b12      	ldr	r3, [pc, #72]	; (801eae8 <state_await_resume+0x21c>)
 801eaa0:	f883 0028 	strb.w	r0, [r3, #40]	; 0x28
                    grbl.report.feedback_message(Message_None);
 801eaa4:	4b17      	ldr	r3, [pc, #92]	; (801eb04 <state_await_resume+0x238>)
 801eaa6:	68db      	ldr	r3, [r3, #12]
 801eaa8:	4798      	blx	r3
 801eaaa:	e7a9      	b.n	801ea00 <state_await_resume+0x134>
                        coolant_set_state(restore_condition.coolant);
 801eaac:	4b11      	ldr	r3, [pc, #68]	; (801eaf4 <state_await_resume+0x228>)
 801eaae:	7818      	ldrb	r0, [r3, #0]
 801eab0:	f7f0 f994 	bl	800eddc <coolant_set_state>
                        delay_sec(settings.safety_door.coolant_on_delay, DelayMode_SysSuspend);
 801eab4:	2001      	movs	r0, #1
 801eab6:	4b0b      	ldr	r3, [pc, #44]	; (801eae4 <state_await_resume+0x218>)
 801eab8:	ed93 0a51 	vldr	s0, [r3, #324]	; 0x144
 801eabc:	f7f6 ffd2 	bl	8015a64 <delay_sec>
 801eac0:	e7ec      	b.n	801ea9c <state_await_resume+0x1d0>
    } else if ((rt_exec & EXEC_DOOR_CLOSED) && !hal.control.get_state().safety_door_ajar)
 801eac2:	f414 4f80 	tst.w	r4, #16384	; 0x4000
 801eac6:	f43f af2c 	beq.w	801e922 <state_await_resume+0x56>
 801eaca:	4b08      	ldr	r3, [pc, #32]	; (801eaec <state_await_resume+0x220>)
 801eacc:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801eace:	4798      	blx	r3
 801ead0:	f010 0f08 	tst.w	r0, #8
 801ead4:	f47f af25 	bne.w	801e922 <state_await_resume+0x56>
        sys.parking_state = Parking_DoorClosed;
 801ead8:	4b03      	ldr	r3, [pc, #12]	; (801eae8 <state_await_resume+0x21c>)
 801eada:	2200      	movs	r2, #0
 801eadc:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
 801eae0:	e71f      	b.n	801e922 <state_await_resume+0x56>
 801eae2:	bf00      	nop
 801eae4:	20003b14 	.word	0x20003b14
 801eae8:	200036c4 	.word	0x200036c4
 801eaec:	2000350c 	.word	0x2000350c
 801eaf0:	20003e74 	.word	0x20003e74
 801eaf4:	20003e60 	.word	0x20003e60
 801eaf8:	20003e14 	.word	0x20003e14
 801eafc:	20000510 	.word	0x20000510
 801eb00:	0801e105 	.word	0x0801e105
 801eb04:	2000343c 	.word	0x2000343c

0801eb08 <state_await_resumed>:

/*! /brief Waits until slow plunge motion is complete then restart the cycle.
Note: A safety door event during the motion will halt it and restart the retract sequence.
 */
static void state_await_resumed (uint_fast16_t rt_exec)
{
 801eb08:	b508      	push	{r3, lr}
    if (rt_exec & EXEC_SAFETY_DOOR)
 801eb0a:	f010 0f40 	tst.w	r0, #64	; 0x40
 801eb0e:	d113      	bne.n	801eb38 <state_await_resumed+0x30>
        restart_retract();

    else if (rt_exec & EXEC_CYCLE_COMPLETE) {
 801eb10:	f010 0f04 	tst.w	r0, #4
 801eb14:	d00f      	beq.n	801eb36 <state_await_resumed+0x2e>
        sys.parking_state = Parking_DoorClosed;
 801eb16:	4b0c      	ldr	r3, [pc, #48]	; (801eb48 <state_await_resumed+0x40>)
 801eb18:	2200      	movs	r2, #0
 801eb1a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        park.flags.value = 0;
 801eb1e:	490b      	ldr	r1, [pc, #44]	; (801eb4c <state_await_resumed+0x44>)
 801eb20:	770a      	strb	r2, [r1, #28]
        if (sys.step_control.execute_sys_motion) {
 801eb22:	7e1b      	ldrb	r3, [r3, #24]
 801eb24:	f013 0f04 	tst.w	r3, #4
 801eb28:	d109      	bne.n	801eb3e <state_await_resumed+0x36>
            sys.step_control.flags = 0;
            st_parking_restore_buffer(); // Restore step segment buffer to normal run state.
        }
        state_set(STATE_IDLE);
 801eb2a:	2000      	movs	r0, #0
 801eb2c:	f7ff fd60 	bl	801e5f0 <state_set>
        state_set(STATE_CYCLE);
 801eb30:	2008      	movs	r0, #8
 801eb32:	f7ff fd5d 	bl	801e5f0 <state_set>
    }
}
 801eb36:	bd08      	pop	{r3, pc}
        restart_retract();
 801eb38:	f7ff fa6e 	bl	801e018 <restart_retract>
 801eb3c:	e7fb      	b.n	801eb36 <state_await_resumed+0x2e>
            sys.step_control.flags = 0;
 801eb3e:	4b02      	ldr	r3, [pc, #8]	; (801eb48 <state_await_resumed+0x40>)
 801eb40:	761a      	strb	r2, [r3, #24]
            st_parking_restore_buffer(); // Restore step segment buffer to normal run state.
 801eb42:	f000 fbff 	bl	801f344 <st_parking_restore_buffer>
 801eb46:	e7f0      	b.n	801eb2a <state_await_resumed+0x22>
 801eb48:	200036c4 	.word	0x200036c4
 801eb4c:	20003e14 	.word	0x20003e14

0801eb50 <state_await_toolchanged>:
    if (rt_exec & EXEC_CYCLE_START) {
 801eb50:	f010 0f02 	tst.w	r0, #2
 801eb54:	d02b      	beq.n	801ebae <state_await_toolchanged+0x5e>
{
 801eb56:	b508      	push	{r3, lr}
        if (!gc_state.tool_change) {
 801eb58:	4b15      	ldr	r3, [pc, #84]	; (801ebb0 <state_await_toolchanged+0x60>)
 801eb5a:	f893 3077 	ldrb.w	r3, [r3, #119]	; 0x77
 801eb5e:	b983      	cbnz	r3, 801eb82 <state_await_toolchanged+0x32>
            if (hal.stream.suspend_read)
 801eb60:	4b14      	ldr	r3, [pc, #80]	; (801ebb4 <state_await_toolchanged+0x64>)
 801eb62:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 801eb66:	b10b      	cbz	r3, 801eb6c <state_await_toolchanged+0x1c>
                hal.stream.suspend_read(false); // Tool change complete, restore "normal" stream input.
 801eb68:	2000      	movs	r0, #0
 801eb6a:	4798      	blx	r3
            if(grbl.on_tool_changed)
 801eb6c:	4b12      	ldr	r3, [pc, #72]	; (801ebb8 <state_await_toolchanged+0x68>)
 801eb6e:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 801eb72:	b11b      	cbz	r3, 801eb7c <state_await_toolchanged+0x2c>
                grbl.on_tool_changed(gc_state.tool);
 801eb74:	4a0e      	ldr	r2, [pc, #56]	; (801ebb0 <state_await_toolchanged+0x60>)
 801eb76:	f8d2 0094 	ldr.w	r0, [r2, #148]	; 0x94
 801eb7a:	4798      	blx	r3
            system_add_rt_report(Report_Tool);
 801eb7c:	2080      	movs	r0, #128	; 0x80
 801eb7e:	f002 fb5f 	bl	8021240 <system_add_rt_report>
        pending_state = gc_state.tool_change ? STATE_TOOL_CHANGE : STATE_IDLE;
 801eb82:	4b0b      	ldr	r3, [pc, #44]	; (801ebb0 <state_await_toolchanged+0x60>)
 801eb84:	f893 3077 	ldrb.w	r3, [r3, #119]	; 0x77
 801eb88:	b17b      	cbz	r3, 801ebaa <state_await_toolchanged+0x5a>
 801eb8a:	f44f 7200 	mov.w	r2, #512	; 0x200
 801eb8e:	4b0b      	ldr	r3, [pc, #44]	; (801ebbc <state_await_toolchanged+0x6c>)
 801eb90:	601a      	str	r2, [r3, #0]
        state_set(STATE_IDLE);
 801eb92:	2000      	movs	r0, #0
 801eb94:	f7ff fd2c 	bl	801e5f0 <state_set>
        state_set(STATE_CYCLE);
 801eb98:	2008      	movs	r0, #8
 801eb9a:	f7ff fd29 	bl	801e5f0 <state_set>
        system_set_exec_state_flag(EXEC_STATUS_REPORT);
 801eb9e:	4b05      	ldr	r3, [pc, #20]	; (801ebb4 <state_await_toolchanged+0x64>)
 801eba0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801eba2:	2101      	movs	r1, #1
 801eba4:	4806      	ldr	r0, [pc, #24]	; (801ebc0 <state_await_toolchanged+0x70>)
 801eba6:	4798      	blx	r3
}
 801eba8:	bd08      	pop	{r3, pc}
        pending_state = gc_state.tool_change ? STATE_TOOL_CHANGE : STATE_IDLE;
 801ebaa:	2200      	movs	r2, #0
 801ebac:	e7ef      	b.n	801eb8e <state_await_toolchanged+0x3e>
 801ebae:	4770      	bx	lr
 801ebb0:	20003344 	.word	0x20003344
 801ebb4:	2000350c 	.word	0x2000350c
 801ebb8:	2000343c 	.word	0x2000343c
 801ebbc:	20003e5c 	.word	0x20003e5c
 801ebc0:	2000370c 	.word	0x2000370c

0801ebc4 <state_cycle>:
    if (rt_exec == EXEC_CYCLE_START)
 801ebc4:	2802      	cmp	r0, #2
 801ebc6:	d02e      	beq.n	801ec26 <state_cycle+0x62>
{
 801ebc8:	b510      	push	{r4, lr}
 801ebca:	4604      	mov	r4, r0
    if ((rt_exec & EXEC_TOOL_CHANGE))
 801ebcc:	f410 7f00 	tst.w	r0, #512	; 0x200
 801ebd0:	d004      	beq.n	801ebdc <state_cycle+0x18>
        hal.stream.suspend_read(true); // Block reading from input stream until tool change state is acknowledged
 801ebd2:	4b15      	ldr	r3, [pc, #84]	; (801ec28 <state_cycle+0x64>)
 801ebd4:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 801ebd8:	2001      	movs	r0, #1
 801ebda:	4798      	blx	r3
    if (rt_exec & EXEC_CYCLE_COMPLETE)
 801ebdc:	f014 0f04 	tst.w	r4, #4
 801ebe0:	d007      	beq.n	801ebf2 <state_cycle+0x2e>
        state_set(gc_state.tool_change ? STATE_TOOL_CHANGE : STATE_IDLE);
 801ebe2:	4b12      	ldr	r3, [pc, #72]	; (801ec2c <state_cycle+0x68>)
 801ebe4:	f893 3077 	ldrb.w	r3, [r3, #119]	; 0x77
 801ebe8:	b153      	cbz	r3, 801ec00 <state_cycle+0x3c>
 801ebea:	f44f 7000 	mov.w	r0, #512	; 0x200
 801ebee:	f7ff fcff 	bl	801e5f0 <state_set>
    if (rt_exec & EXEC_MOTION_CANCEL) {
 801ebf2:	f014 0f80 	tst.w	r4, #128	; 0x80
 801ebf6:	d105      	bne.n	801ec04 <state_cycle+0x40>
    if ((rt_exec & EXEC_FEED_HOLD))
 801ebf8:	f014 0f08 	tst.w	r4, #8
 801ebfc:	d10f      	bne.n	801ec1e <state_cycle+0x5a>
}
 801ebfe:	bd10      	pop	{r4, pc}
        state_set(gc_state.tool_change ? STATE_TOOL_CHANGE : STATE_IDLE);
 801ec00:	2000      	movs	r0, #0
 801ec02:	e7f4      	b.n	801ebee <state_cycle+0x2a>
        st_update_plan_block_parameters();  // Notify stepper module to recompute for hold deceleration.
 801ec04:	f000 fb48 	bl	801f298 <st_update_plan_block_parameters>
        sys.suspend = true;
 801ec08:	4b09      	ldr	r3, [pc, #36]	; (801ec30 <state_cycle+0x6c>)
 801ec0a:	2201      	movs	r2, #1
 801ec0c:	709a      	strb	r2, [r3, #2]
        sys.step_control.execute_hold = On; // Initiate suspend state with active flag.
 801ec0e:	7e1a      	ldrb	r2, [r3, #24]
 801ec10:	f042 0202 	orr.w	r2, r2, #2
 801ec14:	761a      	strb	r2, [r3, #24]
        stateHandler = state_await_motion_cancel;
 801ec16:	4b07      	ldr	r3, [pc, #28]	; (801ec34 <state_cycle+0x70>)
 801ec18:	4a07      	ldr	r2, [pc, #28]	; (801ec38 <state_cycle+0x74>)
 801ec1a:	601a      	str	r2, [r3, #0]
 801ec1c:	e7ec      	b.n	801ebf8 <state_cycle+0x34>
        state_set(STATE_HOLD);
 801ec1e:	2010      	movs	r0, #16
 801ec20:	f7ff fce6 	bl	801e5f0 <state_set>
 801ec24:	e7eb      	b.n	801ebfe <state_cycle+0x3a>
 801ec26:	4770      	bx	lr
 801ec28:	2000350c 	.word	0x2000350c
 801ec2c:	20003344 	.word	0x20003344
 801ec30:	200036c4 	.word	0x200036c4
 801ec34:	20000510 	.word	0x20000510
 801ec38:	0801ec3d 	.word	0x0801ec3d

0801ec3c <state_await_motion_cancel>:
    if (rt_exec & EXEC_CYCLE_COMPLETE) {
 801ec3c:	f010 0f04 	tst.w	r0, #4
 801ec40:	d022      	beq.n	801ec88 <state_await_motion_cancel+0x4c>
{
 801ec42:	b538      	push	{r3, r4, r5, lr}
        if (sys_state == STATE_JOG) {
 801ec44:	4b11      	ldr	r3, [pc, #68]	; (801ec8c <state_await_motion_cancel+0x50>)
 801ec46:	681b      	ldr	r3, [r3, #0]
 801ec48:	2b20      	cmp	r3, #32
 801ec4a:	d008      	beq.n	801ec5e <state_await_motion_cancel+0x22>
        state_set(pending_state);
 801ec4c:	4b10      	ldr	r3, [pc, #64]	; (801ec90 <state_await_motion_cancel+0x54>)
 801ec4e:	6818      	ldr	r0, [r3, #0]
 801ec50:	f7ff fcce 	bl	801e5f0 <state_set>
        if (gc_state.tool_change)
 801ec54:	4b0f      	ldr	r3, [pc, #60]	; (801ec94 <state_await_motion_cancel+0x58>)
 801ec56:	f893 3077 	ldrb.w	r3, [r3, #119]	; 0x77
 801ec5a:	b983      	cbnz	r3, 801ec7e <state_await_motion_cancel+0x42>
}
 801ec5c:	bd38      	pop	{r3, r4, r5, pc}
            sys.step_control.flags = 0;
 801ec5e:	4c0e      	ldr	r4, [pc, #56]	; (801ec98 <state_await_motion_cancel+0x5c>)
 801ec60:	2500      	movs	r5, #0
 801ec62:	7625      	strb	r5, [r4, #24]
            plan_reset();
 801ec64:	f7f7 fc42 	bl	80164ec <plan_reset>
            st_reset();
 801ec68:	f000 fa7e 	bl	801f168 <st_reset>
            sync_position();
 801ec6c:	f7f8 f808 	bl	8016c80 <plan_sync_position>
 801ec70:	f104 0188 	add.w	r1, r4, #136	; 0x88
 801ec74:	4809      	ldr	r0, [pc, #36]	; (801ec9c <state_await_motion_cancel+0x60>)
 801ec76:	f002 f9b1 	bl	8020fdc <system_convert_array_steps_to_mpos>
            sys.suspend = false;
 801ec7a:	70a5      	strb	r5, [r4, #2]
 801ec7c:	e7e6      	b.n	801ec4c <state_await_motion_cancel+0x10>
            state_set(STATE_TOOL_CHANGE);
 801ec7e:	f44f 7000 	mov.w	r0, #512	; 0x200
 801ec82:	f7ff fcb5 	bl	801e5f0 <state_set>
}
 801ec86:	e7e9      	b.n	801ec5c <state_await_motion_cancel+0x20>
 801ec88:	4770      	bx	lr
 801ec8a:	bf00      	nop
 801ec8c:	20003e74 	.word	0x20003e74
 801ec90:	20003e5c 	.word	0x20003e5c
 801ec94:	20003344 	.word	0x20003344
 801ec98:	200036c4 	.word	0x200036c4
 801ec9c:	200033a4 	.word	0x200033a4

0801eca0 <state_suspend_manager>:
    if (stateHandler != state_await_resume || !gc_state.modal.spindle.state.on)
 801eca0:	4b39      	ldr	r3, [pc, #228]	; (801ed88 <state_suspend_manager+0xe8>)
 801eca2:	681a      	ldr	r2, [r3, #0]
 801eca4:	4b39      	ldr	r3, [pc, #228]	; (801ed8c <state_suspend_manager+0xec>)
 801eca6:	429a      	cmp	r2, r3
 801eca8:	d000      	beq.n	801ecac <state_suspend_manager+0xc>
 801ecaa:	4770      	bx	lr
 801ecac:	4b38      	ldr	r3, [pc, #224]	; (801ed90 <state_suspend_manager+0xf0>)
 801ecae:	7e9b      	ldrb	r3, [r3, #26]
 801ecb0:	f013 0f01 	tst.w	r3, #1
 801ecb4:	d0f9      	beq.n	801ecaa <state_suspend_manager+0xa>
{
 801ecb6:	b510      	push	{r4, lr}
    if (sys.override.spindle_stop.value) {
 801ecb8:	4b36      	ldr	r3, [pc, #216]	; (801ed94 <state_suspend_manager+0xf4>)
 801ecba:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 801ecbe:	2b00      	cmp	r3, #0
 801ecc0:	d047      	beq.n	801ed52 <state_suspend_manager+0xb2>
        if (sys.override.spindle_stop.initiate) {
 801ecc2:	f013 0f02 	tst.w	r3, #2
 801ecc6:	d122      	bne.n	801ed0e <state_suspend_manager+0x6e>
        if (sys.override.spindle_stop.restore) {
 801ecc8:	4b32      	ldr	r3, [pc, #200]	; (801ed94 <state_suspend_manager+0xf4>)
 801ecca:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 801ecce:	f013 0f04 	tst.w	r3, #4
 801ecd2:	d01b      	beq.n	801ed0c <state_suspend_manager+0x6c>
            grbl.report.feedback_message(Message_SpindleRestore);
 801ecd4:	4b30      	ldr	r3, [pc, #192]	; (801ed98 <state_suspend_manager+0xf8>)
 801ecd6:	68db      	ldr	r3, [r3, #12]
 801ecd8:	200a      	movs	r0, #10
 801ecda:	4798      	blx	r3
            if (restore_condition.spindle[restore_condition.spindle_num].hal->cap.laser) // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
 801ecdc:	4b2f      	ldr	r3, [pc, #188]	; (801ed9c <state_suspend_manager+0xfc>)
 801ecde:	f993 2001 	ldrsb.w	r2, [r3, #1]
 801ece2:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801ece6:	691b      	ldr	r3, [r3, #16]
 801ece8:	7a5b      	ldrb	r3, [r3, #9]
 801ecea:	f013 0f08 	tst.w	r3, #8
 801ecee:	d029      	beq.n	801ed44 <state_suspend_manager+0xa4>
                sys.step_control.update_spindle_rpm = On;
 801ecf0:	4a28      	ldr	r2, [pc, #160]	; (801ed94 <state_suspend_manager+0xf4>)
 801ecf2:	7e13      	ldrb	r3, [r2, #24]
 801ecf4:	f043 0308 	orr.w	r3, r3, #8
 801ecf8:	7613      	strb	r3, [r2, #24]
            sys.override.spindle_stop.value = 0; // Clear stop override state
 801ecfa:	4b26      	ldr	r3, [pc, #152]	; (801ed94 <state_suspend_manager+0xf4>)
 801ecfc:	2200      	movs	r2, #0
 801ecfe:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
            if(grbl.on_override_changed)
 801ed02:	4b25      	ldr	r3, [pc, #148]	; (801ed98 <state_suspend_manager+0xf8>)
 801ed04:	6a1b      	ldr	r3, [r3, #32]
 801ed06:	b10b      	cbz	r3, 801ed0c <state_suspend_manager+0x6c>
                grbl.on_override_changed(OverrideChanged_SpindleState);
 801ed08:	4610      	mov	r0, r2
 801ed0a:	4798      	blx	r3
}
 801ed0c:	bd10      	pop	{r4, pc}
            sys.override.spindle_stop.value = 0; // Clear stop override state
 801ed0e:	4c21      	ldr	r4, [pc, #132]	; (801ed94 <state_suspend_manager+0xf4>)
 801ed10:	2100      	movs	r1, #0
 801ed12:	f884 1028 	strb.w	r1, [r4, #40]	; 0x28
            spindle_set_state(restore_condition.spindle[restore_condition.spindle_num].hal, (spindle_state_t){0}, 0.0f); // De-energize
 801ed16:	4b21      	ldr	r3, [pc, #132]	; (801ed9c <state_suspend_manager+0xfc>)
 801ed18:	f993 2001 	ldrsb.w	r2, [r3, #1]
 801ed1c:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801ed20:	ed9f 0a1f 	vldr	s0, [pc, #124]	; 801eda0 <state_suspend_manager+0x100>
 801ed24:	6918      	ldr	r0, [r3, #16]
 801ed26:	f7fe fef5 	bl	801db14 <spindle_set_state>
            sys.override.spindle_stop.enabled = On; // Set stop override state to enabled, if de-energized.
 801ed2a:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 801ed2e:	f043 0301 	orr.w	r3, r3, #1
 801ed32:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
            if(grbl.on_override_changed)
 801ed36:	4b18      	ldr	r3, [pc, #96]	; (801ed98 <state_suspend_manager+0xf8>)
 801ed38:	6a1b      	ldr	r3, [r3, #32]
 801ed3a:	2b00      	cmp	r3, #0
 801ed3c:	d0c4      	beq.n	801ecc8 <state_suspend_manager+0x28>
                grbl.on_override_changed(OverrideChanged_SpindleState);
 801ed3e:	2000      	movs	r0, #0
 801ed40:	4798      	blx	r3
 801ed42:	e7c1      	b.n	801ecc8 <state_suspend_manager+0x28>
                state_spindle_set_state(&restore_condition.spindle[restore_condition.spindle_num]);
 801ed44:	4815      	ldr	r0, [pc, #84]	; (801ed9c <state_suspend_manager+0xfc>)
 801ed46:	eb00 1002 	add.w	r0, r0, r2, lsl #4
 801ed4a:	3004      	adds	r0, #4
 801ed4c:	f7ff fc2a 	bl	801e5a4 <state_spindle_set_state>
 801ed50:	e7d3      	b.n	801ecfa <state_suspend_manager+0x5a>
    } else if (sys.step_control.update_spindle_rpm && restore_condition.spindle[0].hal->get_state().on) {
 801ed52:	4b10      	ldr	r3, [pc, #64]	; (801ed94 <state_suspend_manager+0xf4>)
 801ed54:	7e1b      	ldrb	r3, [r3, #24]
 801ed56:	f013 0f08 	tst.w	r3, #8
 801ed5a:	d0d7      	beq.n	801ed0c <state_suspend_manager+0x6c>
 801ed5c:	4b0f      	ldr	r3, [pc, #60]	; (801ed9c <state_suspend_manager+0xfc>)
 801ed5e:	691b      	ldr	r3, [r3, #16]
 801ed60:	6a1b      	ldr	r3, [r3, #32]
 801ed62:	4798      	blx	r3
 801ed64:	f010 0f01 	tst.w	r0, #1
 801ed68:	d0d0      	beq.n	801ed0c <state_suspend_manager+0x6c>
        state_spindle_set_state(&restore_condition.spindle[restore_condition.spindle_num]);
 801ed6a:	480c      	ldr	r0, [pc, #48]	; (801ed9c <state_suspend_manager+0xfc>)
 801ed6c:	f990 3001 	ldrsb.w	r3, [r0, #1]
 801ed70:	eb00 1003 	add.w	r0, r0, r3, lsl #4
 801ed74:	3004      	adds	r0, #4
 801ed76:	f7ff fc15 	bl	801e5a4 <state_spindle_set_state>
        sys.step_control.update_spindle_rpm = Off;
 801ed7a:	4b06      	ldr	r3, [pc, #24]	; (801ed94 <state_suspend_manager+0xf4>)
 801ed7c:	7e1a      	ldrb	r2, [r3, #24]
 801ed7e:	f36f 02c3 	bfc	r2, #3, #1
 801ed82:	761a      	strb	r2, [r3, #24]
 801ed84:	e7c2      	b.n	801ed0c <state_suspend_manager+0x6c>
 801ed86:	bf00      	nop
 801ed88:	20000510 	.word	0x20000510
 801ed8c:	0801e8cd 	.word	0x0801e8cd
 801ed90:	20003344 	.word	0x20003344
 801ed94:	200036c4 	.word	0x200036c4
 801ed98:	2000343c 	.word	0x2000343c
 801ed9c:	20003e60 	.word	0x20003e60
 801eda0:	00000000 	.word	0x00000000

0801eda4 <st_deenergize>:
    }
}

// Callback from delay to deenergize steppers after movement, might been cancelled
void st_deenergize (void)
{
 801eda4:	b508      	push	{r3, lr}
    if(sys.steppers_deenergize) {
 801eda6:	4b07      	ldr	r3, [pc, #28]	; (801edc4 <st_deenergize+0x20>)
 801eda8:	799b      	ldrb	r3, [r3, #6]
 801edaa:	b14b      	cbz	r3, 801edc0 <st_deenergize+0x1c>
        hal.stepper.enable(settings.steppers.deenergize);
 801edac:	4b06      	ldr	r3, [pc, #24]	; (801edc8 <st_deenergize+0x24>)
 801edae:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 801edb2:	4a06      	ldr	r2, [pc, #24]	; (801edcc <st_deenergize+0x28>)
 801edb4:	f892 00ec 	ldrb.w	r0, [r2, #236]	; 0xec
 801edb8:	4798      	blx	r3
        sys.steppers_deenergize = false;
 801edba:	4b02      	ldr	r3, [pc, #8]	; (801edc4 <st_deenergize+0x20>)
 801edbc:	2200      	movs	r2, #0
 801edbe:	719a      	strb	r2, [r3, #6]
    }
}
 801edc0:	bd08      	pop	{r3, pc}
 801edc2:	bf00      	nop
 801edc4:	200036c4 	.word	0x200036c4
 801edc8:	2000350c 	.word	0x2000350c
 801edcc:	20003b14 	.word	0x20003b14

0801edd0 <output_message>:
    if(message) {
 801edd0:	4b0c      	ldr	r3, [pc, #48]	; (801ee04 <output_message+0x34>)
 801edd2:	6818      	ldr	r0, [r3, #0]
 801edd4:	b1a0      	cbz	r0, 801ee00 <output_message+0x30>
{
 801edd6:	b510      	push	{r4, lr}
        if(grbl.on_gcode_message)
 801edd8:	4b0b      	ldr	r3, [pc, #44]	; (801ee08 <output_message+0x38>)
 801edda:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801edde:	b103      	cbz	r3, 801ede2 <output_message+0x12>
            grbl.on_gcode_message(message);
 801ede0:	4798      	blx	r3
        if(*message)
 801ede2:	4b08      	ldr	r3, [pc, #32]	; (801ee04 <output_message+0x34>)
 801ede4:	6818      	ldr	r0, [r3, #0]
 801ede6:	7803      	ldrb	r3, [r0, #0]
 801ede8:	b933      	cbnz	r3, 801edf8 <output_message+0x28>
        free(message);
 801edea:	4c06      	ldr	r4, [pc, #24]	; (801ee04 <output_message+0x34>)
 801edec:	6820      	ldr	r0, [r4, #0]
 801edee:	f003 fb67 	bl	80224c0 <free>
        message = NULL;
 801edf2:	2300      	movs	r3, #0
 801edf4:	6023      	str	r3, [r4, #0]
}
 801edf6:	bd10      	pop	{r4, pc}
            report_message(message, Message_Plain);
 801edf8:	2100      	movs	r1, #0
 801edfa:	f7fa fa15 	bl	8019228 <report_message>
 801edfe:	e7f4      	b.n	801edea <output_message+0x1a>
 801ee00:	4770      	bx	lr
 801ee02:	bf00      	nop
 801ee04:	20003e88 	.word	0x20003e88
 801ee08:	2000343c 	.word	0x2000343c

0801ee0c <st_wake_up>:

// Stepper state initialization. Cycle should only start if the st.cycle_start flag is
// enabled. Startup init and limits call this function but shouldn't start the cycle.
void st_wake_up (void)
{
 801ee0c:	b508      	push	{r3, lr}
    if(sys.steppers_deenergize) {
 801ee0e:	4b05      	ldr	r3, [pc, #20]	; (801ee24 <st_wake_up+0x18>)
 801ee10:	799b      	ldrb	r3, [r3, #6]
 801ee12:	b113      	cbz	r3, 801ee1a <st_wake_up+0xe>
        sys.steppers_deenergize = false;
 801ee14:	4b03      	ldr	r3, [pc, #12]	; (801ee24 <st_wake_up+0x18>)
 801ee16:	2200      	movs	r2, #0
 801ee18:	719a      	strb	r2, [r3, #6]

    // Initialize stepper data to ensure first ISR call does not step and
    // cancel any pending steppers deenergize
    //st.exec_block = NULL;

    hal.stepper.wake_up();
 801ee1a:	4b03      	ldr	r3, [pc, #12]	; (801ee28 <st_wake_up+0x1c>)
 801ee1c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 801ee20:	4798      	blx	r3
}
 801ee22:	bd08      	pop	{r3, pc}
 801ee24:	200036c4 	.word	0x200036c4
 801ee28:	2000350c 	.word	0x2000350c

0801ee2c <st_go_idle>:

// Stepper shutdown
ISR_CODE void ISR_FUNC(st_go_idle)(void)
{
 801ee2c:	b510      	push	{r4, lr}
    // Disable Stepper Driver Interrupt. Allow Stepper Port Reset Interrupt to finish, if active.

    sys_state_t state = state_get();
 801ee2e:	f7ff fbd9 	bl	801e5e4 <state_get>
 801ee32:	4604      	mov	r4, r0

    hal.stepper.go_idle(false);
 801ee34:	4b17      	ldr	r3, [pc, #92]	; (801ee94 <st_go_idle+0x68>)
 801ee36:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 801ee3a:	2000      	movs	r0, #0
 801ee3c:	4798      	blx	r3

    // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
    if (((settings.steppers.idle_lock_time != 255) || sys.rt_exec_alarm || state == STATE_SLEEP) && state != STATE_HOMING) {
 801ee3e:	4b16      	ldr	r3, [pc, #88]	; (801ee98 <st_go_idle+0x6c>)
 801ee40:	f8b3 00f8 	ldrh.w	r0, [r3, #248]	; 0xf8
 801ee44:	28ff      	cmp	r0, #255	; 0xff
 801ee46:	d00b      	beq.n	801ee60 <st_go_idle+0x34>
 801ee48:	2c04      	cmp	r4, #4
 801ee4a:	d00f      	beq.n	801ee6c <st_go_idle+0x40>
        if(state == STATE_SLEEP)
 801ee4c:	2c80      	cmp	r4, #128	; 0x80
 801ee4e:	d017      	beq.n	801ee80 <st_go_idle+0x54>
            hal.stepper.enable((axes_signals_t){0});
        else {
            // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
            // stop and not drift from residual inertial forces at the end of the last movement.
            sys.steppers_deenergize = true;
 801ee50:	4b12      	ldr	r3, [pc, #72]	; (801ee9c <st_go_idle+0x70>)
 801ee52:	2201      	movs	r2, #1
 801ee54:	719a      	strb	r2, [r3, #6]
            hal.delay_ms(settings.steppers.idle_lock_time, st_deenergize);
 801ee56:	4b0f      	ldr	r3, [pc, #60]	; (801ee94 <st_go_idle+0x68>)
 801ee58:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801ee5a:	4911      	ldr	r1, [pc, #68]	; (801eea0 <st_go_idle+0x74>)
 801ee5c:	4798      	blx	r3
 801ee5e:	e00e      	b.n	801ee7e <st_go_idle+0x52>
    if (((settings.steppers.idle_lock_time != 255) || sys.rt_exec_alarm || state == STATE_SLEEP) && state != STATE_HOMING) {
 801ee60:	4b0e      	ldr	r3, [pc, #56]	; (801ee9c <st_go_idle+0x70>)
 801ee62:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801ee64:	2b00      	cmp	r3, #0
 801ee66:	d1ef      	bne.n	801ee48 <st_go_idle+0x1c>
 801ee68:	2c80      	cmp	r4, #128	; 0x80
 801ee6a:	d0ed      	beq.n	801ee48 <st_go_idle+0x1c>
        }
    } else
        hal.stepper.enable(settings.steppers.idle_lock_time == 255 ? (axes_signals_t){AXES_BITMASK} : settings.steppers.deenergize);
 801ee6c:	4b09      	ldr	r3, [pc, #36]	; (801ee94 <st_go_idle+0x68>)
 801ee6e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 801ee72:	28ff      	cmp	r0, #255	; 0xff
 801ee74:	d00b      	beq.n	801ee8e <st_go_idle+0x62>
 801ee76:	4a08      	ldr	r2, [pc, #32]	; (801ee98 <st_go_idle+0x6c>)
 801ee78:	f892 00ec 	ldrb.w	r0, [r2, #236]	; 0xec
 801ee7c:	4798      	blx	r3
}
 801ee7e:	bd10      	pop	{r4, pc}
            hal.stepper.enable((axes_signals_t){0});
 801ee80:	4b04      	ldr	r3, [pc, #16]	; (801ee94 <st_go_idle+0x68>)
 801ee82:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 801ee86:	f04f 0000 	mov.w	r0, #0
 801ee8a:	4798      	blx	r3
 801ee8c:	e7f7      	b.n	801ee7e <st_go_idle+0x52>
        hal.stepper.enable(settings.steppers.idle_lock_time == 255 ? (axes_signals_t){AXES_BITMASK} : settings.steppers.deenergize);
 801ee8e:	f04f 0007 	mov.w	r0, #7
 801ee92:	e7f3      	b.n	801ee7c <st_go_idle+0x50>
 801ee94:	2000350c 	.word	0x2000350c
 801ee98:	20003b14 	.word	0x20003b14
 801ee9c:	200036c4 	.word	0x200036c4
 801eea0:	0801eda5 	.word	0x0801eda5

0801eea4 <stepper_driver_interrupt_handler>:
*/

//! \cond

ISR_CODE void ISR_FUNC(stepper_driver_interrupt_handler)(void)
{
 801eea4:	b510      	push	{r4, lr}
#if ENABLE_BACKLASH_COMPENSATION
    static bool backlash_motion;
#endif

    // Start a step pulse when there is a block to execute.
    if(st.exec_block) {
 801eea6:	4b92      	ldr	r3, [pc, #584]	; (801f0f0 <stepper_driver_interrupt_handler+0x24c>)
 801eea8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801eeaa:	b163      	cbz	r3, 801eec6 <stepper_driver_interrupt_handler+0x22>

        hal.stepper.pulse_start(&st);
 801eeac:	4b91      	ldr	r3, [pc, #580]	; (801f0f4 <stepper_driver_interrupt_handler+0x250>)
 801eeae:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 801eeb2:	4c8f      	ldr	r4, [pc, #572]	; (801f0f0 <stepper_driver_interrupt_handler+0x24c>)
 801eeb4:	4620      	mov	r0, r4
 801eeb6:	4798      	blx	r3

        st.new_block = st.dir_change = false;
 801eeb8:	2300      	movs	r3, #0
 801eeba:	7363      	strb	r3, [r4, #13]
 801eebc:	7323      	strb	r3, [r4, #12]

        if (st.step_count == 0) // Segment is complete. Discard current segment.
 801eebe:	6a23      	ldr	r3, [r4, #32]
 801eec0:	b90b      	cbnz	r3, 801eec6 <stepper_driver_interrupt_handler+0x22>
            st.exec_segment = NULL;
 801eec2:	2200      	movs	r2, #0
 801eec4:	62e2      	str	r2, [r4, #44]	; 0x2c
    }

    // If there is no step segment, attempt to pop one from the stepper buffer
    if (st.exec_segment == NULL) {
 801eec6:	4b8a      	ldr	r3, [pc, #552]	; (801f0f0 <stepper_driver_interrupt_handler+0x24c>)
 801eec8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801eeca:	2b00      	cmp	r3, #0
 801eecc:	d068      	beq.n	801efa0 <stepper_driver_interrupt_handler+0xfc>
    }

    // Check probing state.
    // Monitors probe pin state and records the system position when detected.
    // NOTE: This function must be extremely efficient as to not bog down the stepper ISR.
    if (sys.probing_state == Probing_Active && hal.probe.get_state().triggered) {
 801eece:	4b8a      	ldr	r3, [pc, #552]	; (801f0f8 <stepper_driver_interrupt_handler+0x254>)
 801eed0:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 801eed4:	b2db      	uxtb	r3, r3
 801eed6:	2b01      	cmp	r3, #1
 801eed8:	f000 811a 	beq.w	801f110 <stepper_driver_interrupt_handler+0x26c>
            segment_next_head = segment_next_head->next;
        }
#endif
    }

    register axes_signals_t step_outbits = (axes_signals_t){0};
 801eedc:	f04f 0100 	mov.w	r1, #0

    // Execute step displacement profile by Bresenham line algorithm

    st.counter_x += st.steps[X_AXIS];
 801eee0:	4a83      	ldr	r2, [pc, #524]	; (801f0f0 <stepper_driver_interrupt_handler+0x24c>)
 801eee2:	6913      	ldr	r3, [r2, #16]
 801eee4:	6810      	ldr	r0, [r2, #0]
 801eee6:	4403      	add	r3, r0
 801eee8:	6013      	str	r3, [r2, #0]
    if (st.counter_x > st.step_event_count) {
 801eeea:	6a52      	ldr	r2, [r2, #36]	; 0x24
 801eeec:	4293      	cmp	r3, r2
 801eeee:	d912      	bls.n	801ef16 <stepper_driver_interrupt_handler+0x72>
        step_outbits.x = On;
 801eef0:	f04f 0101 	mov.w	r1, #1
        st.counter_x -= st.step_event_count;
 801eef4:	487e      	ldr	r0, [pc, #504]	; (801f0f0 <stepper_driver_interrupt_handler+0x24c>)
 801eef6:	1a9b      	subs	r3, r3, r2
 801eef8:	6003      	str	r3, [r0, #0]
#if ENABLE_BACKLASH_COMPENSATION
        if(!backlash_motion)
#endif
            sys.position[X_AXIS] = sys.position[X_AXIS] + (st.dir_outbits.x ? -1 : 1);
 801eefa:	4b7f      	ldr	r3, [pc, #508]	; (801f0f8 <stepper_driver_interrupt_handler+0x254>)
 801eefc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 801ef00:	7bc0      	ldrb	r0, [r0, #15]
 801ef02:	f010 0f01 	tst.w	r0, #1
 801ef06:	f000 811b 	beq.w	801f140 <stepper_driver_interrupt_handler+0x29c>
 801ef0a:	f04f 30ff 	mov.w	r0, #4294967295
 801ef0e:	4403      	add	r3, r0
 801ef10:	4879      	ldr	r0, [pc, #484]	; (801f0f8 <stepper_driver_interrupt_handler+0x254>)
 801ef12:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
    }

    st.counter_y += st.steps[Y_AXIS];
 801ef16:	4876      	ldr	r0, [pc, #472]	; (801f0f0 <stepper_driver_interrupt_handler+0x24c>)
 801ef18:	6943      	ldr	r3, [r0, #20]
 801ef1a:	6844      	ldr	r4, [r0, #4]
 801ef1c:	4423      	add	r3, r4
 801ef1e:	6043      	str	r3, [r0, #4]
    if (st.counter_y > st.step_event_count) {
 801ef20:	429a      	cmp	r2, r3
 801ef22:	d211      	bcs.n	801ef48 <stepper_driver_interrupt_handler+0xa4>
        step_outbits.y = On;
 801ef24:	f041 0102 	orr.w	r1, r1, #2
        st.counter_y -= st.step_event_count;
 801ef28:	1a9b      	subs	r3, r3, r2
 801ef2a:	6043      	str	r3, [r0, #4]
#if ENABLE_BACKLASH_COMPENSATION
        if(!backlash_motion)
#endif
            sys.position[Y_AXIS] = sys.position[Y_AXIS] + (st.dir_outbits.y ? -1 : 1);
 801ef2c:	4b72      	ldr	r3, [pc, #456]	; (801f0f8 <stepper_driver_interrupt_handler+0x254>)
 801ef2e:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801ef32:	7bc0      	ldrb	r0, [r0, #15]
 801ef34:	f010 0f02 	tst.w	r0, #2
 801ef38:	f000 8104 	beq.w	801f144 <stepper_driver_interrupt_handler+0x2a0>
 801ef3c:	f04f 30ff 	mov.w	r0, #4294967295
 801ef40:	4403      	add	r3, r0
 801ef42:	486d      	ldr	r0, [pc, #436]	; (801f0f8 <stepper_driver_interrupt_handler+0x254>)
 801ef44:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
    }

    st.counter_z += st.steps[Z_AXIS];
 801ef48:	4869      	ldr	r0, [pc, #420]	; (801f0f0 <stepper_driver_interrupt_handler+0x24c>)
 801ef4a:	6983      	ldr	r3, [r0, #24]
 801ef4c:	6884      	ldr	r4, [r0, #8]
 801ef4e:	4423      	add	r3, r4
 801ef50:	6083      	str	r3, [r0, #8]
    if (st.counter_z > st.step_event_count) {
 801ef52:	429a      	cmp	r2, r3
 801ef54:	d211      	bcs.n	801ef7a <stepper_driver_interrupt_handler+0xd6>
        step_outbits.z = On;
 801ef56:	f041 0104 	orr.w	r1, r1, #4
        st.counter_z -= st.step_event_count;
 801ef5a:	1a9b      	subs	r3, r3, r2
 801ef5c:	6083      	str	r3, [r0, #8]
#if ENABLE_BACKLASH_COMPENSATION
        if(!backlash_motion)
#endif
            sys.position[Z_AXIS] = sys.position[Z_AXIS] + (st.dir_outbits.z ? -1 : 1);
 801ef5e:	4b66      	ldr	r3, [pc, #408]	; (801f0f8 <stepper_driver_interrupt_handler+0x254>)
 801ef60:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 801ef64:	7bc2      	ldrb	r2, [r0, #15]
 801ef66:	f012 0f04 	tst.w	r2, #4
 801ef6a:	f000 80ed 	beq.w	801f148 <stepper_driver_interrupt_handler+0x2a4>
 801ef6e:	f04f 32ff 	mov.w	r2, #4294967295
 801ef72:	4413      	add	r3, r2
 801ef74:	4a60      	ldr	r2, [pc, #384]	; (801f0f8 <stepper_driver_interrupt_handler+0x254>)
 801ef76:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
#endif
            sys.position[V_AXIS] = sys.position[V_AXIS] + (st.dir_outbits.v ? -1 : 1);
    }
  #endif

    st.step_outbits.value = step_outbits.value;
 801ef7a:	4b5d      	ldr	r3, [pc, #372]	; (801f0f0 <stepper_driver_interrupt_handler+0x24c>)
 801ef7c:	7399      	strb	r1, [r3, #14]

    // During a homing cycle, lock out and prevent desired axes from moving.
    if (state_get() == STATE_HOMING)
 801ef7e:	f7ff fb31 	bl	801e5e4 <state_get>
 801ef82:	2804      	cmp	r0, #4
 801ef84:	f000 80e2 	beq.w	801f14c <stepper_driver_interrupt_handler+0x2a8>
        st.step_outbits.value &= sys.homing_axis_lock.mask;

    if (st.step_count == 0 || --st.step_count == 0) {
 801ef88:	4b59      	ldr	r3, [pc, #356]	; (801f0f0 <stepper_driver_interrupt_handler+0x24c>)
 801ef8a:	6a1b      	ldr	r3, [r3, #32]
 801ef8c:	b11b      	cbz	r3, 801ef96 <stepper_driver_interrupt_handler+0xf2>
 801ef8e:	3b01      	subs	r3, #1
 801ef90:	4a57      	ldr	r2, [pc, #348]	; (801f0f0 <stepper_driver_interrupt_handler+0x24c>)
 801ef92:	6213      	str	r3, [r2, #32]
 801ef94:	b91b      	cbnz	r3, 801ef9e <stepper_driver_interrupt_handler+0xfa>
        // Segment is complete. Advance segment tail pointer.
        segment_buffer_tail = segment_buffer_tail->next;
 801ef96:	4b59      	ldr	r3, [pc, #356]	; (801f0fc <stepper_driver_interrupt_handler+0x258>)
 801ef98:	681a      	ldr	r2, [r3, #0]
 801ef9a:	6852      	ldr	r2, [r2, #4]
 801ef9c:	601a      	str	r2, [r3, #0]
    }
}
 801ef9e:	bd10      	pop	{r4, pc}
        if (segment_buffer_tail != segment_buffer_head) {
 801efa0:	4b56      	ldr	r3, [pc, #344]	; (801f0fc <stepper_driver_interrupt_handler+0x258>)
 801efa2:	681b      	ldr	r3, [r3, #0]
 801efa4:	4a56      	ldr	r2, [pc, #344]	; (801f100 <stepper_driver_interrupt_handler+0x25c>)
 801efa6:	6812      	ldr	r2, [r2, #0]
 801efa8:	4293      	cmp	r3, r2
 801efaa:	f000 8089 	beq.w	801f0c0 <stepper_driver_interrupt_handler+0x21c>
            st.exec_segment = (segment_t *)segment_buffer_tail;
 801efae:	4c50      	ldr	r4, [pc, #320]	; (801f0f0 <stepper_driver_interrupt_handler+0x24c>)
 801efb0:	62e3      	str	r3, [r4, #44]	; 0x2c
            hal.stepper.cycles_per_tick(st.exec_segment->cycles_per_tick);
 801efb2:	4a50      	ldr	r2, [pc, #320]	; (801f0f4 <stepper_driver_interrupt_handler+0x250>)
 801efb4:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 801efb8:	68d8      	ldr	r0, [r3, #12]
 801efba:	4790      	blx	r2
            st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
 801efbc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 801efbe:	699a      	ldr	r2, [r3, #24]
 801efc0:	6222      	str	r2, [r4, #32]
            if (st.exec_block != st.exec_segment->exec_block) {
 801efc2:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 801efc4:	6899      	ldr	r1, [r3, #8]
 801efc6:	428a      	cmp	r2, r1
 801efc8:	d058      	beq.n	801f07c <stepper_driver_interrupt_handler+0x1d8>
                if((st.dir_change = st.exec_block == NULL || st.dir_outbits.value != st.exec_segment->exec_block->direction_bits.value))
 801efca:	b1da      	cbz	r2, 801f004 <stepper_driver_interrupt_handler+0x160>
 801efcc:	7be0      	ldrb	r0, [r4, #15]
 801efce:	7e0a      	ldrb	r2, [r1, #24]
 801efd0:	4290      	cmp	r0, r2
 801efd2:	d019      	beq.n	801f008 <stepper_driver_interrupt_handler+0x164>
 801efd4:	2201      	movs	r2, #1
 801efd6:	4946      	ldr	r1, [pc, #280]	; (801f0f0 <stepper_driver_interrupt_handler+0x24c>)
 801efd8:	734a      	strb	r2, [r1, #13]
 801efda:	b11a      	cbz	r2, 801efe4 <stepper_driver_interrupt_handler+0x140>
                    st.dir_outbits = st.exec_segment->exec_block->direction_bits;
 801efdc:	689a      	ldr	r2, [r3, #8]
 801efde:	7e11      	ldrb	r1, [r2, #24]
 801efe0:	4a43      	ldr	r2, [pc, #268]	; (801f0f0 <stepper_driver_interrupt_handler+0x24c>)
 801efe2:	73d1      	strb	r1, [r2, #15]
                st.exec_block = st.exec_segment->exec_block;
 801efe4:	689b      	ldr	r3, [r3, #8]
 801efe6:	4a42      	ldr	r2, [pc, #264]	; (801f0f0 <stepper_driver_interrupt_handler+0x24c>)
 801efe8:	6293      	str	r3, [r2, #40]	; 0x28
                st.step_event_count = st.exec_block->step_event_count;
 801efea:	6959      	ldr	r1, [r3, #20]
 801efec:	6251      	str	r1, [r2, #36]	; 0x24
                st.new_block = true;
 801efee:	2101      	movs	r1, #1
 801eff0:	7311      	strb	r1, [r2, #12]
                if(st.exec_block->overrides.sync)
 801eff2:	f993 2019 	ldrsb.w	r2, [r3, #25]
 801eff6:	2a00      	cmp	r2, #0
 801eff8:	da15      	bge.n	801f026 <stepper_driver_interrupt_handler+0x182>
                    sys.override.control = st.exec_block->overrides;
 801effa:	7e5a      	ldrb	r2, [r3, #25]
 801effc:	4b3e      	ldr	r3, [pc, #248]	; (801f0f8 <stepper_driver_interrupt_handler+0x254>)
 801effe:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
 801f002:	e010      	b.n	801f026 <stepper_driver_interrupt_handler+0x182>
                if((st.dir_change = st.exec_block == NULL || st.dir_outbits.value != st.exec_segment->exec_block->direction_bits.value))
 801f004:	2201      	movs	r2, #1
 801f006:	e7e6      	b.n	801efd6 <stepper_driver_interrupt_handler+0x132>
 801f008:	2200      	movs	r2, #0
 801f00a:	e7e4      	b.n	801efd6 <stepper_driver_interrupt_handler+0x132>
                        hal.port.analog_out(cmd->port, cmd->value);
 801f00c:	4b39      	ldr	r3, [pc, #228]	; (801f0f4 <stepper_driver_interrupt_handler+0x250>)
 801f00e:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
 801f012:	edd4 7a01 	vldr	s15, [r4, #4]
 801f016:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
 801f01a:	78a0      	ldrb	r0, [r4, #2]
 801f01c:	4798      	blx	r3
                    st.exec_block->output_commands = cmd->next;
 801f01e:	4b34      	ldr	r3, [pc, #208]	; (801f0f0 <stepper_driver_interrupt_handler+0x24c>)
 801f020:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801f022:	68a2      	ldr	r2, [r4, #8]
 801f024:	62da      	str	r2, [r3, #44]	; 0x2c
                while(st.exec_block->output_commands) {
 801f026:	4b32      	ldr	r3, [pc, #200]	; (801f0f0 <stepper_driver_interrupt_handler+0x24c>)
 801f028:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801f02a:	6adc      	ldr	r4, [r3, #44]	; 0x2c
 801f02c:	b1ac      	cbz	r4, 801f05a <stepper_driver_interrupt_handler+0x1b6>
                    cmd->is_executed = true;
 801f02e:	2301      	movs	r3, #1
 801f030:	7063      	strb	r3, [r4, #1]
                    if(cmd->is_digital)
 801f032:	7823      	ldrb	r3, [r4, #0]
 801f034:	2b00      	cmp	r3, #0
 801f036:	d0e9      	beq.n	801f00c <stepper_driver_interrupt_handler+0x168>
                        hal.port.digital_out(cmd->port, cmd->value != 0.0f);
 801f038:	4b2e      	ldr	r3, [pc, #184]	; (801f0f4 <stepper_driver_interrupt_handler+0x250>)
 801f03a:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 801f03e:	edd4 7a01 	vldr	s15, [r4, #4]
 801f042:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801f046:	eef5 7a40 	vcmp.f32	s15, #0.0
 801f04a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f04e:	bf14      	ite	ne
 801f050:	2101      	movne	r1, #1
 801f052:	2100      	moveq	r1, #0
 801f054:	78a0      	ldrb	r0, [r4, #2]
 801f056:	4798      	blx	r3
 801f058:	e7e1      	b.n	801f01e <stepper_driver_interrupt_handler+0x17a>
                if(st.exec_block->message) {
 801f05a:	6a98      	ldr	r0, [r3, #40]	; 0x28
 801f05c:	b140      	cbz	r0, 801f070 <stepper_driver_interrupt_handler+0x1cc>
                    if(message == NULL) {
 801f05e:	4b29      	ldr	r3, [pc, #164]	; (801f104 <stepper_driver_interrupt_handler+0x260>)
 801f060:	681b      	ldr	r3, [r3, #0]
 801f062:	b1fb      	cbz	r3, 801f0a4 <stepper_driver_interrupt_handler+0x200>
                        free(st.exec_block->message); //
 801f064:	f003 fa2c 	bl	80224c0 <free>
                    st.exec_block->message = NULL;
 801f068:	4b21      	ldr	r3, [pc, #132]	; (801f0f0 <stepper_driver_interrupt_handler+0x24c>)
 801f06a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801f06c:	2200      	movs	r2, #0
 801f06e:	629a      	str	r2, [r3, #40]	; 0x28
                  = st.step_event_count >> 1;
 801f070:	4a1f      	ldr	r2, [pc, #124]	; (801f0f0 <stepper_driver_interrupt_handler+0x24c>)
 801f072:	6a53      	ldr	r3, [r2, #36]	; 0x24
 801f074:	085b      	lsrs	r3, r3, #1
 801f076:	6093      	str	r3, [r2, #8]
                st.counter_x = st.counter_y = st.counter_z
 801f078:	6053      	str	r3, [r2, #4]
 801f07a:	6013      	str	r3, [r2, #0]
            st.amass_level = st.exec_segment->amass_level;
 801f07c:	4b1c      	ldr	r3, [pc, #112]	; (801f0f0 <stepper_driver_interrupt_handler+0x24c>)
 801f07e:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 801f080:	6a8a      	ldr	r2, [r1, #40]	; 0x28
 801f082:	61da      	str	r2, [r3, #28]
            st.steps[X_AXIS] = st.exec_block->steps[X_AXIS] >> st.amass_level;
 801f084:	6a98      	ldr	r0, [r3, #40]	; 0x28
 801f086:	6884      	ldr	r4, [r0, #8]
 801f088:	40d4      	lsrs	r4, r2
 801f08a:	611c      	str	r4, [r3, #16]
            st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.amass_level;
 801f08c:	68c4      	ldr	r4, [r0, #12]
 801f08e:	40d4      	lsrs	r4, r2
 801f090:	615c      	str	r4, [r3, #20]
            st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.amass_level;
 801f092:	6900      	ldr	r0, [r0, #16]
 801f094:	fa20 f202 	lsr.w	r2, r0, r2
 801f098:	619a      	str	r2, [r3, #24]
            if(st.exec_segment->update_pwm)
 801f09a:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 801f09c:	b143      	cbz	r3, 801f0b0 <stepper_driver_interrupt_handler+0x20c>
                st.exec_segment->update_pwm(st.exec_segment->spindle_pwm);
 801f09e:	69c8      	ldr	r0, [r1, #28]
 801f0a0:	4798      	blx	r3
 801f0a2:	e714      	b.n	801eece <stepper_driver_interrupt_handler+0x2a>
                        message = st.exec_block->message;
 801f0a4:	4b17      	ldr	r3, [pc, #92]	; (801f104 <stepper_driver_interrupt_handler+0x260>)
 801f0a6:	6018      	str	r0, [r3, #0]
                        protocol_enqueue_rt_command(output_message);
 801f0a8:	4817      	ldr	r0, [pc, #92]	; (801f108 <stepper_driver_interrupt_handler+0x264>)
 801f0aa:	f7f8 ffdf 	bl	801806c <protocol_enqueue_rt_command>
 801f0ae:	e7db      	b.n	801f068 <stepper_driver_interrupt_handler+0x1c4>
            else if(st.exec_segment->update_rpm)
 801f0b0:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 801f0b2:	2b00      	cmp	r3, #0
 801f0b4:	f43f af0b 	beq.w	801eece <stepper_driver_interrupt_handler+0x2a>
                st.exec_segment->update_rpm(st.exec_segment->spindle_rpm);
 801f0b8:	ed91 0a08 	vldr	s0, [r1, #32]
 801f0bc:	4798      	blx	r3
 801f0be:	e706      	b.n	801eece <stepper_driver_interrupt_handler+0x2a>
            st_go_idle();
 801f0c0:	f7ff feb4 	bl	801ee2c <st_go_idle>
            if (st.exec_block->dynamic_rpm && st.exec_block->spindle->cap.laser)
 801f0c4:	4b0a      	ldr	r3, [pc, #40]	; (801f0f0 <stepper_driver_interrupt_handler+0x24c>)
 801f0c6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801f0c8:	f893 2031 	ldrb.w	r2, [r3, #49]	; 0x31
 801f0cc:	b13a      	cbz	r2, 801f0de <stepper_driver_interrupt_handler+0x23a>
 801f0ce:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801f0d0:	7a5a      	ldrb	r2, [r3, #9]
 801f0d2:	f012 0f08 	tst.w	r2, #8
 801f0d6:	d002      	beq.n	801f0de <stepper_driver_interrupt_handler+0x23a>
                st.exec_block->spindle->update_pwm(st.exec_block->spindle->pwm_off_value);
 801f0d8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 801f0da:	68d8      	ldr	r0, [r3, #12]
 801f0dc:	4790      	blx	r2
            st.exec_block = NULL;
 801f0de:	4b04      	ldr	r3, [pc, #16]	; (801f0f0 <stepper_driver_interrupt_handler+0x24c>)
 801f0e0:	2200      	movs	r2, #0
 801f0e2:	629a      	str	r2, [r3, #40]	; 0x28
            system_set_exec_state_flag(EXEC_CYCLE_COMPLETE); // Flag main program for cycle complete
 801f0e4:	4b03      	ldr	r3, [pc, #12]	; (801f0f4 <stepper_driver_interrupt_handler+0x250>)
 801f0e6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801f0e8:	2104      	movs	r1, #4
 801f0ea:	4808      	ldr	r0, [pc, #32]	; (801f10c <stepper_driver_interrupt_handler+0x268>)
 801f0ec:	4798      	blx	r3
            return; // Nothing to do but exit.
 801f0ee:	e756      	b.n	801ef9e <stepper_driver_interrupt_handler+0xfa>
 801f0f0:	200040f8 	.word	0x200040f8
 801f0f4:	2000350c 	.word	0x2000350c
 801f0f8:	200036c4 	.word	0x200036c4
 801f0fc:	200040f0 	.word	0x200040f0
 801f100:	200040ec 	.word	0x200040ec
 801f104:	20003e88 	.word	0x20003e88
 801f108:	0801edd1 	.word	0x0801edd1
 801f10c:	2000370c 	.word	0x2000370c
    if (sys.probing_state == Probing_Active && hal.probe.get_state().triggered) {
 801f110:	4b12      	ldr	r3, [pc, #72]	; (801f15c <stepper_driver_interrupt_handler+0x2b8>)
 801f112:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 801f116:	4798      	blx	r3
 801f118:	f010 0f01 	tst.w	r0, #1
 801f11c:	f43f aede 	beq.w	801eedc <stepper_driver_interrupt_handler+0x38>
        sys.probing_state = Probing_Off;
 801f120:	4b0f      	ldr	r3, [pc, #60]	; (801f160 <stepper_driver_interrupt_handler+0x2bc>)
 801f122:	2200      	movs	r2, #0
 801f124:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
        memcpy(sys.probe_position, sys.position, sizeof(sys.position));
 801f128:	f103 0438 	add.w	r4, r3, #56	; 0x38
 801f12c:	f103 0288 	add.w	r2, r3, #136	; 0x88
 801f130:	ca07      	ldmia	r2, {r0, r1, r2}
 801f132:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        bit_true(sys.rt_exec_state, EXEC_MOTION_CANCEL);
 801f136:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 801f138:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 801f13c:	649a      	str	r2, [r3, #72]	; 0x48
 801f13e:	e6cd      	b.n	801eedc <stepper_driver_interrupt_handler+0x38>
            sys.position[X_AXIS] = sys.position[X_AXIS] + (st.dir_outbits.x ? -1 : 1);
 801f140:	2001      	movs	r0, #1
 801f142:	e6e4      	b.n	801ef0e <stepper_driver_interrupt_handler+0x6a>
            sys.position[Y_AXIS] = sys.position[Y_AXIS] + (st.dir_outbits.y ? -1 : 1);
 801f144:	2001      	movs	r0, #1
 801f146:	e6fb      	b.n	801ef40 <stepper_driver_interrupt_handler+0x9c>
            sys.position[Z_AXIS] = sys.position[Z_AXIS] + (st.dir_outbits.z ? -1 : 1);
 801f148:	2201      	movs	r2, #1
 801f14a:	e712      	b.n	801ef72 <stepper_driver_interrupt_handler+0xce>
        st.step_outbits.value &= sys.homing_axis_lock.mask;
 801f14c:	4b04      	ldr	r3, [pc, #16]	; (801f160 <stepper_driver_interrupt_handler+0x2bc>)
 801f14e:	7e5b      	ldrb	r3, [r3, #25]
 801f150:	4a04      	ldr	r2, [pc, #16]	; (801f164 <stepper_driver_interrupt_handler+0x2c0>)
 801f152:	7b91      	ldrb	r1, [r2, #14]
 801f154:	400b      	ands	r3, r1
 801f156:	7393      	strb	r3, [r2, #14]
 801f158:	e716      	b.n	801ef88 <stepper_driver_interrupt_handler+0xe4>
 801f15a:	bf00      	nop
 801f15c:	2000350c 	.word	0x2000350c
 801f160:	200036c4 	.word	0x200036c4
 801f164:	200040f8 	.word	0x200040f8

0801f168 <st_reset>:

//! \endcond

// Reset and clear stepper subsystem variables
void st_reset (void)
{
 801f168:	b510      	push	{r4, lr}
    if(hal.probe.configure)
 801f16a:	4b39      	ldr	r3, [pc, #228]	; (801f250 <st_reset+0xe8>)
 801f16c:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 801f170:	b113      	cbz	r3, 801f178 <st_reset+0x10>
        hal.probe.configure(false, false);
 801f172:	2100      	movs	r1, #0
 801f174:	4608      	mov	r0, r1
 801f176:	4798      	blx	r3

    if(message) {
 801f178:	4b36      	ldr	r3, [pc, #216]	; (801f254 <st_reset+0xec>)
 801f17a:	6818      	ldr	r0, [r3, #0]
 801f17c:	b120      	cbz	r0, 801f188 <st_reset+0x20>
        free(message);
 801f17e:	f003 f99f 	bl	80224c0 <free>
        message = NULL;
 801f182:	4b34      	ldr	r3, [pc, #208]	; (801f254 <st_reset+0xec>)
 801f184:	2200      	movs	r2, #0
 801f186:	601a      	str	r2, [r3, #0]
    }

    // Initialize stepper driver idle state, clear step and direction port pins.
    st_go_idle();
 801f188:	f7ff fe50 	bl	801ee2c <st_go_idle>

    // NOTE: buffer indices starts from 1 for simpler driver coding!

    // Set up stepper block ringbuffer as circular linked list and add id
    uint_fast8_t idx, idx_max = (sizeof(st_block_buffer) / sizeof(st_block_t)) - 1;
    for(idx = 0 ; idx <= idx_max ; idx++) {
 801f18c:	2300      	movs	r3, #0
 801f18e:	e010      	b.n	801f1b2 <st_reset+0x4a>
        st_block_buffer[idx].next = &st_block_buffer[idx == idx_max ? 0 : idx + 1];
 801f190:	2200      	movs	r2, #0
 801f192:	4831      	ldr	r0, [pc, #196]	; (801f258 <st_reset+0xf0>)
 801f194:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 801f198:	00d1      	lsls	r1, r2, #3
 801f19a:	4401      	add	r1, r0
 801f19c:	ebc3 0cc3 	rsb	ip, r3, r3, lsl #3
 801f1a0:	ea4f 02cc 	mov.w	r2, ip, lsl #3
 801f1a4:	4402      	add	r2, r0
 801f1a6:	6051      	str	r1, [r2, #4]
        st_block_buffer[idx].id = idx + 1;
 801f1a8:	1c5a      	adds	r2, r3, #1
 801f1aa:	4663      	mov	r3, ip
 801f1ac:	00d9      	lsls	r1, r3, #3
 801f1ae:	5042      	str	r2, [r0, r1]
    for(idx = 0 ; idx <= idx_max ; idx++) {
 801f1b0:	4613      	mov	r3, r2
 801f1b2:	2b08      	cmp	r3, #8
 801f1b4:	d803      	bhi.n	801f1be <st_reset+0x56>
        st_block_buffer[idx].next = &st_block_buffer[idx == idx_max ? 0 : idx + 1];
 801f1b6:	2b08      	cmp	r3, #8
 801f1b8:	d0ea      	beq.n	801f190 <st_reset+0x28>
 801f1ba:	1c5a      	adds	r2, r3, #1
 801f1bc:	e7e9      	b.n	801f192 <st_reset+0x2a>
    }

    // Set up segments ringbuffer as circular linked list, add id and clear AMASS level
    idx_max = (sizeof(segment_buffer) / sizeof(segment_t)) - 1;
    for(idx = 0 ; idx <= idx_max ; idx++) {
 801f1be:	2300      	movs	r3, #0
 801f1c0:	e00f      	b.n	801f1e2 <st_reset+0x7a>
        segment_buffer[idx].next = &segment_buffer[idx == idx_max ? 0 : idx + 1];
 801f1c2:	2000      	movs	r0, #0
 801f1c4:	4925      	ldr	r1, [pc, #148]	; (801f25c <st_reset+0xf4>)
 801f1c6:	2234      	movs	r2, #52	; 0x34
 801f1c8:	fb02 1000 	mla	r0, r2, r0, r1
 801f1cc:	fb03 f202 	mul.w	r2, r3, r2
 801f1d0:	eb01 0c02 	add.w	ip, r1, r2
 801f1d4:	f8cc 0004 	str.w	r0, [ip, #4]
        segment_buffer[idx].id = idx + 1;
 801f1d8:	3301      	adds	r3, #1
 801f1da:	508b      	str	r3, [r1, r2]
        segment_buffer[idx].amass_level = 0;
 801f1dc:	2200      	movs	r2, #0
 801f1de:	f8cc 2028 	str.w	r2, [ip, #40]	; 0x28
    for(idx = 0 ; idx <= idx_max ; idx++) {
 801f1e2:	2b09      	cmp	r3, #9
 801f1e4:	d803      	bhi.n	801f1ee <st_reset+0x86>
        segment_buffer[idx].next = &segment_buffer[idx == idx_max ? 0 : idx + 1];
 801f1e6:	2b09      	cmp	r3, #9
 801f1e8:	d0eb      	beq.n	801f1c2 <st_reset+0x5a>
 801f1ea:	1c58      	adds	r0, r3, #1
 801f1ec:	e7ea      	b.n	801f1c4 <st_reset+0x5c>
    }

    st_prep_block = &st_block_buffer[0];
 801f1ee:	4b1c      	ldr	r3, [pc, #112]	; (801f260 <st_reset+0xf8>)
 801f1f0:	4a19      	ldr	r2, [pc, #100]	; (801f258 <st_reset+0xf0>)
 801f1f2:	601a      	str	r2, [r3, #0]

    // Initialize stepper algorithm variables.
    pl_block = NULL;  // Planner block pointer used by segment buffer
 801f1f4:	2400      	movs	r4, #0
 801f1f6:	4b1b      	ldr	r3, [pc, #108]	; (801f264 <st_reset+0xfc>)
 801f1f8:	601c      	str	r4, [r3, #0]
    segment_buffer_tail = segment_buffer_head = &segment_buffer[0]; // empty = tail
 801f1fa:	4b18      	ldr	r3, [pc, #96]	; (801f25c <st_reset+0xf4>)
 801f1fc:	4a1a      	ldr	r2, [pc, #104]	; (801f268 <st_reset+0x100>)
 801f1fe:	6013      	str	r3, [r2, #0]
 801f200:	4a1a      	ldr	r2, [pc, #104]	; (801f26c <st_reset+0x104>)
 801f202:	6013      	str	r3, [r2, #0]
    segment_next_head = segment_buffer_head->next;
 801f204:	685a      	ldr	r2, [r3, #4]
 801f206:	4b1a      	ldr	r3, [pc, #104]	; (801f270 <st_reset+0x108>)
 801f208:	601a      	str	r2, [r3, #0]

    memset(&prep, 0, sizeof(st_prep_t));
 801f20a:	2250      	movs	r2, #80	; 0x50
 801f20c:	4621      	mov	r1, r4
 801f20e:	4819      	ldr	r0, [pc, #100]	; (801f274 <st_reset+0x10c>)
 801f210:	f003 fcb1 	bl	8022b76 <memset>
    memset(&st, 0, sizeof(stepper_t));
 801f214:	2230      	movs	r2, #48	; 0x30
 801f216:	4621      	mov	r1, r4
 801f218:	4817      	ldr	r0, [pc, #92]	; (801f278 <st_reset+0x110>)
 801f21a:	f003 fcac 	bl	8022b76 <memset>

#ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    // TODO: move to driver?
    // AMASS_LEVEL0: Normal operation. No AMASS. No upper cutoff frequency. Starts at LEVEL1 cutoff frequency.
    // Defined as step timer frequency / Cutoff frequency in Hz
    amass.level_1 = hal.f_step_timer / 8000;
 801f21e:	4b0c      	ldr	r3, [pc, #48]	; (801f250 <st_reset+0xe8>)
 801f220:	69da      	ldr	r2, [r3, #28]
 801f222:	4b16      	ldr	r3, [pc, #88]	; (801f27c <st_reset+0x114>)
 801f224:	fba3 1302 	umull	r1, r3, r3, r2
 801f228:	0a58      	lsrs	r0, r3, #9
 801f22a:	4915      	ldr	r1, [pc, #84]	; (801f280 <st_reset+0x118>)
 801f22c:	6008      	str	r0, [r1, #0]
    amass.level_2 = hal.f_step_timer / 4000;
 801f22e:	0a18      	lsrs	r0, r3, #8
 801f230:	6048      	str	r0, [r1, #4]
    amass.level_3 = hal.f_step_timer / 2000;
 801f232:	09db      	lsrs	r3, r3, #7
 801f234:	608b      	str	r3, [r1, #8]
#endif

    cycles_per_min = (float)hal.f_step_timer * 60.0f;
 801f236:	ee07 2a90 	vmov	s15, r2
 801f23a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801f23e:	ed9f 7a11 	vldr	s14, [pc, #68]	; 801f284 <st_reset+0x11c>
 801f242:	ee67 7a87 	vmul.f32	s15, s15, s14
 801f246:	4b10      	ldr	r3, [pc, #64]	; (801f288 <st_reset+0x120>)
 801f248:	edc3 7a00 	vstr	s15, [r3]
}
 801f24c:	bd10      	pop	{r4, pc}
 801f24e:	bf00      	nop
 801f250:	2000350c 	.word	0x2000350c
 801f254:	20003e88 	.word	0x20003e88
 801f258:	20004128 	.word	0x20004128
 801f25c:	20003ee4 	.word	0x20003ee4
 801f260:	20004358 	.word	0x20004358
 801f264:	20003e8c 	.word	0x20003e8c
 801f268:	200040ec 	.word	0x200040ec
 801f26c:	200040f0 	.word	0x200040f0
 801f270:	200040f4 	.word	0x200040f4
 801f274:	20003e90 	.word	0x20003e90
 801f278:	200040f8 	.word	0x200040f8
 801f27c:	10624dd3 	.word	0x10624dd3
 801f280:	20003e78 	.word	0x20003e78
 801f284:	42700000 	.word	0x42700000
 801f288:	20003e84 	.word	0x20003e84

0801f28c <st_rpm_changed>:

// Called by spindle_set_state() to inform about RPM changes.
// Used by st_prep_buffer() to determine if spindle needs update when dynamic RPM is called for.
void st_rpm_changed (float rpm)
{
    prep.current_spindle_rpm = rpm;
 801f28c:	4b01      	ldr	r3, [pc, #4]	; (801f294 <st_rpm_changed+0x8>)
 801f28e:	ed83 0a13 	vstr	s0, [r3, #76]	; 0x4c
}
 801f292:	4770      	bx	lr
 801f294:	20003e90 	.word	0x20003e90

0801f298 <st_update_plan_block_parameters>:

// Called by planner_recalculate() when the executing block is updated by the new plan.
void st_update_plan_block_parameters (void)
{
    if (pl_block != NULL) { // Ignore if at start of a new block.
 801f298:	4b08      	ldr	r3, [pc, #32]	; (801f2bc <st_update_plan_block_parameters+0x24>)
 801f29a:	6819      	ldr	r1, [r3, #0]
 801f29c:	b169      	cbz	r1, 801f2ba <st_update_plan_block_parameters+0x22>
        prep.recalculate.velocity_profile = On;
 801f29e:	4b08      	ldr	r3, [pc, #32]	; (801f2c0 <st_update_plan_block_parameters+0x28>)
 801f2a0:	781a      	ldrb	r2, [r3, #0]
 801f2a2:	f042 0201 	orr.w	r2, r2, #1
 801f2a6:	701a      	strb	r2, [r3, #0]
        pl_block->entry_speed_sqr = prep.current_speed * prep.current_speed; // Update entry speed.
 801f2a8:	edd3 7a0b 	vldr	s15, [r3, #44]	; 0x2c
 801f2ac:	ee67 7aa7 	vmul.f32	s15, s15, s15
 801f2b0:	edc1 7a07 	vstr	s15, [r1, #28]
        pl_block = NULL; // Flag st_prep_segment() to load and check active velocity profile.
 801f2b4:	4b01      	ldr	r3, [pc, #4]	; (801f2bc <st_update_plan_block_parameters+0x24>)
 801f2b6:	2200      	movs	r2, #0
 801f2b8:	601a      	str	r2, [r3, #0]
    }
}
 801f2ba:	4770      	bx	lr
 801f2bc:	20003e8c 	.word	0x20003e8c
 801f2c0:	20003e90 	.word	0x20003e90

0801f2c4 <st_parking_setup_buffer>:

// Changes the run state of the step segment buffer to execute the special parking motion.
void st_parking_setup_buffer (void)
{
 801f2c4:	b530      	push	{r4, r5, lr}
    // Store step execution data of partially completed block, if necessary.
    if (prep.recalculate.hold_partial_block && !prep.recalculate.parking) {
 801f2c6:	4b1b      	ldr	r3, [pc, #108]	; (801f334 <st_parking_setup_buffer+0x70>)
 801f2c8:	781b      	ldrb	r3, [r3, #0]
 801f2ca:	f003 0306 	and.w	r3, r3, #6
 801f2ce:	2b02      	cmp	r3, #2
 801f2d0:	d00c      	beq.n	801f2ec <st_parking_setup_buffer+0x28>
        prep.last_steps_remaining = prep.steps_remaining;
        prep.last_dt_remainder = prep.dt_remainder;
        prep.last_steps_per_mm = prep.steps_per_mm;
    }
    // Set flags to execute a parking motion
    prep.recalculate.parking = On;
 801f2d2:	4b18      	ldr	r3, [pc, #96]	; (801f334 <st_parking_setup_buffer+0x70>)
 801f2d4:	781a      	ldrb	r2, [r3, #0]
 801f2d6:	f042 0204 	orr.w	r2, r2, #4
 801f2da:	701a      	strb	r2, [r3, #0]
    prep.recalculate.velocity_profile = Off;
 801f2dc:	b2d2      	uxtb	r2, r2
 801f2de:	f36f 0200 	bfc	r2, #0, #1
 801f2e2:	701a      	strb	r2, [r3, #0]
    pl_block = NULL; // Always reset parking motion to reload new block.
 801f2e4:	4b14      	ldr	r3, [pc, #80]	; (801f338 <st_parking_setup_buffer+0x74>)
 801f2e6:	2200      	movs	r2, #0
 801f2e8:	601a      	str	r2, [r3, #0]
}
 801f2ea:	bd30      	pop	{r4, r5, pc}
        prep.last_st_block = st_prep_block;
 801f2ec:	4b13      	ldr	r3, [pc, #76]	; (801f33c <st_parking_setup_buffer+0x78>)
 801f2ee:	681d      	ldr	r5, [r3, #0]
 801f2f0:	4b10      	ldr	r3, [pc, #64]	; (801f334 <st_parking_setup_buffer+0x70>)
 801f2f2:	615d      	str	r5, [r3, #20]
        memcpy(&st_hold_block, st_prep_block, sizeof(st_block_t));
 801f2f4:	46ac      	mov	ip, r5
 801f2f6:	4c12      	ldr	r4, [pc, #72]	; (801f340 <st_parking_setup_buffer+0x7c>)
 801f2f8:	3530      	adds	r5, #48	; 0x30
 801f2fa:	46a6      	mov	lr, r4
 801f2fc:	f8dc 0000 	ldr.w	r0, [ip]
 801f300:	f8dc 1004 	ldr.w	r1, [ip, #4]
 801f304:	f8dc 2008 	ldr.w	r2, [ip, #8]
 801f308:	f8dc 300c 	ldr.w	r3, [ip, #12]
 801f30c:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 801f310:	f10c 0c10 	add.w	ip, ip, #16
 801f314:	4674      	mov	r4, lr
 801f316:	45ac      	cmp	ip, r5
 801f318:	d1ef      	bne.n	801f2fa <st_parking_setup_buffer+0x36>
 801f31a:	f8dc 0000 	ldr.w	r0, [ip]
 801f31e:	f8dc 1004 	ldr.w	r1, [ip, #4]
 801f322:	c403      	stmia	r4!, {r0, r1}
        prep.last_steps_remaining = prep.steps_remaining;
 801f324:	4b03      	ldr	r3, [pc, #12]	; (801f334 <st_parking_setup_buffer+0x70>)
 801f326:	689a      	ldr	r2, [r3, #8]
 801f328:	619a      	str	r2, [r3, #24]
        prep.last_dt_remainder = prep.dt_remainder;
 801f32a:	685a      	ldr	r2, [r3, #4]
 801f32c:	621a      	str	r2, [r3, #32]
        prep.last_steps_per_mm = prep.steps_per_mm;
 801f32e:	68da      	ldr	r2, [r3, #12]
 801f330:	61da      	str	r2, [r3, #28]
 801f332:	e7ce      	b.n	801f2d2 <st_parking_setup_buffer+0xe>
 801f334:	20003e90 	.word	0x20003e90
 801f338:	20003e8c 	.word	0x20003e8c
 801f33c:	20004358 	.word	0x20004358
 801f340:	20004320 	.word	0x20004320

0801f344 <st_parking_restore_buffer>:

// Restores the step segment buffer to the normal run state after a parking motion.
void st_parking_restore_buffer (void)
{
    // Restore step execution data and flags of partially completed block, if necessary.
    if (prep.recalculate.hold_partial_block) {
 801f344:	4b1e      	ldr	r3, [pc, #120]	; (801f3c0 <st_parking_restore_buffer+0x7c>)
 801f346:	781b      	ldrb	r3, [r3, #0]
 801f348:	f013 0f02 	tst.w	r3, #2
 801f34c:	d106      	bne.n	801f35c <st_parking_restore_buffer+0x18>
        prep.steps_per_mm = prep.last_steps_per_mm;
        prep.recalculate.flags = 0;
        prep.recalculate.hold_partial_block = prep.recalculate.velocity_profile = On;
        prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR / prep.steps_per_mm; // Recompute this value.
    } else
        prep.recalculate.flags = 0;
 801f34e:	4b1c      	ldr	r3, [pc, #112]	; (801f3c0 <st_parking_restore_buffer+0x7c>)
 801f350:	2200      	movs	r2, #0
 801f352:	701a      	strb	r2, [r3, #0]

    pl_block = NULL; // Set to reload next block.
 801f354:	4b1b      	ldr	r3, [pc, #108]	; (801f3c4 <st_parking_restore_buffer+0x80>)
 801f356:	2200      	movs	r2, #0
 801f358:	601a      	str	r2, [r3, #0]
 801f35a:	4770      	bx	lr
{
 801f35c:	b530      	push	{r4, r5, lr}
        memcpy(prep.last_st_block, &st_hold_block, sizeof(st_block_t));
 801f35e:	4d1a      	ldr	r5, [pc, #104]	; (801f3c8 <st_parking_restore_buffer+0x84>)
 801f360:	4b17      	ldr	r3, [pc, #92]	; (801f3c0 <st_parking_restore_buffer+0x7c>)
 801f362:	695c      	ldr	r4, [r3, #20]
 801f364:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 801f368:	46ac      	mov	ip, r5
 801f36a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801f36e:	6020      	str	r0, [r4, #0]
 801f370:	6061      	str	r1, [r4, #4]
 801f372:	60a2      	str	r2, [r4, #8]
 801f374:	60e3      	str	r3, [r4, #12]
 801f376:	4665      	mov	r5, ip
 801f378:	3410      	adds	r4, #16
 801f37a:	45f4      	cmp	ip, lr
 801f37c:	d1f4      	bne.n	801f368 <st_parking_restore_buffer+0x24>
 801f37e:	cd03      	ldmia	r5!, {r0, r1}
 801f380:	6020      	str	r0, [r4, #0]
 801f382:	6061      	str	r1, [r4, #4]
        st_prep_block = prep.last_st_block;
 801f384:	4b0e      	ldr	r3, [pc, #56]	; (801f3c0 <st_parking_restore_buffer+0x7c>)
 801f386:	6959      	ldr	r1, [r3, #20]
 801f388:	4a10      	ldr	r2, [pc, #64]	; (801f3cc <st_parking_restore_buffer+0x88>)
 801f38a:	6011      	str	r1, [r2, #0]
        prep.steps_remaining = prep.last_steps_remaining;
 801f38c:	699a      	ldr	r2, [r3, #24]
 801f38e:	609a      	str	r2, [r3, #8]
        prep.dt_remainder = prep.last_dt_remainder;
 801f390:	6a1a      	ldr	r2, [r3, #32]
 801f392:	605a      	str	r2, [r3, #4]
        prep.steps_per_mm = prep.last_steps_per_mm;
 801f394:	edd3 7a07 	vldr	s15, [r3, #28]
 801f398:	edc3 7a03 	vstr	s15, [r3, #12]
        prep.recalculate.flags = 0;
 801f39c:	2200      	movs	r2, #0
 801f39e:	701a      	strb	r2, [r3, #0]
        prep.recalculate.hold_partial_block = prep.recalculate.velocity_profile = On;
 801f3a0:	2201      	movs	r2, #1
 801f3a2:	701a      	strb	r2, [r3, #0]
 801f3a4:	b2d2      	uxtb	r2, r2
 801f3a6:	f042 0202 	orr.w	r2, r2, #2
 801f3aa:	701a      	strb	r2, [r3, #0]
        prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR / prep.steps_per_mm; // Recompute this value.
 801f3ac:	eef7 6a04 	vmov.f32	s13, #116	; 0x3fa00000  1.250
 801f3b0:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 801f3b4:	ed83 7a04 	vstr	s14, [r3, #16]
    pl_block = NULL; // Set to reload next block.
 801f3b8:	4b02      	ldr	r3, [pc, #8]	; (801f3c4 <st_parking_restore_buffer+0x80>)
 801f3ba:	2200      	movs	r2, #0
 801f3bc:	601a      	str	r2, [r3, #0]
}
 801f3be:	bd30      	pop	{r4, r5, pc}
 801f3c0:	20003e90 	.word	0x20003e90
 801f3c4:	20003e8c 	.word	0x20003e8c
 801f3c8:	20004320 	.word	0x20004320
 801f3cc:	20004358 	.word	0x20004358

0801f3d0 <st_prep_buffer>:
   NOTE: Computation units are in steps, millimeters, and minutes.
*/
void st_prep_buffer (void)
{
    // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
    if (sys.step_control.end_motion)
 801f3d0:	4bb2      	ldr	r3, [pc, #712]	; (801f69c <st_prep_buffer+0x2cc>)
 801f3d2:	7e1b      	ldrb	r3, [r3, #24]
 801f3d4:	f013 0f01 	tst.w	r3, #1
 801f3d8:	d103      	bne.n	801f3e2 <st_prep_buffer+0x12>
{
 801f3da:	b570      	push	{r4, r5, r6, lr}
 801f3dc:	ed2d 8b04 	vpush	{d8-d9}
 801f3e0:	e388      	b.n	801faf4 <st_prep_buffer+0x724>
 801f3e2:	4770      	bx	lr
        // Determine if we need to load a new planner block or if the block needs to be recomputed.
        if (pl_block == NULL) {

            // Query planner for a queued block

            pl_block = sys.step_control.execute_sys_motion ? plan_get_system_motion_block() : plan_get_current_block();
 801f3e4:	4bad      	ldr	r3, [pc, #692]	; (801f69c <st_prep_buffer+0x2cc>)
 801f3e6:	7e1b      	ldrb	r3, [r3, #24]
 801f3e8:	f013 0f04 	tst.w	r3, #4
 801f3ec:	d01b      	beq.n	801f426 <st_prep_buffer+0x56>
 801f3ee:	f7f7 f95b 	bl	80166a8 <plan_get_system_motion_block>
 801f3f2:	4604      	mov	r4, r0
 801f3f4:	4baa      	ldr	r3, [pc, #680]	; (801f6a0 <st_prep_buffer+0x2d0>)
 801f3f6:	601c      	str	r4, [r3, #0]

            if (pl_block == NULL)
 801f3f8:	2c00      	cmp	r4, #0
 801f3fa:	f000 83c2 	beq.w	801fb82 <st_prep_buffer+0x7b2>
                return; // No planner blocks. Exit.

            // Check if we need to only recompute the velocity profile or load a new block.
            if (prep.recalculate.velocity_profile) {
 801f3fe:	4ba9      	ldr	r3, [pc, #676]	; (801f6a4 <st_prep_buffer+0x2d4>)
 801f400:	7819      	ldrb	r1, [r3, #0]
 801f402:	f011 0f01 	tst.w	r1, #1
 801f406:	d055      	beq.n	801f4b4 <st_prep_buffer+0xe4>
                if(settings.parking.flags.enabled) {
 801f408:	4ba7      	ldr	r3, [pc, #668]	; (801f6a8 <st_prep_buffer+0x2d8>)
 801f40a:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 801f40e:	f013 0f01 	tst.w	r3, #1
 801f412:	d010      	beq.n	801f436 <st_prep_buffer+0x66>
                    if (prep.recalculate.parking)
 801f414:	f011 0f04 	tst.w	r1, #4
 801f418:	d009      	beq.n	801f42e <st_prep_buffer+0x5e>
                        prep.recalculate.velocity_profile = Off;
 801f41a:	4ba2      	ldr	r3, [pc, #648]	; (801f6a4 <st_prep_buffer+0x2d4>)
 801f41c:	781a      	ldrb	r2, [r3, #0]
 801f41e:	f36f 0200 	bfc	r2, #0, #1
 801f422:	701a      	strb	r2, [r3, #0]
 801f424:	e00a      	b.n	801f43c <st_prep_buffer+0x6c>
            pl_block = sys.step_control.execute_sys_motion ? plan_get_system_motion_block() : plan_get_current_block();
 801f426:	f7f7 f945 	bl	80166b4 <plan_get_current_block>
 801f42a:	4604      	mov	r4, r0
 801f42c:	e7e2      	b.n	801f3f4 <st_prep_buffer+0x24>
                    else
                        prep.recalculate.flags = 0;
 801f42e:	4b9d      	ldr	r3, [pc, #628]	; (801f6a4 <st_prep_buffer+0x2d4>)
 801f430:	2200      	movs	r2, #0
 801f432:	701a      	strb	r2, [r3, #0]
 801f434:	e002      	b.n	801f43c <st_prep_buffer+0x6c>
                } else
                    prep.recalculate.flags = 0;
 801f436:	4b9b      	ldr	r3, [pc, #620]	; (801f6a4 <st_prep_buffer+0x2d4>)
 801f438:	2200      	movs	r2, #0
 801f43a:	701a      	strb	r2, [r3, #0]
             Compute the velocity profile of a new planner block based on its entry and exit
             speeds, or recompute the profile of a partially-completed planner block if the
             planner has updated it. For a commanded forced-deceleration, such as from a feed
             hold, override the planner velocities and decelerate to the target exit speed.
            */
            prep.mm_complete = 0.0f; // Default velocity profile complete at 0.0mm from end of block.
 801f43c:	4b99      	ldr	r3, [pc, #612]	; (801f6a4 <st_prep_buffer+0x2d4>)
 801f43e:	2200      	movs	r2, #0
 801f440:	629a      	str	r2, [r3, #40]	; 0x28
            float inv_2_accel = 0.5f / pl_block->acceleration;
 801f442:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
 801f446:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 801f44a:	ee87 8a27 	vdiv.f32	s16, s14, s15

            if (sys.step_control.execute_hold) { // [Forced Deceleration to Zero Velocity]
 801f44e:	4b93      	ldr	r3, [pc, #588]	; (801f69c <st_prep_buffer+0x2cc>)
 801f450:	7e1b      	ldrb	r3, [r3, #24]
 801f452:	f013 0f02 	tst.w	r3, #2
 801f456:	f000 80b6 	beq.w	801f5c6 <st_prep_buffer+0x1f6>
                // Compute velocity profile parameters for a feed hold in-progress. This profile overrides
                // the planner block profile, enforcing a deceleration to zero speed.
                prep.ramp_type = Ramp_Decel;
 801f45a:	4b92      	ldr	r3, [pc, #584]	; (801f6a4 <st_prep_buffer+0x2d4>)
 801f45c:	2202      	movs	r2, #2
 801f45e:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
                // Compute decelerate distance relative to end of block.
                float decel_dist = pl_block->millimeters - inv_2_accel * pl_block->entry_speed_sqr;
 801f462:	ed94 7a0a 	vldr	s14, [r4, #40]	; 0x28
 801f466:	ed94 0a07 	vldr	s0, [r4, #28]
 801f46a:	ee60 7a08 	vmul.f32	s15, s0, s16
 801f46e:	ee77 7a67 	vsub.f32	s15, s14, s15
                if (decel_dist < 0.0f) {
 801f472:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801f476:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f47a:	f100 8096 	bmi.w	801f5aa <st_prep_buffer+0x1da>
                    // Deceleration through entire planner block. End of feed hold is not in this block.
                    prep.exit_speed = sqrtf(pl_block->entry_speed_sqr - 2.0f * pl_block->acceleration * pl_block->millimeters);
                } else {
                    prep.mm_complete = decel_dist; // End of feed hold.
 801f47e:	4b89      	ldr	r3, [pc, #548]	; (801f6a4 <st_prep_buffer+0x2d4>)
 801f480:	edc3 7a0a 	vstr	s15, [r3, #40]	; 0x28
                    prep.exit_speed = 0.0f;
 801f484:	2200      	movs	r2, #0
 801f486:	635a      	str	r2, [r3, #52]	; 0x34
                    // prep.decelerate_after = 0.0f;
                    prep.maximum_speed = prep.exit_speed;
                }
            }

            if(state_get() != STATE_HOMING)
 801f488:	f7ff f8ac 	bl	801e5e4 <state_get>
 801f48c:	2804      	cmp	r0, #4
 801f48e:	d00d      	beq.n	801f4ac <st_prep_buffer+0xdc>
                sys.step_control.update_spindle_rpm |= pl_block->spindle.hal->cap.laser; // Force update whenever updating block in laser mode.
 801f490:	4b83      	ldr	r3, [pc, #524]	; (801f6a0 <st_prep_buffer+0x2d0>)
 801f492:	681b      	ldr	r3, [r3, #0]
 801f494:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801f496:	7a5a      	ldrb	r2, [r3, #9]
 801f498:	f3c2 02c0 	ubfx	r2, r2, #3, #1
 801f49c:	497f      	ldr	r1, [pc, #508]	; (801f69c <st_prep_buffer+0x2cc>)
 801f49e:	7e0b      	ldrb	r3, [r1, #24]
 801f4a0:	f3c3 00c0 	ubfx	r0, r3, #3, #1
 801f4a4:	4302      	orrs	r2, r0
 801f4a6:	f362 03c3 	bfi	r3, r2, #3, #1
 801f4aa:	760b      	strb	r3, [r1, #24]

            probe_asserted = false;
 801f4ac:	4b7f      	ldr	r3, [pc, #508]	; (801f6ac <st_prep_buffer+0x2dc>)
 801f4ae:	2200      	movs	r2, #0
 801f4b0:	701a      	strb	r2, [r3, #0]
 801f4b2:	e32a      	b.n	801fb0a <st_prep_buffer+0x73a>
                st_prep_block = st_prep_block->next;
 801f4b4:	4b7e      	ldr	r3, [pc, #504]	; (801f6b0 <st_prep_buffer+0x2e0>)
 801f4b6:	681a      	ldr	r2, [r3, #0]
 801f4b8:	6855      	ldr	r5, [r2, #4]
 801f4ba:	601d      	str	r5, [r3, #0]
                uint_fast8_t idx = N_AXIS;
 801f4bc:	2303      	movs	r3, #3
                    idx--;
 801f4be:	3b01      	subs	r3, #1
                    st_prep_block->steps[idx] = pl_block->steps[idx] << MAX_AMASS_LEVEL;
 801f4c0:	f854 2023 	ldr.w	r2, [r4, r3, lsl #2]
 801f4c4:	00d2      	lsls	r2, r2, #3
 801f4c6:	1c98      	adds	r0, r3, #2
 801f4c8:	f845 2020 	str.w	r2, [r5, r0, lsl #2]
                } while(idx);
 801f4cc:	2b00      	cmp	r3, #0
 801f4ce:	d1f6      	bne.n	801f4be <st_prep_buffer+0xee>
                st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
 801f4d0:	68e3      	ldr	r3, [r4, #12]
 801f4d2:	00db      	lsls	r3, r3, #3
 801f4d4:	616b      	str	r3, [r5, #20]
                st_prep_block->direction_bits = pl_block->direction_bits;
 801f4d6:	7c23      	ldrb	r3, [r4, #16]
 801f4d8:	762b      	strb	r3, [r5, #24]
                st_prep_block->programmed_rate = pl_block->programmed_rate;
 801f4da:	6b63      	ldr	r3, [r4, #52]	; 0x34
 801f4dc:	626b      	str	r3, [r5, #36]	; 0x24
                st_prep_block->millimeters = pl_block->millimeters;
 801f4de:	ed94 7a0a 	vldr	s14, [r4, #40]	; 0x28
 801f4e2:	ed85 7a08 	vstr	s14, [r5, #32]
                st_prep_block->steps_per_mm = (float)pl_block->step_event_count / pl_block->millimeters;
 801f4e6:	edd4 7a03 	vldr	s15, [r4, #12]
 801f4ea:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801f4ee:	eec7 6a87 	vdiv.f32	s13, s15, s14
 801f4f2:	edc5 6a07 	vstr	s13, [r5, #28]
                st_prep_block->output_commands = pl_block->output_commands;
 801f4f6:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 801f4f8:	62eb      	str	r3, [r5, #44]	; 0x2c
                st_prep_block->overrides = pl_block->overrides;
 801f4fa:	7c63      	ldrb	r3, [r4, #17]
 801f4fc:	766b      	strb	r3, [r5, #25]
                st_prep_block->backlash_motion = pl_block->condition.backlash_motion;
 801f4fe:	7d23      	ldrb	r3, [r4, #20]
 801f500:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 801f504:	f885 3030 	strb.w	r3, [r5, #48]	; 0x30
                st_prep_block->message = pl_block->message;
 801f508:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 801f50a:	62ab      	str	r3, [r5, #40]	; 0x28
                pl_block->message= NULL;
 801f50c:	2300      	movs	r3, #0
 801f50e:	64a3      	str	r3, [r4, #72]	; 0x48
                prep.steps_per_mm = st_prep_block->steps_per_mm;
 801f510:	edd5 7a07 	vldr	s15, [r5, #28]
 801f514:	4b63      	ldr	r3, [pc, #396]	; (801f6a4 <st_prep_buffer+0x2d4>)
 801f516:	edc3 7a03 	vstr	s15, [r3, #12]
                prep.steps_remaining = pl_block->step_event_count;
 801f51a:	68e2      	ldr	r2, [r4, #12]
 801f51c:	609a      	str	r2, [r3, #8]
                prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR / prep.steps_per_mm;
 801f51e:	eef7 6a04 	vmov.f32	s13, #116	; 0x3fa00000  1.250
 801f522:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 801f526:	ed83 7a04 	vstr	s14, [r3, #16]
                prep.dt_remainder = prep.target_position = 0.0f; // Reset for new segment block
 801f52a:	2200      	movs	r2, #0
 801f52c:	641a      	str	r2, [r3, #64]	; 0x40
 801f52e:	605a      	str	r2, [r3, #4]
                if (sys.step_control.execute_hold || prep.recalculate.decel_override) {
 801f530:	4b5a      	ldr	r3, [pc, #360]	; (801f69c <st_prep_buffer+0x2cc>)
 801f532:	7e1b      	ldrb	r3, [r3, #24]
 801f534:	f013 0f02 	tst.w	r3, #2
 801f538:	d102      	bne.n	801f540 <st_prep_buffer+0x170>
 801f53a:	f011 0f08 	tst.w	r1, #8
 801f53e:	d022      	beq.n	801f586 <st_prep_buffer+0x1b6>
                    prep.current_speed = prep.exit_speed;
 801f540:	4b58      	ldr	r3, [pc, #352]	; (801f6a4 <st_prep_buffer+0x2d4>)
 801f542:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
 801f546:	edc3 7a0b 	vstr	s15, [r3, #44]	; 0x2c
                    pl_block->entry_speed_sqr = prep.exit_speed * prep.exit_speed;
 801f54a:	ee67 7aa7 	vmul.f32	s15, s15, s15
 801f54e:	edc4 7a07 	vstr	s15, [r4, #28]
                    prep.recalculate.decel_override = Off;
 801f552:	781a      	ldrb	r2, [r3, #0]
 801f554:	f36f 02c3 	bfc	r2, #3, #1
 801f558:	701a      	strb	r2, [r3, #0]
                if ((st_prep_block->dynamic_rpm = pl_block->condition.is_rpm_rate_adjusted)) {
 801f55a:	7d23      	ldrb	r3, [r4, #20]
 801f55c:	f3c3 1280 	ubfx	r2, r3, #6, #1
 801f560:	f885 2031 	strb.w	r2, [r5, #49]	; 0x31
 801f564:	f013 0f40 	tst.w	r3, #64	; 0x40
 801f568:	d018      	beq.n	801f59c <st_prep_buffer+0x1cc>
                    prep.inv_feedrate = pl_block->condition.is_laser_ppi_mode ? 1.0f : 1.0f / pl_block->programmed_rate;
 801f56a:	f994 3014 	ldrsb.w	r3, [r4, #20]
 801f56e:	2b00      	cmp	r3, #0
 801f570:	db11      	blt.n	801f596 <st_prep_buffer+0x1c6>
 801f572:	ed94 7a0d 	vldr	s14, [r4, #52]	; 0x34
 801f576:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 801f57a:	eec6 7a87 	vdiv.f32	s15, s13, s14
 801f57e:	4b49      	ldr	r3, [pc, #292]	; (801f6a4 <st_prep_buffer+0x2d4>)
 801f580:	edc3 7a12 	vstr	s15, [r3, #72]	; 0x48
 801f584:	e75a      	b.n	801f43c <st_prep_buffer+0x6c>
                    prep.current_speed = sqrtf(pl_block->entry_speed_sqr);
 801f586:	ed94 0a07 	vldr	s0, [r4, #28]
 801f58a:	f004 fa21 	bl	80239d0 <sqrtf>
 801f58e:	4b45      	ldr	r3, [pc, #276]	; (801f6a4 <st_prep_buffer+0x2d4>)
 801f590:	ed83 0a0b 	vstr	s0, [r3, #44]	; 0x2c
 801f594:	e7e1      	b.n	801f55a <st_prep_buffer+0x18a>
                    prep.inv_feedrate = pl_block->condition.is_laser_ppi_mode ? 1.0f : 1.0f / pl_block->programmed_rate;
 801f596:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 801f59a:	e7f0      	b.n	801f57e <st_prep_buffer+0x1ae>
                    st_prep_block->dynamic_rpm = !!pl_block->spindle.css;
 801f59c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 801f59e:	3b00      	subs	r3, #0
 801f5a0:	bf18      	it	ne
 801f5a2:	2301      	movne	r3, #1
 801f5a4:	f885 3031 	strb.w	r3, [r5, #49]	; 0x31
 801f5a8:	e748      	b.n	801f43c <st_prep_buffer+0x6c>
                    prep.exit_speed = sqrtf(pl_block->entry_speed_sqr - 2.0f * pl_block->acceleration * pl_block->millimeters);
 801f5aa:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
 801f5ae:	ee77 7aa7 	vadd.f32	s15, s15, s15
 801f5b2:	ee27 7a27 	vmul.f32	s14, s14, s15
 801f5b6:	ee30 0a47 	vsub.f32	s0, s0, s14
 801f5ba:	f004 fa09 	bl	80239d0 <sqrtf>
 801f5be:	4b39      	ldr	r3, [pc, #228]	; (801f6a4 <st_prep_buffer+0x2d4>)
 801f5c0:	ed83 0a0d 	vstr	s0, [r3, #52]	; 0x34
 801f5c4:	e760      	b.n	801f488 <st_prep_buffer+0xb8>
                prep.ramp_type = Ramp_Accel; // Initialize as acceleration ramp.
 801f5c6:	4a37      	ldr	r2, [pc, #220]	; (801f6a4 <st_prep_buffer+0x2d4>)
 801f5c8:	2100      	movs	r1, #0
 801f5ca:	f882 1024 	strb.w	r1, [r2, #36]	; 0x24
                prep.accelerate_until = pl_block->millimeters;
 801f5ce:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 801f5d0:	6391      	str	r1, [r2, #56]	; 0x38
                if (sys.step_control.execute_sys_motion)
 801f5d2:	f013 0f04 	tst.w	r3, #4
 801f5d6:	d03e      	beq.n	801f656 <st_prep_buffer+0x286>
                    prep.exit_speed = exit_speed_sqr = 0.0f; // Enforce stop at end of system motion.
 801f5d8:	eddf 8a36 	vldr	s17, [pc, #216]	; 801f6b4 <st_prep_buffer+0x2e4>
 801f5dc:	edc2 8a0d 	vstr	s17, [r2, #52]	; 0x34
                float nominal_speed = plan_compute_profile_nominal_speed(pl_block);
 801f5e0:	4c2f      	ldr	r4, [pc, #188]	; (801f6a0 <st_prep_buffer+0x2d0>)
 801f5e2:	6820      	ldr	r0, [r4, #0]
 801f5e4:	f7f7 f896 	bl	8016714 <plan_compute_profile_nominal_speed>
                float nominal_speed_sqr = nominal_speed * nominal_speed;
 801f5e8:	ee60 6a00 	vmul.f32	s13, s0, s0
                float intersect_distance = 0.5f * (pl_block->millimeters + inv_2_accel * (pl_block->entry_speed_sqr - exit_speed_sqr));
 801f5ec:	6823      	ldr	r3, [r4, #0]
 801f5ee:	edd3 7a0a 	vldr	s15, [r3, #40]	; 0x28
 801f5f2:	ed93 7a07 	vldr	s14, [r3, #28]
 801f5f6:	ee37 7a68 	vsub.f32	s14, s14, s17
 801f5fa:	ee27 7a08 	vmul.f32	s14, s14, s16
 801f5fe:	ee77 7a87 	vadd.f32	s15, s15, s14
 801f602:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 801f606:	ee67 7a87 	vmul.f32	s15, s15, s14
                prep.target_feed = nominal_speed;
 801f60a:	4a26      	ldr	r2, [pc, #152]	; (801f6a4 <st_prep_buffer+0x2d4>)
 801f60c:	ed82 0a11 	vstr	s0, [r2, #68]	; 0x44
                if (pl_block->entry_speed_sqr > nominal_speed_sqr) { // Only occurs during override reductions.
 801f610:	ed93 7a07 	vldr	s14, [r3, #28]
 801f614:	eeb4 7ae6 	vcmpe.f32	s14, s13
 801f618:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f61c:	dd4c      	ble.n	801f6b8 <st_prep_buffer+0x2e8>
                    prep.accelerate_until = pl_block->millimeters - inv_2_accel * (pl_block->entry_speed_sqr - nominal_speed_sqr);
 801f61e:	ed93 6a0a 	vldr	s12, [r3, #40]	; 0x28
 801f622:	ee77 7a66 	vsub.f32	s15, s14, s13
 801f626:	ee67 7a88 	vmul.f32	s15, s15, s16
 801f62a:	ee76 7a67 	vsub.f32	s15, s12, s15
 801f62e:	edc2 7a0e 	vstr	s15, [r2, #56]	; 0x38
                    if (prep.accelerate_until <= 0.0f) { // Deceleration-only.
 801f632:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801f636:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f63a:	d916      	bls.n	801f66a <st_prep_buffer+0x29a>
                        prep.decelerate_after = inv_2_accel * (nominal_speed_sqr - exit_speed_sqr); // Should always be >= 0.0 due to planner reinit.
 801f63c:	ee76 7ae8 	vsub.f32	s15, s13, s17
 801f640:	ee67 7a88 	vmul.f32	s15, s15, s16
 801f644:	4b17      	ldr	r3, [pc, #92]	; (801f6a4 <st_prep_buffer+0x2d4>)
 801f646:	edc3 7a0f 	vstr	s15, [r3, #60]	; 0x3c
                        prep.maximum_speed = nominal_speed;
 801f64a:	ed83 0a0c 	vstr	s0, [r3, #48]	; 0x30
                        prep.ramp_type = Ramp_DecelOverride;
 801f64e:	2203      	movs	r2, #3
 801f650:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 801f654:	e718      	b.n	801f488 <st_prep_buffer+0xb8>
                    exit_speed_sqr = plan_get_exec_block_exit_speed_sqr();
 801f656:	f7f7 f83b 	bl	80166d0 <plan_get_exec_block_exit_speed_sqr>
 801f65a:	eef0 8a40 	vmov.f32	s17, s0
                    prep.exit_speed = sqrtf(exit_speed_sqr);
 801f65e:	f004 f9b7 	bl	80239d0 <sqrtf>
 801f662:	4b10      	ldr	r3, [pc, #64]	; (801f6a4 <st_prep_buffer+0x2d4>)
 801f664:	ed83 0a0d 	vstr	s0, [r3, #52]	; 0x34
 801f668:	e7ba      	b.n	801f5e0 <st_prep_buffer+0x210>
                        prep.ramp_type = Ramp_Decel;
 801f66a:	4614      	mov	r4, r2
 801f66c:	2202      	movs	r2, #2
 801f66e:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
                        prep.exit_speed = sqrtf(pl_block->entry_speed_sqr - 2.0f * pl_block->acceleration * pl_block->millimeters);
 801f672:	ed93 0a07 	vldr	s0, [r3, #28]
 801f676:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
 801f67a:	ee77 7aa7 	vadd.f32	s15, s15, s15
 801f67e:	ed93 7a0a 	vldr	s14, [r3, #40]	; 0x28
 801f682:	ee67 7a87 	vmul.f32	s15, s15, s14
 801f686:	ee30 0a67 	vsub.f32	s0, s0, s15
 801f68a:	f004 f9a1 	bl	80239d0 <sqrtf>
 801f68e:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
                        prep.recalculate.decel_override = On; // Flag to load next block as deceleration override.
 801f692:	7823      	ldrb	r3, [r4, #0]
 801f694:	f043 0308 	orr.w	r3, r3, #8
 801f698:	7023      	strb	r3, [r4, #0]
 801f69a:	e6f5      	b.n	801f488 <st_prep_buffer+0xb8>
 801f69c:	200036c4 	.word	0x200036c4
 801f6a0:	20003e8c 	.word	0x20003e8c
 801f6a4:	20003e90 	.word	0x20003e90
 801f6a8:	20003b14 	.word	0x20003b14
 801f6ac:	20003ee0 	.word	0x20003ee0
 801f6b0:	20004358 	.word	0x20004358
 801f6b4:	00000000 	.word	0x00000000
                } else if (intersect_distance > 0.0f) {
 801f6b8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801f6bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f6c0:	dd43      	ble.n	801f74a <st_prep_buffer+0x37a>
                    if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
 801f6c2:	ed93 7a0a 	vldr	s14, [r3, #40]	; 0x28
 801f6c6:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801f6ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f6ce:	dd37      	ble.n	801f740 <st_prep_buffer+0x370>
                        prep.decelerate_after = inv_2_accel * (nominal_speed_sqr - exit_speed_sqr);
 801f6d0:	ee36 7ae8 	vsub.f32	s14, s13, s17
 801f6d4:	ee27 7a08 	vmul.f32	s14, s14, s16
 801f6d8:	4ab7      	ldr	r2, [pc, #732]	; (801f9b8 <st_prep_buffer+0x5e8>)
 801f6da:	ed82 7a0f 	vstr	s14, [r2, #60]	; 0x3c
                        if (prep.decelerate_after < intersect_distance) { // Trapezoid type
 801f6de:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801f6e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f6e6:	d519      	bpl.n	801f71c <st_prep_buffer+0x34c>
                            prep.maximum_speed = nominal_speed;
 801f6e8:	ed82 0a0c 	vstr	s0, [r2, #48]	; 0x30
                            if (pl_block->entry_speed_sqr == nominal_speed_sqr) {
 801f6ec:	edd3 7a07 	vldr	s15, [r3, #28]
 801f6f0:	eef4 7a66 	vcmp.f32	s15, s13
 801f6f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f6f8:	d104      	bne.n	801f704 <st_prep_buffer+0x334>
                                prep.ramp_type = Ramp_Cruise;
 801f6fa:	4613      	mov	r3, r2
 801f6fc:	2201      	movs	r2, #1
 801f6fe:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 801f702:	e6c1      	b.n	801f488 <st_prep_buffer+0xb8>
                                prep.accelerate_until -= inv_2_accel * (nominal_speed_sqr - pl_block->entry_speed_sqr);
 801f704:	ee76 7ae7 	vsub.f32	s15, s13, s15
 801f708:	ee67 7a88 	vmul.f32	s15, s15, s16
 801f70c:	4baa      	ldr	r3, [pc, #680]	; (801f9b8 <st_prep_buffer+0x5e8>)
 801f70e:	ed93 7a0e 	vldr	s14, [r3, #56]	; 0x38
 801f712:	ee77 7a67 	vsub.f32	s15, s14, s15
 801f716:	edc3 7a0e 	vstr	s15, [r3, #56]	; 0x38
 801f71a:	e6b5      	b.n	801f488 <st_prep_buffer+0xb8>
                            prep.accelerate_until = prep.decelerate_after = intersect_distance;
 801f71c:	4ca6      	ldr	r4, [pc, #664]	; (801f9b8 <st_prep_buffer+0x5e8>)
 801f71e:	edc4 7a0f 	vstr	s15, [r4, #60]	; 0x3c
 801f722:	edc4 7a0e 	vstr	s15, [r4, #56]	; 0x38
                            prep.maximum_speed = sqrtf(2.0f * pl_block->acceleration * intersect_distance + exit_speed_sqr);
 801f726:	ed93 7a09 	vldr	s14, [r3, #36]	; 0x24
 801f72a:	ee37 7a07 	vadd.f32	s14, s14, s14
 801f72e:	ee27 0a27 	vmul.f32	s0, s14, s15
 801f732:	ee30 0a28 	vadd.f32	s0, s0, s17
 801f736:	f004 f94b 	bl	80239d0 <sqrtf>
 801f73a:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
 801f73e:	e6a3      	b.n	801f488 <st_prep_buffer+0xb8>
                        prep.ramp_type = Ramp_Decel;
 801f740:	4b9d      	ldr	r3, [pc, #628]	; (801f9b8 <st_prep_buffer+0x5e8>)
 801f742:	2202      	movs	r2, #2
 801f744:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 801f748:	e69e      	b.n	801f488 <st_prep_buffer+0xb8>
                    prep.accelerate_until = 0.0f;
 801f74a:	4b9b      	ldr	r3, [pc, #620]	; (801f9b8 <st_prep_buffer+0x5e8>)
 801f74c:	2200      	movs	r2, #0
 801f74e:	639a      	str	r2, [r3, #56]	; 0x38
                    prep.maximum_speed = prep.exit_speed;
 801f750:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 801f752:	631a      	str	r2, [r3, #48]	; 0x30
 801f754:	e698      	b.n	801f488 <st_prep_buffer+0xb8>
        float speed_var; // Speed worker variable
        float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
        float minimum_mm = mm_remaining - prep.req_mm_increment; // Guarantee at least one step.

        if (minimum_mm < 0.0f)
            minimum_mm = 0.0f;
 801f756:	ed9f 5a9b 	vldr	s10, [pc, #620]	; 801f9c4 <st_prep_buffer+0x5f4>
 801f75a:	e1f1      	b.n	801fb40 <st_prep_buffer+0x770>
        do {

            switch (prep.ramp_type) {

                case Ramp_DecelOverride:
                    speed_var = pl_block->acceleration * time_var;
 801f75c:	ed92 6a09 	vldr	s12, [r2, #36]	; 0x24
 801f760:	ee26 6a27 	vmul.f32	s12, s12, s15
                    if ((prep.current_speed - prep.maximum_speed) <= speed_var) {
 801f764:	4b94      	ldr	r3, [pc, #592]	; (801f9b8 <st_prep_buffer+0x5e8>)
 801f766:	edd3 6a0b 	vldr	s13, [r3, #44]	; 0x2c
 801f76a:	edd3 5a0c 	vldr	s11, [r3, #48]	; 0x30
 801f76e:	ee76 4ae5 	vsub.f32	s9, s13, s11
 801f772:	eef4 4ac6 	vcmpe.f32	s9, s12
 801f776:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f77a:	d811      	bhi.n	801f7a0 <st_prep_buffer+0x3d0>
                        // Cruise or cruise-deceleration types only for deceleration override.
                        mm_remaining = prep.accelerate_until;
 801f77c:	ed93 8a0e 	vldr	s16, [r3, #56]	; 0x38
                        time_var = 2.0f * (pl_block->millimeters - mm_remaining) / (prep.current_speed + prep.maximum_speed);
 801f780:	edd2 7a0a 	vldr	s15, [r2, #40]	; 0x28
 801f784:	ee77 7ac8 	vsub.f32	s15, s15, s16
 801f788:	ee37 6aa7 	vadd.f32	s12, s15, s15
 801f78c:	ee76 6aa5 	vadd.f32	s13, s13, s11
 801f790:	eec6 7a26 	vdiv.f32	s15, s12, s13
                        prep.ramp_type = Ramp_Cruise;
 801f794:	2001      	movs	r0, #1
 801f796:	f883 0024 	strb.w	r0, [r3, #36]	; 0x24
                        prep.current_speed = prep.maximum_speed;
 801f79a:	edc3 5a0b 	vstr	s11, [r3, #44]	; 0x2c
 801f79e:	e074      	b.n	801f88a <st_prep_buffer+0x4ba>
                    } else {// Mid-deceleration override ramp.
                        mm_remaining -= time_var * (prep.current_speed - 0.5f * speed_var);
 801f7a0:	eef6 5a00 	vmov.f32	s11, #96	; 0x3f000000  0.5
 801f7a4:	ee66 5a25 	vmul.f32	s11, s12, s11
 801f7a8:	ee76 5ae5 	vsub.f32	s11, s13, s11
 801f7ac:	ee65 5aa7 	vmul.f32	s11, s11, s15
 801f7b0:	ee38 8a65 	vsub.f32	s16, s16, s11
                        prep.current_speed -= speed_var;
 801f7b4:	ee76 6ac6 	vsub.f32	s13, s13, s12
 801f7b8:	4b7f      	ldr	r3, [pc, #508]	; (801f9b8 <st_prep_buffer+0x5e8>)
 801f7ba:	edc3 6a0b 	vstr	s13, [r3, #44]	; 0x2c
 801f7be:	e064      	b.n	801f88a <st_prep_buffer+0x4ba>
                    }
                    break;

                case Ramp_Accel:
                    // NOTE: Acceleration ramp only computes during first do-while loop.
                    speed_var = pl_block->acceleration * time_var;
 801f7c0:	edd2 5a09 	vldr	s11, [r2, #36]	; 0x24
 801f7c4:	ee65 5aa7 	vmul.f32	s11, s11, s15
                    mm_remaining -= time_var * (prep.current_speed + 0.5f * speed_var);
 801f7c8:	4b7b      	ldr	r3, [pc, #492]	; (801f9b8 <st_prep_buffer+0x5e8>)
 801f7ca:	ed93 6a0b 	vldr	s12, [r3, #44]	; 0x2c
 801f7ce:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 801f7d2:	ee65 6aa6 	vmul.f32	s13, s11, s13
 801f7d6:	ee76 6a26 	vadd.f32	s13, s12, s13
 801f7da:	ee66 6aa7 	vmul.f32	s13, s13, s15
 801f7de:	ee38 8a66 	vsub.f32	s16, s16, s13
                    if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
 801f7e2:	edd3 6a0e 	vldr	s13, [r3, #56]	; 0x38
 801f7e6:	eef4 6ac8 	vcmpe.f32	s13, s16
 801f7ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f7ee:	dd1d      	ble.n	801f82c <st_prep_buffer+0x45c>
                        // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
                        mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
                        time_var = 2.0f * (pl_block->millimeters - mm_remaining) / (prep.current_speed + prep.maximum_speed);
 801f7f0:	edd2 7a0a 	vldr	s15, [r2, #40]	; 0x28
 801f7f4:	ee77 7ae6 	vsub.f32	s15, s15, s13
 801f7f8:	ee77 5aa7 	vadd.f32	s11, s15, s15
 801f7fc:	edd3 4a0c 	vldr	s9, [r3, #48]	; 0x30
 801f800:	ee36 6a24 	vadd.f32	s12, s12, s9
 801f804:	eec5 7a86 	vdiv.f32	s15, s11, s12
                        prep.ramp_type = mm_remaining == prep.decelerate_after ? Ramp_Decel : Ramp_Cruise;
 801f808:	ed93 6a0f 	vldr	s12, [r3, #60]	; 0x3c
 801f80c:	eef4 6a46 	vcmp.f32	s13, s12
 801f810:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f814:	d108      	bne.n	801f828 <st_prep_buffer+0x458>
 801f816:	2002      	movs	r0, #2
 801f818:	4b67      	ldr	r3, [pc, #412]	; (801f9b8 <st_prep_buffer+0x5e8>)
 801f81a:	f883 0024 	strb.w	r0, [r3, #36]	; 0x24
                        prep.current_speed = prep.maximum_speed;
 801f81e:	edc3 4a0b 	vstr	s9, [r3, #44]	; 0x2c
                        mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
 801f822:	eeb0 8a66 	vmov.f32	s16, s13
 801f826:	e030      	b.n	801f88a <st_prep_buffer+0x4ba>
                        prep.ramp_type = mm_remaining == prep.decelerate_after ? Ramp_Decel : Ramp_Cruise;
 801f828:	2001      	movs	r0, #1
 801f82a:	e7f5      	b.n	801f818 <st_prep_buffer+0x448>
                    } else // Acceleration only.
                        prep.current_speed += speed_var;
 801f82c:	ee36 6a25 	vadd.f32	s12, s12, s11
 801f830:	4b61      	ldr	r3, [pc, #388]	; (801f9b8 <st_prep_buffer+0x5e8>)
 801f832:	ed83 6a0b 	vstr	s12, [r3, #44]	; 0x2c
 801f836:	e028      	b.n	801f88a <st_prep_buffer+0x4ba>

                case Ramp_Cruise:
                    // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.
                    // NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not change. To
                    //   prevent this, simply enforce a minimum speed threshold in the planner.
                    mm_var = mm_remaining - prep.maximum_speed * time_var;
 801f838:	4b5f      	ldr	r3, [pc, #380]	; (801f9b8 <st_prep_buffer+0x5e8>)
 801f83a:	edd3 5a0c 	vldr	s11, [r3, #48]	; 0x30
 801f83e:	ee65 6aa7 	vmul.f32	s13, s11, s15
 801f842:	ee78 6a66 	vsub.f32	s13, s16, s13
                    if (mm_var < prep.decelerate_after) { // End of cruise.
 801f846:	ed93 6a0f 	vldr	s12, [r3, #60]	; 0x3c
 801f84a:	eeb4 6ae6 	vcmpe.f32	s12, s13
 801f84e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f852:	dd5a      	ble.n	801f90a <st_prep_buffer+0x53a>
                        // Cruise-deceleration junction or end of block.
                        time_var = (mm_remaining - prep.decelerate_after) / prep.maximum_speed;
 801f854:	ee38 8a46 	vsub.f32	s16, s16, s12
 801f858:	eec8 7a25 	vdiv.f32	s15, s16, s11
                        mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
                        prep.ramp_type = Ramp_Decel;
 801f85c:	2002      	movs	r0, #2
 801f85e:	f883 0024 	strb.w	r0, [r3, #36]	; 0x24
                        mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
 801f862:	eeb0 8a46 	vmov.f32	s16, s12
 801f866:	e010      	b.n	801f88a <st_prep_buffer+0x4ba>
                            prep.current_speed -= speed_var;
                            break; // Segment complete. Exit switch-case statement. Continue do-while loop.
                        }
                    }
                    // Otherwise, at end of block or end of forced-deceleration.
                    time_var = 2.0f * (mm_remaining - prep.mm_complete) / (prep.current_speed + prep.exit_speed);
 801f868:	4b53      	ldr	r3, [pc, #332]	; (801f9b8 <st_prep_buffer+0x5e8>)
 801f86a:	ed93 6a0a 	vldr	s12, [r3, #40]	; 0x28
 801f86e:	ee38 8a46 	vsub.f32	s16, s16, s12
 801f872:	ee38 8a08 	vadd.f32	s16, s16, s16
 801f876:	edd3 5a0d 	vldr	s11, [r3, #52]	; 0x34
 801f87a:	ee76 6aa5 	vadd.f32	s13, s13, s11
 801f87e:	eec8 7a26 	vdiv.f32	s15, s16, s13
                    mm_remaining = prep.mm_complete;
                    prep.current_speed = prep.exit_speed;
 801f882:	edc3 5a0b 	vstr	s11, [r3, #44]	; 0x2c
                    mm_remaining = prep.mm_complete;
 801f886:	eeb0 8a46 	vmov.f32	s16, s12
            }

            dt += time_var; // Add computed ramp time to total segment time.
 801f88a:	ee78 8aa7 	vadd.f32	s17, s17, s15

            if (dt < dt_max)
 801f88e:	eeb4 7ae8 	vcmpe.f32	s14, s17
 801f892:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f896:	dd3b      	ble.n	801f910 <st_prep_buffer+0x540>
                time_var = dt_max - dt;// **Incomplete** At ramp junction.
 801f898:	ee77 7a68 	vsub.f32	s15, s14, s17
                    time_var = dt_max - dt;
                } else
                    break; // **Complete** Exit loop. Segment execution time maxed.
            }

        } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
 801f89c:	4b46      	ldr	r3, [pc, #280]	; (801f9b8 <st_prep_buffer+0x5e8>)
 801f89e:	edd3 6a0a 	vldr	s13, [r3, #40]	; 0x28
 801f8a2:	eef4 6ac8 	vcmpe.f32	s13, s16
 801f8a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f8aa:	d53d      	bpl.n	801f928 <st_prep_buffer+0x558>
            switch (prep.ramp_type) {
 801f8ac:	4b42      	ldr	r3, [pc, #264]	; (801f9b8 <st_prep_buffer+0x5e8>)
 801f8ae:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 801f8b2:	2b01      	cmp	r3, #1
 801f8b4:	d0c0      	beq.n	801f838 <st_prep_buffer+0x468>
 801f8b6:	2b03      	cmp	r3, #3
 801f8b8:	f43f af50 	beq.w	801f75c <st_prep_buffer+0x38c>
 801f8bc:	2b00      	cmp	r3, #0
 801f8be:	f43f af7f 	beq.w	801f7c0 <st_prep_buffer+0x3f0>
                    speed_var = pl_block->acceleration * time_var; // Used as delta speed (mm/min)
 801f8c2:	edd2 5a09 	vldr	s11, [r2, #36]	; 0x24
 801f8c6:	ee65 5aa7 	vmul.f32	s11, s11, s15
                    if (prep.current_speed > speed_var) { // Check if at or below zero speed.
 801f8ca:	4b3b      	ldr	r3, [pc, #236]	; (801f9b8 <st_prep_buffer+0x5e8>)
 801f8cc:	edd3 6a0b 	vldr	s13, [r3, #44]	; 0x2c
 801f8d0:	eef4 6ae5 	vcmpe.f32	s13, s11
 801f8d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f8d8:	ddc6      	ble.n	801f868 <st_prep_buffer+0x498>
                        mm_var = mm_remaining - time_var * (prep.current_speed - 0.5f * speed_var); // (mm)
 801f8da:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
 801f8de:	ee25 6a86 	vmul.f32	s12, s11, s12
 801f8e2:	ee36 6ac6 	vsub.f32	s12, s13, s12
 801f8e6:	ee26 6a27 	vmul.f32	s12, s12, s15
 801f8ea:	ee38 6a46 	vsub.f32	s12, s16, s12
                        if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
 801f8ee:	edd3 4a0a 	vldr	s9, [r3, #40]	; 0x28
 801f8f2:	eef4 4ac6 	vcmpe.f32	s9, s12
 801f8f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f8fa:	d5b5      	bpl.n	801f868 <st_prep_buffer+0x498>
                            prep.current_speed -= speed_var;
 801f8fc:	ee76 6ae5 	vsub.f32	s13, s13, s11
 801f900:	edc3 6a0b 	vstr	s13, [r3, #44]	; 0x2c
                            mm_remaining = mm_var;
 801f904:	eeb0 8a46 	vmov.f32	s16, s12
                            break; // Segment complete. Exit switch-case statement. Continue do-while loop.
 801f908:	e7bf      	b.n	801f88a <st_prep_buffer+0x4ba>
                        mm_remaining = mm_var;
 801f90a:	eeb0 8a66 	vmov.f32	s16, s13
 801f90e:	e7bc      	b.n	801f88a <st_prep_buffer+0x4ba>
                if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
 801f910:	eeb4 8ac5 	vcmpe.f32	s16, s10
 801f914:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f918:	dd06      	ble.n	801f928 <st_prep_buffer+0x558>
                    dt_max += DT_SEGMENT;
 801f91a:	eddf 7a28 	vldr	s15, [pc, #160]	; 801f9bc <st_prep_buffer+0x5ec>
 801f91e:	ee37 7a27 	vadd.f32	s14, s14, s15
                    time_var = dt_max - dt;
 801f922:	ee77 7a68 	vsub.f32	s15, s14, s17
 801f926:	e7b9      	b.n	801f89c <st_prep_buffer+0x4cc>

        /* -----------------------------------------------------------------------------------
           Compute spindle spindle speed for step segment
        */

        if (sys.step_control.update_spindle_rpm || st_prep_block->dynamic_rpm) {
 801f928:	4b25      	ldr	r3, [pc, #148]	; (801f9c0 <st_prep_buffer+0x5f0>)
 801f92a:	7e1b      	ldrb	r3, [r3, #24]
 801f92c:	f013 0f08 	tst.w	r3, #8
 801f930:	d103      	bne.n	801f93a <st_prep_buffer+0x56a>
 801f932:	f891 3031 	ldrb.w	r3, [r1, #49]	; 0x31
 801f936:	2b00      	cmp	r3, #0
 801f938:	d06a      	beq.n	801fa10 <st_prep_buffer+0x640>

            float rpm;

            st_prep_block->spindle = pl_block->spindle.hal;
 801f93a:	6c53      	ldr	r3, [r2, #68]	; 0x44
 801f93c:	634b      	str	r3, [r1, #52]	; 0x34

            if (pl_block->spindle.state.on) {
 801f93e:	f892 303c 	ldrb.w	r3, [r2, #60]	; 0x3c
 801f942:	f013 0f01 	tst.w	r3, #1
 801f946:	d03f      	beq.n	801f9c8 <st_prep_buffer+0x5f8>
                if(pl_block->spindle.css) {
 801f948:	6c11      	ldr	r1, [r2, #64]	; 0x40
 801f94a:	b1d9      	cbz	r1, 801f984 <st_prep_buffer+0x5b4>
                    float npos = (float)(pl_block->step_event_count - prep.steps_remaining) / (float)pl_block->step_event_count;
 801f94c:	4b1a      	ldr	r3, [pc, #104]	; (801f9b8 <st_prep_buffer+0x5e8>)
 801f94e:	689b      	ldr	r3, [r3, #8]
 801f950:	68d0      	ldr	r0, [r2, #12]
 801f952:	1ac3      	subs	r3, r0, r3
 801f954:	ee07 3a90 	vmov	s15, r3
 801f958:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801f95c:	ee07 0a10 	vmov	s14, r0
 801f960:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 801f964:	eec7 6a87 	vdiv.f32	s13, s15, s14
                    rpm = spindle_set_rpm(pl_block->spindle.hal,
 801f968:	6c50      	ldr	r0, [r2, #68]	; 0x44
                                           pl_block->spindle.rpm + pl_block->spindle.css->delta_rpm * npos,
 801f96a:	ed92 0a0e 	vldr	s0, [r2, #56]	; 0x38
 801f96e:	edd1 7a02 	vldr	s15, [r1, #8]
 801f972:	ee67 7aa6 	vmul.f32	s15, s15, s13
                                            pl_block->spindle.hal->param->override_pct);
 801f976:	6843      	ldr	r3, [r0, #4]
                    rpm = spindle_set_rpm(pl_block->spindle.hal,
 801f978:	68d9      	ldr	r1, [r3, #12]
 801f97a:	ee30 0a27 	vadd.f32	s0, s0, s15
 801f97e:	f7fe f851 	bl	801da24 <spindle_set_rpm>
 801f982:	e027      	b.n	801f9d4 <st_prep_buffer+0x604>
                } else {
                    // NOTE: Feed and rapid overrides are independent of PWM value and do not alter laser power/rate.
                    // If current_speed is zero, then may need to be rpm_min*(100/MAX_SPINDLE_RPM_OVERRIDE)
                    // but this would be instantaneous only and during a motion. May not matter at all.
                    rpm = spindle_set_rpm(pl_block->spindle.hal,
 801f984:	6c50      	ldr	r0, [r2, #68]	; 0x44
                                           pl_block->condition.is_rpm_rate_adjusted && !pl_block->condition.is_laser_ppi_mode
 801f986:	7d13      	ldrb	r3, [r2, #20]
 801f988:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
                    rpm = spindle_set_rpm(pl_block->spindle.hal,
 801f98c:	2b40      	cmp	r3, #64	; 0x40
 801f98e:	d006      	beq.n	801f99e <st_prep_buffer+0x5ce>
 801f990:	ed92 0a0e 	vldr	s0, [r2, #56]	; 0x38
                                            ? pl_block->spindle.rpm * prep.current_speed * prep.inv_feedrate
                                            : pl_block->spindle.rpm, pl_block->spindle.hal->param->override_pct);
 801f994:	6843      	ldr	r3, [r0, #4]
                    rpm = spindle_set_rpm(pl_block->spindle.hal,
 801f996:	68d9      	ldr	r1, [r3, #12]
 801f998:	f7fe f844 	bl	801da24 <spindle_set_rpm>
 801f99c:	e01a      	b.n	801f9d4 <st_prep_buffer+0x604>
                                            ? pl_block->spindle.rpm * prep.current_speed * prep.inv_feedrate
 801f99e:	ed92 0a0e 	vldr	s0, [r2, #56]	; 0x38
 801f9a2:	4b05      	ldr	r3, [pc, #20]	; (801f9b8 <st_prep_buffer+0x5e8>)
 801f9a4:	edd3 7a0b 	vldr	s15, [r3, #44]	; 0x2c
 801f9a8:	ee20 0a27 	vmul.f32	s0, s0, s15
 801f9ac:	edd3 7a12 	vldr	s15, [r3, #72]	; 0x48
                    rpm = spindle_set_rpm(pl_block->spindle.hal,
 801f9b0:	ee20 0a27 	vmul.f32	s0, s0, s15
 801f9b4:	e7ee      	b.n	801f994 <st_prep_buffer+0x5c4>
 801f9b6:	bf00      	nop
 801f9b8:	20003e90 	.word	0x20003e90
 801f9bc:	392ec33e 	.word	0x392ec33e
 801f9c0:	200036c4 	.word	0x200036c4
 801f9c4:	00000000 	.word	0x00000000
                }
            } else
                pl_block->spindle.hal->param->rpm = rpm = 0.0f;
 801f9c8:	6c53      	ldr	r3, [r2, #68]	; 0x44
 801f9ca:	685b      	ldr	r3, [r3, #4]
 801f9cc:	ed1f 0a03 	vldr	s0, [pc, #-12]	; 801f9c4 <st_prep_buffer+0x5f4>
 801f9d0:	ed83 0a00 	vstr	s0, [r3]

            if(rpm != prep.current_spindle_rpm) {
 801f9d4:	4b8b      	ldr	r3, [pc, #556]	; (801fc04 <st_prep_buffer+0x834>)
 801f9d6:	edd3 7a13 	vldr	s15, [r3, #76]	; 0x4c
 801f9da:	eef4 7a40 	vcmp.f32	s15, s0
 801f9de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f9e2:	d015      	beq.n	801fa10 <st_prep_buffer+0x640>
                if(pl_block->spindle.hal->get_pwm != NULL) {
 801f9e4:	4b88      	ldr	r3, [pc, #544]	; (801fc08 <st_prep_buffer+0x838>)
 801f9e6:	681b      	ldr	r3, [r3, #0]
 801f9e8:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 801f9ea:	6a51      	ldr	r1, [r2, #36]	; 0x24
 801f9ec:	2900      	cmp	r1, #0
 801f9ee:	f000 80ae 	beq.w	801fb4e <st_prep_buffer+0x77e>
                    prep.current_spindle_rpm = rpm;
 801f9f2:	4a84      	ldr	r2, [pc, #528]	; (801fc04 <st_prep_buffer+0x834>)
 801f9f4:	ed82 0a13 	vstr	s0, [r2, #76]	; 0x4c
                    prep_segment->update_pwm = pl_block->spindle.hal->update_pwm;
 801f9f8:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 801f9fa:	6a92      	ldr	r2, [r2, #40]	; 0x28
 801f9fc:	62ea      	str	r2, [r5, #44]	; 0x2c
                    prep_segment->spindle_pwm = pl_block->spindle.hal->get_pwm(rpm);
 801f9fe:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801fa00:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801fa02:	4798      	blx	r3
 801fa04:	61e8      	str	r0, [r5, #28]
                } else {
                    prep_segment->update_rpm = pl_block->spindle.hal->update_rpm;
                    prep.current_spindle_rpm = prep_segment->spindle_rpm = rpm;
                }
                sys.step_control.update_spindle_rpm = Off;
 801fa06:	4b81      	ldr	r3, [pc, #516]	; (801fc0c <st_prep_buffer+0x83c>)
 801fa08:	7e1a      	ldrb	r2, [r3, #24]
 801fa0a:	f36f 02c3 	bfc	r2, #3, #1
 801fa0e:	761a      	strb	r2, [r3, #24]
           However, since floats have only 7.2 significant digits, long moves with extremely
           high step counts can exceed the precision of floats, which can lead to lost steps.
           Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
           supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
        */
        float step_dist_remaining = prep.steps_per_mm * mm_remaining; // Convert mm_remaining to steps
 801fa10:	4e7c      	ldr	r6, [pc, #496]	; (801fc04 <st_prep_buffer+0x834>)
 801fa12:	edd6 9a03 	vldr	s19, [r6, #12]
 801fa16:	ee69 9a88 	vmul.f32	s19, s19, s16
        uint32_t n_steps_remaining = (uint32_t)ceilf(step_dist_remaining); // Round-up current steps remaining
 801fa1a:	eeb0 0a69 	vmov.f32	s0, s19
 801fa1e:	f004 f8e9 	bl	8023bf4 <ceilf>
 801fa22:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 801fa26:	ee17 4a90 	vmov	r4, s15

        prep_segment->n_step = (uint_fast16_t)(prep.steps_remaining - n_steps_remaining); // Compute number of steps to execute.
 801fa2a:	68b3      	ldr	r3, [r6, #8]
 801fa2c:	1b1a      	subs	r2, r3, r4
 801fa2e:	61aa      	str	r2, [r5, #24]

        // Bail if we are at the end of a feed hold and don't have a step to execute.
        if (prep_segment->n_step == 0 && sys.step_control.execute_hold) {
 801fa30:	b92a      	cbnz	r2, 801fa3e <st_prep_buffer+0x66e>
 801fa32:	4a76      	ldr	r2, [pc, #472]	; (801fc0c <st_prep_buffer+0x83c>)
 801fa34:	7e12      	ldrb	r2, [r2, #24]
 801fa36:	f012 0f02 	tst.w	r2, #2
 801fa3a:	f040 8090 	bne.w	801fb5e <st_prep_buffer+0x78e>
        // compensate, we track the time to execute the previous segment's partial step and simply
        // apply it with the partial step distance to the current segment, so that it minutely
        // adjusts the whole segment rate to keep step output exact. These rate adjustments are
        // typically very small and do not adversely effect performance, but ensures that Grbl
        // outputs the exact acceleration and velocity profiles as computed by the planner.
        dt += prep.dt_remainder; // Apply previous segment partial step execute time
 801fa3e:	4a71      	ldr	r2, [pc, #452]	; (801fc04 <st_prep_buffer+0x834>)
 801fa40:	edd2 7a01 	vldr	s15, [r2, #4]
 801fa44:	ee77 8aa8 	vadd.f32	s17, s15, s17
        float inv_rate = dt / ((float)prep.steps_remaining - step_dist_remaining); // Compute adjusted step rate inverse
 801fa48:	ee07 3a90 	vmov	s15, r3
 801fa4c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801fa50:	ee77 7ae9 	vsub.f32	s15, s15, s19
 801fa54:	ee88 9aa7 	vdiv.f32	s18, s17, s15

        // Compute timer ticks per step for the prepped segment.
        uint32_t cycles = (uint32_t)ceilf(cycles_per_min * inv_rate); // (cycles/step)
 801fa58:	4b6d      	ldr	r3, [pc, #436]	; (801fc10 <st_prep_buffer+0x840>)
 801fa5a:	ed93 0a00 	vldr	s0, [r3]
 801fa5e:	ee29 0a00 	vmul.f32	s0, s18, s0
 801fa62:	f004 f8c7 	bl	8023bf4 <ceilf>
 801fa66:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 801fa6a:	ee17 2a90 	vmov	r2, s15

        // Record end position of segment relative to block if spindle synchronized motion
        if((prep_segment->spindle_sync = pl_block->spindle.state.synchronized)) {
 801fa6e:	4b66      	ldr	r3, [pc, #408]	; (801fc08 <st_prep_buffer+0x838>)
 801fa70:	6818      	ldr	r0, [r3, #0]
 801fa72:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 801fa76:	f3c3 11c0 	ubfx	r1, r3, #7, #1
 801fa7a:	f885 1024 	strb.w	r1, [r5, #36]	; 0x24
 801fa7e:	09db      	lsrs	r3, r3, #7
 801fa80:	d014      	beq.n	801faac <st_prep_buffer+0x6dc>
            prep.target_position += dt * prep.target_feed;
 801fa82:	4b60      	ldr	r3, [pc, #384]	; (801fc04 <st_prep_buffer+0x834>)
 801fa84:	ed93 7a11 	vldr	s14, [r3, #68]	; 0x44
 801fa88:	ee27 7a28 	vmul.f32	s14, s14, s17
 801fa8c:	edd3 7a10 	vldr	s15, [r3, #64]	; 0x40
 801fa90:	ee77 7a87 	vadd.f32	s15, s15, s14
 801fa94:	edc3 7a10 	vstr	s15, [r3, #64]	; 0x40
            prep_segment->cruising = prep.ramp_type == Ramp_Cruise;
 801fa98:	f893 1024 	ldrb.w	r1, [r3, #36]	; 0x24
 801fa9c:	2901      	cmp	r1, #1
 801fa9e:	bf14      	ite	ne
 801faa0:	2100      	movne	r1, #0
 801faa2:	2101      	moveq	r1, #1
 801faa4:	f885 1025 	strb.w	r1, [r5, #37]	; 0x25
            prep_segment->target_position = prep.target_position; //st_prep_block->millimeters - pl_block->millimeters;
 801faa8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801faaa:	616b      	str	r3, [r5, #20]
        }

      #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
        // Compute step timing and multi-axis smoothing level.
        // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.
        if (cycles < amass.level_1)
 801faac:	4b59      	ldr	r3, [pc, #356]	; (801fc14 <st_prep_buffer+0x844>)
 801faae:	681b      	ldr	r3, [r3, #0]
 801fab0:	4293      	cmp	r3, r2
 801fab2:	d969      	bls.n	801fb88 <st_prep_buffer+0x7b8>
            prep_segment->amass_level = 0;
 801fab4:	2300      	movs	r3, #0
 801fab6:	62ab      	str	r3, [r5, #40]	; 0x28
            cycles >>= prep_segment->amass_level;
            prep_segment->n_step <<= prep_segment->amass_level;
        }
      #endif

        prep_segment->cycles_per_tick = cycles;
 801fab8:	60ea      	str	r2, [r5, #12]
        prep_segment->current_rate = prep.current_speed;
 801faba:	4b52      	ldr	r3, [pc, #328]	; (801fc04 <st_prep_buffer+0x834>)
 801fabc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801fabe:	612a      	str	r2, [r5, #16]

        // Segment complete! Increment segment pointers, so stepper ISR can immediately execute it.
        segment_buffer_head = segment_next_head;
 801fac0:	4a55      	ldr	r2, [pc, #340]	; (801fc18 <st_prep_buffer+0x848>)
 801fac2:	6811      	ldr	r1, [r2, #0]
 801fac4:	4d55      	ldr	r5, [pc, #340]	; (801fc1c <st_prep_buffer+0x84c>)
 801fac6:	6029      	str	r1, [r5, #0]
        segment_next_head = segment_next_head->next;
 801fac8:	6849      	ldr	r1, [r1, #4]
 801faca:	6011      	str	r1, [r2, #0]

        // Update the appropriate planner and segment data.
        pl_block->millimeters = mm_remaining;
 801facc:	ed80 8a0a 	vstr	s16, [r0, #40]	; 0x28
        prep.steps_remaining = n_steps_remaining;
 801fad0:	609c      	str	r4, [r3, #8]
        prep.dt_remainder = ((float)n_steps_remaining - step_dist_remaining) * inv_rate;
 801fad2:	ee07 4a90 	vmov	s15, r4
 801fad6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801fada:	ee77 7ae9 	vsub.f32	s15, s15, s19
 801fade:	ee67 7a89 	vmul.f32	s15, s15, s18
 801fae2:	edc3 7a01 	vstr	s15, [r3, #4]

        // Check for exit conditions and flag to load next planner block.
        if (mm_remaining <= prep.mm_complete) {
 801fae6:	edd3 7a0a 	vldr	s15, [r3, #40]	; 0x28
 801faea:	eef4 7ac8 	vcmpe.f32	s15, s16
 801faee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801faf2:	da5c      	bge.n	801fbae <st_prep_buffer+0x7de>
    while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
 801faf4:	4b4a      	ldr	r3, [pc, #296]	; (801fc20 <st_prep_buffer+0x850>)
 801faf6:	681a      	ldr	r2, [r3, #0]
 801faf8:	4b47      	ldr	r3, [pc, #284]	; (801fc18 <st_prep_buffer+0x848>)
 801fafa:	681b      	ldr	r3, [r3, #0]
 801fafc:	429a      	cmp	r2, r3
 801fafe:	d040      	beq.n	801fb82 <st_prep_buffer+0x7b2>
        if (pl_block == NULL) {
 801fb00:	4b41      	ldr	r3, [pc, #260]	; (801fc08 <st_prep_buffer+0x838>)
 801fb02:	681b      	ldr	r3, [r3, #0]
 801fb04:	2b00      	cmp	r3, #0
 801fb06:	f43f ac6d 	beq.w	801f3e4 <st_prep_buffer+0x14>
        if(probe_asserted)
 801fb0a:	4b46      	ldr	r3, [pc, #280]	; (801fc24 <st_prep_buffer+0x854>)
 801fb0c:	781b      	ldrb	r3, [r3, #0]
 801fb0e:	2b00      	cmp	r3, #0
 801fb10:	d137      	bne.n	801fb82 <st_prep_buffer+0x7b2>
        segment_t *prep_segment = segment_buffer_head;
 801fb12:	4b42      	ldr	r3, [pc, #264]	; (801fc1c <st_prep_buffer+0x84c>)
 801fb14:	681d      	ldr	r5, [r3, #0]
        prep_segment->exec_block = st_prep_block;
 801fb16:	4b44      	ldr	r3, [pc, #272]	; (801fc28 <st_prep_buffer+0x858>)
 801fb18:	6819      	ldr	r1, [r3, #0]
 801fb1a:	60a9      	str	r1, [r5, #8]
        prep_segment->update_rpm = NULL;
 801fb1c:	2300      	movs	r3, #0
 801fb1e:	632b      	str	r3, [r5, #48]	; 0x30
        prep_segment->update_pwm = NULL;
 801fb20:	62eb      	str	r3, [r5, #44]	; 0x2c
        float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
 801fb22:	4b39      	ldr	r3, [pc, #228]	; (801fc08 <st_prep_buffer+0x838>)
 801fb24:	681a      	ldr	r2, [r3, #0]
 801fb26:	ed92 8a0a 	vldr	s16, [r2, #40]	; 0x28
        float minimum_mm = mm_remaining - prep.req_mm_increment; // Guarantee at least one step.
 801fb2a:	4b36      	ldr	r3, [pc, #216]	; (801fc04 <st_prep_buffer+0x834>)
 801fb2c:	ed93 5a04 	vldr	s10, [r3, #16]
 801fb30:	ee38 5a45 	vsub.f32	s10, s16, s10
        if (minimum_mm < 0.0f)
 801fb34:	eeb5 5ac0 	vcmpe.f32	s10, #0.0
 801fb38:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801fb3c:	f53f ae0b 	bmi.w	801f756 <st_prep_buffer+0x386>
            minimum_mm = 0.0f;
 801fb40:	eddf 7a3a 	vldr	s15, [pc, #232]	; 801fc2c <st_prep_buffer+0x85c>
 801fb44:	eddf 8a3a 	vldr	s17, [pc, #232]	; 801fc30 <st_prep_buffer+0x860>
 801fb48:	eeb0 7a67 	vmov.f32	s14, s15
 801fb4c:	e6ae      	b.n	801f8ac <st_prep_buffer+0x4dc>
                    prep_segment->update_rpm = pl_block->spindle.hal->update_rpm;
 801fb4e:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 801fb50:	632b      	str	r3, [r5, #48]	; 0x30
                    prep.current_spindle_rpm = prep_segment->spindle_rpm = rpm;
 801fb52:	ed85 0a08 	vstr	s0, [r5, #32]
 801fb56:	4b2b      	ldr	r3, [pc, #172]	; (801fc04 <st_prep_buffer+0x834>)
 801fb58:	ed83 0a13 	vstr	s0, [r3, #76]	; 0x4c
 801fb5c:	e753      	b.n	801fa06 <st_prep_buffer+0x636>
            sys.step_control.end_motion = On;
 801fb5e:	4a2b      	ldr	r2, [pc, #172]	; (801fc0c <st_prep_buffer+0x83c>)
 801fb60:	7e13      	ldrb	r3, [r2, #24]
 801fb62:	f043 0301 	orr.w	r3, r3, #1
 801fb66:	7613      	strb	r3, [r2, #24]
            if (settings.parking.flags.enabled && !prep.recalculate.parking)
 801fb68:	4b32      	ldr	r3, [pc, #200]	; (801fc34 <st_prep_buffer+0x864>)
 801fb6a:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 801fb6e:	f013 0f01 	tst.w	r3, #1
 801fb72:	d006      	beq.n	801fb82 <st_prep_buffer+0x7b2>
 801fb74:	7833      	ldrb	r3, [r6, #0]
 801fb76:	f013 0f04 	tst.w	r3, #4
 801fb7a:	d102      	bne.n	801fb82 <st_prep_buffer+0x7b2>
                prep.recalculate.hold_partial_block = On;
 801fb7c:	f043 0302 	orr.w	r3, r3, #2
 801fb80:	7033      	strb	r3, [r6, #0]
                pl_block = NULL; // Set pointer to indicate check and load next planner block.
                plan_discard_current_block();
            }
        }
    }
}
 801fb82:	ecbd 8b04 	vpop	{d8-d9}
 801fb86:	bd70      	pop	{r4, r5, r6, pc}
            prep_segment->amass_level = cycles < amass.level_2 ? 1 : (cycles < amass.level_3 ? 2 : 3);
 801fb88:	4b22      	ldr	r3, [pc, #136]	; (801fc14 <st_prep_buffer+0x844>)
 801fb8a:	685b      	ldr	r3, [r3, #4]
 801fb8c:	4293      	cmp	r3, r2
 801fb8e:	d805      	bhi.n	801fb9c <st_prep_buffer+0x7cc>
 801fb90:	4b20      	ldr	r3, [pc, #128]	; (801fc14 <st_prep_buffer+0x844>)
 801fb92:	689b      	ldr	r3, [r3, #8]
 801fb94:	4293      	cmp	r3, r2
 801fb96:	d908      	bls.n	801fbaa <st_prep_buffer+0x7da>
 801fb98:	2102      	movs	r1, #2
 801fb9a:	e000      	b.n	801fb9e <st_prep_buffer+0x7ce>
 801fb9c:	2101      	movs	r1, #1
 801fb9e:	62a9      	str	r1, [r5, #40]	; 0x28
            cycles >>= prep_segment->amass_level;
 801fba0:	40ca      	lsrs	r2, r1
            prep_segment->n_step <<= prep_segment->amass_level;
 801fba2:	69ab      	ldr	r3, [r5, #24]
 801fba4:	408b      	lsls	r3, r1
 801fba6:	61ab      	str	r3, [r5, #24]
 801fba8:	e786      	b.n	801fab8 <st_prep_buffer+0x6e8>
            prep_segment->amass_level = cycles < amass.level_2 ? 1 : (cycles < amass.level_3 ? 2 : 3);
 801fbaa:	2103      	movs	r1, #3
 801fbac:	e7f7      	b.n	801fb9e <st_prep_buffer+0x7ce>
            if (mm_remaining > 0.0f) { // At end of forced-termination.
 801fbae:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 801fbb2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801fbb6:	dc0a      	bgt.n	801fbce <st_prep_buffer+0x7fe>
                if (sys.step_control.execute_sys_motion) {
 801fbb8:	4b14      	ldr	r3, [pc, #80]	; (801fc0c <st_prep_buffer+0x83c>)
 801fbba:	7e1b      	ldrb	r3, [r3, #24]
 801fbbc:	f013 0f04 	tst.w	r3, #4
 801fbc0:	d11a      	bne.n	801fbf8 <st_prep_buffer+0x828>
                pl_block = NULL; // Set pointer to indicate check and load next planner block.
 801fbc2:	4b11      	ldr	r3, [pc, #68]	; (801fc08 <st_prep_buffer+0x838>)
 801fbc4:	2200      	movs	r2, #0
 801fbc6:	601a      	str	r2, [r3, #0]
                plan_discard_current_block();
 801fbc8:	f7f6 fd44 	bl	8016654 <plan_discard_current_block>
 801fbcc:	e792      	b.n	801faf4 <st_prep_buffer+0x724>
                sys.step_control.end_motion = On;
 801fbce:	4a0f      	ldr	r2, [pc, #60]	; (801fc0c <st_prep_buffer+0x83c>)
 801fbd0:	7e13      	ldrb	r3, [r2, #24]
 801fbd2:	f043 0301 	orr.w	r3, r3, #1
 801fbd6:	7613      	strb	r3, [r2, #24]
                if (settings.parking.flags.enabled && !prep.recalculate.parking)
 801fbd8:	4b16      	ldr	r3, [pc, #88]	; (801fc34 <st_prep_buffer+0x864>)
 801fbda:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 801fbde:	f013 0f01 	tst.w	r3, #1
 801fbe2:	d0ce      	beq.n	801fb82 <st_prep_buffer+0x7b2>
 801fbe4:	4b07      	ldr	r3, [pc, #28]	; (801fc04 <st_prep_buffer+0x834>)
 801fbe6:	781b      	ldrb	r3, [r3, #0]
 801fbe8:	f013 0f04 	tst.w	r3, #4
 801fbec:	d1c9      	bne.n	801fb82 <st_prep_buffer+0x7b2>
                    prep.recalculate.hold_partial_block = On;
 801fbee:	4a05      	ldr	r2, [pc, #20]	; (801fc04 <st_prep_buffer+0x834>)
 801fbf0:	f043 0302 	orr.w	r3, r3, #2
 801fbf4:	7013      	strb	r3, [r2, #0]
                return; // Bail!
 801fbf6:	e7c4      	b.n	801fb82 <st_prep_buffer+0x7b2>
                    sys.step_control.end_motion = On;
 801fbf8:	4a04      	ldr	r2, [pc, #16]	; (801fc0c <st_prep_buffer+0x83c>)
 801fbfa:	f043 0301 	orr.w	r3, r3, #1
 801fbfe:	7613      	strb	r3, [r2, #24]
                    return;
 801fc00:	e7bf      	b.n	801fb82 <st_prep_buffer+0x7b2>
 801fc02:	bf00      	nop
 801fc04:	20003e90 	.word	0x20003e90
 801fc08:	20003e8c 	.word	0x20003e8c
 801fc0c:	200036c4 	.word	0x200036c4
 801fc10:	20003e84 	.word	0x20003e84
 801fc14:	20003e78 	.word	0x20003e78
 801fc18:	200040f4 	.word	0x200040f4
 801fc1c:	200040ec 	.word	0x200040ec
 801fc20:	200040f0 	.word	0x200040f0
 801fc24:	20003ee0 	.word	0x20003ee0
 801fc28:	20004358 	.word	0x20004358
 801fc2c:	392ec33e 	.word	0x392ec33e
 801fc30:	00000000 	.word	0x00000000
 801fc34:	20003b14 	.word	0x20003b14

0801fc38 <st_get_realtime_rate>:
// Called by realtime status reporting to fetch the current speed being executed. This value
// however is not exactly the current speed, but the speed computed in the last step segment
// in the segment buffer. It will always be behind by up to the number of segment blocks (-1)
// divided by the ACCELERATION TICKS PER SECOND in seconds.
float st_get_realtime_rate (void)
{
 801fc38:	b508      	push	{r3, lr}
    return state_get() & (STATE_CYCLE|STATE_HOMING|STATE_HOLD|STATE_JOG|STATE_SAFETY_DOOR)
 801fc3a:	f7fe fcd3 	bl	801e5e4 <state_get>
#ifdef KINEMATICS_API
            ? prep.current_speed * prep.rate_multiplier
#else
            ? prep.current_speed
#endif
            : 0.0f;
 801fc3e:	f010 0f7c 	tst.w	r0, #124	; 0x7c
 801fc42:	d003      	beq.n	801fc4c <st_get_realtime_rate+0x14>
 801fc44:	4b03      	ldr	r3, [pc, #12]	; (801fc54 <st_get_realtime_rate+0x1c>)
 801fc46:	ed93 0a0b 	vldr	s0, [r3, #44]	; 0x2c
}
 801fc4a:	bd08      	pop	{r3, pc}
            : 0.0f;
 801fc4c:	ed9f 0a02 	vldr	s0, [pc, #8]	; 801fc58 <st_get_realtime_rate+0x20>
 801fc50:	e7fb      	b.n	801fc4a <st_get_realtime_rate+0x12>
 801fc52:	bf00      	nop
 801fc54:	20003e90 	.word	0x20003e90
 801fc58:	00000000 	.word	0x00000000

0801fc5c <stream_get_null>:

// "dummy" version of serialGetC
int16_t stream_get_null (void)
{
    return SERIAL_NO_DATA;
}
 801fc5c:	f04f 30ff 	mov.w	r0, #4294967295
 801fc60:	4770      	bx	lr

0801fc62 <is_connected>:
}

static bool is_connected (void)
{
    return true;
}
 801fc62:	2001      	movs	r0, #1
 801fc64:	4770      	bx	lr

0801fc66 <is_not_connected>:

static bool is_not_connected (void)
{
    return false;
}
 801fc66:	2000      	movs	r0, #0
 801fc68:	4770      	bx	lr
	...

0801fc6c <connection_is_up>:

static bool connection_is_up (io_stream_t *stream)
{
 801fc6c:	b508      	push	{r3, lr}
    if(stream->is_connected)
 801fc6e:	6843      	ldr	r3, [r0, #4]
 801fc70:	b1bb      	cbz	r3, 801fca2 <connection_is_up+0x36>
        return stream->is_connected();
 801fc72:	4798      	blx	r3
        }
        connection = connection->next;
    }

    return false;
}
 801fc74:	bd08      	pop	{r3, pc}
        connection = connection->next;
 801fc76:	68db      	ldr	r3, [r3, #12]
    while(connection) {
 801fc78:	b1ab      	cbz	r3, 801fca6 <connection_is_up+0x3a>
        if(connection->stream->type == stream->type &&
 801fc7a:	681a      	ldr	r2, [r3, #0]
 801fc7c:	f8b2 c000 	ldrh.w	ip, [r2]
 801fc80:	8801      	ldrh	r1, [r0, #0]
 801fc82:	458c      	cmp	ip, r1
 801fc84:	d1f7      	bne.n	801fc76 <connection_is_up+0xa>
             connection->stream->state.is_usb == stream->state.is_usb) {
 801fc86:	7891      	ldrb	r1, [r2, #2]
 801fc88:	7882      	ldrb	r2, [r0, #2]
 801fc8a:	404a      	eors	r2, r1
            connection->stream->instance == stream->instance &&
 801fc8c:	f012 0f04 	tst.w	r2, #4
 801fc90:	d1f1      	bne.n	801fc76 <connection_is_up+0xa>
            if(connection->stream->state.is_usb)
 801fc92:	f011 0f04 	tst.w	r1, #4
 801fc96:	d001      	beq.n	801fc9c <connection_is_up+0x30>
                connection->is_up = is_not_connected;
 801fc98:	4a04      	ldr	r2, [pc, #16]	; (801fcac <connection_is_up+0x40>)
 801fc9a:	605a      	str	r2, [r3, #4]
            return connection->is_up();
 801fc9c:	685b      	ldr	r3, [r3, #4]
 801fc9e:	4798      	blx	r3
 801fca0:	e7e8      	b.n	801fc74 <connection_is_up+0x8>
    stream_connection_t *connection = connections;
 801fca2:	4b03      	ldr	r3, [pc, #12]	; (801fcb0 <connection_is_up+0x44>)
 801fca4:	e7e8      	b.n	801fc78 <connection_is_up+0xc>
    return false;
 801fca6:	2000      	movs	r0, #0
 801fca8:	e7e4      	b.n	801fc74 <connection_is_up+0x8>
 801fcaa:	bf00      	nop
 801fcac:	0801fc67 	.word	0x0801fc67
 801fcb0:	20004360 	.word	0x20004360

0801fcb4 <stream_write_all>:

static void stream_write_all (const char *s)
{
 801fcb4:	b538      	push	{r3, r4, r5, lr}
 801fcb6:	4605      	mov	r5, r0
    stream_connection_t *connection = connections;
 801fcb8:	4c06      	ldr	r4, [pc, #24]	; (801fcd4 <stream_write_all+0x20>)

    while(connection) {
 801fcba:	e000      	b.n	801fcbe <stream_write_all+0xa>
        if(connection->is_up())
            connection->stream->write(s);
        connection = connection->next;
 801fcbc:	68e4      	ldr	r4, [r4, #12]
    while(connection) {
 801fcbe:	b144      	cbz	r4, 801fcd2 <stream_write_all+0x1e>
        if(connection->is_up())
 801fcc0:	6863      	ldr	r3, [r4, #4]
 801fcc2:	4798      	blx	r3
 801fcc4:	2800      	cmp	r0, #0
 801fcc6:	d0f9      	beq.n	801fcbc <stream_write_all+0x8>
            connection->stream->write(s);
 801fcc8:	6823      	ldr	r3, [r4, #0]
 801fcca:	68db      	ldr	r3, [r3, #12]
 801fccc:	4628      	mov	r0, r5
 801fcce:	4798      	blx	r3
 801fcd0:	e7f4      	b.n	801fcbc <stream_write_all+0x8>
    }
}
 801fcd2:	bd38      	pop	{r3, r4, r5, pc}
 801fcd4:	20004360 	.word	0x20004360

0801fcd8 <_open_instance>:
    uint32_t baud_rate;
    io_stream_t const *stream;
} connection;

static bool _open_instance (io_stream_properties_t const *stream)
{
 801fcd8:	b510      	push	{r4, lr}
    if(stream->type == StreamType_Serial && (connection.instance == 255 || stream->instance == connection.instance) && stream->flags.claimable && !stream->flags.claimed)
 801fcda:	7803      	ldrb	r3, [r0, #0]
 801fcdc:	b933      	cbnz	r3, 801fcec <_open_instance+0x14>
 801fcde:	4b0c      	ldr	r3, [pc, #48]	; (801fd10 <_open_instance+0x38>)
 801fce0:	781b      	ldrb	r3, [r3, #0]
 801fce2:	2bff      	cmp	r3, #255	; 0xff
 801fce4:	d008      	beq.n	801fcf8 <_open_instance+0x20>
 801fce6:	7842      	ldrb	r2, [r0, #1]
 801fce8:	4293      	cmp	r3, r2
 801fcea:	d005      	beq.n	801fcf8 <_open_instance+0x20>
        connection.stream = stream->claim(connection.baud_rate);

    return connection.stream != NULL;
 801fcec:	4b08      	ldr	r3, [pc, #32]	; (801fd10 <_open_instance+0x38>)
 801fcee:	6898      	ldr	r0, [r3, #8]
}
 801fcf0:	3800      	subs	r0, #0
 801fcf2:	bf18      	it	ne
 801fcf4:	2001      	movne	r0, #1
 801fcf6:	bd10      	pop	{r4, pc}
    if(stream->type == StreamType_Serial && (connection.instance == 255 || stream->instance == connection.instance) && stream->flags.claimable && !stream->flags.claimed)
 801fcf8:	7883      	ldrb	r3, [r0, #2]
 801fcfa:	f003 0306 	and.w	r3, r3, #6
 801fcfe:	2b02      	cmp	r3, #2
 801fd00:	d1f4      	bne.n	801fcec <_open_instance+0x14>
        connection.stream = stream->claim(connection.baud_rate);
 801fd02:	6843      	ldr	r3, [r0, #4]
 801fd04:	4c02      	ldr	r4, [pc, #8]	; (801fd10 <_open_instance+0x38>)
 801fd06:	6860      	ldr	r0, [r4, #4]
 801fd08:	4798      	blx	r3
 801fd0a:	60a0      	str	r0, [r4, #8]
 801fd0c:	e7ee      	b.n	801fcec <_open_instance+0x14>
 801fd0e:	bf00      	nop
 801fd10:	20004370 	.word	0x20004370

0801fd14 <null_rx_free>:
static enqueue_realtime_command_ptr enqueue_realtime_command = protocol_enqueue_realtime_command;

static uint16_t null_rx_free (void)
{
    return RX_BUFFER_SIZE;
}
 801fd14:	f44f 6080 	mov.w	r0, #1024	; 0x400
 801fd18:	4770      	bx	lr

0801fd1a <null_count>:

static uint16_t null_count (void)
{
    return 0;
}
 801fd1a:	2000      	movs	r0, #0
 801fd1c:	4770      	bx	lr

0801fd1e <null_put_c>:

static bool null_put_c (const char c)
{
    return true;
}
 801fd1e:	2001      	movs	r0, #1
 801fd20:	4770      	bx	lr

0801fd22 <null_write_string>:

static void null_write_string (const char *s)
{
}
 801fd22:	4770      	bx	lr

0801fd24 <null_write>:

static void null_write(const char *s, uint16_t length)
{
}
 801fd24:	4770      	bx	lr

0801fd26 <null_suspend_disable>:

static bool null_suspend_disable (bool suspend)
{
    return true;
}
 801fd26:	2001      	movs	r0, #1
 801fd28:	4770      	bx	lr

0801fd2a <null_set_baudrate>:

static bool null_set_baudrate (uint32_t baud_rate)
{
    return true;
}
 801fd2a:	2001      	movs	r0, #1
 801fd2c:	4770      	bx	lr
	...

0801fd30 <null_enqueue_rt_command>:

static bool null_enqueue_rt_command (char c)
{
 801fd30:	b508      	push	{r3, lr}
    return enqueue_realtime_command(c);
 801fd32:	4b02      	ldr	r3, [pc, #8]	; (801fd3c <null_enqueue_rt_command+0xc>)
 801fd34:	681b      	ldr	r3, [r3, #0]
 801fd36:	4798      	blx	r3
}
 801fd38:	bd08      	pop	{r3, pc}
 801fd3a:	bf00      	nop
 801fd3c:	20000514 	.word	0x20000514

0801fd40 <null_set_rt_handler>:

static enqueue_realtime_command_ptr null_set_rt_handler (enqueue_realtime_command_ptr handler)
{
 801fd40:	4603      	mov	r3, r0
    enqueue_realtime_command_ptr prev = enqueue_realtime_command;
 801fd42:	4a03      	ldr	r2, [pc, #12]	; (801fd50 <null_set_rt_handler+0x10>)
 801fd44:	6810      	ldr	r0, [r2, #0]

    if(handler)
 801fd46:	461a      	mov	r2, r3
 801fd48:	b10b      	cbz	r3, 801fd4e <null_set_rt_handler+0xe>
        enqueue_realtime_command = handler;
 801fd4a:	4b01      	ldr	r3, [pc, #4]	; (801fd50 <null_set_rt_handler+0x10>)
 801fd4c:	601a      	str	r2, [r3, #0]

    return prev;
}
 801fd4e:	4770      	bx	lr
 801fd50:	20000514 	.word	0x20000514

0801fd54 <stream_null_init>:
        .set_baud_rate = null_set_baudrate,
        .set_enqueue_rt_handler = null_set_rt_handler
    };

    return &stream;
}
 801fd54:	4800      	ldr	r0, [pc, #0]	; (801fd58 <stream_null_init+0x4>)
 801fd56:	4770      	bx	lr
 801fd58:	0802c4a8 	.word	0x0802c4a8

0801fd5c <await_toolchange_ack>:
{
 801fd5c:	b510      	push	{r4, lr}
    if(c == CMD_TOOL_ACK && !stream.rxbuffer->backup) {
 801fd5e:	28a3      	cmp	r0, #163	; 0xa3
 801fd60:	d103      	bne.n	801fd6a <await_toolchange_ack+0xe>
 801fd62:	4b13      	ldr	r3, [pc, #76]	; (801fdb0 <await_toolchange_ack+0x54>)
 801fd64:	689c      	ldr	r4, [r3, #8]
 801fd66:	7aa3      	ldrb	r3, [r4, #10]
 801fd68:	b11b      	cbz	r3, 801fd72 <await_toolchange_ack+0x16>
        return stream.enqueue_realtime_command(c);
 801fd6a:	4b11      	ldr	r3, [pc, #68]	; (801fdb0 <await_toolchange_ack+0x54>)
 801fd6c:	681b      	ldr	r3, [r3, #0]
 801fd6e:	4798      	blx	r3
}
 801fd70:	bd10      	pop	{r4, pc}
        memcpy(&rxbackup, stream.rxbuffer, sizeof(stream_rx_buffer_t));
 801fd72:	f240 420c 	movw	r2, #1036	; 0x40c
 801fd76:	4621      	mov	r1, r4
 801fd78:	480e      	ldr	r0, [pc, #56]	; (801fdb4 <await_toolchange_ack+0x58>)
 801fd7a:	f003 f859 	bl	8022e30 <memcpy>
        stream.rxbuffer->backup = true;
 801fd7e:	2301      	movs	r3, #1
 801fd80:	72a3      	strb	r3, [r4, #10]
        stream.rxbuffer->tail = stream.rxbuffer->head;
 801fd82:	6823      	ldr	r3, [r4, #0]
 801fd84:	6063      	str	r3, [r4, #4]
        hal.stream.read = stream.read; // restore normal input
 801fd86:	4c0a      	ldr	r4, [pc, #40]	; (801fdb0 <await_toolchange_ack+0x54>)
 801fd88:	6862      	ldr	r2, [r4, #4]
 801fd8a:	4b0b      	ldr	r3, [pc, #44]	; (801fdb8 <await_toolchange_ack+0x5c>)
 801fd8c:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
        hal.stream.set_enqueue_rt_handler(stream.enqueue_realtime_command);
 801fd90:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
 801fd94:	6820      	ldr	r0, [r4, #0]
 801fd96:	4798      	blx	r3
        stream.enqueue_realtime_command = NULL;
 801fd98:	2300      	movs	r3, #0
 801fd9a:	6023      	str	r3, [r4, #0]
        if(grbl.on_toolchange_ack)
 801fd9c:	4b07      	ldr	r3, [pc, #28]	; (801fdbc <await_toolchange_ack+0x60>)
 801fd9e:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 801fda2:	b113      	cbz	r3, 801fdaa <await_toolchange_ack+0x4e>
            grbl.on_toolchange_ack();
 801fda4:	4798      	blx	r3
    return true;
 801fda6:	2001      	movs	r0, #1
 801fda8:	e7e2      	b.n	801fd70 <await_toolchange_ack+0x14>
 801fdaa:	2001      	movs	r0, #1
 801fdac:	e7e0      	b.n	801fd70 <await_toolchange_ack+0x14>
 801fdae:	bf00      	nop
 801fdb0:	2000479c 	.word	0x2000479c
 801fdb4:	20004390 	.word	0x20004390
 801fdb8:	2000350c 	.word	0x2000350c
 801fdbc:	2000343c 	.word	0x2000343c

0801fdc0 <add_connection>:
{
 801fdc0:	b510      	push	{r4, lr}
 801fdc2:	4604      	mov	r4, r0
    if(base.stream == NULL) {
 801fdc4:	4b15      	ldr	r3, [pc, #84]	; (801fe1c <add_connection+0x5c>)
 801fdc6:	681b      	ldr	r3, [r3, #0]
 801fdc8:	b18b      	cbz	r3, 801fdee <add_connection+0x2e>
    } else if((connection = malloc(sizeof(stream_connection_t)))) {
 801fdca:	2010      	movs	r0, #16
 801fdcc:	f002 fb70 	bl	80224b0 <malloc>
 801fdd0:	b178      	cbz	r0, 801fdf2 <add_connection+0x32>
        connection->stream = stream;
 801fdd2:	6004      	str	r4, [r0, #0]
        connection->next = NULL;
 801fdd4:	2300      	movs	r3, #0
 801fdd6:	60c3      	str	r3, [r0, #12]
    stream_connection_t *connection, *last = connections;
 801fdd8:	4b10      	ldr	r3, [pc, #64]	; (801fe1c <add_connection+0x5c>)
        while(last->next) {
 801fdda:	461a      	mov	r2, r3
 801fddc:	68db      	ldr	r3, [r3, #12]
 801fdde:	b163      	cbz	r3, 801fdfa <add_connection+0x3a>
            if(last->stream == stream) {
 801fde0:	681a      	ldr	r2, [r3, #0]
 801fde2:	42a2      	cmp	r2, r4
 801fde4:	d1f9      	bne.n	801fdda <add_connection+0x1a>
                free(connection);
 801fde6:	f002 fb6b 	bl	80224c0 <free>
                return NULL;
 801fdea:	2000      	movs	r0, #0
 801fdec:	e004      	b.n	801fdf8 <add_connection+0x38>
        base.stream = stream;
 801fdee:	480b      	ldr	r0, [pc, #44]	; (801fe1c <add_connection+0x5c>)
 801fdf0:	6004      	str	r4, [r0, #0]
    connection->is_up = stream->is_connected ?
 801fdf2:	6863      	ldr	r3, [r4, #4]
                         stream->is_connected :
 801fdf4:	b11b      	cbz	r3, 801fdfe <add_connection+0x3e>
    connection->is_up = stream->is_connected ?
 801fdf6:	6043      	str	r3, [r0, #4]
}
 801fdf8:	bd10      	pop	{r4, pc}
        last->next = connection;
 801fdfa:	60d0      	str	r0, [r2, #12]
 801fdfc:	e7f9      	b.n	801fdf2 <add_connection+0x32>
                          (stream->state.is_usb && base.stream != stream ? is_not_connected : is_connected);
 801fdfe:	78a3      	ldrb	r3, [r4, #2]
 801fe00:	f013 0f04 	tst.w	r3, #4
 801fe04:	d007      	beq.n	801fe16 <add_connection+0x56>
 801fe06:	4b05      	ldr	r3, [pc, #20]	; (801fe1c <add_connection+0x5c>)
 801fe08:	681b      	ldr	r3, [r3, #0]
 801fe0a:	42a3      	cmp	r3, r4
 801fe0c:	d001      	beq.n	801fe12 <add_connection+0x52>
 801fe0e:	4b04      	ldr	r3, [pc, #16]	; (801fe20 <add_connection+0x60>)
 801fe10:	e7f1      	b.n	801fdf6 <add_connection+0x36>
 801fe12:	4b04      	ldr	r3, [pc, #16]	; (801fe24 <add_connection+0x64>)
 801fe14:	e7ef      	b.n	801fdf6 <add_connection+0x36>
 801fe16:	4b03      	ldr	r3, [pc, #12]	; (801fe24 <add_connection+0x64>)
 801fe18:	e7ed      	b.n	801fdf6 <add_connection+0x36>
 801fe1a:	bf00      	nop
 801fe1c:	20004360 	.word	0x20004360
 801fe20:	0801fc67 	.word	0x0801fc67
 801fe24:	0801fc63 	.word	0x0801fc63

0801fe28 <stream_select>:
{
 801fe28:	b570      	push	{r4, r5, r6, lr}
 801fe2a:	4604      	mov	r4, r0
 801fe2c:	460d      	mov	r5, r1
    if(stream == base.stream) {
 801fe2e:	4b6f      	ldr	r3, [pc, #444]	; (801ffec <stream_select+0x1c4>)
 801fe30:	681b      	ldr	r3, [r3, #0]
 801fe32:	4283      	cmp	r3, r0
 801fe34:	d00f      	beq.n	801fe56 <stream_select+0x2e>
    if(add) {
 801fe36:	b9c1      	cbnz	r1, 801fe6a <stream_select+0x42>
        stream_connection_t *prev, *last = connections;
 801fe38:	486c      	ldr	r0, [pc, #432]	; (801ffec <stream_select+0x1c4>)
        while(last->next) {
 801fe3a:	4606      	mov	r6, r0
 801fe3c:	68c0      	ldr	r0, [r0, #12]
 801fe3e:	b1c8      	cbz	r0, 801fe74 <stream_select+0x4c>
            if(last->stream == stream) {
 801fe40:	6803      	ldr	r3, [r0, #0]
 801fe42:	42a3      	cmp	r3, r4
 801fe44:	d1f9      	bne.n	801fe3a <stream_select+0x12>
                prev->next = last->next;
 801fe46:	68c3      	ldr	r3, [r0, #12]
 801fe48:	60f3      	str	r3, [r6, #12]
                free(last);
 801fe4a:	f002 fb39 	bl	80224c0 <free>
                if(prev->next)
 801fe4e:	68f3      	ldr	r3, [r6, #12]
 801fe50:	b1eb      	cbz	r3, 801fe8e <stream_select+0x66>
                    return false;
 801fe52:	4628      	mov	r0, r5
 801fe54:	e04c      	b.n	801fef0 <stream_select+0xc8>
        base.is_up = add ? (stream->is_connected ? stream->is_connected : is_connected) : is_not_connected;
 801fe56:	b119      	cbz	r1, 801fe60 <stream_select+0x38>
 801fe58:	6843      	ldr	r3, [r0, #4]
 801fe5a:	b913      	cbnz	r3, 801fe62 <stream_select+0x3a>
 801fe5c:	4b64      	ldr	r3, [pc, #400]	; (801fff0 <stream_select+0x1c8>)
 801fe5e:	e000      	b.n	801fe62 <stream_select+0x3a>
 801fe60:	4b64      	ldr	r3, [pc, #400]	; (801fff4 <stream_select+0x1cc>)
 801fe62:	4a62      	ldr	r2, [pc, #392]	; (801ffec <stream_select+0x1c4>)
 801fe64:	6053      	str	r3, [r2, #4]
        return true;
 801fe66:	2001      	movs	r0, #1
 801fe68:	e042      	b.n	801fef0 <stream_select+0xc8>
        if(add_connection(stream) == NULL)
 801fe6a:	f7ff ffa9 	bl	801fdc0 <add_connection>
 801fe6e:	2800      	cmp	r0, #0
 801fe70:	f000 80ba 	beq.w	801ffe8 <stream_select+0x1c0>
    bool webui_connected = hal.stream.state.webui_connected;
 801fe74:	4b60      	ldr	r3, [pc, #384]	; (801fff8 <stream_select+0x1d0>)
 801fe76:	f893 60aa 	ldrb.w	r6, [r3, #170]	; 0xaa
 801fe7a:	f3c6 0640 	ubfx	r6, r6, #1, #1
    switch(stream->type) {
 801fe7e:	7823      	ldrb	r3, [r4, #0]
 801fe80:	2b04      	cmp	r3, #4
 801fe82:	d80b      	bhi.n	801fe9c <stream_select+0x74>
 801fe84:	e8df f003 	tbb	[pc, r3]
 801fe88:	43790a05 	.word	0x43790a05
 801fe8c:	5b          	.byte	0x5b
 801fe8d:	00          	.byte	0x00
                    stream = prev->stream;
 801fe8e:	6834      	ldr	r4, [r6, #0]
                    break;
 801fe90:	e7f0      	b.n	801fe74 <stream_select+0x4c>
            if(active_stream && active_stream->type != StreamType_Serial && connection_is_up((io_stream_t *)stream)) {
 801fe92:	4b5a      	ldr	r3, [pc, #360]	; (801fffc <stream_select+0x1d4>)
 801fe94:	681b      	ldr	r3, [r3, #0]
 801fe96:	b10b      	cbz	r3, 801fe9c <stream_select+0x74>
 801fe98:	781b      	ldrb	r3, [r3, #0]
 801fe9a:	bb53      	cbnz	r3, 801fef2 <stream_select+0xca>
    memcpy(&hal.stream, stream, sizeof(io_stream_t));
 801fe9c:	4d58      	ldr	r5, [pc, #352]	; (8020000 <stream_select+0x1d8>)
 801fe9e:	224c      	movs	r2, #76	; 0x4c
 801fea0:	4621      	mov	r1, r4
 801fea2:	4628      	mov	r0, r5
 801fea4:	f002 ffc4 	bl	8022e30 <memcpy>
    if(!hal.stream.write_all)
 801fea8:	692b      	ldr	r3, [r5, #16]
 801feaa:	2b00      	cmp	r3, #0
 801feac:	d07d      	beq.n	801ffaa <stream_select+0x182>
    if(stream == base.stream && base.is_up == is_not_connected)
 801feae:	4b4f      	ldr	r3, [pc, #316]	; (801ffec <stream_select+0x1c4>)
 801feb0:	681b      	ldr	r3, [r3, #0]
 801feb2:	42a3      	cmp	r3, r4
 801feb4:	f000 8086 	beq.w	801ffc4 <stream_select+0x19c>
    if(stream->type == StreamType_WebSocket && !stream->state.webui_connected)
 801feb8:	6823      	ldr	r3, [r4, #0]
 801feba:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 801febe:	f423 037d 	bic.w	r3, r3, #16580608	; 0xfd0000
 801fec2:	2b04      	cmp	r3, #4
 801fec4:	f000 8088 	beq.w	801ffd8 <stream_select+0x1b0>
    hal.stream.set_enqueue_rt_handler(protocol_enqueue_realtime_command);
 801fec8:	4d4b      	ldr	r5, [pc, #300]	; (801fff8 <stream_select+0x1d0>)
 801feca:	f8d5 30d0 	ldr.w	r3, [r5, #208]	; 0xd0
 801fece:	484d      	ldr	r0, [pc, #308]	; (8020004 <stream_select+0x1dc>)
 801fed0:	4798      	blx	r3
    if(hal.stream.disable_rx)
 801fed2:	f8d5 30dc 	ldr.w	r3, [r5, #220]	; 0xdc
 801fed6:	b10b      	cbz	r3, 801fedc <stream_select+0xb4>
        hal.stream.disable_rx(false);
 801fed8:	2000      	movs	r0, #0
 801feda:	4798      	blx	r3
    if(grbl.on_stream_changed)
 801fedc:	4b4a      	ldr	r3, [pc, #296]	; (8020008 <stream_select+0x1e0>)
 801fede:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801fee0:	b11b      	cbz	r3, 801feea <stream_select+0xc2>
        grbl.on_stream_changed(hal.stream.type);
 801fee2:	4a45      	ldr	r2, [pc, #276]	; (801fff8 <stream_select+0x1d0>)
 801fee4:	f892 00a8 	ldrb.w	r0, [r2, #168]	; 0xa8
 801fee8:	4798      	blx	r3
    active_stream = stream;
 801feea:	4b44      	ldr	r3, [pc, #272]	; (801fffc <stream_select+0x1d4>)
 801feec:	601c      	str	r4, [r3, #0]
    return true;
 801feee:	2001      	movs	r0, #1
}
 801fef0:	bd70      	pop	{r4, r5, r6, pc}
            if(active_stream && active_stream->type != StreamType_Serial && connection_is_up((io_stream_t *)stream)) {
 801fef2:	4620      	mov	r0, r4
 801fef4:	f7ff feba 	bl	801fc6c <connection_is_up>
 801fef8:	2800      	cmp	r0, #0
 801fefa:	d0cf      	beq.n	801fe9c <stream_select+0x74>
                hal.stream.write = stream->write;
 801fefc:	68e2      	ldr	r2, [r4, #12]
 801fefe:	4b3e      	ldr	r3, [pc, #248]	; (801fff8 <stream_select+0x1d0>)
 801ff00:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
                report_message("SERIAL STREAM ACTIVE", Message_Plain);
 801ff04:	2100      	movs	r1, #0
 801ff06:	4841      	ldr	r0, [pc, #260]	; (802000c <stream_select+0x1e4>)
 801ff08:	f7f9 f98e 	bl	8019228 <report_message>
 801ff0c:	e7c6      	b.n	801fe9c <stream_select+0x74>
            if(connection_is_up(&hal.stream))
 801ff0e:	483c      	ldr	r0, [pc, #240]	; (8020000 <stream_select+0x1d8>)
 801ff10:	f7ff feac 	bl	801fc6c <connection_is_up>
 801ff14:	b970      	cbnz	r0, 801ff34 <stream_select+0x10c>
            if(add && sys.driver_started) {
 801ff16:	2d00      	cmp	r5, #0
 801ff18:	d0c0      	beq.n	801fe9c <stream_select+0x74>
 801ff1a:	4b3d      	ldr	r3, [pc, #244]	; (8020010 <stream_select+0x1e8>)
 801ff1c:	f893 307e 	ldrb.w	r3, [r3, #126]	; 0x7e
 801ff20:	2b00      	cmp	r3, #0
 801ff22:	d0bb      	beq.n	801fe9c <stream_select+0x74>
                hal.stream.write_all = stream->write;
 801ff24:	68e2      	ldr	r2, [r4, #12]
 801ff26:	4b34      	ldr	r3, [pc, #208]	; (801fff8 <stream_select+0x1d0>)
 801ff28:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
                grbl.report.init_message();
 801ff2c:	4b36      	ldr	r3, [pc, #216]	; (8020008 <stream_select+0x1e0>)
 801ff2e:	681b      	ldr	r3, [r3, #0]
 801ff30:	4798      	blx	r3
 801ff32:	e7b3      	b.n	801fe9c <stream_select+0x74>
                report_message("TELNET STREAM ACTIVE", Message_Plain);
 801ff34:	2100      	movs	r1, #0
 801ff36:	4837      	ldr	r0, [pc, #220]	; (8020014 <stream_select+0x1ec>)
 801ff38:	f7f9 f976 	bl	8019228 <report_message>
 801ff3c:	e7eb      	b.n	801ff16 <stream_select+0xee>
            if(connection_is_up(&hal.stream))
 801ff3e:	4830      	ldr	r0, [pc, #192]	; (8020000 <stream_select+0x1d8>)
 801ff40:	f7ff fe94 	bl	801fc6c <connection_is_up>
 801ff44:	b9a0      	cbnz	r0, 801ff70 <stream_select+0x148>
            if(add && sys.driver_started && !hal.stream.state.webui_connected) {
 801ff46:	2d00      	cmp	r5, #0
 801ff48:	d0a8      	beq.n	801fe9c <stream_select+0x74>
 801ff4a:	4b31      	ldr	r3, [pc, #196]	; (8020010 <stream_select+0x1e8>)
 801ff4c:	f893 307e 	ldrb.w	r3, [r3, #126]	; 0x7e
 801ff50:	2b00      	cmp	r3, #0
 801ff52:	d0a3      	beq.n	801fe9c <stream_select+0x74>
 801ff54:	4b28      	ldr	r3, [pc, #160]	; (801fff8 <stream_select+0x1d0>)
 801ff56:	f893 30aa 	ldrb.w	r3, [r3, #170]	; 0xaa
 801ff5a:	f013 0f02 	tst.w	r3, #2
 801ff5e:	d19d      	bne.n	801fe9c <stream_select+0x74>
                hal.stream.write_all = stream->write;
 801ff60:	68e2      	ldr	r2, [r4, #12]
 801ff62:	4b25      	ldr	r3, [pc, #148]	; (801fff8 <stream_select+0x1d0>)
 801ff64:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
                grbl.report.init_message();
 801ff68:	4b27      	ldr	r3, [pc, #156]	; (8020008 <stream_select+0x1e0>)
 801ff6a:	681b      	ldr	r3, [r3, #0]
 801ff6c:	4798      	blx	r3
 801ff6e:	e795      	b.n	801fe9c <stream_select+0x74>
                report_message("WEBSOCKET STREAM ACTIVE", Message_Plain);
 801ff70:	2100      	movs	r1, #0
 801ff72:	4829      	ldr	r0, [pc, #164]	; (8020018 <stream_select+0x1f0>)
 801ff74:	f7f9 f958 	bl	8019228 <report_message>
 801ff78:	e7e5      	b.n	801ff46 <stream_select+0x11e>
            if(connection_is_up(&hal.stream))
 801ff7a:	4821      	ldr	r0, [pc, #132]	; (8020000 <stream_select+0x1d8>)
 801ff7c:	f7ff fe76 	bl	801fc6c <connection_is_up>
 801ff80:	b970      	cbnz	r0, 801ffa0 <stream_select+0x178>
            if(add && sys.driver_started) {
 801ff82:	2d00      	cmp	r5, #0
 801ff84:	d08a      	beq.n	801fe9c <stream_select+0x74>
 801ff86:	4b22      	ldr	r3, [pc, #136]	; (8020010 <stream_select+0x1e8>)
 801ff88:	f893 307e 	ldrb.w	r3, [r3, #126]	; 0x7e
 801ff8c:	2b00      	cmp	r3, #0
 801ff8e:	d085      	beq.n	801fe9c <stream_select+0x74>
                hal.stream.write_all = stream->write;
 801ff90:	68e2      	ldr	r2, [r4, #12]
 801ff92:	4b19      	ldr	r3, [pc, #100]	; (801fff8 <stream_select+0x1d0>)
 801ff94:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
                grbl.report.init_message();
 801ff98:	4b1b      	ldr	r3, [pc, #108]	; (8020008 <stream_select+0x1e0>)
 801ff9a:	681b      	ldr	r3, [r3, #0]
 801ff9c:	4798      	blx	r3
 801ff9e:	e77d      	b.n	801fe9c <stream_select+0x74>
                report_message("BLUETOOTH STREAM ACTIVE", Message_Plain);
 801ffa0:	2100      	movs	r1, #0
 801ffa2:	481e      	ldr	r0, [pc, #120]	; (802001c <stream_select+0x1f4>)
 801ffa4:	f7f9 f940 	bl	8019228 <report_message>
 801ffa8:	e7eb      	b.n	801ff82 <stream_select+0x15a>
        hal.stream.write_all = base.next != NULL ? stream_write_all : hal.stream.write;
 801ffaa:	4b10      	ldr	r3, [pc, #64]	; (801ffec <stream_select+0x1c4>)
 801ffac:	68db      	ldr	r3, [r3, #12]
 801ffae:	b123      	cbz	r3, 801ffba <stream_select+0x192>
 801ffb0:	4a1b      	ldr	r2, [pc, #108]	; (8020020 <stream_select+0x1f8>)
 801ffb2:	4b11      	ldr	r3, [pc, #68]	; (801fff8 <stream_select+0x1d0>)
 801ffb4:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
 801ffb8:	e779      	b.n	801feae <stream_select+0x86>
 801ffba:	f1a5 03a8 	sub.w	r3, r5, #168	; 0xa8
 801ffbe:	f8d3 20b4 	ldr.w	r2, [r3, #180]	; 0xb4
 801ffc2:	e7f6      	b.n	801ffb2 <stream_select+0x18a>
    if(stream == base.stream && base.is_up == is_not_connected)
 801ffc4:	4b09      	ldr	r3, [pc, #36]	; (801ffec <stream_select+0x1c4>)
 801ffc6:	685a      	ldr	r2, [r3, #4]
 801ffc8:	4b0a      	ldr	r3, [pc, #40]	; (801fff4 <stream_select+0x1cc>)
 801ffca:	429a      	cmp	r2, r3
 801ffcc:	f47f af74 	bne.w	801feb8 <stream_select+0x90>
        base.is_up = is_connected;
 801ffd0:	4b06      	ldr	r3, [pc, #24]	; (801ffec <stream_select+0x1c4>)
 801ffd2:	4a07      	ldr	r2, [pc, #28]	; (801fff0 <stream_select+0x1c8>)
 801ffd4:	605a      	str	r2, [r3, #4]
 801ffd6:	e76f      	b.n	801feb8 <stream_select+0x90>
        hal.stream.state.webui_connected = webui_connected;
 801ffd8:	4b07      	ldr	r3, [pc, #28]	; (801fff8 <stream_select+0x1d0>)
 801ffda:	f893 20aa 	ldrb.w	r2, [r3, #170]	; 0xaa
 801ffde:	f366 0241 	bfi	r2, r6, #1, #1
 801ffe2:	f883 20aa 	strb.w	r2, [r3, #170]	; 0xaa
 801ffe6:	e76f      	b.n	801fec8 <stream_select+0xa0>
            return false;
 801ffe8:	2000      	movs	r0, #0
 801ffea:	e781      	b.n	801fef0 <stream_select+0xc8>
 801ffec:	20004360 	.word	0x20004360
 801fff0:	0801fc63 	.word	0x0801fc63
 801fff4:	0801fc67 	.word	0x0801fc67
 801fff8:	2000350c 	.word	0x2000350c
 801fffc:	2000435c 	.word	0x2000435c
 8020000:	200035b4 	.word	0x200035b4
 8020004:	08017bfd 	.word	0x08017bfd
 8020008:	2000343c 	.word	0x2000343c
 802000c:	0802c42c 	.word	0x0802c42c
 8020010:	200036c4 	.word	0x200036c4
 8020014:	0802c444 	.word	0x0802c444
 8020018:	0802c45c 	.word	0x0802c45c
 802001c:	0802c474 	.word	0x0802c474
 8020020:	0801fcb5 	.word	0x0801fcb5

08020024 <stream_register_streams>:
    details->next = streams;
 8020024:	4b02      	ldr	r3, [pc, #8]	; (8020030 <stream_register_streams+0xc>)
 8020026:	681a      	ldr	r2, [r3, #0]
 8020028:	6082      	str	r2, [r0, #8]
    streams = details;
 802002a:	6018      	str	r0, [r3, #0]
}
 802002c:	4770      	bx	lr
 802002e:	bf00      	nop
 8020030:	20000570 	.word	0x20000570

08020034 <stream_enumerate_streams>:
    if(callback == NULL)
 8020034:	b1a8      	cbz	r0, 8020062 <stream_enumerate_streams+0x2e>
{
 8020036:	b570      	push	{r4, r5, r6, lr}
 8020038:	4606      	mov	r6, r0
    io_stream_details_t *details = streams;
 802003a:	4b0c      	ldr	r3, [pc, #48]	; (802006c <stream_enumerate_streams+0x38>)
 802003c:	681d      	ldr	r5, [r3, #0]
    bool claimed = false;
 802003e:	2200      	movs	r2, #0
    while(details && !claimed) {
 8020040:	e000      	b.n	8020044 <stream_enumerate_streams+0x10>
        details = details->next;
 8020042:	68ad      	ldr	r5, [r5, #8]
    while(details && !claimed) {
 8020044:	b185      	cbz	r5, 8020068 <stream_enumerate_streams+0x34>
 8020046:	b97a      	cbnz	r2, 8020068 <stream_enumerate_streams+0x34>
        for(idx = 0; idx < details->n_streams; idx++) {
 8020048:	2400      	movs	r4, #0
 802004a:	782b      	ldrb	r3, [r5, #0]
 802004c:	42a3      	cmp	r3, r4
 802004e:	d9f8      	bls.n	8020042 <stream_enumerate_streams+0xe>
            if((claimed = callback(&details->streams[idx])))
 8020050:	6868      	ldr	r0, [r5, #4]
 8020052:	eb00 00c4 	add.w	r0, r0, r4, lsl #3
 8020056:	47b0      	blx	r6
 8020058:	4602      	mov	r2, r0
 802005a:	2800      	cmp	r0, #0
 802005c:	d1f1      	bne.n	8020042 <stream_enumerate_streams+0xe>
        for(idx = 0; idx < details->n_streams; idx++) {
 802005e:	3401      	adds	r4, #1
 8020060:	e7f3      	b.n	802004a <stream_enumerate_streams+0x16>
        return false;
 8020062:	2200      	movs	r2, #0
}
 8020064:	4610      	mov	r0, r2
 8020066:	4770      	bx	lr
 8020068:	4610      	mov	r0, r2
 802006a:	bd70      	pop	{r4, r5, r6, pc}
 802006c:	20000570 	.word	0x20000570

08020070 <stream_tx_blocking>:
{
 8020070:	b510      	push	{r4, lr}
    grbl.on_execute_realtime(state_get());
 8020072:	4b06      	ldr	r3, [pc, #24]	; (802008c <stream_tx_blocking+0x1c>)
 8020074:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 8020076:	f7fe fab5 	bl	801e5e4 <state_get>
 802007a:	47a0      	blx	r4
    return !(sys.rt_exec_state & EXEC_RESET);
 802007c:	4b04      	ldr	r3, [pc, #16]	; (8020090 <stream_tx_blocking+0x20>)
 802007e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8020080:	f013 0f20 	tst.w	r3, #32
}
 8020084:	bf0c      	ite	eq
 8020086:	2001      	moveq	r0, #1
 8020088:	2000      	movne	r0, #0
 802008a:	bd10      	pop	{r4, pc}
 802008c:	2000343c 	.word	0x2000343c
 8020090:	200036c4 	.word	0x200036c4

08020094 <stream_rx_suspend>:
{
 8020094:	b570      	push	{r4, r5, r6, lr}
 8020096:	4604      	mov	r4, r0
    if(suspend) {
 8020098:	b1b9      	cbz	r1, 80200ca <stream_rx_suspend+0x36>
        if(stream.rxbuffer == NULL) {
 802009a:	4b1a      	ldr	r3, [pc, #104]	; (8020104 <stream_rx_suspend+0x70>)
 802009c:	689b      	ldr	r3, [r3, #8]
 802009e:	b12b      	cbz	r3, 80200ac <stream_rx_suspend+0x18>
    return rxbuffer->tail != rxbuffer->head;
 80200a0:	6860      	ldr	r0, [r4, #4]
 80200a2:	6823      	ldr	r3, [r4, #0]
}
 80200a4:	1ac0      	subs	r0, r0, r3
 80200a6:	bf18      	it	ne
 80200a8:	2001      	movne	r0, #1
 80200aa:	bd70      	pop	{r4, r5, r6, pc}
            stream.rxbuffer = rxbuffer;
 80200ac:	4e15      	ldr	r6, [pc, #84]	; (8020104 <stream_rx_suspend+0x70>)
 80200ae:	60b0      	str	r0, [r6, #8]
            stream.read = hal.stream.read;
 80200b0:	4d15      	ldr	r5, [pc, #84]	; (8020108 <stream_rx_suspend+0x74>)
 80200b2:	f8d5 30c4 	ldr.w	r3, [r5, #196]	; 0xc4
 80200b6:	6073      	str	r3, [r6, #4]
            stream.enqueue_realtime_command = hal.stream.set_enqueue_rt_handler(await_toolchange_ack);
 80200b8:	f8d5 30d0 	ldr.w	r3, [r5, #208]	; 0xd0
 80200bc:	4813      	ldr	r0, [pc, #76]	; (802010c <stream_rx_suspend+0x78>)
 80200be:	4798      	blx	r3
 80200c0:	6030      	str	r0, [r6, #0]
            hal.stream.read = stream_get_null;
 80200c2:	4b13      	ldr	r3, [pc, #76]	; (8020110 <stream_rx_suspend+0x7c>)
 80200c4:	f8c5 30c4 	str.w	r3, [r5, #196]	; 0xc4
 80200c8:	e7ea      	b.n	80200a0 <stream_rx_suspend+0xc>
    } else if(stream.rxbuffer) {
 80200ca:	4b0e      	ldr	r3, [pc, #56]	; (8020104 <stream_rx_suspend+0x70>)
 80200cc:	689b      	ldr	r3, [r3, #8]
 80200ce:	2b00      	cmp	r3, #0
 80200d0:	d0e6      	beq.n	80200a0 <stream_rx_suspend+0xc>
        if(rxbuffer->backup)
 80200d2:	7a83      	ldrb	r3, [r0, #10]
 80200d4:	b983      	cbnz	r3, 80200f8 <stream_rx_suspend+0x64>
        if(stream.enqueue_realtime_command) {
 80200d6:	4b0b      	ldr	r3, [pc, #44]	; (8020104 <stream_rx_suspend+0x70>)
 80200d8:	6818      	ldr	r0, [r3, #0]
 80200da:	b148      	cbz	r0, 80200f0 <stream_rx_suspend+0x5c>
            hal.stream.read = stream.read; // restore normal input
 80200dc:	461d      	mov	r5, r3
 80200de:	685a      	ldr	r2, [r3, #4]
 80200e0:	4b09      	ldr	r3, [pc, #36]	; (8020108 <stream_rx_suspend+0x74>)
 80200e2:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
            hal.stream.set_enqueue_rt_handler(stream.enqueue_realtime_command);
 80200e6:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
 80200ea:	4798      	blx	r3
            stream.enqueue_realtime_command = NULL;
 80200ec:	2300      	movs	r3, #0
 80200ee:	602b      	str	r3, [r5, #0]
        stream.rxbuffer = NULL;
 80200f0:	4b04      	ldr	r3, [pc, #16]	; (8020104 <stream_rx_suspend+0x70>)
 80200f2:	2200      	movs	r2, #0
 80200f4:	609a      	str	r2, [r3, #8]
 80200f6:	e7d3      	b.n	80200a0 <stream_rx_suspend+0xc>
            memcpy(rxbuffer, &rxbackup, sizeof(stream_rx_buffer_t));
 80200f8:	f240 420c 	movw	r2, #1036	; 0x40c
 80200fc:	4905      	ldr	r1, [pc, #20]	; (8020114 <stream_rx_suspend+0x80>)
 80200fe:	f002 fe97 	bl	8022e30 <memcpy>
 8020102:	e7e8      	b.n	80200d6 <stream_rx_suspend+0x42>
 8020104:	2000479c 	.word	0x2000479c
 8020108:	2000350c 	.word	0x2000350c
 802010c:	0801fd5d 	.word	0x0801fd5d
 8020110:	0801fc5d 	.word	0x0801fc5d
 8020114:	20004390 	.word	0x20004390

08020118 <stream_enqueue_realtime_command>:
{
 8020118:	b510      	push	{r4, lr}
 802011a:	4604      	mov	r4, r0
	bool drop = hal.stream.enqueue_rt_command ? hal.stream.enqueue_rt_command(c) : protocol_enqueue_realtime_command(c);
 802011c:	4b0c      	ldr	r3, [pc, #48]	; (8020150 <stream_enqueue_realtime_command+0x38>)
 802011e:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8020122:	b193      	cbz	r3, 802014a <stream_enqueue_realtime_command+0x32>
 8020124:	4798      	blx	r3
    if(drop && (c == CMD_CYCLE_START || c == CMD_CYCLE_START_LEGACY))
 8020126:	b178      	cbz	r0, 8020148 <stream_enqueue_realtime_command+0x30>
 8020128:	2c81      	cmp	r4, #129	; 0x81
 802012a:	d001      	beq.n	8020130 <stream_enqueue_realtime_command+0x18>
 802012c:	2c7e      	cmp	r4, #126	; 0x7e
 802012e:	d10b      	bne.n	8020148 <stream_enqueue_realtime_command+0x30>
        sys.report.cycle_start = settings.status_report.pin_state;
 8020130:	4b08      	ldr	r3, [pc, #32]	; (8020154 <stream_enqueue_realtime_command+0x3c>)
 8020132:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 8020136:	f3c3 1300 	ubfx	r3, r3, #4, #1
 802013a:	4a07      	ldr	r2, [pc, #28]	; (8020158 <stream_enqueue_realtime_command+0x40>)
 802013c:	f892 1033 	ldrb.w	r1, [r2, #51]	; 0x33
 8020140:	f363 1186 	bfi	r1, r3, #6, #1
 8020144:	f882 1033 	strb.w	r1, [r2, #51]	; 0x33
}
 8020148:	bd10      	pop	{r4, pc}
	bool drop = hal.stream.enqueue_rt_command ? hal.stream.enqueue_rt_command(c) : protocol_enqueue_realtime_command(c);
 802014a:	f7f7 fd57 	bl	8017bfc <protocol_enqueue_realtime_command>
 802014e:	e7ea      	b.n	8020126 <stream_enqueue_realtime_command+0xe>
 8020150:	2000350c 	.word	0x2000350c
 8020154:	20003b14 	.word	0x20003b14
 8020158:	200036c4 	.word	0x200036c4

0802015c <stream_connect>:
{
 802015c:	b570      	push	{r4, r5, r6, lr}
 802015e:	4605      	mov	r5, r0
    if((ok = stream_select(stream, true)) && stream->type == StreamType_Serial && !stream->state.is_usb && hal.periph_port.set_pin_description) {
 8020160:	2101      	movs	r1, #1
 8020162:	f7ff fe61 	bl	801fe28 <stream_select>
 8020166:	4604      	mov	r4, r0
 8020168:	b1b8      	cbz	r0, 802019a <stream_connect+0x3e>
 802016a:	682b      	ldr	r3, [r5, #0]
 802016c:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 8020170:	f423 037b 	bic.w	r3, r3, #16449536	; 0xfb0000
 8020174:	b98b      	cbnz	r3, 802019a <stream_connect+0x3e>
 8020176:	4b0a      	ldr	r3, [pc, #40]	; (80201a0 <stream_connect+0x44>)
 8020178:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
 802017c:	b16b      	cbz	r3, 802019a <stream_connect+0x3e>
        hal.periph_port.set_pin_description(Input_RX, (pin_group_t)(PinGroup_UART + stream->instance), "Primary UART");
 802017e:	7869      	ldrb	r1, [r5, #1]
 8020180:	4e08      	ldr	r6, [pc, #32]	; (80201a4 <stream_connect+0x48>)
 8020182:	4632      	mov	r2, r6
 8020184:	3111      	adds	r1, #17
 8020186:	2021      	movs	r0, #33	; 0x21
 8020188:	4798      	blx	r3
        hal.periph_port.set_pin_description(Output_TX, (pin_group_t)(PinGroup_UART + stream->instance), "Primary UART");
 802018a:	4b05      	ldr	r3, [pc, #20]	; (80201a0 <stream_connect+0x44>)
 802018c:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
 8020190:	7869      	ldrb	r1, [r5, #1]
 8020192:	4632      	mov	r2, r6
 8020194:	3111      	adds	r1, #17
 8020196:	206c      	movs	r0, #108	; 0x6c
 8020198:	4798      	blx	r3
}
 802019a:	4620      	mov	r0, r4
 802019c:	bd70      	pop	{r4, r5, r6, pc}
 802019e:	bf00      	nop
 80201a0:	2000350c 	.word	0x2000350c
 80201a4:	0802c48c 	.word	0x0802c48c

080201a8 <stream_open_instance>:
{
 80201a8:	b510      	push	{r4, lr}
 80201aa:	4614      	mov	r4, r2
    connection.instance = instance;
 80201ac:	4b08      	ldr	r3, [pc, #32]	; (80201d0 <stream_open_instance+0x28>)
 80201ae:	7018      	strb	r0, [r3, #0]
    connection.baud_rate = baud_rate;
 80201b0:	6059      	str	r1, [r3, #4]
    connection.stream = NULL;
 80201b2:	2100      	movs	r1, #0
 80201b4:	6099      	str	r1, [r3, #8]
    if(stream_enumerate_streams(_open_instance))
 80201b6:	4807      	ldr	r0, [pc, #28]	; (80201d4 <stream_open_instance+0x2c>)
 80201b8:	f7ff ff3c 	bl	8020034 <stream_enumerate_streams>
 80201bc:	b120      	cbz	r0, 80201c8 <stream_open_instance+0x20>
        connection.stream->set_enqueue_rt_handler(rx_handler);
 80201be:	4b04      	ldr	r3, [pc, #16]	; (80201d0 <stream_open_instance+0x28>)
 80201c0:	689b      	ldr	r3, [r3, #8]
 80201c2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80201c4:	4620      	mov	r0, r4
 80201c6:	4798      	blx	r3
}
 80201c8:	4b01      	ldr	r3, [pc, #4]	; (80201d0 <stream_open_instance+0x28>)
 80201ca:	6898      	ldr	r0, [r3, #8]
 80201cc:	bd10      	pop	{r4, pc}
 80201ce:	bf00      	nop
 80201d0:	20004370 	.word	0x20004370
 80201d4:	0801fcd9 	.word	0x0801fcd9

080201d8 <stream_mpg_register>:
    if(stream == NULL || stream->type != StreamType_Serial || stream->disable_rx == NULL)
 80201d8:	2800      	cmp	r0, #0
 80201da:	d047      	beq.n	802026c <stream_mpg_register+0x94>
{
 80201dc:	b570      	push	{r4, r5, r6, lr}
 80201de:	4604      	mov	r4, r0
    if(stream == NULL || stream->type != StreamType_Serial || stream->disable_rx == NULL)
 80201e0:	7803      	ldrb	r3, [r0, #0]
 80201e2:	2b00      	cmp	r3, #0
 80201e4:	d144      	bne.n	8020270 <stream_mpg_register+0x98>
 80201e6:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80201e8:	2b00      	cmp	r3, #0
 80201ea:	d043      	beq.n	8020274 <stream_mpg_register+0x9c>
    mpg_write_char = write_char;
 80201ec:	4b22      	ldr	r3, [pc, #136]	; (8020278 <stream_mpg_register+0xa0>)
 80201ee:	601a      	str	r2, [r3, #0]
    if(stream->write == NULL || rx_only) {
 80201f0:	68c3      	ldr	r3, [r0, #12]
 80201f2:	b103      	cbz	r3, 80201f6 <stream_mpg_register+0x1e>
 80201f4:	b129      	cbz	r1, 8020202 <stream_mpg_register+0x2a>
        mpg.stream = stream;
 80201f6:	4b21      	ldr	r3, [pc, #132]	; (802027c <stream_mpg_register+0xa4>)
 80201f8:	601c      	str	r4, [r3, #0]
        mpg.is_up = is_connected;
 80201fa:	4a21      	ldr	r2, [pc, #132]	; (8020280 <stream_mpg_register+0xa8>)
 80201fc:	605a      	str	r2, [r3, #4]
        return true;
 80201fe:	2001      	movs	r0, #1
 8020200:	e037      	b.n	8020272 <stream_mpg_register+0x9a>
    stream_connection_t *connection = add_connection(stream);
 8020202:	f7ff fddd 	bl	801fdc0 <add_connection>
    if(connection) {
 8020206:	4605      	mov	r5, r0
 8020208:	b330      	cbz	r0, 8020258 <stream_mpg_register+0x80>
        memcpy(&mpg, connection, sizeof(stream_connection_t));
 802020a:	4e1c      	ldr	r6, [pc, #112]	; (802027c <stream_mpg_register+0xa4>)
 802020c:	46b4      	mov	ip, r6
 802020e:	6800      	ldr	r0, [r0, #0]
 8020210:	6869      	ldr	r1, [r5, #4]
 8020212:	68aa      	ldr	r2, [r5, #8]
 8020214:	68eb      	ldr	r3, [r5, #12]
 8020216:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
        mpg.flags.is_mpg_tx = On;
 802021a:	7a33      	ldrb	r3, [r6, #8]
 802021c:	f043 0302 	orr.w	r3, r3, #2
 8020220:	7233      	strb	r3, [r6, #8]
        if(mpg_write_char)
 8020222:	4b15      	ldr	r3, [pc, #84]	; (8020278 <stream_mpg_register+0xa0>)
 8020224:	6818      	ldr	r0, [r3, #0]
 8020226:	b1d8      	cbz	r0, 8020260 <stream_mpg_register+0x88>
            mpg.stream->set_enqueue_rt_handler(mpg_write_char);
 8020228:	6833      	ldr	r3, [r6, #0]
 802022a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802022c:	4798      	blx	r3
        hal.stream.write_all = stream_write_all;
 802022e:	4b15      	ldr	r3, [pc, #84]	; (8020284 <stream_mpg_register+0xac>)
 8020230:	4a15      	ldr	r2, [pc, #84]	; (8020288 <stream_mpg_register+0xb0>)
 8020232:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
        if(hal.periph_port.set_pin_description) {
 8020236:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
 802023a:	b16b      	cbz	r3, 8020258 <stream_mpg_register+0x80>
            hal.periph_port.set_pin_description(Output_TX, (pin_group_t)(PinGroup_UART + stream->instance), "MPG");
 802023c:	7861      	ldrb	r1, [r4, #1]
 802023e:	4e13      	ldr	r6, [pc, #76]	; (802028c <stream_mpg_register+0xb4>)
 8020240:	4632      	mov	r2, r6
 8020242:	3111      	adds	r1, #17
 8020244:	206c      	movs	r0, #108	; 0x6c
 8020246:	4798      	blx	r3
            hal.periph_port.set_pin_description(Input_RX, (pin_group_t)(PinGroup_UART + stream->instance), "MPG");
 8020248:	4b0e      	ldr	r3, [pc, #56]	; (8020284 <stream_mpg_register+0xac>)
 802024a:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
 802024e:	7861      	ldrb	r1, [r4, #1]
 8020250:	4632      	mov	r2, r6
 8020252:	3111      	adds	r1, #17
 8020254:	2021      	movs	r0, #33	; 0x21
 8020256:	4798      	blx	r3
    return connection != NULL;
 8020258:	1e28      	subs	r0, r5, #0
 802025a:	bf18      	it	ne
 802025c:	2001      	movne	r0, #1
 802025e:	e008      	b.n	8020272 <stream_mpg_register+0x9a>
            mpg.stream->disable_rx(true);
 8020260:	4b06      	ldr	r3, [pc, #24]	; (802027c <stream_mpg_register+0xa4>)
 8020262:	681b      	ldr	r3, [r3, #0]
 8020264:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8020266:	2001      	movs	r0, #1
 8020268:	4798      	blx	r3
 802026a:	e7e0      	b.n	802022e <stream_mpg_register+0x56>
        return false;
 802026c:	2000      	movs	r0, #0
}
 802026e:	4770      	bx	lr
        return false;
 8020270:	2000      	movs	r0, #0
}
 8020272:	bd70      	pop	{r4, r5, r6, pc}
        return false;
 8020274:	2000      	movs	r0, #0
 8020276:	e7fc      	b.n	8020272 <stream_mpg_register+0x9a>
 8020278:	2000438c 	.word	0x2000438c
 802027c:	2000437c 	.word	0x2000437c
 8020280:	0801fc63 	.word	0x0801fc63
 8020284:	2000350c 	.word	0x2000350c
 8020288:	0801fcb5 	.word	0x0801fcb5
 802028c:	0802c49c 	.word	0x0802c49c

08020290 <stream_mpg_enable>:
    if(mpg.stream == NULL)
 8020290:	4b46      	ldr	r3, [pc, #280]	; (80203ac <stream_mpg_enable+0x11c>)
 8020292:	681b      	ldr	r3, [r3, #0]
 8020294:	2b00      	cmp	r3, #0
 8020296:	f000 8086 	beq.w	80203a6 <stream_mpg_enable+0x116>
{
 802029a:	b570      	push	{r4, r5, r6, lr}
 802029c:	4604      	mov	r4, r0
    sys_state_t state = state_get();
 802029e:	f7fe f9a1 	bl	801e5e4 <state_get>
    if(on == sys.mpg_mode || (on && (gc_state.file_run || !(state == STATE_IDLE || (state & (STATE_ALARM|STATE_ESTOP)))))) {
 80202a2:	4b43      	ldr	r3, [pc, #268]	; (80203b0 <stream_mpg_enable+0x120>)
 80202a4:	f893 307f 	ldrb.w	r3, [r3, #127]	; 0x7f
 80202a8:	42a3      	cmp	r3, r4
 80202aa:	d020      	beq.n	80202ee <stream_mpg_enable+0x5e>
 80202ac:	b144      	cbz	r4, 80202c0 <stream_mpg_enable+0x30>
 80202ae:	4b41      	ldr	r3, [pc, #260]	; (80203b4 <stream_mpg_enable+0x124>)
 80202b0:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
 80202b4:	b9db      	cbnz	r3, 80202ee <stream_mpg_enable+0x5e>
 80202b6:	b118      	cbz	r0, 80202c0 <stream_mpg_enable+0x30>
 80202b8:	f240 1301 	movw	r3, #257	; 0x101
 80202bc:	4218      	tst	r0, r3
 80202be:	d016      	beq.n	80202ee <stream_mpg_enable+0x5e>
    if(on) {
 80202c0:	2c00      	cmp	r4, #0
 80202c2:	d04c      	beq.n	802035e <stream_mpg_enable+0xce>
        if(org_stream.type == StreamType_Redirected) {
 80202c4:	4b3c      	ldr	r3, [pc, #240]	; (80203b8 <stream_mpg_enable+0x128>)
 80202c6:	781b      	ldrb	r3, [r3, #0]
 80202c8:	2b06      	cmp	r3, #6
 80202ca:	d015      	beq.n	80202f8 <stream_mpg_enable+0x68>
    hal.stream.reset_read_buffer();
 80202cc:	4b3b      	ldr	r3, [pc, #236]	; (80203bc <stream_mpg_enable+0x12c>)
 80202ce:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 80202d2:	4798      	blx	r3
    sys.mpg_mode = on;
 80202d4:	4b36      	ldr	r3, [pc, #216]	; (80203b0 <stream_mpg_enable+0x120>)
 80202d6:	f883 407f 	strb.w	r4, [r3, #127]	; 0x7f
    system_add_rt_report(Report_MPGMode);
 80202da:	2001      	movs	r0, #1
 80202dc:	f000 ffb0 	bl	8021240 <system_add_rt_report>
    protocol_enqueue_realtime_command(on ? CMD_STATUS_REPORT_ALL : CMD_STATUS_REPORT);
 80202e0:	2c00      	cmp	r4, #0
 80202e2:	d05e      	beq.n	80203a2 <stream_mpg_enable+0x112>
 80202e4:	2087      	movs	r0, #135	; 0x87
 80202e6:	f7f7 fc89 	bl	8017bfc <protocol_enqueue_realtime_command>
    return true;
 80202ea:	2001      	movs	r0, #1
}
 80202ec:	bd70      	pop	{r4, r5, r6, pc}
        protocol_enqueue_realtime_command(CMD_STATUS_REPORT_ALL);
 80202ee:	2087      	movs	r0, #135	; 0x87
 80202f0:	f7f7 fc84 	bl	8017bfc <protocol_enqueue_realtime_command>
        return false;
 80202f4:	2000      	movs	r0, #0
 80202f6:	e7f9      	b.n	80202ec <stream_mpg_enable+0x5c>
            memcpy(&org_stream, &hal.stream, sizeof(io_stream_t));
 80202f8:	4d30      	ldr	r5, [pc, #192]	; (80203bc <stream_mpg_enable+0x12c>)
 80202fa:	224c      	movs	r2, #76	; 0x4c
 80202fc:	f105 01a8 	add.w	r1, r5, #168	; 0xa8
 8020300:	482d      	ldr	r0, [pc, #180]	; (80203b8 <stream_mpg_enable+0x128>)
 8020302:	f002 fd95 	bl	8022e30 <memcpy>
            if(hal.stream.disable_rx)
 8020306:	f8d5 30dc 	ldr.w	r3, [r5, #220]	; 0xdc
 802030a:	b10b      	cbz	r3, 8020310 <stream_mpg_enable+0x80>
                hal.stream.disable_rx(true);
 802030c:	2001      	movs	r0, #1
 802030e:	4798      	blx	r3
            mpg.stream->disable_rx(false);
 8020310:	4d26      	ldr	r5, [pc, #152]	; (80203ac <stream_mpg_enable+0x11c>)
 8020312:	682b      	ldr	r3, [r5, #0]
 8020314:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8020316:	2000      	movs	r0, #0
 8020318:	4798      	blx	r3
            mpg.stream->set_enqueue_rt_handler(org_stream.set_enqueue_rt_handler(NULL));
 802031a:	682b      	ldr	r3, [r5, #0]
 802031c:	6a9e      	ldr	r6, [r3, #40]	; 0x28
 802031e:	4b26      	ldr	r3, [pc, #152]	; (80203b8 <stream_mpg_enable+0x128>)
 8020320:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8020322:	2000      	movs	r0, #0
 8020324:	4798      	blx	r3
 8020326:	47b0      	blx	r6
            hal.stream.type = StreamType_MPG;
 8020328:	4a24      	ldr	r2, [pc, #144]	; (80203bc <stream_mpg_enable+0x12c>)
 802032a:	2301      	movs	r3, #1
 802032c:	f882 30a8 	strb.w	r3, [r2, #168]	; 0xa8
            hal.stream.read = mpg.stream->read;
 8020330:	682b      	ldr	r3, [r5, #0]
 8020332:	69d9      	ldr	r1, [r3, #28]
 8020334:	f8c2 10c4 	str.w	r1, [r2, #196]	; 0xc4
            if(mpg.flags.is_mpg_tx)
 8020338:	7a2a      	ldrb	r2, [r5, #8]
 802033a:	f012 0f02 	tst.w	r2, #2
 802033e:	d003      	beq.n	8020348 <stream_mpg_enable+0xb8>
                hal.stream.write = mpg.stream->write;
 8020340:	68d9      	ldr	r1, [r3, #12]
 8020342:	4a1e      	ldr	r2, [pc, #120]	; (80203bc <stream_mpg_enable+0x12c>)
 8020344:	f8c2 10b4 	str.w	r1, [r2, #180]	; 0xb4
            hal.stream.get_rx_buffer_free = mpg.stream->get_rx_buffer_free;
 8020348:	6899      	ldr	r1, [r3, #8]
 802034a:	4a1c      	ldr	r2, [pc, #112]	; (80203bc <stream_mpg_enable+0x12c>)
 802034c:	f8c2 10b0 	str.w	r1, [r2, #176]	; 0xb0
            hal.stream.cancel_read_buffer = mpg.stream->cancel_read_buffer;
 8020350:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8020352:	f8c2 10cc 	str.w	r1, [r2, #204]	; 0xcc
            hal.stream.reset_read_buffer = mpg.stream->reset_read_buffer;
 8020356:	6a1b      	ldr	r3, [r3, #32]
 8020358:	f8c2 30c8 	str.w	r3, [r2, #200]	; 0xc8
 802035c:	e7b6      	b.n	80202cc <stream_mpg_enable+0x3c>
    } else if(org_stream.type != StreamType_Redirected) {
 802035e:	4b16      	ldr	r3, [pc, #88]	; (80203b8 <stream_mpg_enable+0x128>)
 8020360:	781b      	ldrb	r3, [r3, #0]
 8020362:	2b06      	cmp	r3, #6
 8020364:	d0b2      	beq.n	80202cc <stream_mpg_enable+0x3c>
        if(mpg_write_char)
 8020366:	4b16      	ldr	r3, [pc, #88]	; (80203c0 <stream_mpg_enable+0x130>)
 8020368:	6818      	ldr	r0, [r3, #0]
 802036a:	b1a0      	cbz	r0, 8020396 <stream_mpg_enable+0x106>
            mpg.stream->set_enqueue_rt_handler(mpg_write_char);
 802036c:	4b0f      	ldr	r3, [pc, #60]	; (80203ac <stream_mpg_enable+0x11c>)
 802036e:	681b      	ldr	r3, [r3, #0]
 8020370:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8020372:	4798      	blx	r3
        memcpy(&hal.stream, &org_stream, sizeof(io_stream_t));
 8020374:	4d11      	ldr	r5, [pc, #68]	; (80203bc <stream_mpg_enable+0x12c>)
 8020376:	4e10      	ldr	r6, [pc, #64]	; (80203b8 <stream_mpg_enable+0x128>)
 8020378:	224c      	movs	r2, #76	; 0x4c
 802037a:	4631      	mov	r1, r6
 802037c:	f105 00a8 	add.w	r0, r5, #168	; 0xa8
 8020380:	f002 fd56 	bl	8022e30 <memcpy>
        org_stream.type = StreamType_Redirected;
 8020384:	2306      	movs	r3, #6
 8020386:	7033      	strb	r3, [r6, #0]
        if(hal.stream.disable_rx)
 8020388:	f8d5 30dc 	ldr.w	r3, [r5, #220]	; 0xdc
 802038c:	2b00      	cmp	r3, #0
 802038e:	d09d      	beq.n	80202cc <stream_mpg_enable+0x3c>
            hal.stream.disable_rx(false);
 8020390:	2000      	movs	r0, #0
 8020392:	4798      	blx	r3
 8020394:	e79a      	b.n	80202cc <stream_mpg_enable+0x3c>
            mpg.stream->disable_rx(true);
 8020396:	4b05      	ldr	r3, [pc, #20]	; (80203ac <stream_mpg_enable+0x11c>)
 8020398:	681b      	ldr	r3, [r3, #0]
 802039a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 802039c:	2001      	movs	r0, #1
 802039e:	4798      	blx	r3
 80203a0:	e7e8      	b.n	8020374 <stream_mpg_enable+0xe4>
    protocol_enqueue_realtime_command(on ? CMD_STATUS_REPORT_ALL : CMD_STATUS_REPORT);
 80203a2:	2080      	movs	r0, #128	; 0x80
 80203a4:	e79f      	b.n	80202e6 <stream_mpg_enable+0x56>
        return false;
 80203a6:	2000      	movs	r0, #0
}
 80203a8:	4770      	bx	lr
 80203aa:	bf00      	nop
 80203ac:	2000437c 	.word	0x2000437c
 80203b0:	200036c4 	.word	0x200036c4
 80203b4:	20003344 	.word	0x20003344
 80203b8:	20000524 	.word	0x20000524
 80203bc:	2000350c 	.word	0x2000350c
 80203c0:	2000438c 	.word	0x2000438c

080203c4 <toggle_single_block>:

    return Status_OK;
}

static status_code_t toggle_single_block (sys_state_t state, char *args)
{
 80203c4:	b508      	push	{r3, lr}
    sys.flags.single_block = !sys.flags.single_block;
 80203c6:	4a0a      	ldr	r2, [pc, #40]	; (80203f0 <toggle_single_block+0x2c>)
 80203c8:	7d93      	ldrb	r3, [r2, #22]
 80203ca:	43d9      	mvns	r1, r3
 80203cc:	f3c1 11c0 	ubfx	r1, r1, #7, #1
 80203d0:	f361 13c7 	bfi	r3, r1, #7, #1
 80203d4:	7593      	strb	r3, [r2, #22]
    grbl.report.feedback_message(sys.flags.single_block ? Message_Enabled : Message_Disabled);
 80203d6:	4b07      	ldr	r3, [pc, #28]	; (80203f4 <toggle_single_block+0x30>)
 80203d8:	68db      	ldr	r3, [r3, #12]
 80203da:	f992 2016 	ldrsb.w	r2, [r2, #22]
 80203de:	2a00      	cmp	r2, #0
 80203e0:	db03      	blt.n	80203ea <toggle_single_block+0x26>
 80203e2:	2005      	movs	r0, #5
 80203e4:	4798      	blx	r3

    return Status_OK;
}
 80203e6:	2000      	movs	r0, #0
 80203e8:	bd08      	pop	{r3, pc}
    grbl.report.feedback_message(sys.flags.single_block ? Message_Enabled : Message_Disabled);
 80203ea:	2004      	movs	r0, #4
 80203ec:	e7fa      	b.n	80203e4 <toggle_single_block+0x20>
 80203ee:	bf00      	nop
 80203f0:	200036c4 	.word	0x200036c4
 80203f4:	2000343c 	.word	0x2000343c

080203f8 <toggle_block_delete>:

static status_code_t toggle_block_delete (sys_state_t state, char *args)
{
 80203f8:	b508      	push	{r3, lr}
    sys.flags.block_delete_enabled = !sys.flags.block_delete_enabled;
 80203fa:	4a0a      	ldr	r2, [pc, #40]	; (8020424 <toggle_block_delete+0x2c>)
 80203fc:	7d93      	ldrb	r3, [r2, #22]
 80203fe:	0919      	lsrs	r1, r3, #4
 8020400:	f081 0101 	eor.w	r1, r1, #1
 8020404:	f361 1304 	bfi	r3, r1, #4, #1
 8020408:	7593      	strb	r3, [r2, #22]
    grbl.report.feedback_message(sys.flags.block_delete_enabled ? Message_Enabled : Message_Disabled);
 802040a:	4b07      	ldr	r3, [pc, #28]	; (8020428 <toggle_block_delete+0x30>)
 802040c:	68db      	ldr	r3, [r3, #12]
 802040e:	7d92      	ldrb	r2, [r2, #22]
 8020410:	f012 0f10 	tst.w	r2, #16
 8020414:	d003      	beq.n	802041e <toggle_block_delete+0x26>
 8020416:	2004      	movs	r0, #4
 8020418:	4798      	blx	r3

    return Status_OK;
}
 802041a:	2000      	movs	r0, #0
 802041c:	bd08      	pop	{r3, pc}
    grbl.report.feedback_message(sys.flags.block_delete_enabled ? Message_Enabled : Message_Disabled);
 802041e:	2005      	movs	r0, #5
 8020420:	e7fa      	b.n	8020418 <toggle_block_delete+0x20>
 8020422:	bf00      	nop
 8020424:	200036c4 	.word	0x200036c4
 8020428:	2000343c 	.word	0x2000343c

0802042c <toggle_optional_stop>:

static status_code_t toggle_optional_stop (sys_state_t state, char *args)
{
 802042c:	b508      	push	{r3, lr}
    sys.flags.optional_stop_disable = !sys.flags.optional_stop_disable;
 802042e:	4a0a      	ldr	r2, [pc, #40]	; (8020458 <toggle_optional_stop+0x2c>)
 8020430:	7d93      	ldrb	r3, [r2, #22]
 8020432:	0999      	lsrs	r1, r3, #6
 8020434:	f081 0101 	eor.w	r1, r1, #1
 8020438:	f361 1386 	bfi	r3, r1, #6, #1
 802043c:	7593      	strb	r3, [r2, #22]
    grbl.report.feedback_message(sys.flags.block_delete_enabled ? Message_Enabled : Message_Disabled);
 802043e:	4b07      	ldr	r3, [pc, #28]	; (802045c <toggle_optional_stop+0x30>)
 8020440:	68db      	ldr	r3, [r3, #12]
 8020442:	7d92      	ldrb	r2, [r2, #22]
 8020444:	f012 0f10 	tst.w	r2, #16
 8020448:	d003      	beq.n	8020452 <toggle_optional_stop+0x26>
 802044a:	2004      	movs	r0, #4
 802044c:	4798      	blx	r3

    return Status_OK;
}
 802044e:	2000      	movs	r0, #0
 8020450:	bd08      	pop	{r3, pc}
    grbl.report.feedback_message(sys.flags.block_delete_enabled ? Message_Enabled : Message_Disabled);
 8020452:	2005      	movs	r0, #5
 8020454:	e7fa      	b.n	802044c <toggle_optional_stop+0x20>
 8020456:	bf00      	nop
 8020458:	200036c4 	.word	0x200036c4
 802045c:	2000343c 	.word	0x2000343c

08020460 <enter_sleep>:
    return go_home(state, (axes_signals_t){V_AXIS_BIT});
}
#endif

static status_code_t enter_sleep (sys_state_t state, char *args)
{
 8020460:	b508      	push	{r3, lr}
    if(!settings.flags.sleep_enable)
 8020462:	4b0a      	ldr	r3, [pc, #40]	; (802048c <enter_sleep+0x2c>)
 8020464:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 8020468:	f013 0f08 	tst.w	r3, #8
 802046c:	d009      	beq.n	8020482 <enter_sleep+0x22>
        return Status_InvalidStatement;
    else if(!(state == STATE_IDLE || state == STATE_ALARM))
 802046e:	2801      	cmp	r0, #1
 8020470:	d809      	bhi.n	8020486 <enter_sleep+0x26>
        return Status_IdleError;
    else
        system_set_exec_state_flag(EXEC_SLEEP); // Set to execute enter_sleep mode immediately
 8020472:	4b07      	ldr	r3, [pc, #28]	; (8020490 <enter_sleep+0x30>)
 8020474:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8020476:	f44f 7180 	mov.w	r1, #256	; 0x100
 802047a:	4806      	ldr	r0, [pc, #24]	; (8020494 <enter_sleep+0x34>)
 802047c:	4798      	blx	r3

    return Status_OK;
 802047e:	2000      	movs	r0, #0
}
 8020480:	bd08      	pop	{r3, pc}
        return Status_InvalidStatement;
 8020482:	2003      	movs	r0, #3
 8020484:	e7fc      	b.n	8020480 <enter_sleep+0x20>
        return Status_IdleError;
 8020486:	2008      	movs	r0, #8
 8020488:	e7fa      	b.n	8020480 <enter_sleep+0x20>
 802048a:	bf00      	nop
 802048c:	20003b14 	.word	0x20003b14
 8020490:	2000350c 	.word	0x2000350c
 8020494:	2000370c 	.word	0x2000370c

08020498 <jog>:
{
 8020498:	b508      	push	{r3, lr}
    if(!(state == STATE_IDLE || (state & (STATE_JOG|STATE_TOOL_CHANGE))))
 802049a:	b110      	cbz	r0, 80204a2 <jog+0xa>
 802049c:	f410 7f08 	tst.w	r0, #544	; 0x220
 80204a0:	d009      	beq.n	80204b6 <jog+0x1e>
    if(args != NULL) {
 80204a2:	b119      	cbz	r1, 80204ac <jog+0x14>
        *(--args) = '=';
 80204a4:	233d      	movs	r3, #61	; 0x3d
 80204a6:	f801 3c01 	strb.w	r3, [r1, #-1]
        args -= 2;
 80204aa:	3903      	subs	r1, #3
    return args == NULL ? Status_InvalidStatement : gc_execute_block(args); // NOTE: $J= is ignored inside g-code parser and used to detect jog motions.
 80204ac:	b129      	cbz	r1, 80204ba <jog+0x22>
 80204ae:	4608      	mov	r0, r1
 80204b0:	f7ee ff96 	bl	800f3e0 <gc_execute_block>
}
 80204b4:	bd08      	pop	{r3, pc}
         return Status_IdleError;
 80204b6:	2008      	movs	r0, #8
 80204b8:	e7fc      	b.n	80204b4 <jog+0x1c>
    return args == NULL ? Status_InvalidStatement : gc_execute_block(args); // NOTE: $J= is ignored inside g-code parser and used to detect jog motions.
 80204ba:	2003      	movs	r0, #3
 80204bc:	e7fa      	b.n	80204b4 <jog+0x1c>

080204be <spindle_reset_data>:
{
 80204be:	b510      	push	{r4, lr}
    spindle_ptrs_t *spindle = gc_spindle_get();
 80204c0:	f7ee fee6 	bl	800f290 <gc_spindle_get>
 80204c4:	4604      	mov	r4, r0
    if(spindle->reset_data)
 80204c6:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80204c8:	b103      	cbz	r3, 80204cc <spindle_reset_data+0xe>
        spindle->reset_data();
 80204ca:	4798      	blx	r3
    return spindle->reset_data ? Status_OK : Status_InvalidStatement;
 80204cc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80204ce:	b10b      	cbz	r3, 80204d4 <spindle_reset_data+0x16>
 80204d0:	2000      	movs	r0, #0
}
 80204d2:	bd10      	pop	{r4, pc}
    return spindle->reset_data ? Status_OK : Status_InvalidStatement;
 80204d4:	2003      	movs	r0, #3
 80204d6:	e7fc      	b.n	80204d2 <spindle_reset_data+0x14>

080204d8 <output_help>:
{
 80204d8:	b508      	push	{r3, lr}
    return report_help(args);
 80204da:	4608      	mov	r0, r1
 80204dc:	f7fa feb0 	bl	801b240 <report_help>
}
 80204e0:	bd08      	pop	{r3, pc}
	...

080204e4 <rtc_action>:
{
    return set_startup_line(state, args, 1);
}

static status_code_t rtc_action (sys_state_t state, char *args)
{
 80204e4:	b508      	push	{r3, lr}
    status_code_t retval = Status_OK;

    if(args) {
 80204e6:	b149      	cbz	r1, 80204fc <rtc_action+0x18>
 80204e8:	4608      	mov	r0, r1

        struct tm *time = get_datetime(args);
 80204ea:	f7f5 fb0f 	bl	8015b0c <get_datetime>

        if(time)
 80204ee:	b140      	cbz	r0, 8020502 <rtc_action+0x1e>
            hal.rtc.set_datetime(time);
 80204f0:	4a05      	ldr	r2, [pc, #20]	; (8020508 <rtc_action+0x24>)
 80204f2:	f8d2 2110 	ldr.w	r2, [r2, #272]	; 0x110
 80204f6:	4790      	blx	r2
    status_code_t retval = Status_OK;
 80204f8:	2000      	movs	r0, #0
            retval = Status_BadNumberFormat;
    } else
        retval = report_time();

    return retval;
}
 80204fa:	bd08      	pop	{r3, pc}
        retval = report_time();
 80204fc:	f7fa fffe 	bl	801b4fc <report_time>
 8020500:	e7fb      	b.n	80204fa <rtc_action+0x16>
            retval = Status_BadNumberFormat;
 8020502:	2002      	movs	r0, #2
 8020504:	e7f9      	b.n	80204fa <rtc_action+0x16>
 8020506:	bf00      	nop
 8020508:	2000350c 	.word	0x2000350c

0802050c <enumerate_pins>:
{
 802050c:	b508      	push	{r3, lr}
    return report_pins(state, args);
 802050e:	f7fa ffe5 	bl	801b4dc <report_pins>
}
 8020512:	bd08      	pop	{r3, pc}

08020514 <enumerate_alarms_grblformatted>:
{
 8020514:	b508      	push	{r3, lr}
    return report_alarm_details(true);
 8020516:	2001      	movs	r0, #1
 8020518:	f7fa fd86 	bl	801b028 <report_alarm_details>
}
 802051c:	bd08      	pop	{r3, pc}

0802051e <enumerate_alarms>:
{
 802051e:	b508      	push	{r3, lr}
    return report_alarm_details(false);
 8020520:	2000      	movs	r0, #0
 8020522:	f7fa fd81 	bl	801b028 <report_alarm_details>
}
 8020526:	bd08      	pop	{r3, pc}

08020528 <enumerate_errors_grblformatted>:
{
 8020528:	b508      	push	{r3, lr}
    return report_error_details(true);
 802052a:	2001      	movs	r0, #1
 802052c:	f7fa fdd2 	bl	801b0d4 <report_error_details>
}
 8020530:	bd08      	pop	{r3, pc}

08020532 <enumerate_errors>:
{
 8020532:	b508      	push	{r3, lr}
    return report_error_details(false);
 8020534:	2000      	movs	r0, #0
 8020536:	f7fa fdcd 	bl	801b0d4 <report_error_details>
}
 802053a:	bd08      	pop	{r3, pc}

0802053c <enumerate_groups>:
{
 802053c:	b508      	push	{r3, lr}
    return report_setting_group_details(true, NULL);
 802053e:	2100      	movs	r1, #0
 8020540:	2001      	movs	r0, #1
 8020542:	f7fa fe1d 	bl	801b180 <report_setting_group_details>
}
 8020546:	bd08      	pop	{r3, pc}

08020548 <enumerate_all>:
{
 8020548:	b508      	push	{r3, lr}
    report_alarm_details(false);
 802054a:	2000      	movs	r0, #0
 802054c:	f7fa fd6c 	bl	801b028 <report_alarm_details>
    report_error_details(false);
 8020550:	2000      	movs	r0, #0
 8020552:	f7fa fdbf 	bl	801b0d4 <report_error_details>
    report_setting_group_details(true, NULL);
 8020556:	2100      	movs	r1, #0
 8020558:	2001      	movs	r0, #1
 802055a:	f7fa fe11 	bl	801b180 <report_setting_group_details>
    return report_settings_details(SettingsFormat_MachineReadable, Setting_SettingsAll, Group_All);
 802055e:	2200      	movs	r2, #0
 8020560:	f240 218a 	movw	r1, #650	; 0x28a
 8020564:	4610      	mov	r0, r2
 8020566:	f7fa fca1 	bl	801aeac <report_settings_details>
}
 802056a:	bd08      	pop	{r3, pc}

0802056c <enumerate_settings_halformatted>:
{
 802056c:	b508      	push	{r3, lr}
    return report_settings_details(SettingsFormat_grblHAL, Setting_SettingsAll, Group_All);
 802056e:	2200      	movs	r2, #0
 8020570:	f240 218a 	movw	r1, #650	; 0x28a
 8020574:	2003      	movs	r0, #3
 8020576:	f7fa fc99 	bl	801aeac <report_settings_details>
}
 802057a:	bd08      	pop	{r3, pc}

0802057c <enumerate_settings_grblformatted>:
{
 802057c:	b508      	push	{r3, lr}
    return report_settings_details(SettingsFormat_Grbl, Setting_SettingsAll, Group_All);
 802057e:	2200      	movs	r2, #0
 8020580:	f240 218a 	movw	r1, #650	; 0x28a
 8020584:	2002      	movs	r0, #2
 8020586:	f7fa fc91 	bl	801aeac <report_settings_details>
}
 802058a:	bd08      	pop	{r3, pc}

0802058c <enumerate_settings>:
{
 802058c:	b508      	push	{r3, lr}
    return report_settings_details(SettingsFormat_MachineReadable, Setting_SettingsAll, Group_All);
 802058e:	2200      	movs	r2, #0
 8020590:	f240 218a 	movw	r1, #650	; 0x28a
 8020594:	4610      	mov	r0, r2
 8020596:	f7fa fc89 	bl	801aeac <report_settings_details>
}
 802059a:	bd08      	pop	{r3, pc}

0802059c <set_startup_line>:
{
 802059c:	b570      	push	{r4, r5, r6, lr}
 802059e:	460b      	mov	r3, r1
 80205a0:	4615      	mov	r5, r2
    if (!(state == STATE_IDLE || (state & (STATE_ALARM|STATE_ESTOP|STATE_CHECK_MODE))))
 80205a2:	b118      	cbz	r0, 80205ac <set_startup_line+0x10>
 80205a4:	f240 1103 	movw	r1, #259	; 0x103
 80205a8:	4208      	tst	r0, r1
 80205aa:	d017      	beq.n	80205dc <set_startup_line+0x40>
    if(args == NULL)
 80205ac:	b1c3      	cbz	r3, 80205e0 <set_startup_line+0x44>
    args = gc_normalize_block(args, NULL);
 80205ae:	2100      	movs	r1, #0
 80205b0:	4618      	mov	r0, r3
 80205b2:	f7ee fe73 	bl	800f29c <gc_normalize_block>
 80205b6:	4604      	mov	r4, r0
    if(strlen(args) >= (sizeof(stored_line_t) - 1))
 80205b8:	f7e7 fd4c 	bl	8008054 <strlen>
 80205bc:	2844      	cmp	r0, #68	; 0x44
 80205be:	d902      	bls.n	80205c6 <set_startup_line+0x2a>
        retval = Status_Overflow;
 80205c0:	260b      	movs	r6, #11
}
 80205c2:	4630      	mov	r0, r6
 80205c4:	bd70      	pop	{r4, r5, r6, pc}
    else if ((retval = gc_execute_block(args)) == Status_OK) // Execute gcode block to ensure block is valid.
 80205c6:	4620      	mov	r0, r4
 80205c8:	f7ee ff0a 	bl	800f3e0 <gc_execute_block>
 80205cc:	4606      	mov	r6, r0
 80205ce:	2800      	cmp	r0, #0
 80205d0:	d1f7      	bne.n	80205c2 <set_startup_line+0x26>
        settings_write_startup_line(lnr, args);
 80205d2:	4621      	mov	r1, r4
 80205d4:	b2e8      	uxtb	r0, r5
 80205d6:	f7fc f993 	bl	801c900 <settings_write_startup_line>
 80205da:	e7f2      	b.n	80205c2 <set_startup_line+0x26>
        return Status_IdleError;
 80205dc:	2608      	movs	r6, #8
 80205de:	e7f0      	b.n	80205c2 <set_startup_line+0x26>
        return Status_InvalidStatement;
 80205e0:	2603      	movs	r6, #3
 80205e2:	e7ee      	b.n	80205c2 <set_startup_line+0x26>

080205e4 <set_startup_line1>:
{
 80205e4:	b508      	push	{r3, lr}
    return set_startup_line(state, args, 1);
 80205e6:	2201      	movs	r2, #1
 80205e8:	f7ff ffd8 	bl	802059c <set_startup_line>
}
 80205ec:	bd08      	pop	{r3, pc}

080205ee <set_startup_line0>:
{
 80205ee:	b508      	push	{r3, lr}
    return set_startup_line(state, args, 0);
 80205f0:	2200      	movs	r2, #0
 80205f2:	f7ff ffd3 	bl	802059c <set_startup_line>
}
 80205f6:	bd08      	pop	{r3, pc}

080205f8 <output_startup_lines>:
{
 80205f8:	b530      	push	{r4, r5, lr}
 80205fa:	b093      	sub	sp, #76	; 0x4c
    if (!(state == STATE_IDLE || (state & (STATE_ALARM|STATE_ESTOP|STATE_CHECK_MODE))))
 80205fc:	4604      	mov	r4, r0
 80205fe:	b150      	cbz	r0, 8020616 <output_startup_lines+0x1e>
 8020600:	f240 1303 	movw	r3, #259	; 0x103
 8020604:	4218      	tst	r0, r3
 8020606:	d017      	beq.n	8020638 <output_startup_lines+0x40>
 8020608:	2400      	movs	r4, #0
 802060a:	e004      	b.n	8020616 <output_startup_lines+0x1e>
            report_startup_line(counter, line);
 802060c:	4669      	mov	r1, sp
 802060e:	4628      	mov	r0, r5
 8020610:	f7f9 fabe 	bl	8019b90 <report_startup_line>
    for (counter = 0; counter < N_STARTUP_LINE; counter++) {
 8020614:	3401      	adds	r4, #1
 8020616:	2c01      	cmp	r4, #1
 8020618:	d80b      	bhi.n	8020632 <output_startup_lines+0x3a>
        if (!(settings_read_startup_line(counter, line)))
 802061a:	b2e5      	uxtb	r5, r4
 802061c:	4669      	mov	r1, sp
 802061e:	4628      	mov	r0, r5
 8020620:	f7fc f992 	bl	801c948 <settings_read_startup_line>
 8020624:	2800      	cmp	r0, #0
 8020626:	d1f1      	bne.n	802060c <output_startup_lines+0x14>
            grbl.report.status_message(Status_SettingReadFail);
 8020628:	4b04      	ldr	r3, [pc, #16]	; (802063c <output_startup_lines+0x44>)
 802062a:	689b      	ldr	r3, [r3, #8]
 802062c:	2007      	movs	r0, #7
 802062e:	4798      	blx	r3
 8020630:	e7f0      	b.n	8020614 <output_startup_lines+0x1c>
    return Status_OK;
 8020632:	2000      	movs	r0, #0
}
 8020634:	b013      	add	sp, #76	; 0x4c
 8020636:	bd30      	pop	{r4, r5, pc}
        return Status_IdleError;
 8020638:	2008      	movs	r0, #8
 802063a:	e7fb      	b.n	8020634 <output_startup_lines+0x3c>
 802063c:	2000343c 	.word	0x2000343c

08020640 <settings_reset>:
{
 8020640:	b508      	push	{r3, lr}
    if (!(state == STATE_IDLE || (state & (STATE_ALARM|STATE_ESTOP))))
 8020642:	b118      	cbz	r0, 802064c <settings_reset+0xc>
 8020644:	f240 1201 	movw	r2, #257	; 0x101
 8020648:	4210      	tst	r0, r2
 802064a:	d022      	beq.n	8020692 <settings_reset+0x52>
    else switch (*args) {
 802064c:	780b      	ldrb	r3, [r1, #0]
 802064e:	3b23      	subs	r3, #35	; 0x23
 8020650:	2b07      	cmp	r3, #7
 8020652:	d820      	bhi.n	8020696 <settings_reset+0x56>
 8020654:	e8df f003 	tbb	[pc, r3]
 8020658:	0f1f0409 	.word	0x0f1f0409
 802065c:	0c1f1f1f 	.word	0x0c1f1f1f
            restore.defaults = On;
 8020660:	f04f 0301 	mov.w	r3, #1
    if(retval == Status_OK && restore.mask) {
 8020664:	b2d8      	uxtb	r0, r3
 8020666:	b948      	cbnz	r0, 802067c <settings_reset+0x3c>
}
 8020668:	bd08      	pop	{r3, pc}
            restore.parameters = On;
 802066a:	f04f 0302 	mov.w	r3, #2
    if(retval == Status_OK && restore.mask) {
 802066e:	e7f9      	b.n	8020664 <settings_reset+0x24>
            restore.mask = settings_all.mask;
 8020670:	4b0a      	ldr	r3, [pc, #40]	; (802069c <settings_reset+0x5c>)
 8020672:	781b      	ldrb	r3, [r3, #0]
    if(retval == Status_OK && restore.mask) {
 8020674:	e7f6      	b.n	8020664 <settings_reset+0x24>
            restore.driver_parameters = On;
 8020676:	f04f 0310 	mov.w	r3, #16
    if(retval == Status_OK && restore.mask) {
 802067a:	e7f3      	b.n	8020664 <settings_reset+0x24>
        settings_restore(restore);
 802067c:	4618      	mov	r0, r3
 802067e:	f7fc fa4d 	bl	801cb1c <settings_restore>
        grbl.report.feedback_message(Message_RestoreDefaults);
 8020682:	4b07      	ldr	r3, [pc, #28]	; (80206a0 <settings_reset+0x60>)
 8020684:	68db      	ldr	r3, [r3, #12]
 8020686:	2009      	movs	r0, #9
 8020688:	4798      	blx	r3
        mc_reset(); // Force reset to ensure settings are initialized correctly.
 802068a:	f7f4 fb45 	bl	8014d18 <mc_reset>
 802068e:	2000      	movs	r0, #0
 8020690:	e7ea      	b.n	8020668 <settings_reset+0x28>
        retval = Status_IdleError;
 8020692:	2008      	movs	r0, #8
 8020694:	e7e8      	b.n	8020668 <settings_reset+0x28>
    else switch (*args) {
 8020696:	2003      	movs	r0, #3
 8020698:	e7e6      	b.n	8020668 <settings_reset+0x28>
 802069a:	bf00      	nop
 802069c:	0802c3e4 	.word	0x0802c3e4
 80206a0:	2000343c 	.word	0x2000343c

080206a4 <output_all_build_info>:
{
 80206a4:	b500      	push	{lr}
 80206a6:	b093      	sub	sp, #76	; 0x4c
    settings_read_build_info(info);
 80206a8:	4668      	mov	r0, sp
 80206aa:	f7fc f90d 	bl	801c8c8 <settings_read_build_info>
    report_build_info(info, true);
 80206ae:	2101      	movs	r1, #1
 80206b0:	4668      	mov	r0, sp
 80206b2:	f7f9 faab 	bl	8019c0c <report_build_info>
}
 80206b6:	2000      	movs	r0, #0
 80206b8:	b013      	add	sp, #76	; 0x4c
 80206ba:	f85d fb04 	ldr.w	pc, [sp], #4

080206be <build_info>:
{
 80206be:	b510      	push	{r4, lr}
 80206c0:	b092      	sub	sp, #72	; 0x48
 80206c2:	460c      	mov	r4, r1
    if (!(state == STATE_IDLE || (state & (STATE_ALARM|STATE_ESTOP|STATE_SLEEP|STATE_CHECK_MODE))))
 80206c4:	b118      	cbz	r0, 80206ce <build_info+0x10>
 80206c6:	f240 1283 	movw	r2, #387	; 0x183
 80206ca:	4210      	tst	r0, r2
 80206cc:	d014      	beq.n	80206f8 <build_info+0x3a>
    if (args == NULL) {
 80206ce:	b154      	cbz	r4, 80206e6 <build_info+0x28>
    else if (strlen(args) < (sizeof(stored_line_t) - 1))
 80206d0:	4620      	mov	r0, r4
 80206d2:	f7e7 fcbf 	bl	8008054 <strlen>
 80206d6:	2844      	cmp	r0, #68	; 0x44
 80206d8:	d810      	bhi.n	80206fc <build_info+0x3e>
        settings_write_build_info(args);
 80206da:	4620      	mov	r0, r4
 80206dc:	f7fc f8e2 	bl	801c8a4 <settings_write_build_info>
    return Status_OK;
 80206e0:	2000      	movs	r0, #0
}
 80206e2:	b012      	add	sp, #72	; 0x48
 80206e4:	bd10      	pop	{r4, pc}
        settings_read_build_info(info);
 80206e6:	4668      	mov	r0, sp
 80206e8:	f7fc f8ee 	bl	801c8c8 <settings_read_build_info>
        report_build_info(info, false);
 80206ec:	2100      	movs	r1, #0
 80206ee:	4668      	mov	r0, sp
 80206f0:	f7f9 fa8c 	bl	8019c0c <report_build_info>
    return Status_OK;
 80206f4:	2000      	movs	r0, #0
 80206f6:	e7f4      	b.n	80206e2 <build_info+0x24>
        return Status_IdleError;
 80206f8:	2008      	movs	r0, #8
 80206fa:	e7f2      	b.n	80206e2 <build_info+0x24>
        return Status_InvalidStatement;
 80206fc:	2003      	movs	r0, #3
 80206fe:	e7f0      	b.n	80206e2 <build_info+0x24>

08020700 <tool_probe_workpiece>:
{
 8020700:	b508      	push	{r3, lr}
    return tc_probe_workpiece();
 8020702:	f001 fa5d 	bl	8021bc0 <tc_probe_workpiece>
}
 8020706:	bd08      	pop	{r3, pc}

08020708 <output_spindles>:
{
 8020708:	b508      	push	{r3, lr}
    return report_spindles();
 802070a:	f7fa ff3f 	bl	801b58c <report_spindles>
}
 802070e:	bd08      	pop	{r3, pc}

08020710 <check_mode>:
{
 8020710:	b508      	push	{r3, lr}
    if (state == STATE_CHECK_MODE) {
 8020712:	2802      	cmp	r0, #2
 8020714:	d009      	beq.n	802072a <check_mode+0x1a>
    } else if (state == STATE_IDLE) { // Requires idle mode.
 8020716:	b980      	cbnz	r0, 802073a <check_mode+0x2a>
        state_set(STATE_CHECK_MODE);
 8020718:	2002      	movs	r0, #2
 802071a:	f7fd ff69 	bl	801e5f0 <state_set>
        grbl.report.feedback_message(Message_Enabled);
 802071e:	4b08      	ldr	r3, [pc, #32]	; (8020740 <check_mode+0x30>)
 8020720:	68db      	ldr	r3, [r3, #12]
 8020722:	2004      	movs	r0, #4
 8020724:	4798      	blx	r3
    return Status_OK;
 8020726:	2000      	movs	r0, #0
}
 8020728:	bd08      	pop	{r3, pc}
        mc_reset();
 802072a:	f7f4 faf5 	bl	8014d18 <mc_reset>
        grbl.report.feedback_message(Message_Disabled);
 802072e:	4b04      	ldr	r3, [pc, #16]	; (8020740 <check_mode+0x30>)
 8020730:	68db      	ldr	r3, [r3, #12]
 8020732:	2005      	movs	r0, #5
 8020734:	4798      	blx	r3
    return Status_OK;
 8020736:	2000      	movs	r0, #0
 8020738:	e7f6      	b.n	8020728 <check_mode+0x18>
        return Status_IdleError;
 802073a:	2008      	movs	r0, #8
 802073c:	e7f4      	b.n	8020728 <check_mode+0x18>
 802073e:	bf00      	nop
 8020740:	2000343c 	.word	0x2000343c

08020744 <disable_lock>:
{
 8020744:	b510      	push	{r4, lr}
 8020746:	b082      	sub	sp, #8
    if(state & (STATE_ALARM|STATE_ESTOP)) {
 8020748:	f240 1301 	movw	r3, #257	; 0x101
 802074c:	4218      	tst	r0, r3
 802074e:	d037      	beq.n	80207c0 <disable_lock+0x7c>
        control_signals_t control_signals = hal.control.get_state();
 8020750:	4b1d      	ldr	r3, [pc, #116]	; (80207c8 <disable_lock+0x84>)
 8020752:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8020754:	4798      	blx	r3
        if(sys.alarm == Alarm_SelftestFailed)
 8020756:	4b1d      	ldr	r3, [pc, #116]	; (80207cc <disable_lock+0x88>)
 8020758:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 802075c:	2b10      	cmp	r3, #16
 802075e:	d023      	beq.n	80207a8 <disable_lock+0x64>
        else if (control_signals.e_stop)
 8020760:	b2c4      	uxtb	r4, r0
 8020762:	f010 0f40 	tst.w	r0, #64	; 0x40
 8020766:	d121      	bne.n	80207ac <disable_lock+0x68>
        else if (control_signals.safety_door_ajar)
 8020768:	f014 0f08 	tst.w	r4, #8
 802076c:	d120      	bne.n	80207b0 <disable_lock+0x6c>
        else if(control_signals.reset)
 802076e:	f014 0401 	ands.w	r4, r4, #1
 8020772:	d11f      	bne.n	80207b4 <disable_lock+0x70>
        else if(settings.limits.flags.hard_enabled && settings.limits.flags.check_at_init && limit_signals_merge(hal.limits.get_state()).value)
 8020774:	4b16      	ldr	r3, [pc, #88]	; (80207d0 <disable_lock+0x8c>)
 8020776:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 802077a:	f003 0305 	and.w	r3, r3, #5
 802077e:	2b05      	cmp	r3, #5
 8020780:	d107      	bne.n	8020792 <disable_lock+0x4e>
 8020782:	4b11      	ldr	r3, [pc, #68]	; (80207c8 <disable_lock+0x84>)
 8020784:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8020786:	4798      	blx	r3
 8020788:	9001      	str	r0, [sp, #4]
 802078a:	f7f2 fdb5 	bl	80132f8 <limit_signals_merge>
 802078e:	b2c0      	uxtb	r0, r0
 8020790:	b990      	cbnz	r0, 80207b8 <disable_lock+0x74>
        else if(limits_homing_required())
 8020792:	f7f3 f9d9 	bl	8013b48 <limits_homing_required>
 8020796:	b988      	cbnz	r0, 80207bc <disable_lock+0x78>
            grbl.report.feedback_message(Message_AlarmUnlock);
 8020798:	4b0e      	ldr	r3, [pc, #56]	; (80207d4 <disable_lock+0x90>)
 802079a:	68db      	ldr	r3, [r3, #12]
 802079c:	2003      	movs	r0, #3
 802079e:	4798      	blx	r3
            state_set(STATE_IDLE);
 80207a0:	2000      	movs	r0, #0
 80207a2:	f7fd ff25 	bl	801e5f0 <state_set>
 80207a6:	e00c      	b.n	80207c2 <disable_lock+0x7e>
            retval = Status_SelfTestFailed;
 80207a8:	2431      	movs	r4, #49	; 0x31
 80207aa:	e00a      	b.n	80207c2 <disable_lock+0x7e>
            retval = Status_EStop;
 80207ac:	2432      	movs	r4, #50	; 0x32
 80207ae:	e008      	b.n	80207c2 <disable_lock+0x7e>
            retval = Status_CheckDoor;
 80207b0:	240d      	movs	r4, #13
 80207b2:	e006      	b.n	80207c2 <disable_lock+0x7e>
            retval = Status_Reset;
 80207b4:	2412      	movs	r4, #18
 80207b6:	e004      	b.n	80207c2 <disable_lock+0x7e>
            retval = Status_LimitsEngaged;
 80207b8:	242d      	movs	r4, #45	; 0x2d
 80207ba:	e002      	b.n	80207c2 <disable_lock+0x7e>
            retval = Status_HomingRequired;
 80207bc:	242e      	movs	r4, #46	; 0x2e
 80207be:	e000      	b.n	80207c2 <disable_lock+0x7e>
    status_code_t retval = Status_OK;
 80207c0:	2400      	movs	r4, #0
}
 80207c2:	4620      	mov	r0, r4
 80207c4:	b002      	add	sp, #8
 80207c6:	bd10      	pop	{r4, pc}
 80207c8:	2000350c 	.word	0x2000350c
 80207cc:	200036c4 	.word	0x200036c4
 80207d0:	20003b14 	.word	0x20003b14
 80207d4:	2000343c 	.word	0x2000343c

080207d8 <control_interrupt_handler>:
{
 80207d8:	b570      	push	{r4, r5, r6, lr}
 80207da:	b082      	sub	sp, #8
 80207dc:	4604      	mov	r4, r0
    if(signals.deasserted)
 80207de:	f3c4 2507 	ubfx	r5, r4, #8, #8
 80207e2:	f414 4f00 	tst.w	r4, #32768	; 0x8000
 80207e6:	d12c      	bne.n	8020842 <control_interrupt_handler+0x6a>
    if (signals.value) {
 80207e8:	b283      	uxth	r3, r0
 80207ea:	b353      	cbz	r3, 8020842 <control_interrupt_handler+0x6a>
        sys.last_event.control.value = signals.value;
 80207ec:	4a4d      	ldr	r2, [pc, #308]	; (8020924 <control_interrupt_handler+0x14c>)
 80207ee:	f8a2 0080 	strh.w	r0, [r2, #128]	; 0x80
        if ((signals.reset || signals.e_stop || signals.motor_fault) && state_get() != STATE_ESTOP)
 80207f2:	f240 1241 	movw	r2, #321	; 0x141
 80207f6:	4213      	tst	r3, r2
 80207f8:	d125      	bne.n	8020846 <control_interrupt_handler+0x6e>
            if (signals.safety_door_ajar && hal.signals_cap.safety_door_ajar) {
 80207fa:	b2e6      	uxtb	r6, r4
 80207fc:	f014 0f08 	tst.w	r4, #8
 8020800:	d010      	beq.n	8020824 <control_interrupt_handler+0x4c>
 8020802:	4b49      	ldr	r3, [pc, #292]	; (8020928 <control_interrupt_handler+0x150>)
 8020804:	f893 31a8 	ldrb.w	r3, [r3, #424]	; 0x1a8
 8020808:	f013 0f08 	tst.w	r3, #8
 802080c:	d00a      	beq.n	8020824 <control_interrupt_handler+0x4c>
                if(settings.safety_door.flags.ignore_when_idle) {
 802080e:	4b47      	ldr	r3, [pc, #284]	; (802092c <control_interrupt_handler+0x154>)
 8020810:	f893 313c 	ldrb.w	r3, [r3, #316]	; 0x13c
 8020814:	f013 0f01 	tst.w	r3, #1
 8020818:	d11d      	bne.n	8020856 <control_interrupt_handler+0x7e>
                    system_set_exec_state_flag(EXEC_SAFETY_DOOR);
 802081a:	4b43      	ldr	r3, [pc, #268]	; (8020928 <control_interrupt_handler+0x150>)
 802081c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802081e:	2140      	movs	r1, #64	; 0x40
 8020820:	4843      	ldr	r0, [pc, #268]	; (8020930 <control_interrupt_handler+0x158>)
 8020822:	4798      	blx	r3
            if(signals.probe_overtravel) {
 8020824:	f015 0f20 	tst.w	r5, #32
 8020828:	d029      	beq.n	802087e <control_interrupt_handler+0xa6>
                limit_signals_t overtravel = { .min.z = On};
 802082a:	2300      	movs	r3, #0
 802082c:	9301      	str	r3, [sp, #4]
 802082e:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8020832:	f043 0304 	orr.w	r3, r3, #4
 8020836:	f88d 3004 	strb.w	r3, [sp, #4]
                hal.limits.interrupt_callback(overtravel);
 802083a:	4b3b      	ldr	r3, [pc, #236]	; (8020928 <control_interrupt_handler+0x150>)
 802083c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802083e:	9801      	ldr	r0, [sp, #4]
 8020840:	4798      	blx	r3
}
 8020842:	b002      	add	sp, #8
 8020844:	bd70      	pop	{r4, r5, r6, pc}
        if ((signals.reset || signals.e_stop || signals.motor_fault) && state_get() != STATE_ESTOP)
 8020846:	f7fd fecd 	bl	801e5e4 <state_get>
 802084a:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 802084e:	d0d4      	beq.n	80207fa <control_interrupt_handler+0x22>
            mc_reset();
 8020850:	f7f4 fa62 	bl	8014d18 <mc_reset>
 8020854:	e7f5      	b.n	8020842 <control_interrupt_handler+0x6a>
                    if(state_get() != STATE_IDLE && state_get() != STATE_JOG)
 8020856:	f7fd fec5 	bl	801e5e4 <state_get>
 802085a:	b930      	cbnz	r0, 802086a <control_interrupt_handler+0x92>
                    if(settings.mode == Mode_Laser) // Turn off spindle immediately (laser) when in laser mode
 802085c:	4b33      	ldr	r3, [pc, #204]	; (802092c <control_interrupt_handler+0x154>)
 802085e:	7e1b      	ldrb	r3, [r3, #24]
 8020860:	2b01      	cmp	r3, #1
 8020862:	d1df      	bne.n	8020824 <control_interrupt_handler+0x4c>
                        spindle_all_off();
 8020864:	f7fd fa64 	bl	801dd30 <spindle_all_off>
 8020868:	e7dc      	b.n	8020824 <control_interrupt_handler+0x4c>
                    if(state_get() != STATE_IDLE && state_get() != STATE_JOG)
 802086a:	f7fd febb 	bl	801e5e4 <state_get>
 802086e:	2820      	cmp	r0, #32
 8020870:	d0f4      	beq.n	802085c <control_interrupt_handler+0x84>
                        system_set_exec_state_flag(EXEC_SAFETY_DOOR);
 8020872:	4b2d      	ldr	r3, [pc, #180]	; (8020928 <control_interrupt_handler+0x150>)
 8020874:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8020876:	2140      	movs	r1, #64	; 0x40
 8020878:	482d      	ldr	r0, [pc, #180]	; (8020930 <control_interrupt_handler+0x158>)
 802087a:	4798      	blx	r3
 802087c:	e7ee      	b.n	802085c <control_interrupt_handler+0x84>
            } else if (signals.probe_triggered) {
 802087e:	f015 0f40 	tst.w	r5, #64	; 0x40
 8020882:	d019      	beq.n	80208b8 <control_interrupt_handler+0xe0>
                if(sys.probing_state == Probing_Off && (state_get() & (STATE_CYCLE|STATE_JOG))) {
 8020884:	4b27      	ldr	r3, [pc, #156]	; (8020924 <control_interrupt_handler+0x14c>)
 8020886:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 802088a:	b133      	cbz	r3, 802089a <control_interrupt_handler+0xc2>
                    hal.probe.configure(false, false);
 802088c:	4b26      	ldr	r3, [pc, #152]	; (8020928 <control_interrupt_handler+0x150>)
 802088e:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 8020892:	2100      	movs	r1, #0
 8020894:	4608      	mov	r0, r1
 8020896:	4798      	blx	r3
 8020898:	e7d3      	b.n	8020842 <control_interrupt_handler+0x6a>
                if(sys.probing_state == Probing_Off && (state_get() & (STATE_CYCLE|STATE_JOG))) {
 802089a:	f7fd fea3 	bl	801e5e4 <state_get>
 802089e:	f010 0f28 	tst.w	r0, #40	; 0x28
 80208a2:	d0f3      	beq.n	802088c <control_interrupt_handler+0xb4>
                    system_set_exec_state_flag(EXEC_STOP);
 80208a4:	4b20      	ldr	r3, [pc, #128]	; (8020928 <control_interrupt_handler+0x150>)
 80208a6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80208a8:	4c21      	ldr	r4, [pc, #132]	; (8020930 <control_interrupt_handler+0x158>)
 80208aa:	2110      	movs	r1, #16
 80208ac:	4620      	mov	r0, r4
 80208ae:	4798      	blx	r3
                    sys.alarm_pending = Alarm_ProbeProtect;
 80208b0:	230d      	movs	r3, #13
 80208b2:	f804 3c34 	strb.w	r3, [r4, #-52]
 80208b6:	e7c4      	b.n	8020842 <control_interrupt_handler+0x6a>
            } else if (signals.probe_disconnected) {
 80208b8:	f016 0f80 	tst.w	r6, #128	; 0x80
 80208bc:	d108      	bne.n	80208d0 <control_interrupt_handler+0xf8>
            } else if (signals.feed_hold)
 80208be:	f016 0f02 	tst.w	r6, #2
 80208c2:	d019      	beq.n	80208f8 <control_interrupt_handler+0x120>
                system_set_exec_state_flag(EXEC_FEED_HOLD);
 80208c4:	4b18      	ldr	r3, [pc, #96]	; (8020928 <control_interrupt_handler+0x150>)
 80208c6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80208c8:	2108      	movs	r1, #8
 80208ca:	4819      	ldr	r0, [pc, #100]	; (8020930 <control_interrupt_handler+0x158>)
 80208cc:	4798      	blx	r3
 80208ce:	e7b8      	b.n	8020842 <control_interrupt_handler+0x6a>
                if(sys.probing_state == Probing_Active && state_get() == STATE_CYCLE) {
 80208d0:	4b14      	ldr	r3, [pc, #80]	; (8020924 <control_interrupt_handler+0x14c>)
 80208d2:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 80208d6:	b2db      	uxtb	r3, r3
 80208d8:	2b01      	cmp	r3, #1
 80208da:	d1b2      	bne.n	8020842 <control_interrupt_handler+0x6a>
 80208dc:	f7fd fe82 	bl	801e5e4 <state_get>
 80208e0:	2808      	cmp	r0, #8
 80208e2:	d1ae      	bne.n	8020842 <control_interrupt_handler+0x6a>
                    system_set_exec_state_flag(EXEC_FEED_HOLD);
 80208e4:	4b10      	ldr	r3, [pc, #64]	; (8020928 <control_interrupt_handler+0x150>)
 80208e6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80208e8:	4c11      	ldr	r4, [pc, #68]	; (8020930 <control_interrupt_handler+0x158>)
 80208ea:	2108      	movs	r1, #8
 80208ec:	4620      	mov	r0, r4
 80208ee:	4798      	blx	r3
                    sys.alarm_pending = Alarm_ProbeProtect;
 80208f0:	230d      	movs	r3, #13
 80208f2:	f804 3c34 	strb.w	r3, [r4, #-52]
 80208f6:	e7a4      	b.n	8020842 <control_interrupt_handler+0x6a>
            else if (signals.cycle_start) {
 80208f8:	f016 0f04 	tst.w	r6, #4
 80208fc:	d0a1      	beq.n	8020842 <control_interrupt_handler+0x6a>
                system_set_exec_state_flag(EXEC_CYCLE_START);
 80208fe:	4b0a      	ldr	r3, [pc, #40]	; (8020928 <control_interrupt_handler+0x150>)
 8020900:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8020902:	4c0b      	ldr	r4, [pc, #44]	; (8020930 <control_interrupt_handler+0x158>)
 8020904:	2102      	movs	r1, #2
 8020906:	4620      	mov	r0, r4
 8020908:	4798      	blx	r3
                sys.report.cycle_start = settings.status_report.pin_state;
 802090a:	4b08      	ldr	r3, [pc, #32]	; (802092c <control_interrupt_handler+0x154>)
 802090c:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 8020910:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8020914:	f814 2c15 	ldrb.w	r2, [r4, #-21]
 8020918:	f363 1286 	bfi	r2, r3, #6, #1
 802091c:	f804 2c15 	strb.w	r2, [r4, #-21]
 8020920:	e78f      	b.n	8020842 <control_interrupt_handler+0x6a>
 8020922:	bf00      	nop
 8020924:	200036c4 	.word	0x200036c4
 8020928:	2000350c 	.word	0x2000350c
 802092c:	20003b14 	.word	0x20003b14
 8020930:	2000370c 	.word	0x2000370c

08020934 <system_execute_startup>:
    if(hal.nvs.type != NVS_None) {
 8020934:	4b11      	ldr	r3, [pc, #68]	; (802097c <system_execute_startup+0x48>)
 8020936:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 802093a:	b9cb      	cbnz	r3, 8020970 <system_execute_startup+0x3c>
 802093c:	4770      	bx	lr
                report_execute_startup_message(line, Status_SettingReadFail);
 802093e:	2107      	movs	r1, #7
 8020940:	4668      	mov	r0, sp
 8020942:	f7f9 f945 	bl	8019bd0 <report_execute_startup_message>
        for (n = 0; n < N_STARTUP_LINE; n++) {
 8020946:	3401      	adds	r4, #1
 8020948:	2c01      	cmp	r4, #1
 802094a:	d815      	bhi.n	8020978 <system_execute_startup+0x44>
            if (!settings_read_startup_line(n, line))
 802094c:	4669      	mov	r1, sp
 802094e:	b2e0      	uxtb	r0, r4
 8020950:	f7fb fffa 	bl	801c948 <settings_read_startup_line>
 8020954:	2800      	cmp	r0, #0
 8020956:	d0f2      	beq.n	802093e <system_execute_startup+0xa>
            else if (*line != '\0')
 8020958:	f89d 3000 	ldrb.w	r3, [sp]
 802095c:	2b00      	cmp	r3, #0
 802095e:	d0f2      	beq.n	8020946 <system_execute_startup+0x12>
                report_execute_startup_message(line, gc_execute_block(line));
 8020960:	4668      	mov	r0, sp
 8020962:	f7ee fd3d 	bl	800f3e0 <gc_execute_block>
 8020966:	4601      	mov	r1, r0
 8020968:	4668      	mov	r0, sp
 802096a:	f7f9 f931 	bl	8019bd0 <report_execute_startup_message>
 802096e:	e7ea      	b.n	8020946 <system_execute_startup+0x12>
{
 8020970:	b510      	push	{r4, lr}
 8020972:	b092      	sub	sp, #72	; 0x48
        for (n = 0; n < N_STARTUP_LINE; n++) {
 8020974:	2400      	movs	r4, #0
 8020976:	e7e7      	b.n	8020948 <system_execute_startup+0x14>
}
 8020978:	b012      	add	sp, #72	; 0x48
 802097a:	bd10      	pop	{r4, pc}
 802097c:	2000350c 	.word	0x2000350c

08020980 <go_home>:
{
 8020980:	b510      	push	{r4, lr}
 8020982:	460c      	mov	r4, r1
    if(axes.mask && !settings.homing.flags.single_axis_commands)
 8020984:	b2cb      	uxtb	r3, r1
 8020986:	b12b      	cbz	r3, 8020994 <go_home+0x14>
 8020988:	4b3a      	ldr	r3, [pc, #232]	; (8020a74 <go_home+0xf4>)
 802098a:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 802098e:	f013 0f02 	tst.w	r3, #2
 8020992:	d06b      	beq.n	8020a6c <go_home+0xec>
    if(!(state_get() == STATE_IDLE || (state_get() & (STATE_ALARM|STATE_ESTOP))))
 8020994:	f7fd fe26 	bl	801e5e4 <state_get>
 8020998:	bb40      	cbnz	r0, 80209ec <go_home+0x6c>
    control_signals_t control_signals = hal.control.get_state();
 802099a:	4b37      	ldr	r3, [pc, #220]	; (8020a78 <go_home+0xf8>)
 802099c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 802099e:	4798      	blx	r3
    if(sys.alarm == Alarm_SelftestFailed)
 80209a0:	4b36      	ldr	r3, [pc, #216]	; (8020a7c <go_home+0xfc>)
 80209a2:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 80209a6:	2b10      	cmp	r3, #16
 80209a8:	d02d      	beq.n	8020a06 <go_home+0x86>
    else if (control_signals.e_stop)
 80209aa:	b2c3      	uxtb	r3, r0
 80209ac:	f010 0f40 	tst.w	r0, #64	; 0x40
 80209b0:	d132      	bne.n	8020a18 <go_home+0x98>
    else if(control_signals.motor_fault)
 80209b2:	f410 7f80 	tst.w	r0, #256	; 0x100
 80209b6:	d131      	bne.n	8020a1c <go_home+0x9c>
    else if (!(settings.homing.flags.enabled && (sys.homing.mask || settings.homing.flags.single_axis_commands || settings.homing.flags.manual)))
 80209b8:	4a2e      	ldr	r2, [pc, #184]	; (8020a74 <go_home+0xf4>)
 80209ba:	f892 2114 	ldrb.w	r2, [r2, #276]	; 0x114
 80209be:	f012 0f01 	tst.w	r2, #1
 80209c2:	d02d      	beq.n	8020a20 <go_home+0xa0>
 80209c4:	492d      	ldr	r1, [pc, #180]	; (8020a7c <go_home+0xfc>)
 80209c6:	7e89      	ldrb	r1, [r1, #26]
 80209c8:	b911      	cbnz	r1, 80209d0 <go_home+0x50>
 80209ca:	f012 0f12 	tst.w	r2, #18
 80209ce:	d029      	beq.n	8020a24 <go_home+0xa4>
    else if (control_signals.safety_door_ajar && !settings.safety_door.flags.ignore_when_idle)
 80209d0:	f013 0f08 	tst.w	r3, #8
 80209d4:	d005      	beq.n	80209e2 <go_home+0x62>
 80209d6:	4a27      	ldr	r2, [pc, #156]	; (8020a74 <go_home+0xf4>)
 80209d8:	f892 213c 	ldrb.w	r2, [r2, #316]	; 0x13c
 80209dc:	f012 0f01 	tst.w	r2, #1
 80209e0:	d022      	beq.n	8020a28 <go_home+0xa8>
    else if(control_signals.reset)
 80209e2:	f013 0f01 	tst.w	r3, #1
 80209e6:	d009      	beq.n	80209fc <go_home+0x7c>
        retval = Status_Reset;
 80209e8:	2412      	movs	r4, #18
 80209ea:	e00d      	b.n	8020a08 <go_home+0x88>
    if(!(state_get() == STATE_IDLE || (state_get() & (STATE_ALARM|STATE_ESTOP))))
 80209ec:	f7fd fdfa 	bl	801e5e4 <state_get>
 80209f0:	f240 1301 	movw	r3, #257	; 0x101
 80209f4:	4218      	tst	r0, r3
 80209f6:	d1d0      	bne.n	802099a <go_home+0x1a>
        return Status_IdleError;
 80209f8:	2408      	movs	r4, #8
 80209fa:	e00b      	b.n	8020a14 <go_home+0x94>
        retval = mc_homing_cycle(axes); // Home axes according to configuration
 80209fc:	4620      	mov	r0, r4
 80209fe:	f7f4 f9e5 	bl	8014dcc <mc_homing_cycle>
 8020a02:	4604      	mov	r4, r0
 8020a04:	e000      	b.n	8020a08 <go_home+0x88>
        retval = Status_SelfTestFailed;
 8020a06:	2431      	movs	r4, #49	; 0x31
    if (retval == Status_OK && !sys.abort) {
 8020a08:	b914      	cbnz	r4, 8020a10 <go_home+0x90>
 8020a0a:	4b1c      	ldr	r3, [pc, #112]	; (8020a7c <go_home+0xfc>)
 8020a0c:	781b      	ldrb	r3, [r3, #0]
 8020a0e:	b16b      	cbz	r3, 8020a2c <go_home+0xac>
    return retval == Status_Unhandled ? Status_OK : retval;
 8020a10:	2c54      	cmp	r4, #84	; 0x54
 8020a12:	d02d      	beq.n	8020a70 <go_home+0xf0>
}
 8020a14:	4620      	mov	r0, r4
 8020a16:	bd10      	pop	{r4, pc}
        retval = Status_EStop;
 8020a18:	2432      	movs	r4, #50	; 0x32
 8020a1a:	e7f5      	b.n	8020a08 <go_home+0x88>
        retval = Status_MotorFault;
 8020a1c:	2433      	movs	r4, #51	; 0x33
 8020a1e:	e7f3      	b.n	8020a08 <go_home+0x88>
        retval = Status_HomingDisabled;
 8020a20:	2405      	movs	r4, #5
 8020a22:	e7f1      	b.n	8020a08 <go_home+0x88>
 8020a24:	2405      	movs	r4, #5
 8020a26:	e7ef      	b.n	8020a08 <go_home+0x88>
        retval = Status_CheckDoor;
 8020a28:	240d      	movs	r4, #13
 8020a2a:	e7ed      	b.n	8020a08 <go_home+0x88>
        state_set(STATE_IDLE);  // Set to IDLE when complete.
 8020a2c:	2000      	movs	r0, #0
 8020a2e:	f7fd fddf 	bl	801e5f0 <state_set>
        st_go_idle();           // Set steppers to the settings idle state before returning.
 8020a32:	f7fe f9fb 	bl	801ee2c <st_go_idle>
        grbl.report.feedback_message(Message_None);
 8020a36:	4b12      	ldr	r3, [pc, #72]	; (8020a80 <go_home+0x100>)
 8020a38:	68db      	ldr	r3, [r3, #12]
 8020a3a:	2000      	movs	r0, #0
 8020a3c:	4798      	blx	r3
        if (sys.homing.mask && (sys.homing.mask & sys.homed.mask) == sys.homing.mask)
 8020a3e:	4b0f      	ldr	r3, [pc, #60]	; (8020a7c <go_home+0xfc>)
 8020a40:	7e9b      	ldrb	r3, [r3, #26]
 8020a42:	b123      	cbz	r3, 8020a4e <go_home+0xce>
 8020a44:	4a0d      	ldr	r2, [pc, #52]	; (8020a7c <go_home+0xfc>)
 8020a46:	f892 2054 	ldrb.w	r2, [r2, #84]	; 0x54
 8020a4a:	4393      	bics	r3, r2
 8020a4c:	d00b      	beq.n	8020a66 <go_home+0xe6>
        else if(limits_homing_required()) { // Keep alarm state active if homing is required and not all axes homed.
 8020a4e:	f7f3 f87b 	bl	8013b48 <limits_homing_required>
 8020a52:	2800      	cmp	r0, #0
 8020a54:	d0dc      	beq.n	8020a10 <go_home+0x90>
            sys.alarm = Alarm_HomingRequired;
 8020a56:	4b09      	ldr	r3, [pc, #36]	; (8020a7c <go_home+0xfc>)
 8020a58:	220b      	movs	r2, #11
 8020a5a:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c
            state_set(STATE_ALARM);
 8020a5e:	2001      	movs	r0, #1
 8020a60:	f7fd fdc6 	bl	801e5f0 <state_set>
 8020a64:	e7d4      	b.n	8020a10 <go_home+0x90>
            system_execute_startup();
 8020a66:	f7ff ff65 	bl	8020934 <system_execute_startup>
 8020a6a:	e7d1      	b.n	8020a10 <go_home+0x90>
        return Status_HomingDisabled;
 8020a6c:	2405      	movs	r4, #5
 8020a6e:	e7d1      	b.n	8020a14 <go_home+0x94>
    return retval == Status_Unhandled ? Status_OK : retval;
 8020a70:	2400      	movs	r4, #0
 8020a72:	e7cf      	b.n	8020a14 <go_home+0x94>
 8020a74:	20003b14 	.word	0x20003b14
 8020a78:	2000350c 	.word	0x2000350c
 8020a7c:	200036c4 	.word	0x200036c4
 8020a80:	2000343c 	.word	0x2000343c

08020a84 <home_z>:
{
 8020a84:	b508      	push	{r3, lr}
    return go_home(state, (axes_signals_t){Z_AXIS_BIT});
 8020a86:	f04f 0104 	mov.w	r1, #4
 8020a8a:	f7ff ff79 	bl	8020980 <go_home>
}
 8020a8e:	bd08      	pop	{r3, pc}

08020a90 <home_y>:
{
 8020a90:	b508      	push	{r3, lr}
    return go_home(state, (axes_signals_t){Y_AXIS_BIT});
 8020a92:	f04f 0102 	mov.w	r1, #2
 8020a96:	f7ff ff73 	bl	8020980 <go_home>
}
 8020a9a:	bd08      	pop	{r3, pc}

08020a9c <home_x>:
{
 8020a9c:	b508      	push	{r3, lr}
    return go_home(state, (axes_signals_t){X_AXIS_BIT});
 8020a9e:	f04f 0101 	mov.w	r1, #1
 8020aa2:	f7ff ff6d 	bl	8020980 <go_home>
}
 8020aa6:	bd08      	pop	{r3, pc}

08020aa8 <home>:
{
 8020aa8:	b508      	push	{r3, lr}
    return go_home(state, (axes_signals_t){0});
 8020aaa:	f04f 0100 	mov.w	r1, #0
 8020aae:	f7ff ff67 	bl	8020980 <go_home>
}
 8020ab2:	bd08      	pop	{r3, pc}

08020ab4 <read_int>:
{
 8020ab4:	b510      	push	{r4, lr}
 8020ab6:	ed2d 8b02 	vpush	{d8}
 8020aba:	b082      	sub	sp, #8
 8020abc:	460c      	mov	r4, r1
    uint_fast8_t counter = 0;
 8020abe:	2300      	movs	r3, #0
 8020ac0:	9301      	str	r3, [sp, #4]
    if(!read_float(s, &counter, &parameter))
 8020ac2:	466a      	mov	r2, sp
 8020ac4:	a901      	add	r1, sp, #4
 8020ac6:	f7f4 ff3d 	bl	8015944 <read_float>
 8020aca:	b1a8      	cbz	r0, 8020af8 <read_int+0x44>
    if(parameter - truncf(parameter) != 0.0f)
 8020acc:	ed9d 8a00 	vldr	s16, [sp]
 8020ad0:	eeb0 0a48 	vmov.f32	s0, s16
 8020ad4:	f003 f936 	bl	8023d44 <truncf>
 8020ad8:	ee38 0a40 	vsub.f32	s0, s16, s0
 8020adc:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8020ae0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020ae4:	d10a      	bne.n	8020afc <read_int+0x48>
    *value = (int32_t)parameter;
 8020ae6:	eebd 8ac8 	vcvt.s32.f32	s16, s16
 8020aea:	ed84 8a00 	vstr	s16, [r4]
    return Status_OK;
 8020aee:	2000      	movs	r0, #0
}
 8020af0:	b002      	add	sp, #8
 8020af2:	ecbd 8b02 	vpop	{d8}
 8020af6:	bd10      	pop	{r4, pc}
        return Status_BadNumberFormat;
 8020af8:	2002      	movs	r0, #2
 8020afa:	e7f9      	b.n	8020af0 <read_int+0x3c>
        return Status_InvalidStatement;
 8020afc:	2003      	movs	r0, #3
 8020afe:	e7f7      	b.n	8020af0 <read_int+0x3c>

08020b00 <output_setting_description>:
    if(args) {
 8020b00:	b189      	cbz	r1, 8020b26 <output_setting_description+0x26>
{
 8020b02:	b500      	push	{lr}
 8020b04:	b083      	sub	sp, #12
 8020b06:	4608      	mov	r0, r1
        retval = read_int(args, &id);
 8020b08:	a901      	add	r1, sp, #4
 8020b0a:	f7ff ffd3 	bl	8020ab4 <read_int>
        if(retval == Status_OK && id >= 0)
 8020b0e:	b910      	cbnz	r0, 8020b16 <output_setting_description+0x16>
 8020b10:	9901      	ldr	r1, [sp, #4]
 8020b12:	2900      	cmp	r1, #0
 8020b14:	da02      	bge.n	8020b1c <output_setting_description+0x1c>
}
 8020b16:	b003      	add	sp, #12
 8020b18:	f85d fb04 	ldr.w	pc, [sp], #4
            retval = report_setting_description(SettingsFormat_MachineReadable, (setting_id_t)id);
 8020b1c:	b289      	uxth	r1, r1
 8020b1e:	2000      	movs	r0, #0
 8020b20:	f7fa fa2a 	bl	801af78 <report_setting_description>
 8020b24:	e7f7      	b.n	8020b16 <output_setting_description+0x16>
    status_code_t retval = Status_BadNumberFormat;
 8020b26:	2002      	movs	r0, #2
}
 8020b28:	4770      	bx	lr

08020b2a <output_all_settings>:
{
 8020b2a:	b500      	push	{lr}
 8020b2c:	b083      	sub	sp, #12
    if(args) {
 8020b2e:	b171      	cbz	r1, 8020b4e <output_all_settings+0x24>
 8020b30:	460b      	mov	r3, r1
        retval = read_int(args, &id);
 8020b32:	a901      	add	r1, sp, #4
 8020b34:	4618      	mov	r0, r3
 8020b36:	f7ff ffbd 	bl	8020ab4 <read_int>
        if(retval == Status_OK && id >= 0)
 8020b3a:	b960      	cbnz	r0, 8020b56 <output_all_settings+0x2c>
 8020b3c:	9901      	ldr	r1, [sp, #4]
 8020b3e:	2900      	cmp	r1, #0
 8020b40:	db09      	blt.n	8020b56 <output_all_settings+0x2c>
            retval = report_settings_details(SettingsFormat_HumanReadable, (setting_id_t)id, Group_All);
 8020b42:	2200      	movs	r2, #0
 8020b44:	b289      	uxth	r1, r1
 8020b46:	2001      	movs	r0, #1
 8020b48:	f7fa f9b0 	bl	801aeac <report_settings_details>
 8020b4c:	e003      	b.n	8020b56 <output_all_settings+0x2c>
    } else if (state & (STATE_CYCLE|STATE_HOLD))
 8020b4e:	f010 0f18 	tst.w	r0, #24
 8020b52:	d003      	beq.n	8020b5c <output_all_settings+0x32>
        retval = Status_IdleError; // Block during cycle. Takes too long to print.
 8020b54:	2008      	movs	r0, #8
}
 8020b56:	b003      	add	sp, #12
 8020b58:	f85d fb04 	ldr.w	pc, [sp], #4
        report_grbl_settings(true, NULL);
 8020b5c:	2100      	movs	r1, #0
 8020b5e:	2001      	movs	r0, #1
 8020b60:	f7f8 fbbe 	bl	80192e0 <report_grbl_settings>
    status_code_t retval = Status_OK;
 8020b64:	2000      	movs	r0, #0
 8020b66:	e7f6      	b.n	8020b56 <output_all_settings+0x2c>

08020b68 <output_settings>:
{
 8020b68:	b500      	push	{lr}
 8020b6a:	b083      	sub	sp, #12
    if(args) {
 8020b6c:	b171      	cbz	r1, 8020b8c <output_settings+0x24>
 8020b6e:	460b      	mov	r3, r1
        retval = read_int(args, &id);
 8020b70:	a901      	add	r1, sp, #4
 8020b72:	4618      	mov	r0, r3
 8020b74:	f7ff ff9e 	bl	8020ab4 <read_int>
        if(retval == Status_OK && id >= 0)
 8020b78:	b960      	cbnz	r0, 8020b94 <output_settings+0x2c>
 8020b7a:	9901      	ldr	r1, [sp, #4]
 8020b7c:	2900      	cmp	r1, #0
 8020b7e:	db09      	blt.n	8020b94 <output_settings+0x2c>
            retval = report_settings_details(SettingsFormat_HumanReadable, (setting_id_t)id, Group_All);
 8020b80:	2200      	movs	r2, #0
 8020b82:	b289      	uxth	r1, r1
 8020b84:	2001      	movs	r0, #1
 8020b86:	f7fa f991 	bl	801aeac <report_settings_details>
 8020b8a:	e003      	b.n	8020b94 <output_settings+0x2c>
    } else if (state & (STATE_CYCLE|STATE_HOLD))
 8020b8c:	f010 0f18 	tst.w	r0, #24
 8020b90:	d003      	beq.n	8020b9a <output_settings+0x32>
        retval = Status_IdleError; // Block during cycle. Takes too long to print.
 8020b92:	2008      	movs	r0, #8
}
 8020b94:	b003      	add	sp, #12
 8020b96:	f85d fb04 	ldr.w	pc, [sp], #4
    report_grbl_settings(true, NULL);
 8020b9a:	2100      	movs	r1, #0
 8020b9c:	2001      	movs	r0, #1
 8020b9e:	f7f8 fb9f 	bl	80192e0 <report_grbl_settings>
    status_code_t retval = Status_OK;
 8020ba2:	2000      	movs	r0, #0
 8020ba4:	e7f6      	b.n	8020b94 <output_settings+0x2c>

08020ba6 <output_ngc_parameters>:
{
 8020ba6:	b510      	push	{r4, lr}
 8020ba8:	b082      	sub	sp, #8
    if(args) {
 8020baa:	b189      	cbz	r1, 8020bd0 <output_ngc_parameters+0x2a>
 8020bac:	460c      	mov	r4, r1
        retval = read_int(args, &id);
 8020bae:	a901      	add	r1, sp, #4
 8020bb0:	4620      	mov	r0, r4
 8020bb2:	f7ff ff7f 	bl	8020ab4 <read_int>
        if(retval == Status_OK && id >= 0)
 8020bb6:	b910      	cbnz	r0, 8020bbe <output_ngc_parameters+0x18>
 8020bb8:	9801      	ldr	r0, [sp, #4]
 8020bba:	2800      	cmp	r0, #0
 8020bbc:	da04      	bge.n	8020bc8 <output_ngc_parameters+0x22>
            retval = report_named_ngc_parameter(args);
 8020bbe:	4620      	mov	r0, r4
 8020bc0:	f7f8 fcc4 	bl	801954c <report_named_ngc_parameter>
}
 8020bc4:	b002      	add	sp, #8
 8020bc6:	bd10      	pop	{r4, pc}
            retval = report_ngc_parameter((ngc_param_id_t)id);
 8020bc8:	b280      	uxth	r0, r0
 8020bca:	f7f8 fc87 	bl	80194dc <report_ngc_parameter>
 8020bce:	e7f9      	b.n	8020bc4 <output_ngc_parameters+0x1e>
        report_ngc_parameters();
 8020bd0:	f7f8 fcf2 	bl	80195b8 <report_ngc_parameters>
    status_code_t retval = Status_OK;
 8020bd4:	2000      	movs	r0, #0
 8020bd6:	e7f5      	b.n	8020bc4 <output_ngc_parameters+0x1e>

08020bd8 <system_command_help>:
{
 8020bd8:	b510      	push	{r4, lr}
    hal.stream.write("$I - output system information" ASCII_EOL);
 8020bda:	4c65      	ldr	r4, [pc, #404]	; (8020d70 <system_command_help+0x198>)
 8020bdc:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020be0:	4864      	ldr	r0, [pc, #400]	; (8020d74 <system_command_help+0x19c>)
 8020be2:	4798      	blx	r3
    hal.stream.write("$I+ - output extended system information" ASCII_EOL);
 8020be4:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020be8:	4863      	ldr	r0, [pc, #396]	; (8020d78 <system_command_help+0x1a0>)
 8020bea:	4798      	blx	r3
    hal.stream.write("$I=<string> set build info string" ASCII_EOL);
 8020bec:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020bf0:	4862      	ldr	r0, [pc, #392]	; (8020d7c <system_command_help+0x1a4>)
 8020bf2:	4798      	blx	r3
    hal.stream.write("$<n> - output setting <n> value" ASCII_EOL);
 8020bf4:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020bf8:	4861      	ldr	r0, [pc, #388]	; (8020d80 <system_command_help+0x1a8>)
 8020bfa:	4798      	blx	r3
    hal.stream.write("$<n>=<value> - assign <value> to settings <n>" ASCII_EOL);
 8020bfc:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020c00:	4860      	ldr	r0, [pc, #384]	; (8020d84 <system_command_help+0x1ac>)
 8020c02:	4798      	blx	r3
    hal.stream.write("$$ - output all setting values" ASCII_EOL);
 8020c04:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020c08:	485f      	ldr	r0, [pc, #380]	; (8020d88 <system_command_help+0x1b0>)
 8020c0a:	4798      	blx	r3
    hal.stream.write("$+ - output all setting values" ASCII_EOL);
 8020c0c:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020c10:	485e      	ldr	r0, [pc, #376]	; (8020d8c <system_command_help+0x1b4>)
 8020c12:	4798      	blx	r3
    hal.stream.write("$$=<n> - output setting details for setting <n>" ASCII_EOL);
 8020c14:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020c18:	485d      	ldr	r0, [pc, #372]	; (8020d90 <system_command_help+0x1b8>)
 8020c1a:	4798      	blx	r3
    hal.stream.write("$# - output offsets, tool table, probing and home position" ASCII_EOL);
 8020c1c:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020c20:	485c      	ldr	r0, [pc, #368]	; (8020d94 <system_command_help+0x1bc>)
 8020c22:	4798      	blx	r3
    hal.stream.write("$#=<n> - output value for parameter <n>" ASCII_EOL);
 8020c24:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020c28:	485b      	ldr	r0, [pc, #364]	; (8020d98 <system_command_help+0x1c0>)
 8020c2a:	4798      	blx	r3
    hal.stream.write("$G - output parser state" ASCII_EOL);
 8020c2c:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020c30:	485a      	ldr	r0, [pc, #360]	; (8020d9c <system_command_help+0x1c4>)
 8020c32:	4798      	blx	r3
    hal.stream.write("$N - output startup lines" ASCII_EOL);
 8020c34:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020c38:	4859      	ldr	r0, [pc, #356]	; (8020da0 <system_command_help+0x1c8>)
 8020c3a:	4798      	blx	r3
    if(settings.homing.flags.enabled)
 8020c3c:	4b59      	ldr	r3, [pc, #356]	; (8020da4 <system_command_help+0x1cc>)
 8020c3e:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 8020c42:	f013 0f01 	tst.w	r3, #1
 8020c46:	d003      	beq.n	8020c50 <system_command_help+0x78>
        hal.stream.write("$H - home configured axes" ASCII_EOL);
 8020c48:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020c4c:	4856      	ldr	r0, [pc, #344]	; (8020da8 <system_command_help+0x1d0>)
 8020c4e:	4798      	blx	r3
    if(settings.homing.flags.single_axis_commands)
 8020c50:	4b54      	ldr	r3, [pc, #336]	; (8020da4 <system_command_help+0x1cc>)
 8020c52:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 8020c56:	f013 0f02 	tst.w	r3, #2
 8020c5a:	d004      	beq.n	8020c66 <system_command_help+0x8e>
        hal.stream.write("$H<axisletter> - home single axis" ASCII_EOL);
 8020c5c:	4b44      	ldr	r3, [pc, #272]	; (8020d70 <system_command_help+0x198>)
 8020c5e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8020c62:	4852      	ldr	r0, [pc, #328]	; (8020dac <system_command_help+0x1d4>)
 8020c64:	4798      	blx	r3
    hal.stream.write("$X - unlock machine" ASCII_EOL);
 8020c66:	4c42      	ldr	r4, [pc, #264]	; (8020d70 <system_command_help+0x198>)
 8020c68:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020c6c:	4850      	ldr	r0, [pc, #320]	; (8020db0 <system_command_help+0x1d8>)
 8020c6e:	4798      	blx	r3
    hal.stream.write("$SLP - enter sleep mode" ASCII_EOL);
 8020c70:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020c74:	484f      	ldr	r0, [pc, #316]	; (8020db4 <system_command_help+0x1dc>)
 8020c76:	4798      	blx	r3
    hal.stream.write("$HELP - output help topics" ASCII_EOL);
 8020c78:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020c7c:	484e      	ldr	r0, [pc, #312]	; (8020db8 <system_command_help+0x1e0>)
 8020c7e:	4798      	blx	r3
    hal.stream.write("$HELP <topic> - output help for <topic>" ASCII_EOL);
 8020c80:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020c84:	484d      	ldr	r0, [pc, #308]	; (8020dbc <system_command_help+0x1e4>)
 8020c86:	4798      	blx	r3
    hal.stream.write("$SPINDLES - output spindle list" ASCII_EOL);
 8020c88:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020c8c:	484c      	ldr	r0, [pc, #304]	; (8020dc0 <system_command_help+0x1e8>)
 8020c8e:	4798      	blx	r3
    hal.stream.write("$RST=* - restore/reset all settings" ASCII_EOL);
 8020c90:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020c94:	484b      	ldr	r0, [pc, #300]	; (8020dc4 <system_command_help+0x1ec>)
 8020c96:	4798      	blx	r3
    hal.stream.write("$RST=$ - restore default settings" ASCII_EOL);
 8020c98:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020c9c:	484a      	ldr	r0, [pc, #296]	; (8020dc8 <system_command_help+0x1f0>)
 8020c9e:	4798      	blx	r3
    if(settings_get_details()->next)
 8020ca0:	f7fb fb16 	bl	801c2d0 <settings_get_details>
 8020ca4:	6983      	ldr	r3, [r0, #24]
 8020ca6:	b11b      	cbz	r3, 8020cb0 <system_command_help+0xd8>
        hal.stream.write("$RST=& - restore driver and plugin default settings" ASCII_EOL);
 8020ca8:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020cac:	4847      	ldr	r0, [pc, #284]	; (8020dcc <system_command_help+0x1f4>)
 8020cae:	4798      	blx	r3
    hal.stream.write("$RST=# - reset offsets" ASCII_EOL);
 8020cb0:	4b2f      	ldr	r3, [pc, #188]	; (8020d70 <system_command_help+0x198>)
 8020cb2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8020cb6:	4846      	ldr	r0, [pc, #280]	; (8020dd0 <system_command_help+0x1f8>)
 8020cb8:	4798      	blx	r3
    spindle_ptrs_t *spindle = gc_spindle_get();
 8020cba:	f7ee fae9 	bl	800f290 <gc_spindle_get>
 8020cbe:	4604      	mov	r4, r0
    if(spindle->reset_data)
 8020cc0:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8020cc2:	b123      	cbz	r3, 8020cce <system_command_help+0xf6>
        hal.stream.write("$SR - reset spindle encoder data" ASCII_EOL);
 8020cc4:	4b2a      	ldr	r3, [pc, #168]	; (8020d70 <system_command_help+0x198>)
 8020cc6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8020cca:	4842      	ldr	r0, [pc, #264]	; (8020dd4 <system_command_help+0x1fc>)
 8020ccc:	4798      	blx	r3
    if(spindle->get_data)
 8020cce:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8020cd0:	b123      	cbz	r3, 8020cdc <system_command_help+0x104>
        hal.stream.write("$SD - output spindle encoder data" ASCII_EOL);
 8020cd2:	4b27      	ldr	r3, [pc, #156]	; (8020d70 <system_command_help+0x198>)
 8020cd4:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8020cd8:	483f      	ldr	r0, [pc, #252]	; (8020dd8 <system_command_help+0x200>)
 8020cda:	4798      	blx	r3
    hal.stream.write("$TLR - set tool offset reference" ASCII_EOL);
 8020cdc:	4c24      	ldr	r4, [pc, #144]	; (8020d70 <system_command_help+0x198>)
 8020cde:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020ce2:	483e      	ldr	r0, [pc, #248]	; (8020ddc <system_command_help+0x204>)
 8020ce4:	4798      	blx	r3
    hal.stream.write("$TPW - probe tool plate" ASCII_EOL);
 8020ce6:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020cea:	483d      	ldr	r0, [pc, #244]	; (8020de0 <system_command_help+0x208>)
 8020cec:	4798      	blx	r3
    hal.stream.write("$EA - enumerate alarms" ASCII_EOL);
 8020cee:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020cf2:	483c      	ldr	r0, [pc, #240]	; (8020de4 <system_command_help+0x20c>)
 8020cf4:	4798      	blx	r3
    hal.stream.write("$EAG - enumerate alarms, Grbl formatted" ASCII_EOL);
 8020cf6:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020cfa:	483b      	ldr	r0, [pc, #236]	; (8020de8 <system_command_help+0x210>)
 8020cfc:	4798      	blx	r3
    hal.stream.write("$EE - enumerate status codes" ASCII_EOL);
 8020cfe:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020d02:	483a      	ldr	r0, [pc, #232]	; (8020dec <system_command_help+0x214>)
 8020d04:	4798      	blx	r3
    hal.stream.write("$EEG - enumerate status codes, Grbl formatted" ASCII_EOL);
 8020d06:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020d0a:	4839      	ldr	r0, [pc, #228]	; (8020df0 <system_command_help+0x218>)
 8020d0c:	4798      	blx	r3
    hal.stream.write("$ES - enumerate settings" ASCII_EOL);
 8020d0e:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020d12:	4838      	ldr	r0, [pc, #224]	; (8020df4 <system_command_help+0x21c>)
 8020d14:	4798      	blx	r3
    hal.stream.write("$ESG - enumerate settings, Grbl formatted" ASCII_EOL);
 8020d16:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020d1a:	4837      	ldr	r0, [pc, #220]	; (8020df8 <system_command_help+0x220>)
 8020d1c:	4798      	blx	r3
    hal.stream.write("$ESH- enumerate settings, grblHAL formatted" ASCII_EOL);
 8020d1e:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020d22:	4836      	ldr	r0, [pc, #216]	; (8020dfc <system_command_help+0x224>)
 8020d24:	4798      	blx	r3
    hal.stream.write("$E* - enumerate alarms, status codes and settings" ASCII_EOL);
 8020d26:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020d2a:	4835      	ldr	r0, [pc, #212]	; (8020e00 <system_command_help+0x228>)
 8020d2c:	4798      	blx	r3
    if(hal.enumerate_pins)
 8020d2e:	f8d4 3170 	ldr.w	r3, [r4, #368]	; 0x170
 8020d32:	b11b      	cbz	r3, 8020d3c <system_command_help+0x164>
        hal.stream.write("$PINS - enumerate pin bindings" ASCII_EOL);
 8020d34:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020d38:	4832      	ldr	r0, [pc, #200]	; (8020e04 <system_command_help+0x22c>)
 8020d3a:	4798      	blx	r3
    hal.stream.write("$LEV - output last control signal events" ASCII_EOL);
 8020d3c:	4c0c      	ldr	r4, [pc, #48]	; (8020d70 <system_command_help+0x198>)
 8020d3e:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020d42:	4831      	ldr	r0, [pc, #196]	; (8020e08 <system_command_help+0x230>)
 8020d44:	4798      	blx	r3
    hal.stream.write("$LIM - output current limit pins state" ASCII_EOL);
 8020d46:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020d4a:	4830      	ldr	r0, [pc, #192]	; (8020e0c <system_command_help+0x234>)
 8020d4c:	4798      	blx	r3
    if(hal.rtc.get_datetime) {
 8020d4e:	f8d4 310c 	ldr.w	r3, [r4, #268]	; 0x10c
 8020d52:	b13b      	cbz	r3, 8020d64 <system_command_help+0x18c>
        hal.stream.write("$RTC - output current time" ASCII_EOL);
 8020d54:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020d58:	482d      	ldr	r0, [pc, #180]	; (8020e10 <system_command_help+0x238>)
 8020d5a:	4798      	blx	r3
        hal.stream.write("$RTC=<ISO8601 datetime> - set current time" ASCII_EOL);
 8020d5c:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 8020d60:	482c      	ldr	r0, [pc, #176]	; (8020e14 <system_command_help+0x23c>)
 8020d62:	4798      	blx	r3
    hal.stream.write("$SED=<n> - output settings description for setting <n>" ASCII_EOL);
 8020d64:	4b02      	ldr	r3, [pc, #8]	; (8020d70 <system_command_help+0x198>)
 8020d66:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8020d6a:	482b      	ldr	r0, [pc, #172]	; (8020e18 <system_command_help+0x240>)
 8020d6c:	4798      	blx	r3
}
 8020d6e:	bd10      	pop	{r4, pc}
 8020d70:	2000350c 	.word	0x2000350c
 8020d74:	0802c4f4 	.word	0x0802c4f4
 8020d78:	0802c518 	.word	0x0802c518
 8020d7c:	0802c544 	.word	0x0802c544
 8020d80:	0802c568 	.word	0x0802c568
 8020d84:	0802c58c 	.word	0x0802c58c
 8020d88:	0802c5bc 	.word	0x0802c5bc
 8020d8c:	0802c5e0 	.word	0x0802c5e0
 8020d90:	0802c604 	.word	0x0802c604
 8020d94:	0802c638 	.word	0x0802c638
 8020d98:	0802c678 	.word	0x0802c678
 8020d9c:	0802c6a4 	.word	0x0802c6a4
 8020da0:	0802c6c0 	.word	0x0802c6c0
 8020da4:	20003b14 	.word	0x20003b14
 8020da8:	0802c6dc 	.word	0x0802c6dc
 8020dac:	0802c6f8 	.word	0x0802c6f8
 8020db0:	0802c71c 	.word	0x0802c71c
 8020db4:	0802c734 	.word	0x0802c734
 8020db8:	0802c750 	.word	0x0802c750
 8020dbc:	0802c770 	.word	0x0802c770
 8020dc0:	0802c79c 	.word	0x0802c79c
 8020dc4:	0802c7c0 	.word	0x0802c7c0
 8020dc8:	0802c7e8 	.word	0x0802c7e8
 8020dcc:	0802c80c 	.word	0x0802c80c
 8020dd0:	0802c844 	.word	0x0802c844
 8020dd4:	0802c860 	.word	0x0802c860
 8020dd8:	0802c884 	.word	0x0802c884
 8020ddc:	0802c8a8 	.word	0x0802c8a8
 8020de0:	0802c8cc 	.word	0x0802c8cc
 8020de4:	0802c8e8 	.word	0x0802c8e8
 8020de8:	0802c904 	.word	0x0802c904
 8020dec:	0802c930 	.word	0x0802c930
 8020df0:	0802c950 	.word	0x0802c950
 8020df4:	0802c980 	.word	0x0802c980
 8020df8:	0802c99c 	.word	0x0802c99c
 8020dfc:	0802c9c8 	.word	0x0802c9c8
 8020e00:	0802c9f8 	.word	0x0802c9f8
 8020e04:	0802ca2c 	.word	0x0802ca2c
 8020e08:	0802ca50 	.word	0x0802ca50
 8020e0c:	0802ca7c 	.word	0x0802ca7c
 8020e10:	0802caa8 	.word	0x0802caa8
 8020e14:	0802cac8 	.word	0x0802cac8
 8020e18:	0802caf8 	.word	0x0802caf8

08020e1c <system_execute_line>:
{
 8020e1c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8020e20:	b087      	sub	sp, #28
    if(line[1] == '\0') {
 8020e22:	7846      	ldrb	r6, [r0, #1]
 8020e24:	b16e      	cbz	r6, 8020e42 <system_execute_line+0x26>
 8020e26:	4604      	mov	r4, r0
    sys_commands_t base = {
 8020e28:	232a      	movs	r3, #42	; 0x2a
 8020e2a:	f88d 300c 	strb.w	r3, [sp, #12]
 8020e2e:	4b67      	ldr	r3, [pc, #412]	; (8020fcc <system_execute_line+0x1b0>)
 8020e30:	9304      	str	r3, [sp, #16]
        .on_get_commands = grbl.on_get_commands
 8020e32:	4b67      	ldr	r3, [pc, #412]	; (8020fd0 <system_execute_line+0x1b4>)
 8020e34:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    sys_commands_t base = {
 8020e36:	9305      	str	r3, [sp, #20]
    s1 = s2 = ++line;
 8020e38:	1c47      	adds	r7, r0, #1
    c = *s1;
 8020e3a:	7841      	ldrb	r1, [r0, #1]
    s1 = s2 = ++line;
 8020e3c:	463b      	mov	r3, r7
 8020e3e:	463a      	mov	r2, r7
    while(c && c != '=') {
 8020e40:	e007      	b.n	8020e52 <system_execute_line+0x36>
        grbl.report.help_message();
 8020e42:	4b63      	ldr	r3, [pc, #396]	; (8020fd0 <system_execute_line+0x1b4>)
 8020e44:	685b      	ldr	r3, [r3, #4]
 8020e46:	4798      	blx	r3
        return Status_OK;
 8020e48:	e067      	b.n	8020f1a <system_execute_line+0xfe>
            *s2++ = CAPS(c);
 8020e4a:	f803 1b01 	strb.w	r1, [r3], #1
        c = *++s1;
 8020e4e:	f812 1f01 	ldrb.w	r1, [r2, #1]!
    while(c && c != '=') {
 8020e52:	b169      	cbz	r1, 8020e70 <system_execute_line+0x54>
 8020e54:	293d      	cmp	r1, #61	; 0x3d
 8020e56:	d00b      	beq.n	8020e70 <system_execute_line+0x54>
        if(c != ' ')
 8020e58:	2920      	cmp	r1, #32
 8020e5a:	d0f8      	beq.n	8020e4e <system_execute_line+0x32>
            *s2++ = CAPS(c);
 8020e5c:	f1a1 0061 	sub.w	r0, r1, #97	; 0x61
 8020e60:	b2c0      	uxtb	r0, r0
 8020e62:	2819      	cmp	r0, #25
 8020e64:	d8f1      	bhi.n	8020e4a <system_execute_line+0x2e>
 8020e66:	f001 015f 	and.w	r1, r1, #95	; 0x5f
 8020e6a:	e7ee      	b.n	8020e4a <system_execute_line+0x2e>
        *s2++ = c;
 8020e6c:	f803 1b01 	strb.w	r1, [r3], #1
    while((c = *s1++))
 8020e70:	f812 1b01 	ldrb.w	r1, [r2], #1
 8020e74:	2900      	cmp	r1, #0
 8020e76:	d1f9      	bne.n	8020e6c <system_execute_line+0x50>
    *s2 = '\0';
 8020e78:	2200      	movs	r2, #0
 8020e7a:	701a      	strb	r2, [r3, #0]
    if(!strncmp(line, "HELP", 4))
 8020e7c:	2204      	movs	r2, #4
 8020e7e:	4955      	ldr	r1, [pc, #340]	; (8020fd4 <system_execute_line+0x1b8>)
 8020e80:	4638      	mov	r0, r7
 8020e82:	f001 fe9c 	bl	8022bbe <strncmp>
 8020e86:	b158      	cbz	r0, 8020ea0 <system_execute_line+0x84>
    char *args = strchr(line, '=');
 8020e88:	213d      	movs	r1, #61	; 0x3d
 8020e8a:	4638      	mov	r0, r7
 8020e8c:	f001 fe8a 	bl	8022ba4 <strchr>
    if(args)
 8020e90:	4680      	mov	r8, r0
 8020e92:	b110      	cbz	r0, 8020e9a <system_execute_line+0x7e>
        *args++ = '\0';
 8020e94:	2300      	movs	r3, #0
 8020e96:	f808 3b01 	strb.w	r3, [r8], #1
    sys_commands_t *cmd = &base;
 8020e9a:	ad03      	add	r5, sp, #12
    status_code_t retval = Status_Unhandled;
 8020e9c:	2654      	movs	r6, #84	; 0x54
 8020e9e:	e036      	b.n	8020f0e <system_execute_line+0xf2>
        return report_help(&line[4]);
 8020ea0:	1d60      	adds	r0, r4, #5
 8020ea2:	f7fa f9cd 	bl	801b240 <report_help>
 8020ea6:	4606      	mov	r6, r0
 8020ea8:	e037      	b.n	8020f1a <system_execute_line+0xfe>
                    if((retval = cmd->commands[idx].execute(state_get(), args)) != Status_Unhandled)
 8020eaa:	f8d9 6004 	ldr.w	r6, [r9, #4]
 8020eae:	f7fd fb99 	bl	801e5e4 <state_get>
 8020eb2:	4641      	mov	r1, r8
 8020eb4:	47b0      	blx	r6
 8020eb6:	4606      	mov	r6, r0
 8020eb8:	2854      	cmp	r0, #84	; 0x54
 8020eba:	d121      	bne.n	8020f00 <system_execute_line+0xe4>
        for(idx = 0; idx < cmd->n_commands; idx++) {
 8020ebc:	3401      	adds	r4, #1
 8020ebe:	782b      	ldrb	r3, [r5, #0]
 8020ec0:	42a3      	cmp	r3, r4
 8020ec2:	d91d      	bls.n	8020f00 <system_execute_line+0xe4>
            if(!strcmp(line, cmd->commands[idx].command)) {
 8020ec4:	686b      	ldr	r3, [r5, #4]
 8020ec6:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 8020eca:	eb03 0982 	add.w	r9, r3, r2, lsl #2
 8020ece:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8020ed2:	4638      	mov	r0, r7
 8020ed4:	f7e7 f8b4 	bl	8008040 <strcmp>
 8020ed8:	2800      	cmp	r0, #0
 8020eda:	d1ef      	bne.n	8020ebc <system_execute_line+0xa0>
                if(sys.blocking_event && !cmd->commands[idx].flags.allow_blocking) {
 8020edc:	4b3e      	ldr	r3, [pc, #248]	; (8020fd8 <system_execute_line+0x1bc>)
 8020ede:	795b      	ldrb	r3, [r3, #5]
 8020ee0:	b123      	cbz	r3, 8020eec <system_execute_line+0xd0>
 8020ee2:	f899 3008 	ldrb.w	r3, [r9, #8]
 8020ee6:	f013 0f02 	tst.w	r3, #2
 8020eea:	d008      	beq.n	8020efe <system_execute_line+0xe2>
                } else if(!cmd->commands[idx].flags.noargs || args == NULL) {
 8020eec:	f899 3008 	ldrb.w	r3, [r9, #8]
 8020ef0:	f013 0f01 	tst.w	r3, #1
 8020ef4:	d0d9      	beq.n	8020eaa <system_execute_line+0x8e>
 8020ef6:	f1b8 0f00 	cmp.w	r8, #0
 8020efa:	d1df      	bne.n	8020ebc <system_execute_line+0xa0>
 8020efc:	e7d5      	b.n	8020eaa <system_execute_line+0x8e>
                    retval = Status_NotAllowedCriticalEvent;
 8020efe:	264f      	movs	r6, #79	; 0x4f
        cmd = retval == Status_Unhandled && cmd->on_get_commands ? cmd->on_get_commands() : NULL;
 8020f00:	2e54      	cmp	r6, #84	; 0x54
 8020f02:	d106      	bne.n	8020f12 <system_execute_line+0xf6>
 8020f04:	68ab      	ldr	r3, [r5, #8]
 8020f06:	b123      	cbz	r3, 8020f12 <system_execute_line+0xf6>
 8020f08:	4798      	blx	r3
    } while(cmd);
 8020f0a:	4605      	mov	r5, r0
 8020f0c:	b108      	cbz	r0, 8020f12 <system_execute_line+0xf6>
        for(idx = 0; idx < cmd->n_commands; idx++) {
 8020f0e:	2400      	movs	r4, #0
 8020f10:	e7d5      	b.n	8020ebe <system_execute_line+0xa2>
    if(retval == Status_Unhandled && grbl.on_unknown_sys_command) {
 8020f12:	2e54      	cmp	r6, #84	; 0x54
 8020f14:	d005      	beq.n	8020f22 <system_execute_line+0x106>
    if (retval == Status_Unhandled) {
 8020f16:	2e54      	cmp	r6, #84	; 0x54
 8020f18:	d020      	beq.n	8020f5c <system_execute_line+0x140>
}
 8020f1a:	4630      	mov	r0, r6
 8020f1c:	b007      	add	sp, #28
 8020f1e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if(retval == Status_Unhandled && grbl.on_unknown_sys_command) {
 8020f22:	4b2b      	ldr	r3, [pc, #172]	; (8020fd0 <system_execute_line+0x1b4>)
 8020f24:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8020f26:	2b00      	cmp	r3, #0
 8020f28:	d0f5      	beq.n	8020f16 <system_execute_line+0xfa>
        if(args)
 8020f2a:	f1b8 0f00 	cmp.w	r8, #0
 8020f2e:	d011      	beq.n	8020f54 <system_execute_line+0x138>
            *(--args) = '=';
 8020f30:	f108 34ff 	add.w	r4, r8, #4294967295
 8020f34:	233d      	movs	r3, #61	; 0x3d
 8020f36:	f808 3c01 	strb.w	r3, [r8, #-1]
        retval = grbl.on_unknown_sys_command(state_get(), line);
 8020f3a:	4b25      	ldr	r3, [pc, #148]	; (8020fd0 <system_execute_line+0x1b4>)
 8020f3c:	6e9d      	ldr	r5, [r3, #104]	; 0x68
 8020f3e:	f7fd fb51 	bl	801e5e4 <state_get>
 8020f42:	4639      	mov	r1, r7
 8020f44:	47a8      	blx	r5
 8020f46:	4606      	mov	r6, r0
        if(args)
 8020f48:	b134      	cbz	r4, 8020f58 <system_execute_line+0x13c>
            *args++ = '\0';
 8020f4a:	46a0      	mov	r8, r4
 8020f4c:	2300      	movs	r3, #0
 8020f4e:	f808 3b01 	strb.w	r3, [r8], #1
 8020f52:	e7e0      	b.n	8020f16 <system_execute_line+0xfa>
 8020f54:	4644      	mov	r4, r8
 8020f56:	e7f0      	b.n	8020f3a <system_execute_line+0x11e>
 8020f58:	46a0      	mov	r8, r4
 8020f5a:	e7dc      	b.n	8020f16 <system_execute_line+0xfa>
        if(state_get() == STATE_IDLE || (state_get() & (STATE_ALARM|STATE_ESTOP|STATE_CHECK_MODE))) {
 8020f5c:	f7fd fb42 	bl	801e5e4 <state_get>
 8020f60:	b128      	cbz	r0, 8020f6e <system_execute_line+0x152>
 8020f62:	f7fd fb3f 	bl	801e5e4 <state_get>
 8020f66:	f240 1303 	movw	r3, #259	; 0x103
 8020f6a:	4218      	tst	r0, r3
 8020f6c:	d02b      	beq.n	8020fc6 <system_execute_line+0x1aa>
            uint_fast8_t counter = 0;
 8020f6e:	2300      	movs	r3, #0
 8020f70:	9301      	str	r3, [sp, #4]
            if(!read_float(line, &counter, &parameter))
 8020f72:	aa02      	add	r2, sp, #8
 8020f74:	a901      	add	r1, sp, #4
 8020f76:	4638      	mov	r0, r7
 8020f78:	f7f4 fce4 	bl	8015944 <read_float>
 8020f7c:	b908      	cbnz	r0, 8020f82 <system_execute_line+0x166>
                retval = Status_BadNumberFormat;
 8020f7e:	2602      	movs	r6, #2
 8020f80:	e7cb      	b.n	8020f1a <system_execute_line+0xfe>
            else if(!isintf(parameter))
 8020f82:	ed9d 0a02 	vldr	s0, [sp, #8]
 8020f86:	f7f4 fd53 	bl	8015a30 <isintf>
 8020f8a:	b1d0      	cbz	r0, 8020fc2 <system_execute_line+0x1a6>
            else if(args)
 8020f8c:	f1b8 0f00 	cmp.w	r8, #0
 8020f90:	d00b      	beq.n	8020faa <system_execute_line+0x18e>
                retval = settings_store_setting((setting_id_t)parameter, args);
 8020f92:	eddd 7a02 	vldr	s15, [sp, #8]
 8020f96:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8020f9a:	4641      	mov	r1, r8
 8020f9c:	ee17 3a90 	vmov	r3, s15
 8020fa0:	b298      	uxth	r0, r3
 8020fa2:	f7fc f82f 	bl	801d004 <settings_store_setting>
 8020fa6:	4606      	mov	r6, r0
 8020fa8:	e7b7      	b.n	8020f1a <system_execute_line+0xfe>
                retval = report_grbl_setting((setting_id_t)parameter, NULL);
 8020faa:	eddd 7a02 	vldr	s15, [sp, #8]
 8020fae:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8020fb2:	2100      	movs	r1, #0
 8020fb4:	ee17 3a90 	vmov	r3, s15
 8020fb8:	b298      	uxth	r0, r3
 8020fba:	f7f8 f97d 	bl	80192b8 <report_grbl_setting>
 8020fbe:	4606      	mov	r6, r0
 8020fc0:	e7ab      	b.n	8020f1a <system_execute_line+0xfe>
                retval = Status_InvalidStatement;
 8020fc2:	2603      	movs	r6, #3
        if(state_get() == STATE_IDLE || (state_get() & (STATE_ALARM|STATE_ESTOP|STATE_CHECK_MODE))) {
 8020fc4:	e7a9      	b.n	8020f1a <system_execute_line+0xfe>
            retval = Status_IdleError;
 8020fc6:	2608      	movs	r6, #8
 8020fc8:	e7a7      	b.n	8020f1a <system_execute_line+0xfe>
 8020fca:	bf00      	nop
 8020fcc:	0802cbd4 	.word	0x0802cbd4
 8020fd0:	2000343c 	.word	0x2000343c
 8020fd4:	0802cb34 	.word	0x0802cb34
 8020fd8:	200036c4 	.word	0x200036c4

08020fdc <system_convert_array_steps_to_mpos>:

// Sets machine position. Must be sent a 'step' array.
// NOTE: If motor steps and machine position are not in the same coordinate frame, this function
//       serves as a central place to compute the transformation.
void system_convert_array_steps_to_mpos (float *position, int32_t *steps)
{
 8020fdc:	b410      	push	{r4}
#ifdef KINEMATICS_API
    kinematics.transform_steps_to_cartesian(position, steps);
#else
    uint_fast8_t idx = N_AXIS;
 8020fde:	2303      	movs	r3, #3
    do {
        idx--;
 8020fe0:	3b01      	subs	r3, #1
        position[idx] = steps[idx] / settings.axis[idx].steps_per_mm;
 8020fe2:	eb03 0c83 	add.w	ip, r3, r3, lsl #2
 8020fe6:	4a0b      	ldr	r2, [pc, #44]	; (8021014 <system_convert_array_steps_to_mpos+0x38>)
 8020fe8:	eb02 028c 	add.w	r2, r2, ip, lsl #2
 8020fec:	edd2 6a0c 	vldr	s13, [r2, #48]	; 0x30
 8020ff0:	eb00 0283 	add.w	r2, r0, r3, lsl #2
 8020ff4:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
 8020ff8:	ee07 4a90 	vmov	s15, r4
 8020ffc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8021000:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 8021004:	ed82 7a00 	vstr	s14, [r2]
    } while(idx);
 8021008:	2b00      	cmp	r3, #0
 802100a:	d1e9      	bne.n	8020fe0 <system_convert_array_steps_to_mpos+0x4>
#endif
}
 802100c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8021010:	4770      	bx	lr
 8021012:	bf00      	nop
 8021014:	20003b14 	.word	0x20003b14

08021018 <system_xy_at_fixture>:
{
    bool ok = false;

    coord_data_t target, position;

    if(tolerance > 0.0f && settings_read_coord_data(id, &target.values)) {
 8021018:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 802101c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021020:	dc01      	bgt.n	8021026 <system_xy_at_fixture+0xe>
    bool ok = false;
 8021022:	2000      	movs	r0, #0
        system_convert_array_steps_to_mpos(position.values, sys.position);
        ok = hypot_f(position.x - target.x, position.y - target.y) <= tolerance;
    }

    return ok;
}
 8021024:	4770      	bx	lr
{
 8021026:	b500      	push	{lr}
 8021028:	ed2d 8b02 	vpush	{d8}
 802102c:	b087      	sub	sp, #28
 802102e:	eeb0 8a40 	vmov.f32	s16, s0
    if(tolerance > 0.0f && settings_read_coord_data(id, &target.values)) {
 8021032:	a903      	add	r1, sp, #12
 8021034:	f7fb fcde 	bl	801c9f4 <settings_read_coord_data>
 8021038:	b920      	cbnz	r0, 8021044 <system_xy_at_fixture+0x2c>
}
 802103a:	b007      	add	sp, #28
 802103c:	ecbd 8b02 	vpop	{d8}
 8021040:	f85d fb04 	ldr.w	pc, [sp], #4
        system_convert_array_steps_to_mpos(position.values, sys.position);
 8021044:	490f      	ldr	r1, [pc, #60]	; (8021084 <system_xy_at_fixture+0x6c>)
 8021046:	4668      	mov	r0, sp
 8021048:	f7ff ffc8 	bl	8020fdc <system_convert_array_steps_to_mpos>
        ok = hypot_f(position.x - target.x, position.y - target.y) <= tolerance;
 802104c:	ed9d 0a00 	vldr	s0, [sp]
 8021050:	eddd 7a03 	vldr	s15, [sp, #12]
 8021054:	ee30 0a67 	vsub.f32	s0, s0, s15
 8021058:	eddd 7a01 	vldr	s15, [sp, #4]
 802105c:	ed9d 7a04 	vldr	s14, [sp, #16]
 8021060:	ee77 7ac7 	vsub.f32	s15, s15, s14
    return sqrtf(x*x + y*y);
 8021064:	ee20 0a00 	vmul.f32	s0, s0, s0
 8021068:	ee67 7aa7 	vmul.f32	s15, s15, s15
 802106c:	ee30 0a27 	vadd.f32	s0, s0, s15
 8021070:	f002 fcae 	bl	80239d0 <sqrtf>
        ok = hypot_f(position.x - target.x, position.y - target.y) <= tolerance;
 8021074:	eeb4 8ac0 	vcmpe.f32	s16, s0
 8021078:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802107c:	bfac      	ite	ge
 802107e:	2001      	movge	r0, #1
 8021080:	2000      	movlt	r0, #0
 8021082:	e7da      	b.n	802103a <system_xy_at_fixture+0x22>
 8021084:	2000374c 	.word	0x2000374c

08021088 <system_check_travel_limits>:
bool system_check_travel_limits (float *target)
{
    bool failed = false;
    uint_fast8_t idx = N_AXIS;

    if(sys.homed.mask) do {
 8021088:	4b22      	ldr	r3, [pc, #136]	; (8021114 <system_check_travel_limits+0x8c>)
 802108a:	f893 1054 	ldrb.w	r1, [r3, #84]	; 0x54
 802108e:	b3c1      	cbz	r1, 8021102 <system_check_travel_limits+0x7a>
{
 8021090:	b410      	push	{r4}
    uint_fast8_t idx = N_AXIS;
 8021092:	2303      	movs	r3, #3
    bool failed = false;
 8021094:	2200      	movs	r2, #0
 8021096:	e002      	b.n	802109e <system_check_travel_limits+0x16>
        idx--;
        if(bit_istrue(sys.homed.mask, bit(idx)) && settings.axis[idx].max_travel < -0.0f)
            failed = target[idx] < sys.work_envelope.min[idx] || target[idx] > sys.work_envelope.max[idx];
 8021098:	2201      	movs	r2, #1
    } while(!failed && idx);
 802109a:	bbb2      	cbnz	r2, 802110a <system_check_travel_limits+0x82>
 802109c:	b3ab      	cbz	r3, 802110a <system_check_travel_limits+0x82>
        idx--;
 802109e:	3b01      	subs	r3, #1
        if(bit_istrue(sys.homed.mask, bit(idx)) && settings.axis[idx].max_travel < -0.0f)
 80210a0:	fa21 f403 	lsr.w	r4, r1, r3
 80210a4:	f014 0f01 	tst.w	r4, #1
 80210a8:	d0f7      	beq.n	802109a <system_check_travel_limits+0x12>
 80210aa:	eb03 0c83 	add.w	ip, r3, r3, lsl #2
 80210ae:	4c1a      	ldr	r4, [pc, #104]	; (8021118 <system_check_travel_limits+0x90>)
 80210b0:	eb04 0c8c 	add.w	ip, r4, ip, lsl #2
 80210b4:	eddc 7a0f 	vldr	s15, [ip, #60]	; 0x3c
 80210b8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80210bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80210c0:	d5eb      	bpl.n	802109a <system_check_travel_limits+0x12>
            failed = target[idx] < sys.work_envelope.min[idx] || target[idx] > sys.work_envelope.max[idx];
 80210c2:	eb00 0283 	add.w	r2, r0, r3, lsl #2
 80210c6:	edd2 7a00 	vldr	s15, [r2]
 80210ca:	f103 0418 	add.w	r4, r3, #24
 80210ce:	4a11      	ldr	r2, [pc, #68]	; (8021114 <system_check_travel_limits+0x8c>)
 80210d0:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 80210d4:	ed92 7a01 	vldr	s14, [r2, #4]
 80210d8:	eef4 7ac7 	vcmpe.f32	s15, s14
 80210dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80210e0:	d4da      	bmi.n	8021098 <system_check_travel_limits+0x10>
 80210e2:	f103 041a 	add.w	r4, r3, #26
 80210e6:	4a0b      	ldr	r2, [pc, #44]	; (8021114 <system_check_travel_limits+0x8c>)
 80210e8:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 80210ec:	ed92 7a02 	vldr	s14, [r2, #8]
 80210f0:	eef4 7ac7 	vcmpe.f32	s15, s14
 80210f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80210f8:	dd01      	ble.n	80210fe <system_check_travel_limits+0x76>
 80210fa:	2201      	movs	r2, #1
 80210fc:	e7cd      	b.n	802109a <system_check_travel_limits+0x12>
 80210fe:	2200      	movs	r2, #0
 8021100:	e7cb      	b.n	802109a <system_check_travel_limits+0x12>
    bool failed = false;
 8021102:	2200      	movs	r2, #0

    return !failed;
}
 8021104:	f082 0001 	eor.w	r0, r2, #1
 8021108:	4770      	bx	lr
 802110a:	f082 0001 	eor.w	r0, r2, #1
 802110e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8021112:	4770      	bx	lr
 8021114:	200036c4 	.word	0x200036c4
 8021118:	20003b14 	.word	0x20003b14

0802111c <system_apply_jog_limits>:
// Limits jog commands to be within machine limits, homed axes only.
void system_apply_jog_limits (float *target)
{
    uint_fast8_t idx = N_AXIS;

    if(sys.homed.mask) do {
 802111c:	4b1f      	ldr	r3, [pc, #124]	; (802119c <system_apply_jog_limits+0x80>)
 802111e:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 8021122:	b3cb      	cbz	r3, 8021198 <system_apply_jog_limits+0x7c>
    uint_fast8_t idx = N_AXIS;
 8021124:	2303      	movs	r3, #3
 8021126:	e002      	b.n	802112e <system_apply_jog_limits+0x12>
        idx--;
        if(bit_istrue(sys.homed.mask, bit(idx)) && settings.axis[idx].max_travel < -0.0f)
            target[idx] = max(min(target[idx], sys.work_envelope.max[idx]), sys.work_envelope.min[idx]);
 8021128:	edcc 7a00 	vstr	s15, [ip]
    } while(idx);
 802112c:	b3a3      	cbz	r3, 8021198 <system_apply_jog_limits+0x7c>
        idx--;
 802112e:	3b01      	subs	r3, #1
        if(bit_istrue(sys.homed.mask, bit(idx)) && settings.axis[idx].max_travel < -0.0f)
 8021130:	4a1a      	ldr	r2, [pc, #104]	; (802119c <system_apply_jog_limits+0x80>)
 8021132:	f892 2054 	ldrb.w	r2, [r2, #84]	; 0x54
 8021136:	40da      	lsrs	r2, r3
 8021138:	f012 0f01 	tst.w	r2, #1
 802113c:	d0f6      	beq.n	802112c <system_apply_jog_limits+0x10>
 802113e:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8021142:	4a17      	ldr	r2, [pc, #92]	; (80211a0 <system_apply_jog_limits+0x84>)
 8021144:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8021148:	edd2 7a0f 	vldr	s15, [r2, #60]	; 0x3c
 802114c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8021150:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021154:	d5ea      	bpl.n	802112c <system_apply_jog_limits+0x10>
            target[idx] = max(min(target[idx], sys.work_envelope.max[idx]), sys.work_envelope.min[idx]);
 8021156:	eb00 0c83 	add.w	ip, r0, r3, lsl #2
 802115a:	ed9c 7a00 	vldr	s14, [ip]
 802115e:	f103 011a 	add.w	r1, r3, #26
 8021162:	4a0e      	ldr	r2, [pc, #56]	; (802119c <system_apply_jog_limits+0x80>)
 8021164:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8021168:	edd2 7a02 	vldr	s15, [r2, #8]
 802116c:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8021170:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021174:	d501      	bpl.n	802117a <system_apply_jog_limits+0x5e>
 8021176:	eef0 7a47 	vmov.f32	s15, s14
 802117a:	f103 0118 	add.w	r1, r3, #24
 802117e:	4a07      	ldr	r2, [pc, #28]	; (802119c <system_apply_jog_limits+0x80>)
 8021180:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8021184:	ed92 7a01 	vldr	s14, [r2, #4]
 8021188:	eeb4 7ae7 	vcmpe.f32	s14, s15
 802118c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021190:	d4ca      	bmi.n	8021128 <system_apply_jog_limits+0xc>
 8021192:	eef0 7a47 	vmov.f32	s15, s14
 8021196:	e7c7      	b.n	8021128 <system_apply_jog_limits+0xc>
}
 8021198:	4770      	bx	lr
 802119a:	bf00      	nop
 802119c:	200036c4 	.word	0x200036c4
 80211a0:	20003b14 	.word	0x20003b14

080211a4 <system_raise_alarm>:

void system_raise_alarm (alarm_code_t alarm)
{
 80211a4:	b510      	push	{r4, lr}
 80211a6:	4604      	mov	r4, r0
    if(state_get() == STATE_HOMING && !(sys.rt_exec_state & EXEC_RESET))
 80211a8:	f7fd fa1c 	bl	801e5e4 <state_get>
 80211ac:	2804      	cmp	r0, #4
 80211ae:	d011      	beq.n	80211d4 <system_raise_alarm+0x30>
        system_set_exec_alarm(alarm);
    else if(sys.alarm != alarm) {
 80211b0:	4b1c      	ldr	r3, [pc, #112]	; (8021224 <system_raise_alarm+0x80>)
 80211b2:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 80211b6:	42a3      	cmp	r3, r4
 80211b8:	d02e      	beq.n	8021218 <system_raise_alarm+0x74>
        sys.alarm = alarm;
 80211ba:	4b1a      	ldr	r3, [pc, #104]	; (8021224 <system_raise_alarm+0x80>)
 80211bc:	f883 407c 	strb.w	r4, [r3, #124]	; 0x7c
        sys.blocking_event = sys.alarm == Alarm_HardLimit ||
 80211c0:	1e63      	subs	r3, r4, #1
 80211c2:	b2db      	uxtb	r3, r3
                              sys.alarm == Alarm_SoftLimit ||
                               sys.alarm == Alarm_EStop ||
 80211c4:	2b01      	cmp	r3, #1
 80211c6:	d912      	bls.n	80211ee <system_raise_alarm+0x4a>
                              sys.alarm == Alarm_SoftLimit ||
 80211c8:	2c0a      	cmp	r4, #10
 80211ca:	d026      	beq.n	802121a <system_raise_alarm+0x76>
                               sys.alarm == Alarm_EStop ||
 80211cc:	2c11      	cmp	r4, #17
 80211ce:	d00c      	beq.n	80211ea <system_raise_alarm+0x46>
 80211d0:	2200      	movs	r2, #0
 80211d2:	e00d      	b.n	80211f0 <system_raise_alarm+0x4c>
    if(state_get() == STATE_HOMING && !(sys.rt_exec_state & EXEC_RESET))
 80211d4:	4b13      	ldr	r3, [pc, #76]	; (8021224 <system_raise_alarm+0x80>)
 80211d6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80211d8:	f013 0f20 	tst.w	r3, #32
 80211dc:	d1e8      	bne.n	80211b0 <system_raise_alarm+0xc>
        system_set_exec_alarm(alarm);
 80211de:	4b12      	ldr	r3, [pc, #72]	; (8021228 <system_raise_alarm+0x84>)
 80211e0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80211e2:	4621      	mov	r1, r4
 80211e4:	4811      	ldr	r0, [pc, #68]	; (802122c <system_raise_alarm+0x88>)
 80211e6:	4798      	blx	r3
 80211e8:	e016      	b.n	8021218 <system_raise_alarm+0x74>
                               sys.alarm == Alarm_EStop ||
 80211ea:	2201      	movs	r2, #1
 80211ec:	e000      	b.n	80211f0 <system_raise_alarm+0x4c>
 80211ee:	2201      	movs	r2, #1
        sys.blocking_event = sys.alarm == Alarm_HardLimit ||
 80211f0:	4b0c      	ldr	r3, [pc, #48]	; (8021224 <system_raise_alarm+0x80>)
 80211f2:	715a      	strb	r2, [r3, #5]
                                sys.alarm == Alarm_MotorFault;
        state_set(alarm == Alarm_EStop ? STATE_ESTOP : STATE_ALARM);
 80211f4:	2c0a      	cmp	r4, #10
 80211f6:	d012      	beq.n	802121e <system_raise_alarm+0x7a>
 80211f8:	2001      	movs	r0, #1
 80211fa:	f7fd f9f9 	bl	801e5f0 <state_set>
        if(sys.driver_started || sys.alarm == Alarm_SelftestFailed)
 80211fe:	4b09      	ldr	r3, [pc, #36]	; (8021224 <system_raise_alarm+0x80>)
 8021200:	f893 307e 	ldrb.w	r3, [r3, #126]	; 0x7e
 8021204:	b923      	cbnz	r3, 8021210 <system_raise_alarm+0x6c>
 8021206:	4b07      	ldr	r3, [pc, #28]	; (8021224 <system_raise_alarm+0x80>)
 8021208:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 802120c:	2b10      	cmp	r3, #16
 802120e:	d103      	bne.n	8021218 <system_raise_alarm+0x74>
            grbl.report.alarm_message(alarm);
 8021210:	4b07      	ldr	r3, [pc, #28]	; (8021230 <system_raise_alarm+0x8c>)
 8021212:	691b      	ldr	r3, [r3, #16]
 8021214:	4620      	mov	r0, r4
 8021216:	4798      	blx	r3
    }
}
 8021218:	bd10      	pop	{r4, pc}
                               sys.alarm == Alarm_EStop ||
 802121a:	2201      	movs	r2, #1
 802121c:	e7e8      	b.n	80211f0 <system_raise_alarm+0x4c>
        state_set(alarm == Alarm_EStop ? STATE_ESTOP : STATE_ALARM);
 802121e:	f44f 7080 	mov.w	r0, #256	; 0x100
 8021222:	e7ea      	b.n	80211fa <system_raise_alarm+0x56>
 8021224:	200036c4 	.word	0x200036c4
 8021228:	2000350c 	.word	0x2000350c
 802122c:	20003710 	.word	0x20003710
 8021230:	2000343c 	.word	0x2000343c

08021234 <system_get_rt_report_flags>:
// TODO: encapsulate sys.report

report_tracking_flags_t system_get_rt_report_flags (void)
{
    return sys.report;
}
 8021234:	4b01      	ldr	r3, [pc, #4]	; (802123c <system_get_rt_report_flags+0x8>)
 8021236:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8021238:	4770      	bx	lr
 802123a:	bf00      	nop
 802123c:	200036c4 	.word	0x200036c4

08021240 <system_add_rt_report>:

void system_add_rt_report (report_tracking_t report)
{
 8021240:	b508      	push	{r3, lr}
    if(report == Report_ClearAll)
 8021242:	4603      	mov	r3, r0
 8021244:	b958      	cbnz	r0, 802125e <system_add_rt_report+0x1e>
        sys.report.value = 0;
 8021246:	4a10      	ldr	r2, [pc, #64]	; (8021288 <system_add_rt_report+0x48>)
 8021248:	2100      	movs	r1, #0
 802124a:	6311      	str	r1, [r2, #48]	; 0x30
    else if(report == Report_MPGMode)
        sys.report.mpg_mode = hal.driver_cap.mpg_mode;
    else
        sys.report.value |= (uint32_t)report;

    if(sys.report.value && grbl.on_rt_reports_added)
 802124c:	4a0e      	ldr	r2, [pc, #56]	; (8021288 <system_add_rt_report+0x48>)
 802124e:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8021250:	b122      	cbz	r2, 802125c <system_add_rt_report+0x1c>
 8021252:	4a0e      	ldr	r2, [pc, #56]	; (802128c <system_add_rt_report+0x4c>)
 8021254:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8021256:	b10a      	cbz	r2, 802125c <system_add_rt_report+0x1c>
        grbl.on_rt_reports_added((report_tracking_flags_t)((uint32_t)report));
 8021258:	4618      	mov	r0, r3
 802125a:	4790      	blx	r2
}
 802125c:	bd08      	pop	{r3, pc}
    else if(report == Report_MPGMode)
 802125e:	2801      	cmp	r0, #1
 8021260:	d004      	beq.n	802126c <system_add_rt_report+0x2c>
        sys.report.value |= (uint32_t)report;
 8021262:	4909      	ldr	r1, [pc, #36]	; (8021288 <system_add_rt_report+0x48>)
 8021264:	6b0a      	ldr	r2, [r1, #48]	; 0x30
 8021266:	4302      	orrs	r2, r0
 8021268:	630a      	str	r2, [r1, #48]	; 0x30
 802126a:	e7ef      	b.n	802124c <system_add_rt_report+0xc>
        sys.report.mpg_mode = hal.driver_cap.mpg_mode;
 802126c:	4a08      	ldr	r2, [pc, #32]	; (8021290 <system_add_rt_report+0x50>)
 802126e:	f892 21a5 	ldrb.w	r2, [r2, #421]	; 0x1a5
 8021272:	f3c2 1280 	ubfx	r2, r2, #6, #1
 8021276:	4904      	ldr	r1, [pc, #16]	; (8021288 <system_add_rt_report+0x48>)
 8021278:	f891 0030 	ldrb.w	r0, [r1, #48]	; 0x30
 802127c:	f362 0000 	bfi	r0, r2, #0, #1
 8021280:	f881 0030 	strb.w	r0, [r1, #48]	; 0x30
 8021284:	e7e2      	b.n	802124c <system_add_rt_report+0xc>
 8021286:	bf00      	nop
 8021288:	200036c4 	.word	0x200036c4
 802128c:	2000343c 	.word	0x2000343c
 8021290:	2000350c 	.word	0x2000350c

08021294 <set_tool_reference>:
{
 8021294:	b500      	push	{lr}
 8021296:	b083      	sub	sp, #12
    gc_get_plane_data(&plane, gc_state.modal.plane_select);
 8021298:	4b12      	ldr	r3, [pc, #72]	; (80212e4 <set_tool_reference+0x50>)
 802129a:	7999      	ldrb	r1, [r3, #6]
 802129c:	a801      	add	r0, sp, #4
 802129e:	f7ed ff2f 	bl	800f100 <gc_get_plane_data>
    if(sys.flags.probe_succeeded) {
 80212a2:	4b11      	ldr	r3, [pc, #68]	; (80212e8 <set_tool_reference+0x54>)
 80212a4:	7d9b      	ldrb	r3, [r3, #22]
 80212a6:	f013 0f02 	tst.w	r3, #2
 80212aa:	d016      	beq.n	80212da <set_tool_reference+0x46>
        sys.tlo_reference_set.mask |= bit(plane.axis_linear);
 80212ac:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80212b0:	2001      	movs	r0, #1
 80212b2:	4098      	lsls	r0, r3
 80212b4:	4a0c      	ldr	r2, [pc, #48]	; (80212e8 <set_tool_reference+0x54>)
 80212b6:	79d1      	ldrb	r1, [r2, #7]
 80212b8:	4301      	orrs	r1, r0
 80212ba:	71d1      	strb	r1, [r2, #7]
        sys.tlo_reference[plane.axis_linear] = sys.probe_position[plane.axis_linear];
 80212bc:	f103 010e 	add.w	r1, r3, #14
 80212c0:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
 80212c4:	3302      	adds	r3, #2
 80212c6:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    system_add_rt_report(Report_TLOReference);
 80212ca:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80212ce:	f7ff ffb7 	bl	8021240 <system_add_rt_report>
}
 80212d2:	2000      	movs	r0, #0
 80212d4:	b003      	add	sp, #12
 80212d6:	f85d fb04 	ldr.w	pc, [sp], #4
        sys.tlo_reference_set.mask = 0;
 80212da:	4b03      	ldr	r3, [pc, #12]	; (80212e8 <set_tool_reference+0x54>)
 80212dc:	2200      	movs	r2, #0
 80212de:	71da      	strb	r2, [r3, #7]
 80212e0:	e7f3      	b.n	80212ca <set_tool_reference+0x36>
 80212e2:	bf00      	nop
 80212e4:	20003344 	.word	0x20003344
 80212e8:	200036c4 	.word	0x200036c4

080212ec <output_parser_state>:
{
 80212ec:	b508      	push	{r3, lr}
    report_gcode_modes();
 80212ee:	f7f8 fa25 	bl	801973c <report_gcode_modes>
    system_add_rt_report(Report_Homed); // Report homed state on next realtime report
 80212f2:	2004      	movs	r0, #4
 80212f4:	f7ff ffa4 	bl	8021240 <system_add_rt_report>
}
 80212f8:	2000      	movs	r0, #0
 80212fa:	bd08      	pop	{r3, pc}

080212fc <system_flag_wco_change>:
{
 80212fc:	b508      	push	{r3, lr}
    if(!settings.status_report.sync_on_wco_change)
 80212fe:	4b09      	ldr	r3, [pc, #36]	; (8021324 <system_flag_wco_change+0x28>)
 8021300:	f893 30fd 	ldrb.w	r3, [r3, #253]	; 0xfd
 8021304:	f013 0f01 	tst.w	r3, #1
 8021308:	d008      	beq.n	802131c <system_flag_wco_change+0x20>
    if(grbl.on_wco_changed)
 802130a:	4b07      	ldr	r3, [pc, #28]	; (8021328 <system_flag_wco_change+0x2c>)
 802130c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802130e:	b103      	cbz	r3, 8021312 <system_flag_wco_change+0x16>
        grbl.on_wco_changed();
 8021310:	4798      	blx	r3
    system_add_rt_report(Report_WCO);
 8021312:	f44f 7080 	mov.w	r0, #256	; 0x100
 8021316:	f7ff ff93 	bl	8021240 <system_add_rt_report>
}
 802131a:	bd08      	pop	{r3, pc}
        protocol_buffer_synchronize();
 802131c:	f7f6 fc5c 	bl	8017bd8 <protocol_buffer_synchronize>
 8021320:	e7f3      	b.n	802130a <system_flag_wco_change+0xe>
 8021322:	bf00      	nop
 8021324:	20003b14 	.word	0x20003b14
 8021328:	2000343c 	.word	0x2000343c

0802132c <change_completed>:
//    else error?
}

// Restore HAL pointers on completion or reset.
static void change_completed (void)
{
 802132c:	b538      	push	{r3, r4, r5, lr}
    if(enqueue_realtime_command) {
 802132e:	4b1c      	ldr	r3, [pc, #112]	; (80213a0 <change_completed+0x74>)
 8021330:	681b      	ldr	r3, [r3, #0]
 8021332:	b17b      	cbz	r3, 8021354 <change_completed+0x28>
        while(spin_lock);
 8021334:	4b1b      	ldr	r3, [pc, #108]	; (80213a4 <change_completed+0x78>)
 8021336:	681b      	ldr	r3, [r3, #0]
 8021338:	2b00      	cmp	r3, #0
 802133a:	d1fb      	bne.n	8021334 <change_completed+0x8>
        hal.irq_disable();
 802133c:	4c1a      	ldr	r4, [pc, #104]	; (80213a8 <change_completed+0x7c>)
 802133e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8021340:	4798      	blx	r3
        hal.stream.set_enqueue_rt_handler(enqueue_realtime_command);
 8021342:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
 8021346:	4d16      	ldr	r5, [pc, #88]	; (80213a0 <change_completed+0x74>)
 8021348:	6828      	ldr	r0, [r5, #0]
 802134a:	4798      	blx	r3
        enqueue_realtime_command = NULL;
 802134c:	2300      	movs	r3, #0
 802134e:	602b      	str	r3, [r5, #0]
        hal.irq_enable();
 8021350:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8021352:	4798      	blx	r3
    }

    if(control_interrupt_callback) {
 8021354:	4b15      	ldr	r3, [pc, #84]	; (80213ac <change_completed+0x80>)
 8021356:	681b      	ldr	r3, [r3, #0]
 8021358:	b16b      	cbz	r3, 8021376 <change_completed+0x4a>
        while(spin_lock);
 802135a:	4b12      	ldr	r3, [pc, #72]	; (80213a4 <change_completed+0x78>)
 802135c:	681b      	ldr	r3, [r3, #0]
 802135e:	2b00      	cmp	r3, #0
 8021360:	d1fb      	bne.n	802135a <change_completed+0x2e>
        hal.irq_disable();
 8021362:	4c11      	ldr	r4, [pc, #68]	; (80213a8 <change_completed+0x7c>)
 8021364:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8021366:	4798      	blx	r3
        hal.control.interrupt_callback = control_interrupt_callback;
 8021368:	4b10      	ldr	r3, [pc, #64]	; (80213ac <change_completed+0x80>)
 802136a:	681a      	ldr	r2, [r3, #0]
 802136c:	66e2      	str	r2, [r4, #108]	; 0x6c
        control_interrupt_callback = NULL;
 802136e:	2200      	movs	r2, #0
 8021370:	601a      	str	r2, [r3, #0]
        hal.irq_enable();
 8021372:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8021374:	4798      	blx	r3
    }

    if(probe_fixture)
 8021376:	4b0e      	ldr	r3, [pc, #56]	; (80213b0 <change_completed+0x84>)
 8021378:	781b      	ldrb	r3, [r3, #0]
 802137a:	b133      	cbz	r3, 802138a <change_completed+0x5e>
        grbl.on_probe_fixture(&current_tool, true, false);
 802137c:	4b0d      	ldr	r3, [pc, #52]	; (80213b4 <change_completed+0x88>)
 802137e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8021382:	2200      	movs	r2, #0
 8021384:	2101      	movs	r1, #1
 8021386:	480c      	ldr	r0, [pc, #48]	; (80213b8 <change_completed+0x8c>)
 8021388:	4798      	blx	r3

    grbl.on_probe_completed = NULL;
 802138a:	2300      	movs	r3, #0
 802138c:	4a09      	ldr	r2, [pc, #36]	; (80213b4 <change_completed+0x88>)
 802138e:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    gc_state.tool_change = probe_fixture = false;
 8021392:	4a07      	ldr	r2, [pc, #28]	; (80213b0 <change_completed+0x84>)
 8021394:	7013      	strb	r3, [r2, #0]
 8021396:	4a09      	ldr	r2, [pc, #36]	; (80213bc <change_completed+0x90>)
 8021398:	f882 3077 	strb.w	r3, [r2, #119]	; 0x77
}
 802139c:	bd38      	pop	{r3, r4, r5, pc}
 802139e:	bf00      	nop
 80213a0:	200047c8 	.word	0x200047c8
 80213a4:	200047e8 	.word	0x200047e8
 80213a8:	2000350c 	.word	0x2000350c
 80213ac:	200047ac 	.word	0x200047ac
 80213b0:	200047e4 	.word	0x200047e4
 80213b4:	2000343c 	.word	0x2000343c
 80213b8:	200047b0 	.word	0x200047b0
 80213bc:	20003344 	.word	0x20003344

080213c0 <execute_warning>:
}

// Issue warning on cycle start event if touch off by $TPW is pending.
// Used in Manual and Manual_G59_3 modes ($341=1 or $341=2). Called from the foreground process.
static void execute_warning (sys_state_t state)
{
 80213c0:	b508      	push	{r3, lr}
    grbl.report.feedback_message(Message_ExecuteTPW);
 80213c2:	4b02      	ldr	r3, [pc, #8]	; (80213cc <execute_warning+0xc>)
 80213c4:	68db      	ldr	r3, [r3, #12]
 80213c6:	2014      	movs	r0, #20
 80213c8:	4798      	blx	r3
}
 80213ca:	bd08      	pop	{r3, pc}
 80213cc:	2000343c 	.word	0x2000343c

080213d0 <on_toolchange_ack>:
    return drop;
}

// Trap cycle start command and control signal when tool change is acknowledged by sender.
ISR_CODE static void ISR_FUNC(on_toolchange_ack)(void)
{
 80213d0:	b508      	push	{r3, lr}
    control_interrupt_callback = hal.control.interrupt_callback;
 80213d2:	4b06      	ldr	r3, [pc, #24]	; (80213ec <on_toolchange_ack+0x1c>)
 80213d4:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 80213d6:	4a06      	ldr	r2, [pc, #24]	; (80213f0 <on_toolchange_ack+0x20>)
 80213d8:	6011      	str	r1, [r2, #0]
    hal.control.interrupt_callback = trap_control_cycle_start;
 80213da:	4a06      	ldr	r2, [pc, #24]	; (80213f4 <on_toolchange_ack+0x24>)
 80213dc:	66da      	str	r2, [r3, #108]	; 0x6c
    enqueue_realtime_command = hal.stream.set_enqueue_rt_handler(trap_stream_cycle_start);
 80213de:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
 80213e2:	4805      	ldr	r0, [pc, #20]	; (80213f8 <on_toolchange_ack+0x28>)
 80213e4:	4798      	blx	r3
 80213e6:	4b05      	ldr	r3, [pc, #20]	; (80213fc <on_toolchange_ack+0x2c>)
 80213e8:	6018      	str	r0, [r3, #0]

}
 80213ea:	bd08      	pop	{r3, pc}
 80213ec:	2000350c 	.word	0x2000350c
 80213f0:	200047ac 	.word	0x200047ac
 80213f4:	08021551 	.word	0x08021551
 80213f8:	080214cd 	.word	0x080214cd
 80213fc:	200047c8 	.word	0x200047c8

08021400 <on_probe_completed>:
{
 8021400:	b508      	push	{r3, lr}
    if(!sys.flags.probe_succeeded)
 8021402:	4b0f      	ldr	r3, [pc, #60]	; (8021440 <on_probe_completed+0x40>)
 8021404:	7d9b      	ldrb	r3, [r3, #22]
 8021406:	f013 0f02 	tst.w	r3, #2
 802140a:	d104      	bne.n	8021416 <on_probe_completed+0x16>
        grbl.report.feedback_message(Message_ProbeFailedRetry);
 802140c:	4b0d      	ldr	r3, [pc, #52]	; (8021444 <on_probe_completed+0x44>)
 802140e:	68db      	ldr	r3, [r3, #12]
 8021410:	2013      	movs	r0, #19
 8021412:	4798      	blx	r3
}
 8021414:	bd08      	pop	{r3, pc}
    else if(sys.tlo_reference_set.mask & bit(plane.axis_linear))
 8021416:	4b0a      	ldr	r3, [pc, #40]	; (8021440 <on_probe_completed+0x40>)
 8021418:	79db      	ldrb	r3, [r3, #7]
 802141a:	4a0b      	ldr	r2, [pc, #44]	; (8021448 <on_probe_completed+0x48>)
 802141c:	7891      	ldrb	r1, [r2, #2]
 802141e:	40cb      	lsrs	r3, r1
 8021420:	f013 0f01 	tst.w	r3, #1
 8021424:	d0f6      	beq.n	8021414 <on_probe_completed+0x14>
        gc_set_tool_offset(ToolLengthOffset_EnableDynamic, plane.axis_linear, sys.probe_position[plane.axis_linear] - sys.tlo_reference[plane.axis_linear]);
 8021426:	4b06      	ldr	r3, [pc, #24]	; (8021440 <on_probe_completed+0x40>)
 8021428:	f101 020e 	add.w	r2, r1, #14
 802142c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8021430:	1c88      	adds	r0, r1, #2
 8021432:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8021436:	1ad2      	subs	r2, r2, r3
 8021438:	2002      	movs	r0, #2
 802143a:	f7ed fe07 	bl	800f04c <gc_set_tool_offset>
}
 802143e:	e7e9      	b.n	8021414 <on_probe_completed+0x14>
 8021440:	200036c4 	.word	0x200036c4
 8021444:	2000343c 	.word	0x2000343c
 8021448:	200047d4 	.word	0x200047d4

0802144c <reset>:
{
 802144c:	b538      	push	{r3, r4, r5, lr}
    if(next_tool) { //TODO: move to gc_xxx() function?
 802144e:	4b11      	ldr	r3, [pc, #68]	; (8021494 <reset+0x48>)
 8021450:	681c      	ldr	r4, [r3, #0]
 8021452:	b164      	cbz	r4, 802146e <reset+0x22>
        if(current_tool.tool_id != next_tool->tool_id) {
 8021454:	4b10      	ldr	r3, [pc, #64]	; (8021498 <reset+0x4c>)
 8021456:	691a      	ldr	r2, [r3, #16]
 8021458:	6923      	ldr	r3, [r4, #16]
 802145a:	429a      	cmp	r2, r3
 802145c:	d10d      	bne.n	802147a <reset+0x2e>
        gc_state.tool_pending = gc_state.tool->tool_id;
 802145e:	4b0f      	ldr	r3, [pc, #60]	; (802149c <reset+0x50>)
 8021460:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8021464:	6912      	ldr	r2, [r2, #16]
 8021466:	671a      	str	r2, [r3, #112]	; 0x70
        next_tool = NULL;
 8021468:	4b0a      	ldr	r3, [pc, #40]	; (8021494 <reset+0x48>)
 802146a:	2200      	movs	r2, #0
 802146c:	601a      	str	r2, [r3, #0]
    change_completed();
 802146e:	f7ff ff5d 	bl	802132c <change_completed>
    driver_reset();
 8021472:	4b0b      	ldr	r3, [pc, #44]	; (80214a0 <reset+0x54>)
 8021474:	681b      	ldr	r3, [r3, #0]
 8021476:	4798      	blx	r3
}
 8021478:	bd38      	pop	{r3, r4, r5, pc}
            memcpy(next_tool, &current_tool, sizeof(tool_data_t));
 802147a:	4d07      	ldr	r5, [pc, #28]	; (8021498 <reset+0x4c>)
 802147c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802147e:	6020      	str	r0, [r4, #0]
 8021480:	6061      	str	r1, [r4, #4]
 8021482:	60a2      	str	r2, [r4, #8]
 8021484:	60e3      	str	r3, [r4, #12]
 8021486:	6828      	ldr	r0, [r5, #0]
 8021488:	6120      	str	r0, [r4, #16]
            system_add_rt_report(Report_Tool);
 802148a:	2080      	movs	r0, #128	; 0x80
 802148c:	f7ff fed8 	bl	8021240 <system_add_rt_report>
 8021490:	e7e5      	b.n	802145e <reset+0x12>
 8021492:	bf00      	nop
 8021494:	200047d0 	.word	0x200047d0
 8021498:	200047b0 	.word	0x200047b0
 802149c:	20003344 	.word	0x20003344
 80214a0:	200047c4 	.word	0x200047c4

080214a4 <tool_select>:

// Set next and/or current tool. Called by gcode.c on on a Tn or M61 command (via HAL).
static void tool_select (tool_data_t *tool, bool next)
{
    next_tool = tool;
 80214a4:	4b07      	ldr	r3, [pc, #28]	; (80214c4 <tool_select+0x20>)
 80214a6:	6018      	str	r0, [r3, #0]
    if(!next)
 80214a8:	b101      	cbz	r1, 80214ac <tool_select+0x8>
 80214aa:	4770      	bx	lr
{
 80214ac:	b430      	push	{r4, r5}
 80214ae:	4604      	mov	r4, r0
        memcpy(&current_tool, tool, sizeof(tool_data_t));
 80214b0:	4d05      	ldr	r5, [pc, #20]	; (80214c8 <tool_select+0x24>)
 80214b2:	6800      	ldr	r0, [r0, #0]
 80214b4:	6861      	ldr	r1, [r4, #4]
 80214b6:	68a2      	ldr	r2, [r4, #8]
 80214b8:	68e3      	ldr	r3, [r4, #12]
 80214ba:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80214bc:	6920      	ldr	r0, [r4, #16]
 80214be:	6028      	str	r0, [r5, #0]
}
 80214c0:	bc30      	pop	{r4, r5}
 80214c2:	4770      	bx	lr
 80214c4:	200047d0 	.word	0x200047d0
 80214c8:	200047b0 	.word	0x200047b0

080214cc <trap_stream_cycle_start>:
{
 80214cc:	b510      	push	{r4, lr}
    spin_lock++;
 80214ce:	4a18      	ldr	r2, [pc, #96]	; (8021530 <trap_stream_cycle_start+0x64>)
 80214d0:	6813      	ldr	r3, [r2, #0]
 80214d2:	3301      	adds	r3, #1
 80214d4:	6013      	str	r3, [r2, #0]
    if((drop = (c == CMD_CYCLE_START || c == CMD_CYCLE_START_LEGACY))) {
 80214d6:	2881      	cmp	r0, #129	; 0x81
 80214d8:	d017      	beq.n	802150a <trap_stream_cycle_start+0x3e>
 80214da:	287e      	cmp	r0, #126	; 0x7e
 80214dc:	d013      	beq.n	8021506 <trap_stream_cycle_start+0x3a>
 80214de:	2300      	movs	r3, #0
 80214e0:	461c      	mov	r4, r3
 80214e2:	b1d3      	cbz	r3, 802151a <trap_stream_cycle_start+0x4e>
        if(!execute_posted) {
 80214e4:	4b13      	ldr	r3, [pc, #76]	; (8021534 <trap_stream_cycle_start+0x68>)
 80214e6:	781b      	ldrb	r3, [r3, #0]
 80214e8:	b9db      	cbnz	r3, 8021522 <trap_stream_cycle_start+0x56>
            if(!block_cycle_start)
 80214ea:	4b13      	ldr	r3, [pc, #76]	; (8021538 <trap_stream_cycle_start+0x6c>)
 80214ec:	781b      	ldrb	r3, [r3, #0]
 80214ee:	b983      	cbnz	r3, 8021512 <trap_stream_cycle_start+0x46>
                execute_posted = protocol_enqueue_rt_command(settings.tool_change.mode == ToolChange_SemiAutomatic ? execute_probe : execute_restore);
 80214f0:	4b12      	ldr	r3, [pc, #72]	; (802153c <trap_stream_cycle_start+0x70>)
 80214f2:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 80214f6:	2b03      	cmp	r3, #3
 80214f8:	d009      	beq.n	802150e <trap_stream_cycle_start+0x42>
 80214fa:	4811      	ldr	r0, [pc, #68]	; (8021540 <trap_stream_cycle_start+0x74>)
 80214fc:	f7f6 fdb6 	bl	801806c <protocol_enqueue_rt_command>
 8021500:	4b0c      	ldr	r3, [pc, #48]	; (8021534 <trap_stream_cycle_start+0x68>)
 8021502:	7018      	strb	r0, [r3, #0]
 8021504:	e00d      	b.n	8021522 <trap_stream_cycle_start+0x56>
    if((drop = (c == CMD_CYCLE_START || c == CMD_CYCLE_START_LEGACY))) {
 8021506:	2301      	movs	r3, #1
 8021508:	e7ea      	b.n	80214e0 <trap_stream_cycle_start+0x14>
 802150a:	2301      	movs	r3, #1
 802150c:	e7e8      	b.n	80214e0 <trap_stream_cycle_start+0x14>
                execute_posted = protocol_enqueue_rt_command(settings.tool_change.mode == ToolChange_SemiAutomatic ? execute_probe : execute_restore);
 802150e:	480d      	ldr	r0, [pc, #52]	; (8021544 <trap_stream_cycle_start+0x78>)
 8021510:	e7f4      	b.n	80214fc <trap_stream_cycle_start+0x30>
                protocol_enqueue_rt_command(execute_warning);
 8021512:	480d      	ldr	r0, [pc, #52]	; (8021548 <trap_stream_cycle_start+0x7c>)
 8021514:	f7f6 fdaa 	bl	801806c <protocol_enqueue_rt_command>
 8021518:	e003      	b.n	8021522 <trap_stream_cycle_start+0x56>
        drop = enqueue_realtime_command(c);
 802151a:	4b0c      	ldr	r3, [pc, #48]	; (802154c <trap_stream_cycle_start+0x80>)
 802151c:	681b      	ldr	r3, [r3, #0]
 802151e:	4798      	blx	r3
 8021520:	4604      	mov	r4, r0
    spin_lock--;
 8021522:	4a03      	ldr	r2, [pc, #12]	; (8021530 <trap_stream_cycle_start+0x64>)
 8021524:	6813      	ldr	r3, [r2, #0]
 8021526:	3b01      	subs	r3, #1
 8021528:	6013      	str	r3, [r2, #0]
}
 802152a:	4620      	mov	r0, r4
 802152c:	bd10      	pop	{r4, pc}
 802152e:	bf00      	nop
 8021530:	200047e8 	.word	0x200047e8
 8021534:	200047cc 	.word	0x200047cc
 8021538:	200047a8 	.word	0x200047a8
 802153c:	20003b14 	.word	0x20003b14
 8021540:	080216e5 	.word	0x080216e5
 8021544:	08021725 	.word	0x08021725
 8021548:	080213c1 	.word	0x080213c1
 802154c:	200047c8 	.word	0x200047c8

08021550 <trap_control_cycle_start>:
{
 8021550:	b508      	push	{r3, lr}
    spin_lock++;
 8021552:	4a13      	ldr	r2, [pc, #76]	; (80215a0 <trap_control_cycle_start+0x50>)
 8021554:	6813      	ldr	r3, [r2, #0]
 8021556:	3301      	adds	r3, #1
 8021558:	6013      	str	r3, [r2, #0]
    if(signals.cycle_start) {
 802155a:	f010 0f04 	tst.w	r0, #4
 802155e:	d016      	beq.n	802158e <trap_control_cycle_start+0x3e>
        if(!execute_posted) {
 8021560:	4b10      	ldr	r3, [pc, #64]	; (80215a4 <trap_control_cycle_start+0x54>)
 8021562:	781b      	ldrb	r3, [r3, #0]
 8021564:	b9b3      	cbnz	r3, 8021594 <trap_control_cycle_start+0x44>
            if(!block_cycle_start)
 8021566:	4b10      	ldr	r3, [pc, #64]	; (80215a8 <trap_control_cycle_start+0x58>)
 8021568:	781b      	ldrb	r3, [r3, #0]
 802156a:	b963      	cbnz	r3, 8021586 <trap_control_cycle_start+0x36>
                execute_posted = protocol_enqueue_rt_command(settings.tool_change.mode == ToolChange_SemiAutomatic ? execute_probe : execute_restore);
 802156c:	4b0f      	ldr	r3, [pc, #60]	; (80215ac <trap_control_cycle_start+0x5c>)
 802156e:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8021572:	2b03      	cmp	r3, #3
 8021574:	d005      	beq.n	8021582 <trap_control_cycle_start+0x32>
 8021576:	480e      	ldr	r0, [pc, #56]	; (80215b0 <trap_control_cycle_start+0x60>)
 8021578:	f7f6 fd78 	bl	801806c <protocol_enqueue_rt_command>
 802157c:	4b09      	ldr	r3, [pc, #36]	; (80215a4 <trap_control_cycle_start+0x54>)
 802157e:	7018      	strb	r0, [r3, #0]
 8021580:	e008      	b.n	8021594 <trap_control_cycle_start+0x44>
 8021582:	480c      	ldr	r0, [pc, #48]	; (80215b4 <trap_control_cycle_start+0x64>)
 8021584:	e7f8      	b.n	8021578 <trap_control_cycle_start+0x28>
                protocol_enqueue_rt_command(execute_warning);
 8021586:	480c      	ldr	r0, [pc, #48]	; (80215b8 <trap_control_cycle_start+0x68>)
 8021588:	f7f6 fd70 	bl	801806c <protocol_enqueue_rt_command>
        signals.cycle_start = Off;
 802158c:	e002      	b.n	8021594 <trap_control_cycle_start+0x44>
        control_interrupt_callback(signals);
 802158e:	4b0b      	ldr	r3, [pc, #44]	; (80215bc <trap_control_cycle_start+0x6c>)
 8021590:	681b      	ldr	r3, [r3, #0]
 8021592:	4798      	blx	r3
    spin_lock--;
 8021594:	4a02      	ldr	r2, [pc, #8]	; (80215a0 <trap_control_cycle_start+0x50>)
 8021596:	6813      	ldr	r3, [r2, #0]
 8021598:	3b01      	subs	r3, #1
 802159a:	6013      	str	r3, [r2, #0]
}
 802159c:	bd08      	pop	{r3, pc}
 802159e:	bf00      	nop
 80215a0:	200047e8 	.word	0x200047e8
 80215a4:	200047cc 	.word	0x200047cc
 80215a8:	200047a8 	.word	0x200047a8
 80215ac:	20003b14 	.word	0x20003b14
 80215b0:	080216e5 	.word	0x080216e5
 80215b4:	08021725 	.word	0x08021725
 80215b8:	080213c1 	.word	0x080213c1
 80215bc:	200047ac 	.word	0x200047ac

080215c0 <restore>:
{
 80215c0:	b530      	push	{r4, r5, lr}
 80215c2:	b08b      	sub	sp, #44	; 0x2c
    plan_data_init(&plan_data);
 80215c4:	4668      	mov	r0, sp
 80215c6:	f7f5 fbcb 	bl	8016d60 <plan_data_init>
    plan_data.condition.rapid_motion = On;
 80215ca:	f89d 3014 	ldrb.w	r3, [sp, #20]
 80215ce:	f043 0301 	orr.w	r3, r3, #1
 80215d2:	f88d 3014 	strb.w	r3, [sp, #20]
    target.values[plane.axis_linear] = tool_change_position;
 80215d6:	4b39      	ldr	r3, [pc, #228]	; (80216bc <restore+0xfc>)
 80215d8:	789b      	ldrb	r3, [r3, #2]
 80215da:	4839      	ldr	r0, [pc, #228]	; (80216c0 <restore+0x100>)
 80215dc:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80215e0:	4a38      	ldr	r2, [pc, #224]	; (80216c4 <restore+0x104>)
 80215e2:	6812      	ldr	r2, [r2, #0]
 80215e4:	601a      	str	r2, [r3, #0]
    mc_line(target.values, &plan_data);
 80215e6:	4669      	mov	r1, sp
 80215e8:	f7f2 fae6 	bl	8013bb8 <mc_line>
    if(!settings.flags.no_restore_position_after_M6) {
 80215ec:	4b36      	ldr	r3, [pc, #216]	; (80216c8 <restore+0x108>)
 80215ee:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
 80215f2:	f013 0f40 	tst.w	r3, #64	; 0x40
 80215f6:	d010      	beq.n	802161a <restore+0x5a>
    if(protocol_buffer_synchronize()) {
 80215f8:	f7f6 faee 	bl	8017bd8 <protocol_buffer_synchronize>
 80215fc:	b9f0      	cbnz	r0, 802163c <restore+0x7c>
    if(protocol_buffer_synchronize()) {
 80215fe:	f7f6 faeb 	bl	8017bd8 <protocol_buffer_synchronize>
 8021602:	2800      	cmp	r0, #0
 8021604:	d144      	bne.n	8021690 <restore+0xd0>
    return !ABORTED;
 8021606:	4b31      	ldr	r3, [pc, #196]	; (80216cc <restore+0x10c>)
 8021608:	781b      	ldrb	r3, [r3, #0]
 802160a:	2b00      	cmp	r3, #0
 802160c:	d151      	bne.n	80216b2 <restore+0xf2>
 802160e:	4b2f      	ldr	r3, [pc, #188]	; (80216cc <restore+0x10c>)
 8021610:	785b      	ldrb	r3, [r3, #1]
 8021612:	2b00      	cmp	r3, #0
 8021614:	d050      	beq.n	80216b8 <restore+0xf8>
 8021616:	2000      	movs	r0, #0
 8021618:	e04c      	b.n	80216b4 <restore+0xf4>
        memcpy(&target, &previous, sizeof(coord_data_t));
 802161a:	4b29      	ldr	r3, [pc, #164]	; (80216c0 <restore+0x100>)
 802161c:	4a2c      	ldr	r2, [pc, #176]	; (80216d0 <restore+0x110>)
 802161e:	ca07      	ldmia	r2, {r0, r1, r2}
 8021620:	e883 0007 	stmia.w	r3, {r0, r1, r2}
        target.values[plane.axis_linear] = tool_change_position;
 8021624:	4a25      	ldr	r2, [pc, #148]	; (80216bc <restore+0xfc>)
 8021626:	7892      	ldrb	r2, [r2, #2]
 8021628:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 802162c:	4925      	ldr	r1, [pc, #148]	; (80216c4 <restore+0x104>)
 802162e:	6809      	ldr	r1, [r1, #0]
 8021630:	6011      	str	r1, [r2, #0]
        mc_line(target.values, &plan_data);
 8021632:	4669      	mov	r1, sp
 8021634:	4618      	mov	r0, r3
 8021636:	f7f2 fabf 	bl	8013bb8 <mc_line>
 802163a:	e7dd      	b.n	80215f8 <restore+0x38>
        sync_position();
 802163c:	f7f5 fb20 	bl	8016c80 <plan_sync_position>
 8021640:	4c24      	ldr	r4, [pc, #144]	; (80216d4 <restore+0x114>)
 8021642:	4925      	ldr	r1, [pc, #148]	; (80216d8 <restore+0x118>)
 8021644:	4620      	mov	r0, r4
 8021646:	f7ff fcc9 	bl	8020fdc <system_convert_array_steps_to_mpos>
        coolant_sync(gc_state.modal.coolant);
 802164a:	f814 0c47 	ldrb.w	r0, [r4, #-71]
 802164e:	f7ed fbd7 	bl	800ee00 <coolant_sync>
        spindle_restore(plan_data.spindle.hal, gc_state.modal.spindle.state, gc_state.spindle.rpm);
 8021652:	ed14 0a06 	vldr	s0, [r4, #-24]	; 0xffffffe8
 8021656:	f814 1c46 	ldrb.w	r1, [r4, #-70]
 802165a:	9804      	ldr	r0, [sp, #16]
 802165c:	f7fc fa5e 	bl	801db1c <spindle_restore>
        if(!settings.flags.no_restore_position_after_M6) {
 8021660:	4b19      	ldr	r3, [pc, #100]	; (80216c8 <restore+0x108>)
 8021662:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
 8021666:	f013 0f40 	tst.w	r3, #64	; 0x40
 802166a:	d1c8      	bne.n	80215fe <restore+0x3e>
            previous.values[plane.axis_linear] += gc_get_offset(plane.axis_linear);
 802166c:	4c13      	ldr	r4, [pc, #76]	; (80216bc <restore+0xfc>)
 802166e:	78a0      	ldrb	r0, [r4, #2]
 8021670:	f7ed fcd4 	bl	800f01c <gc_get_offset>
 8021674:	78a3      	ldrb	r3, [r4, #2]
 8021676:	4816      	ldr	r0, [pc, #88]	; (80216d0 <restore+0x110>)
 8021678:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 802167c:	edd3 7a00 	vldr	s15, [r3]
 8021680:	ee77 7a80 	vadd.f32	s15, s15, s0
 8021684:	edc3 7a00 	vstr	s15, [r3]
            mc_line(previous.values, &plan_data);
 8021688:	4669      	mov	r1, sp
 802168a:	f7f2 fa95 	bl	8013bb8 <mc_line>
 802168e:	e7b6      	b.n	80215fe <restore+0x3e>
        sync_position();
 8021690:	f7f5 faf6 	bl	8016c80 <plan_sync_position>
 8021694:	4910      	ldr	r1, [pc, #64]	; (80216d8 <restore+0x118>)
 8021696:	480f      	ldr	r0, [pc, #60]	; (80216d4 <restore+0x114>)
 8021698:	f7ff fca0 	bl	8020fdc <system_convert_array_steps_to_mpos>
        memcpy(&current_tool, next_tool, sizeof(tool_data_t));
 802169c:	4b0f      	ldr	r3, [pc, #60]	; (80216dc <restore+0x11c>)
 802169e:	681d      	ldr	r5, [r3, #0]
 80216a0:	4c0f      	ldr	r4, [pc, #60]	; (80216e0 <restore+0x120>)
 80216a2:	6828      	ldr	r0, [r5, #0]
 80216a4:	6869      	ldr	r1, [r5, #4]
 80216a6:	68aa      	ldr	r2, [r5, #8]
 80216a8:	68eb      	ldr	r3, [r5, #12]
 80216aa:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80216ac:	6928      	ldr	r0, [r5, #16]
 80216ae:	6020      	str	r0, [r4, #0]
 80216b0:	e7a9      	b.n	8021606 <restore+0x46>
    return !ABORTED;
 80216b2:	2000      	movs	r0, #0
}
 80216b4:	b00b      	add	sp, #44	; 0x2c
 80216b6:	bd30      	pop	{r4, r5, pc}
    return !ABORTED;
 80216b8:	2001      	movs	r0, #1
 80216ba:	e7fb      	b.n	80216b4 <restore+0xf4>
 80216bc:	200047d4 	.word	0x200047d4
 80216c0:	200047ec 	.word	0x200047ec
 80216c4:	200047f8 	.word	0x200047f8
 80216c8:	20003b14 	.word	0x20003b14
 80216cc:	200036c4 	.word	0x200036c4
 80216d0:	200047d8 	.word	0x200047d8
 80216d4:	200033a4 	.word	0x200033a4
 80216d8:	2000374c 	.word	0x2000374c
 80216dc:	200047d0 	.word	0x200047d0
 80216e0:	200047b0 	.word	0x200047b0

080216e4 <execute_restore>:
{
 80216e4:	b510      	push	{r4, lr}
    system_convert_array_steps_to_mpos(target.values, sys.position);
 80216e6:	490a      	ldr	r1, [pc, #40]	; (8021710 <execute_restore+0x2c>)
 80216e8:	480a      	ldr	r0, [pc, #40]	; (8021714 <execute_restore+0x30>)
 80216ea:	f7ff fc77 	bl	8020fdc <system_convert_array_steps_to_mpos>
    bool ok = restore();
 80216ee:	f7ff ff67 	bl	80215c0 <restore>
 80216f2:	4604      	mov	r4, r0
    change_completed();
 80216f4:	f7ff fe1a 	bl	802132c <change_completed>
    grbl.report.feedback_message(Message_None);
 80216f8:	4b07      	ldr	r3, [pc, #28]	; (8021718 <execute_restore+0x34>)
 80216fa:	68db      	ldr	r3, [r3, #12]
 80216fc:	2000      	movs	r0, #0
 80216fe:	4798      	blx	r3
    if(ok)
 8021700:	b124      	cbz	r4, 802170c <execute_restore+0x28>
        system_set_exec_state_flag(EXEC_CYCLE_START);
 8021702:	4b06      	ldr	r3, [pc, #24]	; (802171c <execute_restore+0x38>)
 8021704:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8021706:	2102      	movs	r1, #2
 8021708:	4805      	ldr	r0, [pc, #20]	; (8021720 <execute_restore+0x3c>)
 802170a:	4798      	blx	r3
}
 802170c:	bd10      	pop	{r4, pc}
 802170e:	bf00      	nop
 8021710:	2000374c 	.word	0x2000374c
 8021714:	200047ec 	.word	0x200047ec
 8021718:	2000343c 	.word	0x2000343c
 802171c:	2000350c 	.word	0x2000350c
 8021720:	2000370c 	.word	0x2000370c

08021724 <execute_probe>:
{
 8021724:	b570      	push	{r4, r5, r6, lr}
 8021726:	b08e      	sub	sp, #56	; 0x38
    gc_parser_flags_t flags = {0};
 8021728:	2400      	movs	r4, #0
    if(probe_fixture)
 802172a:	4b67      	ldr	r3, [pc, #412]	; (80218c8 <execute_probe+0x1a4>)
 802172c:	781b      	ldrb	r3, [r3, #0]
 802172e:	b13b      	cbz	r3, 8021740 <execute_probe+0x1c>
        grbl.on_probe_fixture(next_tool, true, true);
 8021730:	4b66      	ldr	r3, [pc, #408]	; (80218cc <execute_probe+0x1a8>)
 8021732:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8021736:	2201      	movs	r2, #1
 8021738:	4611      	mov	r1, r2
 802173a:	4865      	ldr	r0, [pc, #404]	; (80218d0 <execute_probe+0x1ac>)
 802173c:	6800      	ldr	r0, [r0, #0]
 802173e:	4798      	blx	r3
    settings_read_coord_data(CoordinateSystem_G59_3, &offset.values);
 8021740:	a90b      	add	r1, sp, #44	; 0x2c
 8021742:	2008      	movs	r0, #8
 8021744:	f7fb f956 	bl	801c9f4 <settings_read_coord_data>
    plan_data_init(&plan_data);
 8021748:	a801      	add	r0, sp, #4
 802174a:	f7f5 fb09 	bl	8016d60 <plan_data_init>
    plan_data.condition.rapid_motion = On;
 802174e:	f89d 3018 	ldrb.w	r3, [sp, #24]
 8021752:	f043 0301 	orr.w	r3, r3, #1
 8021756:	f88d 3018 	strb.w	r3, [sp, #24]
    target.values[plane.axis_0] = offset.values[plane.axis_0];
 802175a:	4a5e      	ldr	r2, [pc, #376]	; (80218d4 <execute_probe+0x1b0>)
 802175c:	7813      	ldrb	r3, [r2, #0]
 802175e:	a90e      	add	r1, sp, #56	; 0x38
 8021760:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 8021764:	f851 1c0c 	ldr.w	r1, [r1, #-12]
 8021768:	485b      	ldr	r0, [pc, #364]	; (80218d8 <execute_probe+0x1b4>)
 802176a:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 802176e:	6019      	str	r1, [r3, #0]
    target.values[plane.axis_1] = offset.values[plane.axis_1];
 8021770:	7853      	ldrb	r3, [r2, #1]
 8021772:	aa0e      	add	r2, sp, #56	; 0x38
 8021774:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8021778:	f852 2c0c 	ldr.w	r2, [r2, #-12]
 802177c:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8021780:	601a      	str	r2, [r3, #0]
    if((ok = mc_line(target.values, &plan_data))) {
 8021782:	a901      	add	r1, sp, #4
 8021784:	f7f2 fa18 	bl	8013bb8 <mc_line>
 8021788:	4605      	mov	r5, r0
 802178a:	b948      	cbnz	r0, 80217a0 <execute_probe+0x7c>
    change_completed();
 802178c:	f7ff fdce 	bl	802132c <change_completed>
    if(ok)
 8021790:	b125      	cbz	r5, 802179c <execute_probe+0x78>
        system_set_exec_state_flag(EXEC_CYCLE_START);
 8021792:	4b52      	ldr	r3, [pc, #328]	; (80218dc <execute_probe+0x1b8>)
 8021794:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8021796:	2102      	movs	r1, #2
 8021798:	4851      	ldr	r0, [pc, #324]	; (80218e0 <execute_probe+0x1bc>)
 802179a:	4798      	blx	r3
}
 802179c:	b00e      	add	sp, #56	; 0x38
 802179e:	bd70      	pop	{r4, r5, r6, pc}
        target.values[plane.axis_linear] = offset.values[plane.axis_linear];
 80217a0:	4e4c      	ldr	r6, [pc, #304]	; (80218d4 <execute_probe+0x1b0>)
 80217a2:	78b3      	ldrb	r3, [r6, #2]
 80217a4:	aa0e      	add	r2, sp, #56	; 0x38
 80217a6:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 80217aa:	f852 2c0c 	ldr.w	r2, [r2, #-12]
 80217ae:	4d4a      	ldr	r5, [pc, #296]	; (80218d8 <execute_probe+0x1b4>)
 80217b0:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 80217b4:	601a      	str	r2, [r3, #0]
        ok = mc_line(target.values, &plan_data);
 80217b6:	a901      	add	r1, sp, #4
 80217b8:	4628      	mov	r0, r5
 80217ba:	f7f2 f9fd 	bl	8013bb8 <mc_line>
        plan_data.feed_rate = settings.tool_change.seek_rate;
 80217be:	4b49      	ldr	r3, [pc, #292]	; (80218e4 <execute_probe+0x1c0>)
 80217c0:	6a1a      	ldr	r2, [r3, #32]
 80217c2:	9201      	str	r2, [sp, #4]
        plan_data.condition.value = 0;
 80217c4:	2200      	movs	r2, #0
 80217c6:	9206      	str	r2, [sp, #24]
        plan_data.spindle.state.value = 0;
 80217c8:	f88d 200c 	strb.w	r2, [sp, #12]
        target.values[plane.axis_linear] -= settings.tool_change.probing_distance;
 80217cc:	78b2      	ldrb	r2, [r6, #2]
 80217ce:	ed93 7a0a 	vldr	s14, [r3, #40]	; 0x28
 80217d2:	eb05 0582 	add.w	r5, r5, r2, lsl #2
 80217d6:	edd5 7a00 	vldr	s15, [r5]
 80217da:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80217de:	edc5 7a00 	vstr	s15, [r5]
        if((ok = ok && mc_probe_cycle(target.values, &plan_data, flags) == GCProbe_Found))
 80217e2:	bb28      	cbnz	r0, 8021830 <execute_probe+0x10c>
 80217e4:	2300      	movs	r3, #0
 80217e6:	461d      	mov	r5, r3
 80217e8:	bb6b      	cbnz	r3, 8021846 <execute_probe+0x122>
        if(ok) {
 80217ea:	2d00      	cmp	r5, #0
 80217ec:	d0ce      	beq.n	802178c <execute_probe+0x68>
            if(!(sys.tlo_reference_set.mask & bit(plane.axis_linear))) {
 80217ee:	4b3e      	ldr	r3, [pc, #248]	; (80218e8 <execute_probe+0x1c4>)
 80217f0:	79db      	ldrb	r3, [r3, #7]
 80217f2:	4a38      	ldr	r2, [pc, #224]	; (80218d4 <execute_probe+0x1b0>)
 80217f4:	7891      	ldrb	r1, [r2, #2]
 80217f6:	fa23 f201 	lsr.w	r2, r3, r1
 80217fa:	f012 0f01 	tst.w	r2, #1
 80217fe:	d156      	bne.n	80218ae <execute_probe+0x18a>
                sys.tlo_reference[plane.axis_linear] = sys.probe_position[plane.axis_linear];
 8021800:	4a39      	ldr	r2, [pc, #228]	; (80218e8 <execute_probe+0x1c4>)
 8021802:	f101 000e 	add.w	r0, r1, #14
 8021806:	f852 4020 	ldr.w	r4, [r2, r0, lsl #2]
 802180a:	1c88      	adds	r0, r1, #2
 802180c:	f842 4020 	str.w	r4, [r2, r0, lsl #2]
                sys.tlo_reference_set.mask |= bit(plane.axis_linear);
 8021810:	2001      	movs	r0, #1
 8021812:	4088      	lsls	r0, r1
 8021814:	4303      	orrs	r3, r0
 8021816:	71d3      	strb	r3, [r2, #7]
                system_add_rt_report(Report_TLOReference);
 8021818:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 802181c:	f7ff fd10 	bl	8021240 <system_add_rt_report>
                grbl.report.feedback_message(Message_ReferenceTLOEstablished);
 8021820:	4b2a      	ldr	r3, [pc, #168]	; (80218cc <execute_probe+0x1a8>)
 8021822:	68db      	ldr	r3, [r3, #12]
 8021824:	200f      	movs	r0, #15
 8021826:	4798      	blx	r3
            ok = restore();
 8021828:	f7ff feca 	bl	80215c0 <restore>
 802182c:	4605      	mov	r5, r0
 802182e:	e7ad      	b.n	802178c <execute_probe+0x68>
        if((ok = ok && mc_probe_cycle(target.values, &plan_data, flags) == GCProbe_Found))
 8021830:	4622      	mov	r2, r4
 8021832:	a901      	add	r1, sp, #4
 8021834:	4828      	ldr	r0, [pc, #160]	; (80218d8 <execute_probe+0x1b4>)
 8021836:	f7f3 f925 	bl	8014a84 <mc_probe_cycle>
 802183a:	2801      	cmp	r0, #1
 802183c:	d001      	beq.n	8021842 <execute_probe+0x11e>
 802183e:	2300      	movs	r3, #0
 8021840:	e7d1      	b.n	80217e6 <execute_probe+0xc2>
 8021842:	2301      	movs	r3, #1
 8021844:	e7cf      	b.n	80217e6 <execute_probe+0xc2>
            system_convert_array_steps_to_mpos(target.values, sys.probe_position);
 8021846:	4d24      	ldr	r5, [pc, #144]	; (80218d8 <execute_probe+0x1b4>)
 8021848:	4928      	ldr	r1, [pc, #160]	; (80218ec <execute_probe+0x1c8>)
 802184a:	4628      	mov	r0, r5
 802184c:	f7ff fbc6 	bl	8020fdc <system_convert_array_steps_to_mpos>
            plan_data.feed_rate = settings.tool_change.pulloff_rate;
 8021850:	4b24      	ldr	r3, [pc, #144]	; (80218e4 <execute_probe+0x1c0>)
 8021852:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8021854:	9301      	str	r3, [sp, #4]
            target.values[plane.axis_linear] += TOOL_CHANGE_PROBE_RETRACT_DISTANCE;
 8021856:	4b1f      	ldr	r3, [pc, #124]	; (80218d4 <execute_probe+0x1b0>)
 8021858:	789b      	ldrb	r3, [r3, #2]
 802185a:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 802185e:	edd3 7a00 	vldr	s15, [r3]
 8021862:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
 8021866:	ee77 7a87 	vadd.f32	s15, s15, s14
 802186a:	edc3 7a00 	vstr	s15, [r3]
            if((ok = mc_line(target.values, &plan_data))) {
 802186e:	a901      	add	r1, sp, #4
 8021870:	4628      	mov	r0, r5
 8021872:	f7f2 f9a1 	bl	8013bb8 <mc_line>
 8021876:	4605      	mov	r5, r0
 8021878:	2800      	cmp	r0, #0
 802187a:	d0b6      	beq.n	80217ea <execute_probe+0xc6>
                plan_data.feed_rate = settings.tool_change.feed_rate;
 802187c:	4b19      	ldr	r3, [pc, #100]	; (80218e4 <execute_probe+0x1c0>)
 802187e:	69db      	ldr	r3, [r3, #28]
 8021880:	9301      	str	r3, [sp, #4]
                target.values[plane.axis_linear] -= (TOOL_CHANGE_PROBE_RETRACT_DISTANCE + 2.0f);
 8021882:	4b14      	ldr	r3, [pc, #80]	; (80218d4 <execute_probe+0x1b0>)
 8021884:	789b      	ldrb	r3, [r3, #2]
 8021886:	4814      	ldr	r0, [pc, #80]	; (80218d8 <execute_probe+0x1b4>)
 8021888:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 802188c:	edd3 7a00 	vldr	s15, [r3]
 8021890:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 8021894:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8021898:	edc3 7a00 	vstr	s15, [r3]
                ok = mc_probe_cycle(target.values, &plan_data, flags) == GCProbe_Found;
 802189c:	4622      	mov	r2, r4
 802189e:	a901      	add	r1, sp, #4
 80218a0:	f7f3 f8f0 	bl	8014a84 <mc_probe_cycle>
 80218a4:	2801      	cmp	r0, #1
 80218a6:	bf14      	ite	ne
 80218a8:	2500      	movne	r5, #0
 80218aa:	2501      	moveq	r5, #1
 80218ac:	e79d      	b.n	80217ea <execute_probe+0xc6>
                                    sys.probe_position[plane.axis_linear] - sys.tlo_reference[plane.axis_linear]);
 80218ae:	4b0e      	ldr	r3, [pc, #56]	; (80218e8 <execute_probe+0x1c4>)
 80218b0:	f101 020e 	add.w	r2, r1, #14
 80218b4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80218b8:	1c88      	adds	r0, r1, #2
 80218ba:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
                gc_set_tool_offset(ToolLengthOffset_EnableDynamic, plane.axis_linear,
 80218be:	1ad2      	subs	r2, r2, r3
 80218c0:	2002      	movs	r0, #2
 80218c2:	f7ed fbc3 	bl	800f04c <gc_set_tool_offset>
 80218c6:	e7af      	b.n	8021828 <execute_probe+0x104>
 80218c8:	200047e4 	.word	0x200047e4
 80218cc:	2000343c 	.word	0x2000343c
 80218d0:	200047d0 	.word	0x200047d0
 80218d4:	200047d4 	.word	0x200047d4
 80218d8:	200047ec 	.word	0x200047ec
 80218dc:	2000350c 	.word	0x2000350c
 80218e0:	2000370c 	.word	0x2000370c
 80218e4:	20003b14 	.word	0x20003b14
 80218e8:	200036c4 	.word	0x200036c4
 80218ec:	200036fc 	.word	0x200036fc

080218f0 <tool_change>:

// Start a tool change sequence. Called by gcode.c on a M6 command (via HAL).
static status_code_t tool_change (parser_state_t *parser_state)
{
    if(next_tool == NULL)
 80218f0:	4b61      	ldr	r3, [pc, #388]	; (8021a78 <tool_change+0x188>)
 80218f2:	681b      	ldr	r3, [r3, #0]
 80218f4:	2b00      	cmp	r3, #0
 80218f6:	f000 80b4 	beq.w	8021a62 <tool_change+0x172>
{
 80218fa:	b5f0      	push	{r4, r5, r6, r7, lr}
 80218fc:	b08b      	sub	sp, #44	; 0x2c
 80218fe:	4604      	mov	r4, r0
        return Status_GCodeToolError;

    if(current_tool.tool_id == next_tool->tool_id)
 8021900:	4a5e      	ldr	r2, [pc, #376]	; (8021a7c <tool_change+0x18c>)
 8021902:	6912      	ldr	r2, [r2, #16]
 8021904:	691b      	ldr	r3, [r3, #16]
 8021906:	429a      	cmp	r2, r3
 8021908:	f000 80ad 	beq.w	8021a66 <tool_change+0x176>
  #else
    plane.axis_0 = X_AXIS;
    plane.axis_1 = Y_AXIS;
  #endif
#else
    gc_get_plane_data(&plane, parser_state->modal.plane_select);
 802190c:	7981      	ldrb	r1, [r0, #6]
 802190e:	485c      	ldr	r0, [pc, #368]	; (8021a80 <tool_change+0x190>)
 8021910:	f7ed fbf6 	bl	800f100 <gc_get_plane_data>
#endif

    uint8_t homed_req = settings.tool_change.mode == ToolChange_Manual ? bit(plane.axis_linear) : (X_AXIS_BIT|Y_AXIS_BIT|Z_AXIS_BIT);
 8021914:	4b5b      	ldr	r3, [pc, #364]	; (8021a84 <tool_change+0x194>)
 8021916:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 802191a:	2b01      	cmp	r3, #1
 802191c:	d07a      	beq.n	8021a14 <tool_change+0x124>
 802191e:	2207      	movs	r2, #7

    if((sys.homed.mask & homed_req) != homed_req)
 8021920:	4959      	ldr	r1, [pc, #356]	; (8021a88 <tool_change+0x198>)
 8021922:	f891 1054 	ldrb.w	r1, [r1, #84]	; 0x54
 8021926:	438a      	bics	r2, r1
 8021928:	f040 80a0 	bne.w	8021a6c <tool_change+0x17c>
        return Status_HomingRequired;

    if(settings.tool_change.mode != ToolChange_SemiAutomatic)
 802192c:	2b03      	cmp	r3, #3
 802192e:	d003      	beq.n	8021938 <tool_change+0x48>
        grbl.on_probe_completed = on_probe_completed;
 8021930:	4a56      	ldr	r2, [pc, #344]	; (8021a8c <tool_change+0x19c>)
 8021932:	4957      	ldr	r1, [pc, #348]	; (8021a90 <tool_change+0x1a0>)
 8021934:	f8c2 1088 	str.w	r1, [r2, #136]	; 0x88

    block_cycle_start = settings.tool_change.mode != ToolChange_SemiAutomatic;
 8021938:	3b03      	subs	r3, #3
 802193a:	bf18      	it	ne
 802193c:	2301      	movne	r3, #1
 802193e:	4a55      	ldr	r2, [pc, #340]	; (8021a94 <tool_change+0x1a4>)
 8021940:	7013      	strb	r3, [r2, #0]

    // Stop spindle and coolant.
    spindle_all_off();
 8021942:	f7fc f9f5 	bl	801dd30 <spindle_all_off>
    hal.coolant.set_state((coolant_state_t){0});
 8021946:	4b54      	ldr	r3, [pc, #336]	; (8021a98 <tool_change+0x1a8>)
 8021948:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 802194a:	2500      	movs	r5, #0
 802194c:	4628      	mov	r0, r5
 802194e:	4798      	blx	r3

    execute_posted = false;
 8021950:	4b52      	ldr	r3, [pc, #328]	; (8021a9c <tool_change+0x1ac>)
 8021952:	701d      	strb	r5, [r3, #0]
    probe_fixture = grbl.on_probe_fixture != NULL &&
 8021954:	4b4d      	ldr	r3, [pc, #308]	; (8021a8c <tool_change+0x19c>)
 8021956:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 802195a:	2b00      	cmp	r3, #0
 802195c:	d060      	beq.n	8021a20 <tool_change+0x130>
                     (settings.tool_change.mode == ToolChange_Manual ||
 802195e:	4b49      	ldr	r3, [pc, #292]	; (8021a84 <tool_change+0x194>)
 8021960:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
                       settings.tool_change.mode == ToolChange_Manual_G59_3 ||
 8021964:	3b01      	subs	r3, #1
 8021966:	b2db      	uxtb	r3, r3
    probe_fixture = grbl.on_probe_fixture != NULL &&
 8021968:	2b02      	cmp	r3, #2
 802196a:	d95b      	bls.n	8021a24 <tool_change+0x134>
 802196c:	462a      	mov	r2, r5
 802196e:	4b4c      	ldr	r3, [pc, #304]	; (8021aa0 <tool_change+0x1b0>)
 8021970:	701a      	strb	r2, [r3, #0]
                        settings.tool_change.mode == ToolChange_SemiAutomatic);

    // Save current position.
    system_convert_array_steps_to_mpos(previous.values, sys.position);
 8021972:	4d4c      	ldr	r5, [pc, #304]	; (8021aa4 <tool_change+0x1b4>)
 8021974:	4e4c      	ldr	r6, [pc, #304]	; (8021aa8 <tool_change+0x1b8>)
 8021976:	4629      	mov	r1, r5
 8021978:	4630      	mov	r0, r6
 802197a:	f7ff fb2f 	bl	8020fdc <system_convert_array_steps_to_mpos>

    // Establish axis assignments.

    previous.values[plane.axis_linear] -= gc_get_offset(plane.axis_linear);
 802197e:	4f40      	ldr	r7, [pc, #256]	; (8021a80 <tool_change+0x190>)
 8021980:	78b8      	ldrb	r0, [r7, #2]
 8021982:	f7ed fb4b 	bl	800f01c <gc_get_offset>
 8021986:	78bb      	ldrb	r3, [r7, #2]
 8021988:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 802198c:	edd3 7a00 	vldr	s15, [r3]
 8021990:	ee77 7ac0 	vsub.f32	s15, s15, s0
 8021994:	edc3 7a00 	vstr	s15, [r3]

    plan_line_data_t plan_data;

    plan_data_init(&plan_data);
 8021998:	4668      	mov	r0, sp
 802199a:	f7f5 f9e1 	bl	8016d60 <plan_data_init>
    plan_data.condition.rapid_motion = On;
 802199e:	f89d 3014 	ldrb.w	r3, [sp, #20]
 80219a2:	f043 0301 	orr.w	r3, r3, #1
 80219a6:	f88d 3014 	strb.w	r3, [sp, #20]
    // TODO: add?
    //if(!settings.homing.flags.force_set_origin && bit_istrue(settings.homing.dir_mask.value, bit(plane.axis_linear)))
    //    tool_change_position = ?
    //else

    tool_change_position = sys.home_position[plane.axis_linear]; // - settings.homing.flags.force_set_origin ? LINEAR_AXIS_HOME_OFFSET : 0.0f;
 80219aa:	f897 c002 	ldrb.w	ip, [r7, #2]
 80219ae:	3d88      	subs	r5, #136	; 0x88
 80219b0:	f10c 0316 	add.w	r3, ip, #22
 80219b4:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 80219b8:	682d      	ldr	r5, [r5, #0]
 80219ba:	4b3c      	ldr	r3, [pc, #240]	; (8021aac <tool_change+0x1bc>)
 80219bc:	601d      	str	r5, [r3, #0]

    // Rapid to home position of linear axis.
    memcpy(&target, &previous, sizeof(coord_data_t));
 80219be:	4b3c      	ldr	r3, [pc, #240]	; (8021ab0 <tool_change+0x1c0>)
 80219c0:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
 80219c4:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    target.values[plane.axis_linear] = tool_change_position;
 80219c8:	eb03 0c8c 	add.w	ip, r3, ip, lsl #2
 80219cc:	f8cc 5000 	str.w	r5, [ip]
    if(!mc_line(target.values, &plan_data))
 80219d0:	4669      	mov	r1, sp
 80219d2:	4618      	mov	r0, r3
 80219d4:	f7f2 f8f0 	bl	8013bb8 <mc_line>
 80219d8:	2800      	cmp	r0, #0
 80219da:	d049      	beq.n	8021a70 <tool_change+0x180>
        return Status_Reset;

#if COMPATIBILITY_LEVEL <= 1
    if(settings.tool_change.mode == ToolChange_Manual_G59_3) {
 80219dc:	4b29      	ldr	r3, [pc, #164]	; (8021a84 <tool_change+0x194>)
 80219de:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 80219e2:	2b02      	cmp	r3, #2
 80219e4:	d020      	beq.n	8021a28 <tool_change+0x138>
        if(!mc_line(target.values, &plan_data))
            return Status_Reset;
    }
#endif

    protocol_buffer_synchronize();
 80219e6:	f7f6 f8f7 	bl	8017bd8 <protocol_buffer_synchronize>
    sync_position();
 80219ea:	f7f5 f949 	bl	8016c80 <plan_sync_position>
 80219ee:	4d2d      	ldr	r5, [pc, #180]	; (8021aa4 <tool_change+0x1b4>)
 80219f0:	4629      	mov	r1, r5
 80219f2:	4830      	ldr	r0, [pc, #192]	; (8021ab4 <tool_change+0x1c4>)
 80219f4:	f7ff faf2 	bl	8020fdc <system_convert_array_steps_to_mpos>

    // Enter tool change mode, waits for cycle start to continue.
    parser_state->tool_change = true;
 80219f8:	2301      	movs	r3, #1
 80219fa:	f884 3077 	strb.w	r3, [r4, #119]	; 0x77
    system_set_exec_state_flag(EXEC_TOOL_CHANGE);   // Set up program pause for manual tool change
 80219fe:	4b26      	ldr	r3, [pc, #152]	; (8021a98 <tool_change+0x1a8>)
 8021a00:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8021a02:	f44f 7100 	mov.w	r1, #512	; 0x200
 8021a06:	f1a5 0040 	sub.w	r0, r5, #64	; 0x40
 8021a0a:	4798      	blx	r3
    protocol_execute_realtime();                    // Execute...
 8021a0c:	f7f5 fe1e 	bl	801764c <protocol_execute_realtime>

    return Status_OK;
 8021a10:	2000      	movs	r0, #0
 8021a12:	e029      	b.n	8021a68 <tool_change+0x178>
    uint8_t homed_req = settings.tool_change.mode == ToolChange_Manual ? bit(plane.axis_linear) : (X_AXIS_BIT|Y_AXIS_BIT|Z_AXIS_BIT);
 8021a14:	4a1a      	ldr	r2, [pc, #104]	; (8021a80 <tool_change+0x190>)
 8021a16:	7891      	ldrb	r1, [r2, #2]
 8021a18:	2201      	movs	r2, #1
 8021a1a:	408a      	lsls	r2, r1
 8021a1c:	b2d2      	uxtb	r2, r2
 8021a1e:	e77f      	b.n	8021920 <tool_change+0x30>
    probe_fixture = grbl.on_probe_fixture != NULL &&
 8021a20:	2200      	movs	r2, #0
 8021a22:	e7a4      	b.n	802196e <tool_change+0x7e>
 8021a24:	2201      	movs	r2, #1
 8021a26:	e7a2      	b.n	802196e <tool_change+0x7e>
        settings_read_coord_data(CoordinateSystem_G59_3, &target.values);
 8021a28:	4d21      	ldr	r5, [pc, #132]	; (8021ab0 <tool_change+0x1c0>)
 8021a2a:	4629      	mov	r1, r5
 8021a2c:	2008      	movs	r0, #8
 8021a2e:	f7fa ffe1 	bl	801c9f4 <settings_read_coord_data>
        float tmp_pos = target.values[plane.axis_linear];
 8021a32:	78bb      	ldrb	r3, [r7, #2]
 8021a34:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8021a38:	681e      	ldr	r6, [r3, #0]
        target.values[plane.axis_linear] = tool_change_position;
 8021a3a:	4a1c      	ldr	r2, [pc, #112]	; (8021aac <tool_change+0x1bc>)
 8021a3c:	6812      	ldr	r2, [r2, #0]
 8021a3e:	601a      	str	r2, [r3, #0]
        if(!mc_line(target.values, &plan_data))
 8021a40:	4669      	mov	r1, sp
 8021a42:	4628      	mov	r0, r5
 8021a44:	f7f2 f8b8 	bl	8013bb8 <mc_line>
 8021a48:	b1a0      	cbz	r0, 8021a74 <tool_change+0x184>
        target.values[plane.axis_linear] = tmp_pos;
 8021a4a:	78bb      	ldrb	r3, [r7, #2]
 8021a4c:	4628      	mov	r0, r5
 8021a4e:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8021a52:	601e      	str	r6, [r3, #0]
        if(!mc_line(target.values, &plan_data))
 8021a54:	4669      	mov	r1, sp
 8021a56:	f7f2 f8af 	bl	8013bb8 <mc_line>
 8021a5a:	2800      	cmp	r0, #0
 8021a5c:	d1c3      	bne.n	80219e6 <tool_change+0xf6>
            return Status_Reset;
 8021a5e:	2012      	movs	r0, #18
 8021a60:	e002      	b.n	8021a68 <tool_change+0x178>
        return Status_GCodeToolError;
 8021a62:	202f      	movs	r0, #47	; 0x2f
}
 8021a64:	4770      	bx	lr
        return Status_OK;
 8021a66:	2000      	movs	r0, #0
}
 8021a68:	b00b      	add	sp, #44	; 0x2c
 8021a6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return Status_HomingRequired;
 8021a6c:	202e      	movs	r0, #46	; 0x2e
 8021a6e:	e7fb      	b.n	8021a68 <tool_change+0x178>
        return Status_Reset;
 8021a70:	2012      	movs	r0, #18
 8021a72:	e7f9      	b.n	8021a68 <tool_change+0x178>
            return Status_Reset;
 8021a74:	2012      	movs	r0, #18
 8021a76:	e7f7      	b.n	8021a68 <tool_change+0x178>
 8021a78:	200047d0 	.word	0x200047d0
 8021a7c:	200047b0 	.word	0x200047b0
 8021a80:	200047d4 	.word	0x200047d4
 8021a84:	20003b14 	.word	0x20003b14
 8021a88:	200036c4 	.word	0x200036c4
 8021a8c:	2000343c 	.word	0x2000343c
 8021a90:	08021401 	.word	0x08021401
 8021a94:	200047a8 	.word	0x200047a8
 8021a98:	2000350c 	.word	0x2000350c
 8021a9c:	200047cc 	.word	0x200047cc
 8021aa0:	200047e4 	.word	0x200047e4
 8021aa4:	2000374c 	.word	0x2000374c
 8021aa8:	200047d8 	.word	0x200047d8
 8021aac:	200047f8 	.word	0x200047f8
 8021ab0:	200047ec 	.word	0x200047ec
 8021ab4:	200033a4 	.word	0x200033a4

08021ab8 <tc_init>:

// Claim HAL tool change entry points and clear current tool offsets.
// TODO: change to survive a warm reset?
void tc_init (void)
{
 8021ab8:	b508      	push	{r3, lr}
    if(hal.driver_cap.atc) // Do not override driver tool change implementation!
 8021aba:	4b21      	ldr	r3, [pc, #132]	; (8021b40 <tc_init+0x88>)
 8021abc:	f893 31a6 	ldrb.w	r3, [r3, #422]	; 0x1a6
 8021ac0:	f013 0f01 	tst.w	r3, #1
 8021ac4:	d13a      	bne.n	8021b3c <tc_init+0x84>
        return;

    if(!hal.stream.suspend_read) // Tool change requires support for suspending input stream.
 8021ac6:	4b1e      	ldr	r3, [pc, #120]	; (8021b40 <tc_init+0x88>)
 8021ac8:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 8021acc:	2b00      	cmp	r3, #0
 8021ace:	d035      	beq.n	8021b3c <tc_init+0x84>
        return;

    if(sys.tlo_reference_set.mask != 0) {
 8021ad0:	4b1c      	ldr	r3, [pc, #112]	; (8021b44 <tc_init+0x8c>)
 8021ad2:	79db      	ldrb	r3, [r3, #7]
 8021ad4:	bb0b      	cbnz	r3, 8021b1a <tc_init+0x62>
        sys.tlo_reference_set.mask = 0;
        system_add_rt_report(Report_TLOReference);
    }

    gc_set_tool_offset(ToolLengthOffset_Cancel, 0, 0.0f);
 8021ad6:	2200      	movs	r2, #0
 8021ad8:	4611      	mov	r1, r2
 8021ada:	4610      	mov	r0, r2
 8021adc:	f7ed fab6 	bl	800f04c <gc_set_tool_offset>

    if(settings.tool_change.mode == ToolChange_Disabled || settings.tool_change.mode == ToolChange_Ignore) {
 8021ae0:	4b19      	ldr	r3, [pc, #100]	; (8021b48 <tc_init+0x90>)
 8021ae2:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8021ae6:	b303      	cbz	r3, 8021b2a <tc_init+0x72>
 8021ae8:	2b04      	cmp	r3, #4
 8021aea:	d01e      	beq.n	8021b2a <tc_init+0x72>
        hal.tool.select = NULL;
        hal.tool.change = NULL;
        grbl.on_toolchange_ack = NULL;
    } else {
        hal.tool.select = tool_select;
 8021aec:	4b14      	ldr	r3, [pc, #80]	; (8021b40 <tc_init+0x88>)
 8021aee:	4a17      	ldr	r2, [pc, #92]	; (8021b4c <tc_init+0x94>)
 8021af0:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
        hal.tool.change = tool_change;
 8021af4:	4a16      	ldr	r2, [pc, #88]	; (8021b50 <tc_init+0x98>)
 8021af6:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
        grbl.on_toolchange_ack = on_toolchange_ack;
 8021afa:	4b16      	ldr	r3, [pc, #88]	; (8021b54 <tc_init+0x9c>)
 8021afc:	4a16      	ldr	r2, [pc, #88]	; (8021b58 <tc_init+0xa0>)
 8021afe:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
        if(driver_reset == NULL) {
 8021b02:	4b16      	ldr	r3, [pc, #88]	; (8021b5c <tc_init+0xa4>)
 8021b04:	681b      	ldr	r3, [r3, #0]
 8021b06:	b9cb      	cbnz	r3, 8021b3c <tc_init+0x84>
            driver_reset = hal.driver_reset;
 8021b08:	4b0d      	ldr	r3, [pc, #52]	; (8021b40 <tc_init+0x88>)
 8021b0a:	f8d3 1140 	ldr.w	r1, [r3, #320]	; 0x140
 8021b0e:	4a13      	ldr	r2, [pc, #76]	; (8021b5c <tc_init+0xa4>)
 8021b10:	6011      	str	r1, [r2, #0]
            hal.driver_reset = reset;
 8021b12:	4a13      	ldr	r2, [pc, #76]	; (8021b60 <tc_init+0xa8>)
 8021b14:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
 8021b18:	e010      	b.n	8021b3c <tc_init+0x84>
        sys.tlo_reference_set.mask = 0;
 8021b1a:	4b0a      	ldr	r3, [pc, #40]	; (8021b44 <tc_init+0x8c>)
 8021b1c:	2200      	movs	r2, #0
 8021b1e:	71da      	strb	r2, [r3, #7]
        system_add_rt_report(Report_TLOReference);
 8021b20:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8021b24:	f7ff fb8c 	bl	8021240 <system_add_rt_report>
 8021b28:	e7d5      	b.n	8021ad6 <tc_init+0x1e>
        hal.tool.select = NULL;
 8021b2a:	4a05      	ldr	r2, [pc, #20]	; (8021b40 <tc_init+0x88>)
 8021b2c:	2300      	movs	r3, #0
 8021b2e:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
        hal.tool.change = NULL;
 8021b32:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
        grbl.on_toolchange_ack = NULL;
 8021b36:	4a07      	ldr	r2, [pc, #28]	; (8021b54 <tc_init+0x9c>)
 8021b38:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
        }
    }
}
 8021b3c:	bd08      	pop	{r3, pc}
 8021b3e:	bf00      	nop
 8021b40:	2000350c 	.word	0x2000350c
 8021b44:	200036c4 	.word	0x200036c4
 8021b48:	20003b14 	.word	0x20003b14
 8021b4c:	080214a5 	.word	0x080214a5
 8021b50:	080218f1 	.word	0x080218f1
 8021b54:	2000343c 	.word	0x2000343c
 8021b58:	080213d1 	.word	0x080213d1
 8021b5c:	200047c4 	.word	0x200047c4
 8021b60:	0802144d 	.word	0x0802144d

08021b64 <tc_clear_tlo_reference>:

void tc_clear_tlo_reference (axes_signals_t homing_cycle)
{
    if(settings.tool_change.mode != ToolChange_Disabled) {
 8021b64:	4b13      	ldr	r3, [pc, #76]	; (8021bb4 <tc_clear_tlo_reference+0x50>)
 8021b66:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8021b6a:	b903      	cbnz	r3, 8021b6e <tc_clear_tlo_reference+0xa>
 8021b6c:	4770      	bx	lr
{
 8021b6e:	b510      	push	{r4, lr}
 8021b70:	b082      	sub	sp, #8
 8021b72:	4604      	mov	r4, r0
        plane_t plane;

#if TOOL_LENGTH_OFFSET_AXIS >= 0
        plane.axis_linear = TOOL_LENGTH_OFFSET_AXIS;
#else
        gc_get_plane_data(&plane, gc_state.modal.plane_select);
 8021b74:	4b10      	ldr	r3, [pc, #64]	; (8021bb8 <tc_clear_tlo_reference+0x54>)
 8021b76:	7999      	ldrb	r1, [r3, #6]
 8021b78:	a801      	add	r0, sp, #4
 8021b7a:	f7ed fac1 	bl	800f100 <gc_get_plane_data>
#endif
        if(homing_cycle.mask & (settings.mode == Mode_Lathe ? (X_AXIS_BIT|Z_AXIS_BIT) : bit(plane.axis_linear))) {
 8021b7e:	b2e0      	uxtb	r0, r4
 8021b80:	4b0c      	ldr	r3, [pc, #48]	; (8021bb4 <tc_clear_tlo_reference+0x50>)
 8021b82:	7e1b      	ldrb	r3, [r3, #24]
 8021b84:	2b02      	cmp	r3, #2
 8021b86:	d00a      	beq.n	8021b9e <tc_clear_tlo_reference+0x3a>
 8021b88:	f89d 2006 	ldrb.w	r2, [sp, #6]
 8021b8c:	2301      	movs	r3, #1
 8021b8e:	4093      	lsls	r3, r2
 8021b90:	4218      	tst	r0, r3
 8021b92:	d002      	beq.n	8021b9a <tc_clear_tlo_reference+0x36>
            if(sys.tlo_reference_set.mask != 0) {
 8021b94:	4b09      	ldr	r3, [pc, #36]	; (8021bbc <tc_clear_tlo_reference+0x58>)
 8021b96:	79db      	ldrb	r3, [r3, #7]
 8021b98:	b91b      	cbnz	r3, 8021ba2 <tc_clear_tlo_reference+0x3e>
                sys.tlo_reference_set.mask = 0;  // Invalidate tool length offset reference
                system_add_rt_report(Report_TLOReference);
            }
        }
    }
}
 8021b9a:	b002      	add	sp, #8
 8021b9c:	bd10      	pop	{r4, pc}
        if(homing_cycle.mask & (settings.mode == Mode_Lathe ? (X_AXIS_BIT|Z_AXIS_BIT) : bit(plane.axis_linear))) {
 8021b9e:	2305      	movs	r3, #5
 8021ba0:	e7f6      	b.n	8021b90 <tc_clear_tlo_reference+0x2c>
                sys.tlo_reference_set.mask = 0;  // Invalidate tool length offset reference
 8021ba2:	4b06      	ldr	r3, [pc, #24]	; (8021bbc <tc_clear_tlo_reference+0x58>)
 8021ba4:	2200      	movs	r2, #0
 8021ba6:	71da      	strb	r2, [r3, #7]
                system_add_rt_report(Report_TLOReference);
 8021ba8:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8021bac:	f7ff fb48 	bl	8021240 <system_add_rt_report>
}
 8021bb0:	e7f3      	b.n	8021b9a <tc_clear_tlo_reference+0x36>
 8021bb2:	bf00      	nop
 8021bb4:	20003b14 	.word	0x20003b14
 8021bb8:	20003344 	.word	0x20003344
 8021bbc:	200036c4 	.word	0x200036c4

08021bc0 <tc_probe_workpiece>:
// Perform a probe cycle: set tool length offset and restart job if successful.
// Note: tool length offset is set by the on_probe_completed event handler.
// Called by the $TPW system command.
status_code_t tc_probe_workpiece (void)
{
    if(!(settings.tool_change.mode == ToolChange_Manual || settings.tool_change.mode == ToolChange_Manual_G59_3) || enqueue_realtime_command == NULL)
 8021bc0:	4b60      	ldr	r3, [pc, #384]	; (8021d44 <tc_probe_workpiece+0x184>)
 8021bc2:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8021bc6:	3b01      	subs	r3, #1
 8021bc8:	b2db      	uxtb	r3, r3
 8021bca:	2b01      	cmp	r3, #1
 8021bcc:	f200 80b4 	bhi.w	8021d38 <tc_probe_workpiece+0x178>
 8021bd0:	4b5d      	ldr	r3, [pc, #372]	; (8021d48 <tc_probe_workpiece+0x188>)
 8021bd2:	681b      	ldr	r3, [r3, #0]
 8021bd4:	2b00      	cmp	r3, #0
 8021bd6:	f000 80b1 	beq.w	8021d3c <tc_probe_workpiece+0x17c>
{
 8021bda:	b530      	push	{r4, r5, lr}
 8021bdc:	b08b      	sub	sp, #44	; 0x2c
    bool ok;
    gc_parser_flags_t flags = {0};
    plan_line_data_t plan_data;

#if COMPATIBILITY_LEVEL <= 1
    if(probe_fixture)
 8021bde:	4b5b      	ldr	r3, [pc, #364]	; (8021d4c <tc_probe_workpiece+0x18c>)
 8021be0:	781b      	ldrb	r3, [r3, #0]
 8021be2:	bb4b      	cbnz	r3, 8021c38 <tc_probe_workpiece+0x78>
        grbl.on_probe_fixture(next_tool, system_xy_at_fixture(CoordinateSystem_G59_3, TOOLSETTER_RADIUS), true);
#endif

    // Get current position.
    system_convert_array_steps_to_mpos(target.values, sys.position);
 8021be4:	4c5a      	ldr	r4, [pc, #360]	; (8021d50 <tc_probe_workpiece+0x190>)
 8021be6:	495b      	ldr	r1, [pc, #364]	; (8021d54 <tc_probe_workpiece+0x194>)
 8021be8:	4620      	mov	r0, r4
 8021bea:	f7ff f9f7 	bl	8020fdc <system_convert_array_steps_to_mpos>

    flags.probe_is_no_error = On;
 8021bee:	2510      	movs	r5, #16

    plan_data_init(&plan_data);
 8021bf0:	4668      	mov	r0, sp
 8021bf2:	f7f5 f8b5 	bl	8016d60 <plan_data_init>
    plan_data.feed_rate = settings.tool_change.seek_rate;
 8021bf6:	4a53      	ldr	r2, [pc, #332]	; (8021d44 <tc_probe_workpiece+0x184>)
 8021bf8:	6a13      	ldr	r3, [r2, #32]
 8021bfa:	9300      	str	r3, [sp, #0]

    target.values[plane.axis_linear] -= settings.tool_change.probing_distance;
 8021bfc:	4b56      	ldr	r3, [pc, #344]	; (8021d58 <tc_probe_workpiece+0x198>)
 8021bfe:	789b      	ldrb	r3, [r3, #2]
 8021c00:	ed92 7a0a 	vldr	s14, [r2, #40]	; 0x28
 8021c04:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8021c08:	edd3 7a00 	vldr	s15, [r3]
 8021c0c:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8021c10:	edc3 7a00 	vstr	s15, [r3]

    if((ok = mc_probe_cycle(target.values, &plan_data, flags) == GCProbe_Found))
 8021c14:	462a      	mov	r2, r5
 8021c16:	4669      	mov	r1, sp
 8021c18:	4620      	mov	r0, r4
 8021c1a:	f7f2 ff33 	bl	8014a84 <mc_probe_cycle>
 8021c1e:	2801      	cmp	r0, #1
 8021c20:	bf0c      	ite	eq
 8021c22:	2401      	moveq	r4, #1
 8021c24:	2400      	movne	r4, #0
 8021c26:	d016      	beq.n	8021c56 <tc_probe_workpiece+0x96>
                ok = mc_line(target.values, &plan_data);
            }
        }
    }

    if(ok && protocol_buffer_synchronize()) {
 8021c28:	2c00      	cmp	r4, #0
 8021c2a:	d16c      	bne.n	8021d06 <tc_probe_workpiece+0x146>
        grbl.report.feedback_message(settings.tool_change.mode == ToolChange_Manual_G59_3
                                      ? Message_CycleStart2Continue
                                      : Message_TPCycleStart2Continue);
    }

    return ok ? Status_OK : Status_GCodeToolError;
 8021c2c:	2c00      	cmp	r4, #0
 8021c2e:	f000 8087 	beq.w	8021d40 <tc_probe_workpiece+0x180>
 8021c32:	2000      	movs	r0, #0
}
 8021c34:	b00b      	add	sp, #44	; 0x2c
 8021c36:	bd30      	pop	{r4, r5, pc}
        grbl.on_probe_fixture(next_tool, system_xy_at_fixture(CoordinateSystem_G59_3, TOOLSETTER_RADIUS), true);
 8021c38:	4b48      	ldr	r3, [pc, #288]	; (8021d5c <tc_probe_workpiece+0x19c>)
 8021c3a:	f8d3 4080 	ldr.w	r4, [r3, #128]	; 0x80
 8021c3e:	4b48      	ldr	r3, [pc, #288]	; (8021d60 <tc_probe_workpiece+0x1a0>)
 8021c40:	681d      	ldr	r5, [r3, #0]
 8021c42:	eeb1 0a04 	vmov.f32	s0, #20	; 0x40a00000  5.0
 8021c46:	2008      	movs	r0, #8
 8021c48:	f7ff f9e6 	bl	8021018 <system_xy_at_fixture>
 8021c4c:	4601      	mov	r1, r0
 8021c4e:	2201      	movs	r2, #1
 8021c50:	4628      	mov	r0, r5
 8021c52:	47a0      	blx	r4
 8021c54:	e7c6      	b.n	8021be4 <tc_probe_workpiece+0x24>
        system_convert_array_steps_to_mpos(target.values, sys.probe_position);
 8021c56:	4c3e      	ldr	r4, [pc, #248]	; (8021d50 <tc_probe_workpiece+0x190>)
 8021c58:	4942      	ldr	r1, [pc, #264]	; (8021d64 <tc_probe_workpiece+0x1a4>)
 8021c5a:	4620      	mov	r0, r4
 8021c5c:	f7ff f9be 	bl	8020fdc <system_convert_array_steps_to_mpos>
        plan_data.feed_rate = settings.tool_change.pulloff_rate;
 8021c60:	4b38      	ldr	r3, [pc, #224]	; (8021d44 <tc_probe_workpiece+0x184>)
 8021c62:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8021c64:	9300      	str	r3, [sp, #0]
        target.values[plane.axis_linear] += TOOL_CHANGE_PROBE_RETRACT_DISTANCE;
 8021c66:	4b3c      	ldr	r3, [pc, #240]	; (8021d58 <tc_probe_workpiece+0x198>)
 8021c68:	789b      	ldrb	r3, [r3, #2]
 8021c6a:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8021c6e:	edd3 7a00 	vldr	s15, [r3]
 8021c72:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
 8021c76:	ee77 7a87 	vadd.f32	s15, s15, s14
 8021c7a:	edc3 7a00 	vstr	s15, [r3]
        if((ok = mc_line(target.values, &plan_data))) {
 8021c7e:	4669      	mov	r1, sp
 8021c80:	4620      	mov	r0, r4
 8021c82:	f7f1 ff99 	bl	8013bb8 <mc_line>
 8021c86:	4604      	mov	r4, r0
 8021c88:	2800      	cmp	r0, #0
 8021c8a:	d0cd      	beq.n	8021c28 <tc_probe_workpiece+0x68>
            plan_data.feed_rate = settings.tool_change.feed_rate;
 8021c8c:	4b2d      	ldr	r3, [pc, #180]	; (8021d44 <tc_probe_workpiece+0x184>)
 8021c8e:	69db      	ldr	r3, [r3, #28]
 8021c90:	9300      	str	r3, [sp, #0]
            target.values[plane.axis_linear] -= (TOOL_CHANGE_PROBE_RETRACT_DISTANCE + 2.0f);
 8021c92:	4b31      	ldr	r3, [pc, #196]	; (8021d58 <tc_probe_workpiece+0x198>)
 8021c94:	789b      	ldrb	r3, [r3, #2]
 8021c96:	482e      	ldr	r0, [pc, #184]	; (8021d50 <tc_probe_workpiece+0x190>)
 8021c98:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8021c9c:	edd3 7a00 	vldr	s15, [r3]
 8021ca0:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 8021ca4:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8021ca8:	edc3 7a00 	vstr	s15, [r3]
            if((ok = mc_probe_cycle(target.values, &plan_data, flags) == GCProbe_Found)) {
 8021cac:	462a      	mov	r2, r5
 8021cae:	4669      	mov	r1, sp
 8021cb0:	f7f2 fee8 	bl	8014a84 <mc_probe_cycle>
 8021cb4:	2801      	cmp	r0, #1
 8021cb6:	bf0c      	ite	eq
 8021cb8:	2401      	moveq	r4, #1
 8021cba:	2400      	movne	r4, #0
 8021cbc:	d1b4      	bne.n	8021c28 <tc_probe_workpiece+0x68>
                system_convert_array_steps_to_mpos(target.values, sys.probe_position);
 8021cbe:	4c24      	ldr	r4, [pc, #144]	; (8021d50 <tc_probe_workpiece+0x190>)
 8021cc0:	4928      	ldr	r1, [pc, #160]	; (8021d64 <tc_probe_workpiece+0x1a4>)
 8021cc2:	4620      	mov	r0, r4
 8021cc4:	f7ff f98a 	bl	8020fdc <system_convert_array_steps_to_mpos>
                plan_data.feed_rate = settings.tool_change.seek_rate;
 8021cc8:	4b1e      	ldr	r3, [pc, #120]	; (8021d44 <tc_probe_workpiece+0x184>)
 8021cca:	6a1b      	ldr	r3, [r3, #32]
 8021ccc:	9300      	str	r3, [sp, #0]
                target.values[plane.axis_linear] += TOOL_CHANGE_PROBE_RETRACT_DISTANCE * 2.0f;
 8021cce:	4b22      	ldr	r3, [pc, #136]	; (8021d58 <tc_probe_workpiece+0x198>)
 8021cd0:	789b      	ldrb	r3, [r3, #2]
 8021cd2:	eb04 0483 	add.w	r4, r4, r3, lsl #2
 8021cd6:	edd4 7a00 	vldr	s15, [r4]
 8021cda:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 8021cde:	ee77 7a87 	vadd.f32	s15, s15, s14
 8021ce2:	edc4 7a00 	vstr	s15, [r4]
                if(target.values[plane.axis_linear] > tool_change_position)
 8021ce6:	4a20      	ldr	r2, [pc, #128]	; (8021d68 <tc_probe_workpiece+0x1a8>)
 8021ce8:	ed92 7a00 	vldr	s14, [r2]
 8021cec:	eef4 7ac7 	vcmpe.f32	s15, s14
 8021cf0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021cf4:	dd01      	ble.n	8021cfa <tc_probe_workpiece+0x13a>
                    target.values[plane.axis_linear] = tool_change_position;
 8021cf6:	ed84 7a00 	vstr	s14, [r4]
                ok = mc_line(target.values, &plan_data);
 8021cfa:	4669      	mov	r1, sp
 8021cfc:	4814      	ldr	r0, [pc, #80]	; (8021d50 <tc_probe_workpiece+0x190>)
 8021cfe:	f7f1 ff5b 	bl	8013bb8 <mc_line>
 8021d02:	4604      	mov	r4, r0
 8021d04:	e790      	b.n	8021c28 <tc_probe_workpiece+0x68>
    if(ok && protocol_buffer_synchronize()) {
 8021d06:	f7f5 ff67 	bl	8017bd8 <protocol_buffer_synchronize>
 8021d0a:	2800      	cmp	r0, #0
 8021d0c:	d08e      	beq.n	8021c2c <tc_probe_workpiece+0x6c>
        sync_position();
 8021d0e:	f7f4 ffb7 	bl	8016c80 <plan_sync_position>
 8021d12:	4910      	ldr	r1, [pc, #64]	; (8021d54 <tc_probe_workpiece+0x194>)
 8021d14:	4815      	ldr	r0, [pc, #84]	; (8021d6c <tc_probe_workpiece+0x1ac>)
 8021d16:	f7ff f961 	bl	8020fdc <system_convert_array_steps_to_mpos>
        block_cycle_start = false;
 8021d1a:	4b15      	ldr	r3, [pc, #84]	; (8021d70 <tc_probe_workpiece+0x1b0>)
 8021d1c:	2200      	movs	r2, #0
 8021d1e:	701a      	strb	r2, [r3, #0]
        grbl.report.feedback_message(settings.tool_change.mode == ToolChange_Manual_G59_3
 8021d20:	4b0e      	ldr	r3, [pc, #56]	; (8021d5c <tc_probe_workpiece+0x19c>)
 8021d22:	68db      	ldr	r3, [r3, #12]
 8021d24:	4a07      	ldr	r2, [pc, #28]	; (8021d44 <tc_probe_workpiece+0x184>)
 8021d26:	f892 202c 	ldrb.w	r2, [r2, #44]	; 0x2c
 8021d2a:	2a02      	cmp	r2, #2
 8021d2c:	d002      	beq.n	8021d34 <tc_probe_workpiece+0x174>
 8021d2e:	2012      	movs	r0, #18
 8021d30:	4798      	blx	r3
 8021d32:	e77b      	b.n	8021c2c <tc_probe_workpiece+0x6c>
 8021d34:	2011      	movs	r0, #17
 8021d36:	e7fb      	b.n	8021d30 <tc_probe_workpiece+0x170>
        return Status_InvalidStatement;
 8021d38:	2003      	movs	r0, #3
 8021d3a:	4770      	bx	lr
 8021d3c:	2003      	movs	r0, #3
}
 8021d3e:	4770      	bx	lr
    return ok ? Status_OK : Status_GCodeToolError;
 8021d40:	202f      	movs	r0, #47	; 0x2f
 8021d42:	e777      	b.n	8021c34 <tc_probe_workpiece+0x74>
 8021d44:	20003b14 	.word	0x20003b14
 8021d48:	200047c8 	.word	0x200047c8
 8021d4c:	200047e4 	.word	0x200047e4
 8021d50:	200047ec 	.word	0x200047ec
 8021d54:	2000374c 	.word	0x2000374c
 8021d58:	200047d4 	.word	0x200047d4
 8021d5c:	2000343c 	.word	0x2000343c
 8021d60:	200047d0 	.word	0x200047d0
 8021d64:	200036fc 	.word	0x200036fc
 8021d68:	200047f8 	.word	0x200047f8
 8021d6c:	200033a4 	.word	0x200033a4
 8021d70:	200047a8 	.word	0x200047a8

08021d74 <keypad_settings_save>:
};

#endif

static void keypad_settings_save (void)
{
 8021d74:	b510      	push	{r4, lr}
    hal.nvs.memcpy_to_nvs(nvs_address, (uint8_t *)&jog, sizeof(jog_settings_t), true);
 8021d76:	4b05      	ldr	r3, [pc, #20]	; (8021d8c <keypad_settings_save+0x18>)
 8021d78:	f8d3 4160 	ldr.w	r4, [r3, #352]	; 0x160
 8021d7c:	2301      	movs	r3, #1
 8021d7e:	2218      	movs	r2, #24
 8021d80:	4903      	ldr	r1, [pc, #12]	; (8021d90 <keypad_settings_save+0x1c>)
 8021d82:	4804      	ldr	r0, [pc, #16]	; (8021d94 <keypad_settings_save+0x20>)
 8021d84:	6800      	ldr	r0, [r0, #0]
 8021d86:	47a0      	blx	r4
}
 8021d88:	bd10      	pop	{r4, pc}
 8021d8a:	bf00      	nop
 8021d8c:	2000350c 	.word	0x2000350c
 8021d90:	200047fc 	.word	0x200047fc
 8021d94:	20004834 	.word	0x20004834

08021d98 <keypad_settings_restore>:

static void keypad_settings_restore (void)
{
 8021d98:	b510      	push	{r4, lr}
    jog.step_speed    = 100.0f;
 8021d9a:	490b      	ldr	r1, [pc, #44]	; (8021dc8 <keypad_settings_restore+0x30>)
 8021d9c:	4b0b      	ldr	r3, [pc, #44]	; (8021dcc <keypad_settings_restore+0x34>)
 8021d9e:	608b      	str	r3, [r1, #8]
    jog.slow_speed    = 600.0f;
 8021da0:	4b0b      	ldr	r3, [pc, #44]	; (8021dd0 <keypad_settings_restore+0x38>)
 8021da2:	604b      	str	r3, [r1, #4]
    jog.fast_speed    = 3000.0f;
 8021da4:	4b0b      	ldr	r3, [pc, #44]	; (8021dd4 <keypad_settings_restore+0x3c>)
 8021da6:	600b      	str	r3, [r1, #0]
    jog.step_distance = 0.25f;
 8021da8:	f04f 527a 	mov.w	r2, #1048576000	; 0x3e800000
 8021dac:	614a      	str	r2, [r1, #20]
    jog.slow_distance = 500.0f;
 8021dae:	4a0a      	ldr	r2, [pc, #40]	; (8021dd8 <keypad_settings_restore+0x40>)
 8021db0:	610a      	str	r2, [r1, #16]
    jog.fast_distance = 3000.0f;
 8021db2:	60cb      	str	r3, [r1, #12]

    hal.nvs.memcpy_to_nvs(nvs_address, (uint8_t *)&jog, sizeof(jog_settings_t), true);
 8021db4:	4b09      	ldr	r3, [pc, #36]	; (8021ddc <keypad_settings_restore+0x44>)
 8021db6:	f8d3 4160 	ldr.w	r4, [r3, #352]	; 0x160
 8021dba:	2301      	movs	r3, #1
 8021dbc:	2218      	movs	r2, #24
 8021dbe:	4808      	ldr	r0, [pc, #32]	; (8021de0 <keypad_settings_restore+0x48>)
 8021dc0:	6800      	ldr	r0, [r0, #0]
 8021dc2:	47a0      	blx	r4
}
 8021dc4:	bd10      	pop	{r4, pc}
 8021dc6:	bf00      	nop
 8021dc8:	200047fc 	.word	0x200047fc
 8021dcc:	42c80000 	.word	0x42c80000
 8021dd0:	44160000 	.word	0x44160000
 8021dd4:	453b8000 	.word	0x453b8000
 8021dd8:	43fa0000 	.word	0x43fa0000
 8021ddc:	2000350c 	.word	0x2000350c
 8021de0:	20004834 	.word	0x20004834

08021de4 <keypad_settings_load>:

static void keypad_settings_load (void)
{
 8021de4:	b538      	push	{r3, r4, r5, lr}
    if(hal.nvs.memcpy_from_nvs((uint8_t *)&jog, nvs_address, sizeof(jog_settings_t), true) != NVS_TransferResult_OK)
 8021de6:	4b0e      	ldr	r3, [pc, #56]	; (8021e20 <keypad_settings_load+0x3c>)
 8021de8:	f8d3 4164 	ldr.w	r4, [r3, #356]	; 0x164
 8021dec:	2301      	movs	r3, #1
 8021dee:	2218      	movs	r2, #24
 8021df0:	490c      	ldr	r1, [pc, #48]	; (8021e24 <keypad_settings_load+0x40>)
 8021df2:	6809      	ldr	r1, [r1, #0]
 8021df4:	480c      	ldr	r0, [pc, #48]	; (8021e28 <keypad_settings_load+0x44>)
 8021df6:	47a0      	blx	r4
 8021df8:	2802      	cmp	r0, #2
 8021dfa:	d10e      	bne.n	8021e1a <keypad_settings_load+0x36>
        keypad_settings_restore();

    memcpy(&jogdata.settings, &jog, sizeof(jog_settings_t));
 8021dfc:	4c0b      	ldr	r4, [pc, #44]	; (8021e2c <keypad_settings_load+0x48>)
 8021dfe:	4d0a      	ldr	r5, [pc, #40]	; (8021e28 <keypad_settings_load+0x44>)
 8021e00:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8021e02:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8021e04:	e895 0003 	ldmia.w	r5, {r0, r1}
 8021e08:	e884 0003 	stmia.w	r4, {r0, r1}

    if(keypad.on_jogdata_changed)
 8021e0c:	4b08      	ldr	r3, [pc, #32]	; (8021e30 <keypad_settings_load+0x4c>)
 8021e0e:	689b      	ldr	r3, [r3, #8]
 8021e10:	b113      	cbz	r3, 8021e18 <keypad_settings_load+0x34>
        keypad.on_jogdata_changed(&jogdata);
 8021e12:	f1a4 0010 	sub.w	r0, r4, #16
 8021e16:	4798      	blx	r3
}
 8021e18:	bd38      	pop	{r3, r4, r5, pc}
        keypad_settings_restore();
 8021e1a:	f7ff ffbd 	bl	8021d98 <keypad_settings_restore>
 8021e1e:	e7ed      	b.n	8021dfc <keypad_settings_load+0x18>
 8021e20:	2000350c 	.word	0x2000350c
 8021e24:	20004834 	.word	0x20004834
 8021e28:	200047fc 	.word	0x200047fc
 8021e2c:	20000574 	.word	0x20000574
 8021e30:	20004828 	.word	0x20004828

08021e34 <keypad_get_keycode>:
};

// Returns 0 if no keycode enqueued
static char keypad_get_keycode (void)
{
    uint32_t data = 0, bptr = keybuf.tail;
 8021e34:	4a06      	ldr	r2, [pc, #24]	; (8021e50 <keypad_get_keycode+0x1c>)
 8021e36:	68d3      	ldr	r3, [r2, #12]

    if(bptr != keybuf.head) {
 8021e38:	6892      	ldr	r2, [r2, #8]
 8021e3a:	429a      	cmp	r2, r3
 8021e3c:	d006      	beq.n	8021e4c <keypad_get_keycode+0x18>
        data = keybuf.buf[bptr++];               // Get next character, increment tmp pointer
 8021e3e:	1c5a      	adds	r2, r3, #1
 8021e40:	4903      	ldr	r1, [pc, #12]	; (8021e50 <keypad_get_keycode+0x1c>)
 8021e42:	5cc8      	ldrb	r0, [r1, r3]
        keybuf.tail = bptr & (KEYBUF_SIZE - 1);  // and update pointer
 8021e44:	f002 0207 	and.w	r2, r2, #7
 8021e48:	60ca      	str	r2, [r1, #12]
 8021e4a:	4770      	bx	lr
    uint32_t data = 0, bptr = keybuf.tail;
 8021e4c:	2000      	movs	r0, #0
    }

    return data;
}
 8021e4e:	4770      	bx	lr
 8021e50:	20004818 	.word	0x20004818

08021e54 <onReportOptions>:
        }
    }
}

static void onReportOptions (bool newopt)
{
 8021e54:	b510      	push	{r4, lr}
 8021e56:	4604      	mov	r4, r0
    on_report_options(newopt);
 8021e58:	4b04      	ldr	r3, [pc, #16]	; (8021e6c <onReportOptions+0x18>)
 8021e5a:	681b      	ldr	r3, [r3, #0]
 8021e5c:	4798      	blx	r3

    if(!newopt)
 8021e5e:	b924      	cbnz	r4, 8021e6a <onReportOptions+0x16>
        hal.stream.write("[PLUGIN:KEYPAD v1.34]" ASCII_EOL);
 8021e60:	4b03      	ldr	r3, [pc, #12]	; (8021e70 <onReportOptions+0x1c>)
 8021e62:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8021e66:	4803      	ldr	r0, [pc, #12]	; (8021e74 <onReportOptions+0x20>)
 8021e68:	4798      	blx	r3
}
 8021e6a:	bd10      	pop	{r4, pc}
 8021e6c:	20004838 	.word	0x20004838
 8021e70:	2000350c 	.word	0x2000350c
 8021e74:	0802cdcc 	.word	0x0802cdcc

08021e78 <jog_command>:
{
 8021e78:	b508      	push	{r3, lr}
 8021e7a:	4603      	mov	r3, r0
 8021e7c:	468c      	mov	ip, r1
    strcat(strcpy(cmd, "$J=G91G21"), to);
 8021e7e:	4a05      	ldr	r2, [pc, #20]	; (8021e94 <jog_command+0x1c>)
 8021e80:	ca03      	ldmia	r2!, {r0, r1}
 8021e82:	6018      	str	r0, [r3, #0]
 8021e84:	6059      	str	r1, [r3, #4]
 8021e86:	8812      	ldrh	r2, [r2, #0]
 8021e88:	811a      	strh	r2, [r3, #8]
 8021e8a:	4661      	mov	r1, ip
 8021e8c:	4618      	mov	r0, r3
 8021e8e:	f000 fe7a 	bl	8022b86 <strcat>
}
 8021e92:	bd08      	pop	{r3, pc}
 8021e94:	0802cde4 	.word	0x0802cde4

08021e98 <strrepl>:
{
 8021e98:	b5f0      	push	{r4, r5, r6, r7, lr}
 8021e9a:	b089      	sub	sp, #36	; 0x24
 8021e9c:	4605      	mov	r5, r0
 8021e9e:	460f      	mov	r7, r1
 8021ea0:	4616      	mov	r6, r2
    char *s = strrchr(str, c);
 8021ea2:	f000 feb1 	bl	8022c08 <strrchr>
 8021ea6:	4604      	mov	r4, r0
    while(s) {
 8021ea8:	e010      	b.n	8021ecc <strrepl+0x34>
        strcpy(tmp, str3);
 8021eaa:	4631      	mov	r1, r6
 8021eac:	4668      	mov	r0, sp
 8021eae:	f000 ffb7 	bl	8022e20 <strcpy>
        strcat(tmp, s + 1);
 8021eb2:	1c61      	adds	r1, r4, #1
 8021eb4:	4668      	mov	r0, sp
 8021eb6:	f000 fe66 	bl	8022b86 <strcat>
        strcpy(s, tmp);
 8021eba:	4669      	mov	r1, sp
 8021ebc:	4620      	mov	r0, r4
 8021ebe:	f000 ffaf 	bl	8022e20 <strcpy>
        s = strrchr(str, c);
 8021ec2:	4639      	mov	r1, r7
 8021ec4:	4628      	mov	r0, r5
 8021ec6:	f000 fe9f 	bl	8022c08 <strrchr>
 8021eca:	4604      	mov	r4, r0
    while(s) {
 8021ecc:	2c00      	cmp	r4, #0
 8021ece:	d1ec      	bne.n	8021eaa <strrepl+0x12>
}
 8021ed0:	4628      	mov	r0, r5
 8021ed2:	b009      	add	sp, #36	; 0x24
 8021ed4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08021ed8 <keypad_process_keypress>:
{
 8021ed8:	b530      	push	{r4, r5, lr}
 8021eda:	ed2d 8b02 	vpush	{d8}
 8021ede:	b08b      	sub	sp, #44	; 0x2c
 8021ee0:	4605      	mov	r5, r0
    char command[35] = "", keycode = keypad_get_keycode();
 8021ee2:	2100      	movs	r1, #0
 8021ee4:	9101      	str	r1, [sp, #4]
 8021ee6:	221f      	movs	r2, #31
 8021ee8:	a802      	add	r0, sp, #8
 8021eea:	f000 fe44 	bl	8022b76 <memset>
 8021eee:	f7ff ffa1 	bl	8021e34 <keypad_get_keycode>
 8021ef2:	4604      	mov	r4, r0
    if(state == STATE_ESTOP && keycode != CMD_RESET)
 8021ef4:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 8021ef8:	f000 80a0 	beq.w	802203c <keypad_process_keypress+0x164>
    if(keycode) {
 8021efc:	2c00      	cmp	r4, #0
 8021efe:	f000 80a0 	beq.w	8022042 <keypad_process_keypress+0x16a>
        if(keypad.on_keypress_preview && keypad.on_keypress_preview(keycode, state))
 8021f02:	4b89      	ldr	r3, [pc, #548]	; (8022128 <keypad_process_keypress+0x250>)
 8021f04:	681b      	ldr	r3, [r3, #0]
 8021f06:	b12b      	cbz	r3, 8021f14 <keypad_process_keypress+0x3c>
 8021f08:	4629      	mov	r1, r5
 8021f0a:	4620      	mov	r0, r4
 8021f0c:	4798      	blx	r3
 8021f0e:	2800      	cmp	r0, #0
 8021f10:	f040 8097 	bne.w	8022042 <keypad_process_keypress+0x16a>
        switch(keycode) {
 8021f14:	f1a4 0318 	sub.w	r3, r4, #24
 8021f18:	2b8c      	cmp	r3, #140	; 0x8c
 8021f1a:	f200 8099 	bhi.w	8022050 <keypad_process_keypress+0x178>
 8021f1e:	e8df f013 	tbh	[pc, r3, lsl #1]
 8021f22:	0154      	.short	0x0154
 8021f24:	00970097 	.word	0x00970097
 8021f28:	00970097 	.word	0x00970097
 8021f2c:	00970097 	.word	0x00970097
 8021f30:	00970097 	.word	0x00970097
 8021f34:	009700cd 	.word	0x009700cd
 8021f38:	00970097 	.word	0x00970097
 8021f3c:	00970097 	.word	0x00970097
 8021f40:	00970097 	.word	0x00970097
 8021f44:	00970097 	.word	0x00970097
 8021f48:	00970097 	.word	0x00970097
 8021f4c:	00970097 	.word	0x00970097
 8021f50:	00e80097 	.word	0x00e80097
 8021f54:	00e800e8 	.word	0x00e800e8
 8021f58:	00970097 	.word	0x00970097
 8021f5c:	00970097 	.word	0x00970097
 8021f60:	00970097 	.word	0x00970097
 8021f64:	00970097 	.word	0x00970097
 8021f68:	00970097 	.word	0x00970097
 8021f6c:	00970097 	.word	0x00970097
 8021f70:	00970097 	.word	0x00970097
 8021f74:	01690097 	.word	0x01690097
 8021f78:	017300c9 	.word	0x017300c9
 8021f7c:	01640097 	.word	0x01640097
 8021f80:	01200097 	.word	0x01200097
 8021f84:	00970130 	.word	0x00970130
 8021f88:	015f013c 	.word	0x015f013c
 8021f8c:	00970094 	.word	0x00970094
 8021f90:	00970097 	.word	0x00970097
 8021f94:	015a0097 	.word	0x015a0097
 8021f98:	00970097 	.word	0x00970097
 8021f9c:	0097016e 	.word	0x0097016e
 8021fa0:	01280097 	.word	0x01280097
 8021fa4:	00970097 	.word	0x00970097
 8021fa8:	00970097 	.word	0x00970097
 8021fac:	00970097 	.word	0x00970097
 8021fb0:	00970097 	.word	0x00970097
 8021fb4:	00970097 	.word	0x00970097
 8021fb8:	00970097 	.word	0x00970097
 8021fbc:	00970097 	.word	0x00970097
 8021fc0:	00ec0097 	.word	0x00ec0097
 8021fc4:	01380134 	.word	0x01380134
 8021fc8:	00970140 	.word	0x00970140
 8021fcc:	0097010f 	.word	0x0097010f
 8021fd0:	00970097 	.word	0x00970097
 8021fd4:	0178017d 	.word	0x0178017d
 8021fd8:	01870182 	.word	0x01870182
 8021fdc:	01910196 	.word	0x01910196
 8021fe0:	019b018c 	.word	0x019b018c
 8021fe4:	01440097 	.word	0x01440097
 8021fe8:	00970097 	.word	0x00970097
 8021fec:	00d30097 	.word	0x00d30097
 8021ff0:	00970097 	.word	0x00970097
 8021ff4:	00970097 	.word	0x00970097
 8021ff8:	01540097 	.word	0x01540097
 8021ffc:	00970097 	.word	0x00970097
 8022000:	01540097 	.word	0x01540097
 8022004:	014c0154 	.word	0x014c0154
 8022008:	009700d9 	.word	0x009700d9
 802200c:	00970097 	.word	0x00970097
 8022010:	01480097 	.word	0x01480097
 8022014:	01480148 	.word	0x01480148
 8022018:	01480148 	.word	0x01480148
 802201c:	01480148 	.word	0x01480148
 8022020:	00970148 	.word	0x00970148
 8022024:	01500150 	.word	0x01500150
 8022028:	01500150 	.word	0x01500150
 802202c:	01500150 	.word	0x01500150
 8022030:	014c0097 	.word	0x014c0097
 8022034:	0097014c 	.word	0x0097014c
 8022038:	01540097 	.word	0x01540097
    if(state == STATE_ESTOP && keycode != CMD_RESET)
 802203c:	2818      	cmp	r0, #24
 802203e:	f43f af5d 	beq.w	8021efc <keypad_process_keypress+0x24>
}
 8022042:	b00b      	add	sp, #44	; 0x2c
 8022044:	ecbd 8b02 	vpop	{d8}
 8022048:	bd30      	pop	{r4, r5, pc}
                enqueue_coolant_override(CMD_OVERRIDE_COOLANT_MIST_TOGGLE);
 802204a:	20a1      	movs	r0, #161	; 0xa1
 802204c:	f7f4 f980 	bl	8016350 <enqueue_coolant_override>
        if(command[0] != '\0') {
 8022050:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8022054:	2b00      	cmp	r3, #0
 8022056:	d0f4      	beq.n	8022042 <keypad_process_keypress+0x16a>
            float modifier = jogdata.modifier[jogdata.modifier_index];
 8022058:	4a34      	ldr	r2, [pc, #208]	; (802212c <keypad_process_keypress+0x254>)
 802205a:	6a51      	ldr	r1, [r2, #36]	; 0x24
 802205c:	3106      	adds	r1, #6
 802205e:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8022062:	ed92 8a00 	vldr	s16, [r2]
            if((jogCommand = (command[0] == '$' && command[1] == 'J'))) {
 8022066:	2b24      	cmp	r3, #36	; 0x24
 8022068:	f000 80fb 	beq.w	8022262 <keypad_process_keypress+0x38a>
 802206c:	2300      	movs	r3, #0
 802206e:	461c      	mov	r4, r3
 8022070:	2b00      	cmp	r3, #0
 8022072:	f000 8114 	beq.w	802229e <keypad_process_keypress+0x3c6>
                switch(jogMode) {
 8022076:	4b2e      	ldr	r3, [pc, #184]	; (8022130 <keypad_process_keypress+0x258>)
 8022078:	781b      	ldrb	r3, [r3, #0]
 802207a:	2b01      	cmp	r3, #1
 802207c:	f000 80f9 	beq.w	8022272 <keypad_process_keypress+0x39a>
 8022080:	2b02      	cmp	r3, #2
 8022082:	f000 811e 	beq.w	80222c2 <keypad_process_keypress+0x3ea>
                        strrepl(command, '?', ftoa(jog.fast_distance, 0));
 8022086:	4d2b      	ldr	r5, [pc, #172]	; (8022134 <keypad_process_keypress+0x25c>)
 8022088:	2000      	movs	r0, #0
 802208a:	ed95 0a03 	vldr	s0, [r5, #12]
 802208e:	f7f3 fb95 	bl	80157bc <ftoa>
 8022092:	4602      	mov	r2, r0
 8022094:	213f      	movs	r1, #63	; 0x3f
 8022096:	a801      	add	r0, sp, #4
 8022098:	f7ff fefe 	bl	8021e98 <strrepl>
                        strcat(command, ftoa(jog.fast_speed * modifier, 0));
 802209c:	ed95 0a00 	vldr	s0, [r5]
 80220a0:	2000      	movs	r0, #0
 80220a2:	ee20 0a08 	vmul.f32	s0, s0, s16
 80220a6:	f7f3 fb89 	bl	80157bc <ftoa>
 80220aa:	4601      	mov	r1, r0
 80220ac:	a801      	add	r0, sp, #4
 80220ae:	f000 fd6a 	bl	8022b86 <strcat>
                        break;
 80220b2:	e0f4      	b.n	802229e <keypad_process_keypress+0x3c6>
                enqueue_coolant_override(CMD_OVERRIDE_COOLANT_FLOOD_TOGGLE);
 80220b4:	20a0      	movs	r0, #160	; 0xa0
 80220b6:	f7f4 f94b 	bl	8016350 <enqueue_coolant_override>
                break;
 80220ba:	e7c9      	b.n	8022050 <keypad_process_keypress+0x178>
                grbl.enqueue_realtime_command(CMD_FEED_HOLD);
 80220bc:	4b1e      	ldr	r3, [pc, #120]	; (8022138 <keypad_process_keypress+0x260>)
 80220be:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 80220c2:	2082      	movs	r0, #130	; 0x82
 80220c4:	4798      	blx	r3
                break;
 80220c6:	e7c3      	b.n	8022050 <keypad_process_keypress+0x178>
                grbl.enqueue_realtime_command(CMD_CYCLE_START);
 80220c8:	4b1b      	ldr	r3, [pc, #108]	; (8022138 <keypad_process_keypress+0x260>)
 80220ca:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 80220ce:	2081      	movs	r0, #129	; 0x81
 80220d0:	4798      	blx	r3
                break;
 80220d2:	e7bd      	b.n	8022050 <keypad_process_keypress+0x178>
                if(hal.driver_cap.mpg_mode)
 80220d4:	4b19      	ldr	r3, [pc, #100]	; (802213c <keypad_process_keypress+0x264>)
 80220d6:	f893 31a5 	ldrb.w	r3, [r3, #421]	; 0x1a5
 80220da:	f013 0f40 	tst.w	r3, #64	; 0x40
 80220de:	d0b7      	beq.n	8022050 <keypad_process_keypress+0x178>
                    stream_mpg_enable(hal.stream.type != StreamType_MPG);
 80220e0:	4b16      	ldr	r3, [pc, #88]	; (802213c <keypad_process_keypress+0x264>)
 80220e2:	f893 00a8 	ldrb.w	r0, [r3, #168]	; 0xa8
 80220e6:	3801      	subs	r0, #1
 80220e8:	bf18      	it	ne
 80220ea:	2001      	movne	r0, #1
 80220ec:	f7fe f8d0 	bl	8020290 <stream_mpg_enable>
 80220f0:	e7ae      	b.n	8022050 <keypad_process_keypress+0x178>
                jogMode = (jogmode_t)(keycode - '0');
 80220f2:	3c30      	subs	r4, #48	; 0x30
 80220f4:	4b0e      	ldr	r3, [pc, #56]	; (8022130 <keypad_process_keypress+0x258>)
 80220f6:	701c      	strb	r4, [r3, #0]
                break;
 80220f8:	e7aa      	b.n	8022050 <keypad_process_keypress+0x178>
                jogMode = jogMode == JogMode_Step ? JogMode_Fast : (jogMode == JogMode_Fast ? JogMode_Slow : JogMode_Step);
 80220fa:	4b0d      	ldr	r3, [pc, #52]	; (8022130 <keypad_process_keypress+0x258>)
 80220fc:	781b      	ldrb	r3, [r3, #0]
 80220fe:	2b02      	cmp	r3, #2
 8022100:	d002      	beq.n	8022108 <keypad_process_keypress+0x230>
 8022102:	b97b      	cbnz	r3, 8022124 <keypad_process_keypress+0x24c>
 8022104:	2001      	movs	r0, #1
 8022106:	e000      	b.n	802210a <keypad_process_keypress+0x232>
 8022108:	2000      	movs	r0, #0
 802210a:	4b09      	ldr	r3, [pc, #36]	; (8022130 <keypad_process_keypress+0x258>)
 802210c:	7018      	strb	r0, [r3, #0]
                if(keypad.on_jogmode_changed)
 802210e:	4b06      	ldr	r3, [pc, #24]	; (8022128 <keypad_process_keypress+0x250>)
 8022110:	685b      	ldr	r3, [r3, #4]
 8022112:	b103      	cbz	r3, 8022116 <keypad_process_keypress+0x23e>
                    keypad.on_jogmode_changed(jogMode);
 8022114:	4798      	blx	r3
                if(keypad.on_jogdata_changed)
 8022116:	4b04      	ldr	r3, [pc, #16]	; (8022128 <keypad_process_keypress+0x250>)
 8022118:	689b      	ldr	r3, [r3, #8]
 802211a:	2b00      	cmp	r3, #0
 802211c:	d098      	beq.n	8022050 <keypad_process_keypress+0x178>
                    keypad.on_jogdata_changed(&jogdata);
 802211e:	4803      	ldr	r0, [pc, #12]	; (802212c <keypad_process_keypress+0x254>)
 8022120:	4798      	blx	r3
 8022122:	e795      	b.n	8022050 <keypad_process_keypress+0x178>
                jogMode = jogMode == JogMode_Step ? JogMode_Fast : (jogMode == JogMode_Fast ? JogMode_Slow : JogMode_Step);
 8022124:	2002      	movs	r0, #2
 8022126:	e7f0      	b.n	802210a <keypad_process_keypress+0x232>
 8022128:	20004828 	.word	0x20004828
 802212c:	20000574 	.word	0x20000574
 8022130:	20004814 	.word	0x20004814
 8022134:	200047fc 	.word	0x200047fc
 8022138:	2000343c 	.word	0x2000343c
 802213c:	2000350c 	.word	0x2000350c
                if(++jogdata.modifier_index >= sizeof(jogdata.modifier) / sizeof(float))
 8022140:	4a72      	ldr	r2, [pc, #456]	; (802230c <keypad_process_keypress+0x434>)
 8022142:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8022144:	3301      	adds	r3, #1
 8022146:	6253      	str	r3, [r2, #36]	; 0x24
 8022148:	2b02      	cmp	r3, #2
 802214a:	d902      	bls.n	8022152 <keypad_process_keypress+0x27a>
                    jogdata.modifier_index = 0;
 802214c:	4613      	mov	r3, r2
 802214e:	2200      	movs	r2, #0
 8022150:	625a      	str	r2, [r3, #36]	; 0x24
                if(keypad.on_jogdata_changed)
 8022152:	4b6f      	ldr	r3, [pc, #444]	; (8022310 <keypad_process_keypress+0x438>)
 8022154:	689b      	ldr	r3, [r3, #8]
 8022156:	2b00      	cmp	r3, #0
 8022158:	f43f af7a 	beq.w	8022050 <keypad_process_keypress+0x178>
                    keypad.on_jogdata_changed(&jogdata);
 802215c:	486b      	ldr	r0, [pc, #428]	; (802230c <keypad_process_keypress+0x434>)
 802215e:	4798      	blx	r3
 8022160:	e776      	b.n	8022050 <keypad_process_keypress+0x178>
                strcpy(command, "$H");
 8022162:	4b6c      	ldr	r3, [pc, #432]	; (8022314 <keypad_process_keypress+0x43c>)
 8022164:	681b      	ldr	r3, [r3, #0]
 8022166:	f8ad 3004 	strh.w	r3, [sp, #4]
 802216a:	0c1b      	lsrs	r3, r3, #16
 802216c:	f88d 3006 	strb.w	r3, [sp, #6]
                break;
 8022170:	e76e      	b.n	8022050 <keypad_process_keypress+0x178>
                strcpy(command, "$X");
 8022172:	4b69      	ldr	r3, [pc, #420]	; (8022318 <keypad_process_keypress+0x440>)
 8022174:	681b      	ldr	r3, [r3, #0]
 8022176:	f8ad 3004 	strh.w	r3, [sp, #4]
 802217a:	0c1b      	lsrs	r3, r3, #16
 802217c:	f88d 3006 	strb.w	r3, [sp, #6]
                break;
 8022180:	e766      	b.n	8022050 <keypad_process_keypress+0x178>
                enqueue_feed_override(CMD_OVERRIDE_FEED_RESET);
 8022182:	2090      	movs	r0, #144	; 0x90
 8022184:	f7f4 f8a0 	bl	80162c8 <enqueue_feed_override>
                break;
 8022188:	e762      	b.n	8022050 <keypad_process_keypress+0x178>
                enqueue_feed_override(CMD_OVERRIDE_FEED_COARSE_PLUS);
 802218a:	2091      	movs	r0, #145	; 0x91
 802218c:	f7f4 f89c 	bl	80162c8 <enqueue_feed_override>
                break;
 8022190:	e75e      	b.n	8022050 <keypad_process_keypress+0x178>
                enqueue_feed_override(CMD_OVERRIDE_FEED_COARSE_MINUS);
 8022192:	2092      	movs	r0, #146	; 0x92
 8022194:	f7f4 f898 	bl	80162c8 <enqueue_feed_override>
                break;
 8022198:	e75a      	b.n	8022050 <keypad_process_keypress+0x178>
                enqueue_spindle_override(CMD_OVERRIDE_SPINDLE_RESET);
 802219a:	2099      	movs	r0, #153	; 0x99
 802219c:	f7f4 f8b6 	bl	801630c <enqueue_spindle_override>
                break;
 80221a0:	e756      	b.n	8022050 <keypad_process_keypress+0x178>
                enqueue_spindle_override(CMD_OVERRIDE_SPINDLE_COARSE_PLUS);
 80221a2:	209a      	movs	r0, #154	; 0x9a
 80221a4:	f7f4 f8b2 	bl	801630c <enqueue_spindle_override>
                break;
 80221a8:	e752      	b.n	8022050 <keypad_process_keypress+0x178>
                enqueue_spindle_override(CMD_OVERRIDE_SPINDLE_COARSE_MINUS);
 80221aa:	209b      	movs	r0, #155	; 0x9b
 80221ac:	f7f4 f8ae 	bl	801630c <enqueue_spindle_override>
                break;
 80221b0:	e74e      	b.n	8022050 <keypad_process_keypress+0x178>
                enqueue_feed_override(keycode);
 80221b2:	4620      	mov	r0, r4
 80221b4:	f7f4 f888 	bl	80162c8 <enqueue_feed_override>
                break;
 80221b8:	e74a      	b.n	8022050 <keypad_process_keypress+0x178>
                enqueue_coolant_override(keycode);
 80221ba:	4620      	mov	r0, r4
 80221bc:	f7f4 f8c8 	bl	8016350 <enqueue_coolant_override>
                break;
 80221c0:	e746      	b.n	8022050 <keypad_process_keypress+0x178>
                enqueue_spindle_override(keycode);
 80221c2:	4620      	mov	r0, r4
 80221c4:	f7f4 f8a2 	bl	801630c <enqueue_spindle_override>
                break;
 80221c8:	e742      	b.n	8022050 <keypad_process_keypress+0x178>
                grbl.enqueue_realtime_command(keycode);
 80221ca:	4b54      	ldr	r3, [pc, #336]	; (802231c <keypad_process_keypress+0x444>)
 80221cc:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 80221d0:	4620      	mov	r0, r4
 80221d2:	4798      	blx	r3
                break;
 80221d4:	e73c      	b.n	8022050 <keypad_process_keypress+0x178>
                jog_command(command, "X?F");
 80221d6:	4952      	ldr	r1, [pc, #328]	; (8022320 <keypad_process_keypress+0x448>)
 80221d8:	a801      	add	r0, sp, #4
 80221da:	f7ff fe4d 	bl	8021e78 <jog_command>
                break;
 80221de:	e737      	b.n	8022050 <keypad_process_keypress+0x178>
                jog_command(command, "X-?F");
 80221e0:	4950      	ldr	r1, [pc, #320]	; (8022324 <keypad_process_keypress+0x44c>)
 80221e2:	a801      	add	r0, sp, #4
 80221e4:	f7ff fe48 	bl	8021e78 <jog_command>
                break;
 80221e8:	e732      	b.n	8022050 <keypad_process_keypress+0x178>
                jog_command(command, "Y?F");
 80221ea:	494f      	ldr	r1, [pc, #316]	; (8022328 <keypad_process_keypress+0x450>)
 80221ec:	a801      	add	r0, sp, #4
 80221ee:	f7ff fe43 	bl	8021e78 <jog_command>
                break;
 80221f2:	e72d      	b.n	8022050 <keypad_process_keypress+0x178>
                jog_command(command, "Y-?F");
 80221f4:	494d      	ldr	r1, [pc, #308]	; (802232c <keypad_process_keypress+0x454>)
 80221f6:	a801      	add	r0, sp, #4
 80221f8:	f7ff fe3e 	bl	8021e78 <jog_command>
                break;
 80221fc:	e728      	b.n	8022050 <keypad_process_keypress+0x178>
                jog_command(command, "Z?F");
 80221fe:	494c      	ldr	r1, [pc, #304]	; (8022330 <keypad_process_keypress+0x458>)
 8022200:	a801      	add	r0, sp, #4
 8022202:	f7ff fe39 	bl	8021e78 <jog_command>
                break;
 8022206:	e723      	b.n	8022050 <keypad_process_keypress+0x178>
                jog_command(command, "Z-?F");
 8022208:	494a      	ldr	r1, [pc, #296]	; (8022334 <keypad_process_keypress+0x45c>)
 802220a:	a801      	add	r0, sp, #4
 802220c:	f7ff fe34 	bl	8021e78 <jog_command>
                break;
 8022210:	e71e      	b.n	8022050 <keypad_process_keypress+0x178>
                jog_command(command, "X?Y?F");
 8022212:	4949      	ldr	r1, [pc, #292]	; (8022338 <keypad_process_keypress+0x460>)
 8022214:	a801      	add	r0, sp, #4
 8022216:	f7ff fe2f 	bl	8021e78 <jog_command>
                break;
 802221a:	e719      	b.n	8022050 <keypad_process_keypress+0x178>
                jog_command(command, "X?Y-?F");
 802221c:	4947      	ldr	r1, [pc, #284]	; (802233c <keypad_process_keypress+0x464>)
 802221e:	a801      	add	r0, sp, #4
 8022220:	f7ff fe2a 	bl	8021e78 <jog_command>
                break;
 8022224:	e714      	b.n	8022050 <keypad_process_keypress+0x178>
                jog_command(command, "X-?Y?F");
 8022226:	4946      	ldr	r1, [pc, #280]	; (8022340 <keypad_process_keypress+0x468>)
 8022228:	a801      	add	r0, sp, #4
 802222a:	f7ff fe25 	bl	8021e78 <jog_command>
                break;
 802222e:	e70f      	b.n	8022050 <keypad_process_keypress+0x178>
                jog_command(command, "X-?Y-?F");
 8022230:	4944      	ldr	r1, [pc, #272]	; (8022344 <keypad_process_keypress+0x46c>)
 8022232:	a801      	add	r0, sp, #4
 8022234:	f7ff fe20 	bl	8021e78 <jog_command>
                break;
 8022238:	e70a      	b.n	8022050 <keypad_process_keypress+0x178>
                jog_command(command, "X?Z?F");
 802223a:	4943      	ldr	r1, [pc, #268]	; (8022348 <keypad_process_keypress+0x470>)
 802223c:	a801      	add	r0, sp, #4
 802223e:	f7ff fe1b 	bl	8021e78 <jog_command>
                break;
 8022242:	e705      	b.n	8022050 <keypad_process_keypress+0x178>
                jog_command(command, "X?Z-?F");
 8022244:	4941      	ldr	r1, [pc, #260]	; (802234c <keypad_process_keypress+0x474>)
 8022246:	a801      	add	r0, sp, #4
 8022248:	f7ff fe16 	bl	8021e78 <jog_command>
                break;
 802224c:	e700      	b.n	8022050 <keypad_process_keypress+0x178>
                jog_command(command, "X-?Z?F");
 802224e:	4940      	ldr	r1, [pc, #256]	; (8022350 <keypad_process_keypress+0x478>)
 8022250:	a801      	add	r0, sp, #4
 8022252:	f7ff fe11 	bl	8021e78 <jog_command>
                break;
 8022256:	e6fb      	b.n	8022050 <keypad_process_keypress+0x178>
                jog_command(command, "X-?Z-?F");
 8022258:	493e      	ldr	r1, [pc, #248]	; (8022354 <keypad_process_keypress+0x47c>)
 802225a:	a801      	add	r0, sp, #4
 802225c:	f7ff fe0c 	bl	8021e78 <jog_command>
                break;
 8022260:	e6f6      	b.n	8022050 <keypad_process_keypress+0x178>
            if((jogCommand = (command[0] == '$' && command[1] == 'J'))) {
 8022262:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8022266:	2b4a      	cmp	r3, #74	; 0x4a
 8022268:	d001      	beq.n	802226e <keypad_process_keypress+0x396>
 802226a:	2300      	movs	r3, #0
 802226c:	e6ff      	b.n	802206e <keypad_process_keypress+0x196>
 802226e:	2301      	movs	r3, #1
 8022270:	e6fd      	b.n	802206e <keypad_process_keypress+0x196>
                        strrepl(command, '?', ftoa(jog.slow_distance, 0));
 8022272:	4d39      	ldr	r5, [pc, #228]	; (8022358 <keypad_process_keypress+0x480>)
 8022274:	2000      	movs	r0, #0
 8022276:	ed95 0a04 	vldr	s0, [r5, #16]
 802227a:	f7f3 fa9f 	bl	80157bc <ftoa>
 802227e:	4602      	mov	r2, r0
 8022280:	213f      	movs	r1, #63	; 0x3f
 8022282:	a801      	add	r0, sp, #4
 8022284:	f7ff fe08 	bl	8021e98 <strrepl>
                        strcat(command, ftoa(jog.slow_speed * modifier, 0));
 8022288:	ed95 0a01 	vldr	s0, [r5, #4]
 802228c:	2000      	movs	r0, #0
 802228e:	ee20 0a08 	vmul.f32	s0, s0, s16
 8022292:	f7f3 fa93 	bl	80157bc <ftoa>
 8022296:	4601      	mov	r1, r0
 8022298:	a801      	add	r0, sp, #4
 802229a:	f000 fc74 	bl	8022b86 <strcat>
            if(!(jogCommand && keyreleased)) { // key still pressed? - do not execute jog command if released!
 802229e:	b124      	cbz	r4, 80222aa <keypad_process_keypress+0x3d2>
 80222a0:	4b2e      	ldr	r3, [pc, #184]	; (802235c <keypad_process_keypress+0x484>)
 80222a2:	781b      	ldrb	r3, [r3, #0]
 80222a4:	2b00      	cmp	r3, #0
 80222a6:	f47f aecc 	bne.w	8022042 <keypad_process_keypress+0x16a>
                addedGcode = grbl.enqueue_gcode((char *)command);
 80222aa:	4b1c      	ldr	r3, [pc, #112]	; (802231c <keypad_process_keypress+0x444>)
 80222ac:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 80222b0:	a801      	add	r0, sp, #4
 80222b2:	4798      	blx	r3
                jogging = jogging || (jogCommand && addedGcode);
 80222b4:	4b2a      	ldr	r3, [pc, #168]	; (8022360 <keypad_process_keypress+0x488>)
 80222b6:	781b      	ldrb	r3, [r3, #0]
 80222b8:	bb03      	cbnz	r3, 80222fc <keypad_process_keypress+0x424>
 80222ba:	b31c      	cbz	r4, 8022304 <keypad_process_keypress+0x42c>
 80222bc:	bb20      	cbnz	r0, 8022308 <keypad_process_keypress+0x430>
 80222be:	2200      	movs	r2, #0
 80222c0:	e01d      	b.n	80222fe <keypad_process_keypress+0x426>
                        strrepl(command, '?', ftoa(jog.step_distance * modifier, gc_state.modal.units_imperial ? 4 : 3));
 80222c2:	4b25      	ldr	r3, [pc, #148]	; (8022358 <keypad_process_keypress+0x480>)
 80222c4:	ed93 0a05 	vldr	s0, [r3, #20]
 80222c8:	ee20 0a08 	vmul.f32	s0, s0, s16
 80222cc:	4b25      	ldr	r3, [pc, #148]	; (8022364 <keypad_process_keypress+0x48c>)
 80222ce:	78db      	ldrb	r3, [r3, #3]
 80222d0:	b193      	cbz	r3, 80222f8 <keypad_process_keypress+0x420>
 80222d2:	2004      	movs	r0, #4
 80222d4:	f7f3 fa72 	bl	80157bc <ftoa>
 80222d8:	4602      	mov	r2, r0
 80222da:	213f      	movs	r1, #63	; 0x3f
 80222dc:	a801      	add	r0, sp, #4
 80222de:	f7ff fddb 	bl	8021e98 <strrepl>
                        strcat(command, ftoa(jog.step_speed, 0));
 80222e2:	2000      	movs	r0, #0
 80222e4:	4b1c      	ldr	r3, [pc, #112]	; (8022358 <keypad_process_keypress+0x480>)
 80222e6:	ed93 0a02 	vldr	s0, [r3, #8]
 80222ea:	f7f3 fa67 	bl	80157bc <ftoa>
 80222ee:	4601      	mov	r1, r0
 80222f0:	a801      	add	r0, sp, #4
 80222f2:	f000 fc48 	bl	8022b86 <strcat>
                        break;
 80222f6:	e7d2      	b.n	802229e <keypad_process_keypress+0x3c6>
                        strrepl(command, '?', ftoa(jog.step_distance * modifier, gc_state.modal.units_imperial ? 4 : 3));
 80222f8:	2003      	movs	r0, #3
 80222fa:	e7eb      	b.n	80222d4 <keypad_process_keypress+0x3fc>
                jogging = jogging || (jogCommand && addedGcode);
 80222fc:	2201      	movs	r2, #1
 80222fe:	4b18      	ldr	r3, [pc, #96]	; (8022360 <keypad_process_keypress+0x488>)
 8022300:	701a      	strb	r2, [r3, #0]
 8022302:	e69e      	b.n	8022042 <keypad_process_keypress+0x16a>
 8022304:	2200      	movs	r2, #0
 8022306:	e7fa      	b.n	80222fe <keypad_process_keypress+0x426>
 8022308:	2201      	movs	r2, #1
 802230a:	e7f8      	b.n	80222fe <keypad_process_keypress+0x426>
 802230c:	20000574 	.word	0x20000574
 8022310:	20004828 	.word	0x20004828
 8022314:	0802cdf0 	.word	0x0802cdf0
 8022318:	0802cdf4 	.word	0x0802cdf4
 802231c:	2000343c 	.word	0x2000343c
 8022320:	0802cdf8 	.word	0x0802cdf8
 8022324:	0802cdfc 	.word	0x0802cdfc
 8022328:	0802ce04 	.word	0x0802ce04
 802232c:	0802ce08 	.word	0x0802ce08
 8022330:	0802ce10 	.word	0x0802ce10
 8022334:	0802ce14 	.word	0x0802ce14
 8022338:	0802ce1c 	.word	0x0802ce1c
 802233c:	0802ce24 	.word	0x0802ce24
 8022340:	0802ce2c 	.word	0x0802ce2c
 8022344:	0802ce34 	.word	0x0802ce34
 8022348:	0802ce3c 	.word	0x0802ce3c
 802234c:	0802ce44 	.word	0x0802ce44
 8022350:	0802ce4c 	.word	0x0802ce4c
 8022354:	0802ce54 	.word	0x0802ce54
 8022358:	200047fc 	.word	0x200047fc
 802235c:	200005a0 	.word	0x200005a0
 8022360:	20004815 	.word	0x20004815
 8022364:	20003344 	.word	0x20003344

08022368 <keypad_enqueue_keycode>:

ISR_CODE bool ISR_FUNC(keypad_enqueue_keycode)(char c)
{
 8022368:	b508      	push	{r3, lr}
    uint32_t bptr = (keybuf.head + 1) & (KEYBUF_SIZE - 1);    // Get next head pointer
 802236a:	4b17      	ldr	r3, [pc, #92]	; (80223c8 <keypad_enqueue_keycode+0x60>)
 802236c:	689b      	ldr	r3, [r3, #8]
#if MPG_MODE != 2
    if(c == CMD_MPG_MODE_TOGGLE)
        return true;
#endif

    if(c == CMD_JOG_CANCEL || c == ASCII_CAN) {
 802236e:	2885      	cmp	r0, #133	; 0x85
 8022370:	d016      	beq.n	80223a0 <keypad_enqueue_keycode+0x38>
 8022372:	3301      	adds	r3, #1
 8022374:	f003 0307 	and.w	r3, r3, #7
 8022378:	2818      	cmp	r0, #24
 802237a:	d011      	beq.n	80223a0 <keypad_enqueue_keycode+0x38>
        if(jogging) {
            jogging = false;
            grbl.enqueue_realtime_command(CMD_JOG_CANCEL);
        }
        keybuf.tail = keybuf.head;      // Flush keycode buffer.
    } else if(bptr != keybuf.tail) {    // If not buffer full
 802237c:	4a12      	ldr	r2, [pc, #72]	; (80223c8 <keypad_enqueue_keycode+0x60>)
 802237e:	68d2      	ldr	r2, [r2, #12]
 8022380:	429a      	cmp	r2, r3
 8022382:	d01e      	beq.n	80223c2 <keypad_enqueue_keycode+0x5a>
        keybuf.buf[keybuf.head] = c;    // add data to buffer
 8022384:	4a10      	ldr	r2, [pc, #64]	; (80223c8 <keypad_enqueue_keycode+0x60>)
 8022386:	6891      	ldr	r1, [r2, #8]
 8022388:	5450      	strb	r0, [r2, r1]
        keybuf.head = bptr;             // and update pointer.
 802238a:	6093      	str	r3, [r2, #8]
        keyreleased = false;
 802238c:	4b0f      	ldr	r3, [pc, #60]	; (80223cc <keypad_enqueue_keycode+0x64>)
 802238e:	2200      	movs	r2, #0
 8022390:	701a      	strb	r2, [r3, #0]
        // Tell foreground process to process keycode
        if(nvs_address != 0)
 8022392:	4b0f      	ldr	r3, [pc, #60]	; (80223d0 <keypad_enqueue_keycode+0x68>)
 8022394:	681b      	ldr	r3, [r3, #0]
 8022396:	b1a3      	cbz	r3, 80223c2 <keypad_enqueue_keycode+0x5a>
            protocol_enqueue_rt_command(keypad_process_keypress);
 8022398:	480e      	ldr	r0, [pc, #56]	; (80223d4 <keypad_enqueue_keycode+0x6c>)
 802239a:	f7f5 fe67 	bl	801806c <protocol_enqueue_rt_command>
 802239e:	e010      	b.n	80223c2 <keypad_enqueue_keycode+0x5a>
        keyreleased = true;
 80223a0:	4b0a      	ldr	r3, [pc, #40]	; (80223cc <keypad_enqueue_keycode+0x64>)
 80223a2:	2201      	movs	r2, #1
 80223a4:	701a      	strb	r2, [r3, #0]
        if(jogging) {
 80223a6:	4b0c      	ldr	r3, [pc, #48]	; (80223d8 <keypad_enqueue_keycode+0x70>)
 80223a8:	781b      	ldrb	r3, [r3, #0]
 80223aa:	b13b      	cbz	r3, 80223bc <keypad_enqueue_keycode+0x54>
            jogging = false;
 80223ac:	4b0a      	ldr	r3, [pc, #40]	; (80223d8 <keypad_enqueue_keycode+0x70>)
 80223ae:	2200      	movs	r2, #0
 80223b0:	701a      	strb	r2, [r3, #0]
            grbl.enqueue_realtime_command(CMD_JOG_CANCEL);
 80223b2:	4b0a      	ldr	r3, [pc, #40]	; (80223dc <keypad_enqueue_keycode+0x74>)
 80223b4:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 80223b8:	2085      	movs	r0, #133	; 0x85
 80223ba:	4798      	blx	r3
        keybuf.tail = keybuf.head;      // Flush keycode buffer.
 80223bc:	4b02      	ldr	r3, [pc, #8]	; (80223c8 <keypad_enqueue_keycode+0x60>)
 80223be:	689a      	ldr	r2, [r3, #8]
 80223c0:	60da      	str	r2, [r3, #12]
    }

    return true;
}
 80223c2:	2001      	movs	r0, #1
 80223c4:	bd08      	pop	{r3, pc}
 80223c6:	bf00      	nop
 80223c8:	20004818 	.word	0x20004818
 80223cc:	200005a0 	.word	0x200005a0
 80223d0:	20004834 	.word	0x20004834
 80223d4:	08021ed9 	.word	0x08021ed9
 80223d8:	20004815 	.word	0x20004815
 80223dc:	2000343c 	.word	0x2000343c

080223e0 <keypad_init>:
}

#else

bool keypad_init (void)
{
 80223e0:	b508      	push	{r3, lr}
    if((nvs_address = nvs_alloc(sizeof(jog_settings_t)))) {
 80223e2:	2018      	movs	r0, #24
 80223e4:	f7f3 fe30 	bl	8016048 <nvs_alloc>
 80223e8:	4b0c      	ldr	r3, [pc, #48]	; (802241c <keypad_init+0x3c>)
 80223ea:	6018      	str	r0, [r3, #0]
 80223ec:	b928      	cbnz	r0, 80223fa <keypad_init+0x1a>

        if(keypad.on_jogmode_changed)
            keypad.on_jogmode_changed(jogMode);
    }

    return nvs_address != 0;
 80223ee:	4b0b      	ldr	r3, [pc, #44]	; (802241c <keypad_init+0x3c>)
 80223f0:	6818      	ldr	r0, [r3, #0]
}
 80223f2:	3800      	subs	r0, #0
 80223f4:	bf18      	it	ne
 80223f6:	2001      	movne	r0, #1
 80223f8:	bd08      	pop	{r3, pc}
        on_report_options = grbl.on_report_options;
 80223fa:	4b09      	ldr	r3, [pc, #36]	; (8022420 <keypad_init+0x40>)
 80223fc:	6c19      	ldr	r1, [r3, #64]	; 0x40
 80223fe:	4a09      	ldr	r2, [pc, #36]	; (8022424 <keypad_init+0x44>)
 8022400:	6011      	str	r1, [r2, #0]
        grbl.on_report_options = onReportOptions;
 8022402:	4a09      	ldr	r2, [pc, #36]	; (8022428 <keypad_init+0x48>)
 8022404:	641a      	str	r2, [r3, #64]	; 0x40
        settings_register(&setting_details);
 8022406:	4809      	ldr	r0, [pc, #36]	; (802242c <keypad_init+0x4c>)
 8022408:	f7f9 ff5a 	bl	801c2c0 <settings_register>
        if(keypad.on_jogmode_changed)
 802240c:	4b08      	ldr	r3, [pc, #32]	; (8022430 <keypad_init+0x50>)
 802240e:	685b      	ldr	r3, [r3, #4]
 8022410:	2b00      	cmp	r3, #0
 8022412:	d0ec      	beq.n	80223ee <keypad_init+0xe>
            keypad.on_jogmode_changed(jogMode);
 8022414:	4a07      	ldr	r2, [pc, #28]	; (8022434 <keypad_init+0x54>)
 8022416:	7810      	ldrb	r0, [r2, #0]
 8022418:	4798      	blx	r3
 802241a:	e7e8      	b.n	80223ee <keypad_init+0xe>
 802241c:	20004834 	.word	0x20004834
 8022420:	2000343c 	.word	0x2000343c
 8022424:	20004838 	.word	0x20004838
 8022428:	08021e55 	.word	0x08021e55
 802242c:	200005a4 	.word	0x200005a4
 8022430:	20004828 	.word	0x20004828
 8022434:	20004814 	.word	0x20004814

08022438 <__assert_func>:
 8022438:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 802243a:	4614      	mov	r4, r2
 802243c:	461a      	mov	r2, r3
 802243e:	4b09      	ldr	r3, [pc, #36]	; (8022464 <__assert_func+0x2c>)
 8022440:	681b      	ldr	r3, [r3, #0]
 8022442:	4605      	mov	r5, r0
 8022444:	68d8      	ldr	r0, [r3, #12]
 8022446:	b14c      	cbz	r4, 802245c <__assert_func+0x24>
 8022448:	4b07      	ldr	r3, [pc, #28]	; (8022468 <__assert_func+0x30>)
 802244a:	9100      	str	r1, [sp, #0]
 802244c:	e9cd 3401 	strd	r3, r4, [sp, #4]
 8022450:	4906      	ldr	r1, [pc, #24]	; (802246c <__assert_func+0x34>)
 8022452:	462b      	mov	r3, r5
 8022454:	f000 fb0c 	bl	8022a70 <fiprintf>
 8022458:	f000 fcf8 	bl	8022e4c <abort>
 802245c:	4b04      	ldr	r3, [pc, #16]	; (8022470 <__assert_func+0x38>)
 802245e:	461c      	mov	r4, r3
 8022460:	e7f3      	b.n	802244a <__assert_func+0x12>
 8022462:	bf00      	nop
 8022464:	2000062c 	.word	0x2000062c
 8022468:	0802d018 	.word	0x0802d018
 802246c:	0802d025 	.word	0x0802d025
 8022470:	0802d053 	.word	0x0802d053

08022474 <calloc>:
 8022474:	4b02      	ldr	r3, [pc, #8]	; (8022480 <calloc+0xc>)
 8022476:	460a      	mov	r2, r1
 8022478:	4601      	mov	r1, r0
 802247a:	6818      	ldr	r0, [r3, #0]
 802247c:	f000 b802 	b.w	8022484 <_calloc_r>
 8022480:	2000062c 	.word	0x2000062c

08022484 <_calloc_r>:
 8022484:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8022486:	fba1 2402 	umull	r2, r4, r1, r2
 802248a:	b94c      	cbnz	r4, 80224a0 <_calloc_r+0x1c>
 802248c:	4611      	mov	r1, r2
 802248e:	9201      	str	r2, [sp, #4]
 8022490:	f000 f83e 	bl	8022510 <_malloc_r>
 8022494:	9a01      	ldr	r2, [sp, #4]
 8022496:	4605      	mov	r5, r0
 8022498:	b930      	cbnz	r0, 80224a8 <_calloc_r+0x24>
 802249a:	4628      	mov	r0, r5
 802249c:	b003      	add	sp, #12
 802249e:	bd30      	pop	{r4, r5, pc}
 80224a0:	220c      	movs	r2, #12
 80224a2:	6002      	str	r2, [r0, #0]
 80224a4:	2500      	movs	r5, #0
 80224a6:	e7f8      	b.n	802249a <_calloc_r+0x16>
 80224a8:	4621      	mov	r1, r4
 80224aa:	f000 fb64 	bl	8022b76 <memset>
 80224ae:	e7f4      	b.n	802249a <_calloc_r+0x16>

080224b0 <malloc>:
 80224b0:	4b02      	ldr	r3, [pc, #8]	; (80224bc <malloc+0xc>)
 80224b2:	4601      	mov	r1, r0
 80224b4:	6818      	ldr	r0, [r3, #0]
 80224b6:	f000 b82b 	b.w	8022510 <_malloc_r>
 80224ba:	bf00      	nop
 80224bc:	2000062c 	.word	0x2000062c

080224c0 <free>:
 80224c0:	4b02      	ldr	r3, [pc, #8]	; (80224cc <free+0xc>)
 80224c2:	4601      	mov	r1, r0
 80224c4:	6818      	ldr	r0, [r3, #0]
 80224c6:	f000 bcc9 	b.w	8022e5c <_free_r>
 80224ca:	bf00      	nop
 80224cc:	2000062c 	.word	0x2000062c

080224d0 <sbrk_aligned>:
 80224d0:	b570      	push	{r4, r5, r6, lr}
 80224d2:	4e0e      	ldr	r6, [pc, #56]	; (802250c <sbrk_aligned+0x3c>)
 80224d4:	460c      	mov	r4, r1
 80224d6:	6831      	ldr	r1, [r6, #0]
 80224d8:	4605      	mov	r5, r0
 80224da:	b911      	cbnz	r1, 80224e2 <sbrk_aligned+0x12>
 80224dc:	f000 fc52 	bl	8022d84 <_sbrk_r>
 80224e0:	6030      	str	r0, [r6, #0]
 80224e2:	4621      	mov	r1, r4
 80224e4:	4628      	mov	r0, r5
 80224e6:	f000 fc4d 	bl	8022d84 <_sbrk_r>
 80224ea:	1c43      	adds	r3, r0, #1
 80224ec:	d00a      	beq.n	8022504 <sbrk_aligned+0x34>
 80224ee:	1cc4      	adds	r4, r0, #3
 80224f0:	f024 0403 	bic.w	r4, r4, #3
 80224f4:	42a0      	cmp	r0, r4
 80224f6:	d007      	beq.n	8022508 <sbrk_aligned+0x38>
 80224f8:	1a21      	subs	r1, r4, r0
 80224fa:	4628      	mov	r0, r5
 80224fc:	f000 fc42 	bl	8022d84 <_sbrk_r>
 8022500:	3001      	adds	r0, #1
 8022502:	d101      	bne.n	8022508 <sbrk_aligned+0x38>
 8022504:	f04f 34ff 	mov.w	r4, #4294967295
 8022508:	4620      	mov	r0, r4
 802250a:	bd70      	pop	{r4, r5, r6, pc}
 802250c:	20004840 	.word	0x20004840

08022510 <_malloc_r>:
 8022510:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8022514:	1ccd      	adds	r5, r1, #3
 8022516:	f025 0503 	bic.w	r5, r5, #3
 802251a:	3508      	adds	r5, #8
 802251c:	2d0c      	cmp	r5, #12
 802251e:	bf38      	it	cc
 8022520:	250c      	movcc	r5, #12
 8022522:	2d00      	cmp	r5, #0
 8022524:	4607      	mov	r7, r0
 8022526:	db01      	blt.n	802252c <_malloc_r+0x1c>
 8022528:	42a9      	cmp	r1, r5
 802252a:	d905      	bls.n	8022538 <_malloc_r+0x28>
 802252c:	230c      	movs	r3, #12
 802252e:	603b      	str	r3, [r7, #0]
 8022530:	2600      	movs	r6, #0
 8022532:	4630      	mov	r0, r6
 8022534:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8022538:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 802260c <_malloc_r+0xfc>
 802253c:	f000 f868 	bl	8022610 <__malloc_lock>
 8022540:	f8d8 3000 	ldr.w	r3, [r8]
 8022544:	461c      	mov	r4, r3
 8022546:	bb5c      	cbnz	r4, 80225a0 <_malloc_r+0x90>
 8022548:	4629      	mov	r1, r5
 802254a:	4638      	mov	r0, r7
 802254c:	f7ff ffc0 	bl	80224d0 <sbrk_aligned>
 8022550:	1c43      	adds	r3, r0, #1
 8022552:	4604      	mov	r4, r0
 8022554:	d155      	bne.n	8022602 <_malloc_r+0xf2>
 8022556:	f8d8 4000 	ldr.w	r4, [r8]
 802255a:	4626      	mov	r6, r4
 802255c:	2e00      	cmp	r6, #0
 802255e:	d145      	bne.n	80225ec <_malloc_r+0xdc>
 8022560:	2c00      	cmp	r4, #0
 8022562:	d048      	beq.n	80225f6 <_malloc_r+0xe6>
 8022564:	6823      	ldr	r3, [r4, #0]
 8022566:	4631      	mov	r1, r6
 8022568:	4638      	mov	r0, r7
 802256a:	eb04 0903 	add.w	r9, r4, r3
 802256e:	f000 fc09 	bl	8022d84 <_sbrk_r>
 8022572:	4581      	cmp	r9, r0
 8022574:	d13f      	bne.n	80225f6 <_malloc_r+0xe6>
 8022576:	6821      	ldr	r1, [r4, #0]
 8022578:	1a6d      	subs	r5, r5, r1
 802257a:	4629      	mov	r1, r5
 802257c:	4638      	mov	r0, r7
 802257e:	f7ff ffa7 	bl	80224d0 <sbrk_aligned>
 8022582:	3001      	adds	r0, #1
 8022584:	d037      	beq.n	80225f6 <_malloc_r+0xe6>
 8022586:	6823      	ldr	r3, [r4, #0]
 8022588:	442b      	add	r3, r5
 802258a:	6023      	str	r3, [r4, #0]
 802258c:	f8d8 3000 	ldr.w	r3, [r8]
 8022590:	2b00      	cmp	r3, #0
 8022592:	d038      	beq.n	8022606 <_malloc_r+0xf6>
 8022594:	685a      	ldr	r2, [r3, #4]
 8022596:	42a2      	cmp	r2, r4
 8022598:	d12b      	bne.n	80225f2 <_malloc_r+0xe2>
 802259a:	2200      	movs	r2, #0
 802259c:	605a      	str	r2, [r3, #4]
 802259e:	e00f      	b.n	80225c0 <_malloc_r+0xb0>
 80225a0:	6822      	ldr	r2, [r4, #0]
 80225a2:	1b52      	subs	r2, r2, r5
 80225a4:	d41f      	bmi.n	80225e6 <_malloc_r+0xd6>
 80225a6:	2a0b      	cmp	r2, #11
 80225a8:	d917      	bls.n	80225da <_malloc_r+0xca>
 80225aa:	1961      	adds	r1, r4, r5
 80225ac:	42a3      	cmp	r3, r4
 80225ae:	6025      	str	r5, [r4, #0]
 80225b0:	bf18      	it	ne
 80225b2:	6059      	strne	r1, [r3, #4]
 80225b4:	6863      	ldr	r3, [r4, #4]
 80225b6:	bf08      	it	eq
 80225b8:	f8c8 1000 	streq.w	r1, [r8]
 80225bc:	5162      	str	r2, [r4, r5]
 80225be:	604b      	str	r3, [r1, #4]
 80225c0:	4638      	mov	r0, r7
 80225c2:	f104 060b 	add.w	r6, r4, #11
 80225c6:	f000 f829 	bl	802261c <__malloc_unlock>
 80225ca:	f026 0607 	bic.w	r6, r6, #7
 80225ce:	1d23      	adds	r3, r4, #4
 80225d0:	1af2      	subs	r2, r6, r3
 80225d2:	d0ae      	beq.n	8022532 <_malloc_r+0x22>
 80225d4:	1b9b      	subs	r3, r3, r6
 80225d6:	50a3      	str	r3, [r4, r2]
 80225d8:	e7ab      	b.n	8022532 <_malloc_r+0x22>
 80225da:	42a3      	cmp	r3, r4
 80225dc:	6862      	ldr	r2, [r4, #4]
 80225de:	d1dd      	bne.n	802259c <_malloc_r+0x8c>
 80225e0:	f8c8 2000 	str.w	r2, [r8]
 80225e4:	e7ec      	b.n	80225c0 <_malloc_r+0xb0>
 80225e6:	4623      	mov	r3, r4
 80225e8:	6864      	ldr	r4, [r4, #4]
 80225ea:	e7ac      	b.n	8022546 <_malloc_r+0x36>
 80225ec:	4634      	mov	r4, r6
 80225ee:	6876      	ldr	r6, [r6, #4]
 80225f0:	e7b4      	b.n	802255c <_malloc_r+0x4c>
 80225f2:	4613      	mov	r3, r2
 80225f4:	e7cc      	b.n	8022590 <_malloc_r+0x80>
 80225f6:	230c      	movs	r3, #12
 80225f8:	603b      	str	r3, [r7, #0]
 80225fa:	4638      	mov	r0, r7
 80225fc:	f000 f80e 	bl	802261c <__malloc_unlock>
 8022600:	e797      	b.n	8022532 <_malloc_r+0x22>
 8022602:	6025      	str	r5, [r4, #0]
 8022604:	e7dc      	b.n	80225c0 <_malloc_r+0xb0>
 8022606:	605b      	str	r3, [r3, #4]
 8022608:	deff      	udf	#255	; 0xff
 802260a:	bf00      	nop
 802260c:	2000483c 	.word	0x2000483c

08022610 <__malloc_lock>:
 8022610:	4801      	ldr	r0, [pc, #4]	; (8022618 <__malloc_lock+0x8>)
 8022612:	f000 bc03 	b.w	8022e1c <__retarget_lock_acquire_recursive>
 8022616:	bf00      	nop
 8022618:	20004984 	.word	0x20004984

0802261c <__malloc_unlock>:
 802261c:	4801      	ldr	r0, [pc, #4]	; (8022624 <__malloc_unlock+0x8>)
 802261e:	f000 bbfe 	b.w	8022e1e <__retarget_lock_release_recursive>
 8022622:	bf00      	nop
 8022624:	20004984 	.word	0x20004984

08022628 <mallinfo>:
 8022628:	b510      	push	{r4, lr}
 802262a:	4b03      	ldr	r3, [pc, #12]	; (8022638 <mallinfo+0x10>)
 802262c:	4604      	mov	r4, r0
 802262e:	6819      	ldr	r1, [r3, #0]
 8022630:	f000 fc60 	bl	8022ef4 <_mallinfo_r>
 8022634:	4620      	mov	r0, r4
 8022636:	bd10      	pop	{r4, pc}
 8022638:	2000062c 	.word	0x2000062c

0802263c <swapfunc>:
 802263c:	2b02      	cmp	r3, #2
 802263e:	b510      	push	{r4, lr}
 8022640:	d00a      	beq.n	8022658 <swapfunc+0x1c>
 8022642:	0892      	lsrs	r2, r2, #2
 8022644:	3a01      	subs	r2, #1
 8022646:	6803      	ldr	r3, [r0, #0]
 8022648:	680c      	ldr	r4, [r1, #0]
 802264a:	f840 4b04 	str.w	r4, [r0], #4
 802264e:	2a00      	cmp	r2, #0
 8022650:	f841 3b04 	str.w	r3, [r1], #4
 8022654:	dcf6      	bgt.n	8022644 <swapfunc+0x8>
 8022656:	bd10      	pop	{r4, pc}
 8022658:	4402      	add	r2, r0
 802265a:	780c      	ldrb	r4, [r1, #0]
 802265c:	7803      	ldrb	r3, [r0, #0]
 802265e:	f800 4b01 	strb.w	r4, [r0], #1
 8022662:	f801 3b01 	strb.w	r3, [r1], #1
 8022666:	1a13      	subs	r3, r2, r0
 8022668:	2b00      	cmp	r3, #0
 802266a:	dcf6      	bgt.n	802265a <swapfunc+0x1e>
 802266c:	e7f3      	b.n	8022656 <swapfunc+0x1a>

0802266e <med3.constprop.0>:
 802266e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8022670:	460c      	mov	r4, r1
 8022672:	4615      	mov	r5, r2
 8022674:	4607      	mov	r7, r0
 8022676:	461e      	mov	r6, r3
 8022678:	4798      	blx	r3
 802267a:	2800      	cmp	r0, #0
 802267c:	4629      	mov	r1, r5
 802267e:	4620      	mov	r0, r4
 8022680:	da0a      	bge.n	8022698 <med3.constprop.0+0x2a>
 8022682:	47b0      	blx	r6
 8022684:	2800      	cmp	r0, #0
 8022686:	db05      	blt.n	8022694 <med3.constprop.0+0x26>
 8022688:	4629      	mov	r1, r5
 802268a:	4638      	mov	r0, r7
 802268c:	47b0      	blx	r6
 802268e:	2800      	cmp	r0, #0
 8022690:	db0a      	blt.n	80226a8 <med3.constprop.0+0x3a>
 8022692:	463c      	mov	r4, r7
 8022694:	4620      	mov	r0, r4
 8022696:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8022698:	47b0      	blx	r6
 802269a:	2800      	cmp	r0, #0
 802269c:	dcfa      	bgt.n	8022694 <med3.constprop.0+0x26>
 802269e:	4629      	mov	r1, r5
 80226a0:	4638      	mov	r0, r7
 80226a2:	47b0      	blx	r6
 80226a4:	2800      	cmp	r0, #0
 80226a6:	dbf4      	blt.n	8022692 <med3.constprop.0+0x24>
 80226a8:	462c      	mov	r4, r5
 80226aa:	e7f3      	b.n	8022694 <med3.constprop.0+0x26>

080226ac <qsort>:
 80226ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80226b0:	469a      	mov	sl, r3
 80226b2:	ea40 0302 	orr.w	r3, r0, r2
 80226b6:	079b      	lsls	r3, r3, #30
 80226b8:	b097      	sub	sp, #92	; 0x5c
 80226ba:	4606      	mov	r6, r0
 80226bc:	4614      	mov	r4, r2
 80226be:	d11a      	bne.n	80226f6 <qsort+0x4a>
 80226c0:	f1b2 0804 	subs.w	r8, r2, #4
 80226c4:	bf18      	it	ne
 80226c6:	f04f 0801 	movne.w	r8, #1
 80226ca:	2300      	movs	r3, #0
 80226cc:	9302      	str	r3, [sp, #8]
 80226ce:	1933      	adds	r3, r6, r4
 80226d0:	fb04 f701 	mul.w	r7, r4, r1
 80226d4:	9301      	str	r3, [sp, #4]
 80226d6:	2906      	cmp	r1, #6
 80226d8:	eb06 0307 	add.w	r3, r6, r7
 80226dc:	9303      	str	r3, [sp, #12]
 80226de:	d82a      	bhi.n	8022736 <qsort+0x8a>
 80226e0:	9b01      	ldr	r3, [sp, #4]
 80226e2:	9a03      	ldr	r2, [sp, #12]
 80226e4:	4293      	cmp	r3, r2
 80226e6:	d310      	bcc.n	802270a <qsort+0x5e>
 80226e8:	9b02      	ldr	r3, [sp, #8]
 80226ea:	2b00      	cmp	r3, #0
 80226ec:	f040 811e 	bne.w	802292c <qsort+0x280>
 80226f0:	b017      	add	sp, #92	; 0x5c
 80226f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80226f6:	f04f 0802 	mov.w	r8, #2
 80226fa:	e7e6      	b.n	80226ca <qsort+0x1e>
 80226fc:	4643      	mov	r3, r8
 80226fe:	4622      	mov	r2, r4
 8022700:	4639      	mov	r1, r7
 8022702:	4628      	mov	r0, r5
 8022704:	f7ff ff9a 	bl	802263c <swapfunc>
 8022708:	e00e      	b.n	8022728 <qsort+0x7c>
 802270a:	9d01      	ldr	r5, [sp, #4]
 802270c:	e00d      	b.n	802272a <qsort+0x7e>
 802270e:	1b2f      	subs	r7, r5, r4
 8022710:	4629      	mov	r1, r5
 8022712:	4638      	mov	r0, r7
 8022714:	47d0      	blx	sl
 8022716:	2800      	cmp	r0, #0
 8022718:	dd09      	ble.n	802272e <qsort+0x82>
 802271a:	f1b8 0f00 	cmp.w	r8, #0
 802271e:	d1ed      	bne.n	80226fc <qsort+0x50>
 8022720:	682b      	ldr	r3, [r5, #0]
 8022722:	683a      	ldr	r2, [r7, #0]
 8022724:	602a      	str	r2, [r5, #0]
 8022726:	603b      	str	r3, [r7, #0]
 8022728:	463d      	mov	r5, r7
 802272a:	42ae      	cmp	r6, r5
 802272c:	d3ef      	bcc.n	802270e <qsort+0x62>
 802272e:	9b01      	ldr	r3, [sp, #4]
 8022730:	4423      	add	r3, r4
 8022732:	9301      	str	r3, [sp, #4]
 8022734:	e7d4      	b.n	80226e0 <qsort+0x34>
 8022736:	ea4f 0951 	mov.w	r9, r1, lsr #1
 802273a:	1b3f      	subs	r7, r7, r4
 802273c:	2907      	cmp	r1, #7
 802273e:	fb04 6909 	mla	r9, r4, r9, r6
 8022742:	4437      	add	r7, r6
 8022744:	d021      	beq.n	802278a <qsort+0xde>
 8022746:	2928      	cmp	r1, #40	; 0x28
 8022748:	d944      	bls.n	80227d4 <qsort+0x128>
 802274a:	08cd      	lsrs	r5, r1, #3
 802274c:	4365      	muls	r5, r4
 802274e:	4653      	mov	r3, sl
 8022750:	eb06 0245 	add.w	r2, r6, r5, lsl #1
 8022754:	1971      	adds	r1, r6, r5
 8022756:	4630      	mov	r0, r6
 8022758:	f7ff ff89 	bl	802266e <med3.constprop.0>
 802275c:	4649      	mov	r1, r9
 802275e:	eb09 0205 	add.w	r2, r9, r5
 8022762:	4653      	mov	r3, sl
 8022764:	4683      	mov	fp, r0
 8022766:	1b48      	subs	r0, r1, r5
 8022768:	f7ff ff81 	bl	802266e <med3.constprop.0>
 802276c:	463a      	mov	r2, r7
 802276e:	4681      	mov	r9, r0
 8022770:	4653      	mov	r3, sl
 8022772:	1b79      	subs	r1, r7, r5
 8022774:	eba7 0045 	sub.w	r0, r7, r5, lsl #1
 8022778:	f7ff ff79 	bl	802266e <med3.constprop.0>
 802277c:	4602      	mov	r2, r0
 802277e:	4649      	mov	r1, r9
 8022780:	4653      	mov	r3, sl
 8022782:	4658      	mov	r0, fp
 8022784:	f7ff ff73 	bl	802266e <med3.constprop.0>
 8022788:	4681      	mov	r9, r0
 802278a:	f1b8 0f00 	cmp.w	r8, #0
 802278e:	d124      	bne.n	80227da <qsort+0x12e>
 8022790:	6833      	ldr	r3, [r6, #0]
 8022792:	f8d9 2000 	ldr.w	r2, [r9]
 8022796:	6032      	str	r2, [r6, #0]
 8022798:	f8c9 3000 	str.w	r3, [r9]
 802279c:	eb06 0b04 	add.w	fp, r6, r4
 80227a0:	46b9      	mov	r9, r7
 80227a2:	465d      	mov	r5, fp
 80227a4:	2300      	movs	r3, #0
 80227a6:	45bb      	cmp	fp, r7
 80227a8:	d835      	bhi.n	8022816 <qsort+0x16a>
 80227aa:	4631      	mov	r1, r6
 80227ac:	4658      	mov	r0, fp
 80227ae:	9304      	str	r3, [sp, #16]
 80227b0:	47d0      	blx	sl
 80227b2:	2800      	cmp	r0, #0
 80227b4:	9b04      	ldr	r3, [sp, #16]
 80227b6:	dc3e      	bgt.n	8022836 <qsort+0x18a>
 80227b8:	d10a      	bne.n	80227d0 <qsort+0x124>
 80227ba:	f1b8 0f00 	cmp.w	r8, #0
 80227be:	d113      	bne.n	80227e8 <qsort+0x13c>
 80227c0:	682b      	ldr	r3, [r5, #0]
 80227c2:	f8db 2000 	ldr.w	r2, [fp]
 80227c6:	602a      	str	r2, [r5, #0]
 80227c8:	f8cb 3000 	str.w	r3, [fp]
 80227cc:	4425      	add	r5, r4
 80227ce:	2301      	movs	r3, #1
 80227d0:	44a3      	add	fp, r4
 80227d2:	e7e8      	b.n	80227a6 <qsort+0xfa>
 80227d4:	463a      	mov	r2, r7
 80227d6:	46b3      	mov	fp, r6
 80227d8:	e7d1      	b.n	802277e <qsort+0xd2>
 80227da:	4643      	mov	r3, r8
 80227dc:	4622      	mov	r2, r4
 80227de:	4649      	mov	r1, r9
 80227e0:	4630      	mov	r0, r6
 80227e2:	f7ff ff2b 	bl	802263c <swapfunc>
 80227e6:	e7d9      	b.n	802279c <qsort+0xf0>
 80227e8:	4643      	mov	r3, r8
 80227ea:	4622      	mov	r2, r4
 80227ec:	4659      	mov	r1, fp
 80227ee:	4628      	mov	r0, r5
 80227f0:	f7ff ff24 	bl	802263c <swapfunc>
 80227f4:	e7ea      	b.n	80227cc <qsort+0x120>
 80227f6:	d10b      	bne.n	8022810 <qsort+0x164>
 80227f8:	f1b8 0f00 	cmp.w	r8, #0
 80227fc:	d114      	bne.n	8022828 <qsort+0x17c>
 80227fe:	683b      	ldr	r3, [r7, #0]
 8022800:	f8d9 2000 	ldr.w	r2, [r9]
 8022804:	603a      	str	r2, [r7, #0]
 8022806:	f8c9 3000 	str.w	r3, [r9]
 802280a:	eba9 0904 	sub.w	r9, r9, r4
 802280e:	2301      	movs	r3, #1
 8022810:	9f04      	ldr	r7, [sp, #16]
 8022812:	45bb      	cmp	fp, r7
 8022814:	d90f      	bls.n	8022836 <qsort+0x18a>
 8022816:	2b00      	cmp	r3, #0
 8022818:	d143      	bne.n	80228a2 <qsort+0x1f6>
 802281a:	9b01      	ldr	r3, [sp, #4]
 802281c:	9a03      	ldr	r2, [sp, #12]
 802281e:	4293      	cmp	r3, r2
 8022820:	f4bf af62 	bcs.w	80226e8 <qsort+0x3c>
 8022824:	9d01      	ldr	r5, [sp, #4]
 8022826:	e036      	b.n	8022896 <qsort+0x1ea>
 8022828:	4643      	mov	r3, r8
 802282a:	4622      	mov	r2, r4
 802282c:	4649      	mov	r1, r9
 802282e:	4638      	mov	r0, r7
 8022830:	f7ff ff04 	bl	802263c <swapfunc>
 8022834:	e7e9      	b.n	802280a <qsort+0x15e>
 8022836:	4631      	mov	r1, r6
 8022838:	4638      	mov	r0, r7
 802283a:	9305      	str	r3, [sp, #20]
 802283c:	47d0      	blx	sl
 802283e:	1b3b      	subs	r3, r7, r4
 8022840:	2800      	cmp	r0, #0
 8022842:	9304      	str	r3, [sp, #16]
 8022844:	9b05      	ldr	r3, [sp, #20]
 8022846:	dad6      	bge.n	80227f6 <qsort+0x14a>
 8022848:	f1b8 0f00 	cmp.w	r8, #0
 802284c:	d006      	beq.n	802285c <qsort+0x1b0>
 802284e:	4643      	mov	r3, r8
 8022850:	4622      	mov	r2, r4
 8022852:	4639      	mov	r1, r7
 8022854:	4658      	mov	r0, fp
 8022856:	f7ff fef1 	bl	802263c <swapfunc>
 802285a:	e005      	b.n	8022868 <qsort+0x1bc>
 802285c:	f8db 3000 	ldr.w	r3, [fp]
 8022860:	683a      	ldr	r2, [r7, #0]
 8022862:	f8cb 2000 	str.w	r2, [fp]
 8022866:	603b      	str	r3, [r7, #0]
 8022868:	9f04      	ldr	r7, [sp, #16]
 802286a:	e7b0      	b.n	80227ce <qsort+0x122>
 802286c:	4643      	mov	r3, r8
 802286e:	4622      	mov	r2, r4
 8022870:	4639      	mov	r1, r7
 8022872:	4628      	mov	r0, r5
 8022874:	f7ff fee2 	bl	802263c <swapfunc>
 8022878:	e00c      	b.n	8022894 <qsort+0x1e8>
 802287a:	1b2f      	subs	r7, r5, r4
 802287c:	4629      	mov	r1, r5
 802287e:	4638      	mov	r0, r7
 8022880:	47d0      	blx	sl
 8022882:	2800      	cmp	r0, #0
 8022884:	dd09      	ble.n	802289a <qsort+0x1ee>
 8022886:	f1b8 0f00 	cmp.w	r8, #0
 802288a:	d1ef      	bne.n	802286c <qsort+0x1c0>
 802288c:	682b      	ldr	r3, [r5, #0]
 802288e:	683a      	ldr	r2, [r7, #0]
 8022890:	602a      	str	r2, [r5, #0]
 8022892:	603b      	str	r3, [r7, #0]
 8022894:	463d      	mov	r5, r7
 8022896:	42ae      	cmp	r6, r5
 8022898:	d3ef      	bcc.n	802287a <qsort+0x1ce>
 802289a:	9b01      	ldr	r3, [sp, #4]
 802289c:	4423      	add	r3, r4
 802289e:	9301      	str	r3, [sp, #4]
 80228a0:	e7bb      	b.n	802281a <qsort+0x16e>
 80228a2:	ebab 0305 	sub.w	r3, fp, r5
 80228a6:	1baa      	subs	r2, r5, r6
 80228a8:	429a      	cmp	r2, r3
 80228aa:	bfa8      	it	ge
 80228ac:	461a      	movge	r2, r3
 80228ae:	9301      	str	r3, [sp, #4]
 80228b0:	b12a      	cbz	r2, 80228be <qsort+0x212>
 80228b2:	4643      	mov	r3, r8
 80228b4:	ebab 0102 	sub.w	r1, fp, r2
 80228b8:	4630      	mov	r0, r6
 80228ba:	f7ff febf 	bl	802263c <swapfunc>
 80228be:	9b03      	ldr	r3, [sp, #12]
 80228c0:	eba3 0209 	sub.w	r2, r3, r9
 80228c4:	eba9 0707 	sub.w	r7, r9, r7
 80228c8:	1b12      	subs	r2, r2, r4
 80228ca:	42ba      	cmp	r2, r7
 80228cc:	bf28      	it	cs
 80228ce:	463a      	movcs	r2, r7
 80228d0:	b12a      	cbz	r2, 80228de <qsort+0x232>
 80228d2:	9903      	ldr	r1, [sp, #12]
 80228d4:	4643      	mov	r3, r8
 80228d6:	1a89      	subs	r1, r1, r2
 80228d8:	4658      	mov	r0, fp
 80228da:	f7ff feaf 	bl	802263c <swapfunc>
 80228de:	f8dd 9004 	ldr.w	r9, [sp, #4]
 80228e2:	9b03      	ldr	r3, [sp, #12]
 80228e4:	454f      	cmp	r7, r9
 80228e6:	eba3 0007 	sub.w	r0, r3, r7
 80228ea:	d904      	bls.n	80228f6 <qsort+0x24a>
 80228ec:	4633      	mov	r3, r6
 80228ee:	46b9      	mov	r9, r7
 80228f0:	9f01      	ldr	r7, [sp, #4]
 80228f2:	4606      	mov	r6, r0
 80228f4:	4618      	mov	r0, r3
 80228f6:	42a7      	cmp	r7, r4
 80228f8:	d921      	bls.n	802293e <qsort+0x292>
 80228fa:	fbb7 f1f4 	udiv	r1, r7, r4
 80228fe:	9b02      	ldr	r3, [sp, #8]
 8022900:	2b07      	cmp	r3, #7
 8022902:	d80d      	bhi.n	8022920 <qsort+0x274>
 8022904:	aa16      	add	r2, sp, #88	; 0x58
 8022906:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 802290a:	fbb9 f2f4 	udiv	r2, r9, r4
 802290e:	f843 6c40 	str.w	r6, [r3, #-64]
 8022912:	f843 2c3c 	str.w	r2, [r3, #-60]
 8022916:	9b02      	ldr	r3, [sp, #8]
 8022918:	3301      	adds	r3, #1
 802291a:	9302      	str	r3, [sp, #8]
 802291c:	4606      	mov	r6, r0
 802291e:	e6d6      	b.n	80226ce <qsort+0x22>
 8022920:	4653      	mov	r3, sl
 8022922:	4622      	mov	r2, r4
 8022924:	f7ff fec2 	bl	80226ac <qsort>
 8022928:	45a1      	cmp	r9, r4
 802292a:	d80b      	bhi.n	8022944 <qsort+0x298>
 802292c:	9b02      	ldr	r3, [sp, #8]
 802292e:	aa16      	add	r2, sp, #88	; 0x58
 8022930:	3b01      	subs	r3, #1
 8022932:	9302      	str	r3, [sp, #8]
 8022934:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8022938:	e953 0110 	ldrd	r0, r1, [r3, #-64]	; 0x40
 802293c:	e7ee      	b.n	802291c <qsort+0x270>
 802293e:	45a1      	cmp	r9, r4
 8022940:	f67f aed2 	bls.w	80226e8 <qsort+0x3c>
 8022944:	fbb9 f1f4 	udiv	r1, r9, r4
 8022948:	4630      	mov	r0, r6
 802294a:	e7e7      	b.n	802291c <qsort+0x270>

0802294c <std>:
 802294c:	2300      	movs	r3, #0
 802294e:	b510      	push	{r4, lr}
 8022950:	4604      	mov	r4, r0
 8022952:	e9c0 3300 	strd	r3, r3, [r0]
 8022956:	e9c0 3304 	strd	r3, r3, [r0, #16]
 802295a:	6083      	str	r3, [r0, #8]
 802295c:	8181      	strh	r1, [r0, #12]
 802295e:	6643      	str	r3, [r0, #100]	; 0x64
 8022960:	81c2      	strh	r2, [r0, #14]
 8022962:	6183      	str	r3, [r0, #24]
 8022964:	4619      	mov	r1, r3
 8022966:	2208      	movs	r2, #8
 8022968:	305c      	adds	r0, #92	; 0x5c
 802296a:	f000 f904 	bl	8022b76 <memset>
 802296e:	4b05      	ldr	r3, [pc, #20]	; (8022984 <std+0x38>)
 8022970:	6263      	str	r3, [r4, #36]	; 0x24
 8022972:	4b05      	ldr	r3, [pc, #20]	; (8022988 <std+0x3c>)
 8022974:	62a3      	str	r3, [r4, #40]	; 0x28
 8022976:	4b05      	ldr	r3, [pc, #20]	; (802298c <std+0x40>)
 8022978:	62e3      	str	r3, [r4, #44]	; 0x2c
 802297a:	4b05      	ldr	r3, [pc, #20]	; (8022990 <std+0x44>)
 802297c:	6224      	str	r4, [r4, #32]
 802297e:	6323      	str	r3, [r4, #48]	; 0x30
 8022980:	bd10      	pop	{r4, pc}
 8022982:	bf00      	nop
 8022984:	08022ad1 	.word	0x08022ad1
 8022988:	08022af3 	.word	0x08022af3
 802298c:	08022b2b 	.word	0x08022b2b
 8022990:	08022b4f 	.word	0x08022b4f

08022994 <stdio_exit_handler>:
 8022994:	4a02      	ldr	r2, [pc, #8]	; (80229a0 <stdio_exit_handler+0xc>)
 8022996:	4903      	ldr	r1, [pc, #12]	; (80229a4 <stdio_exit_handler+0x10>)
 8022998:	4803      	ldr	r0, [pc, #12]	; (80229a8 <stdio_exit_handler+0x14>)
 802299a:	f000 b87b 	b.w	8022a94 <_fwalk_sglue>
 802299e:	bf00      	nop
 80229a0:	200005d4 	.word	0x200005d4
 80229a4:	08023611 	.word	0x08023611
 80229a8:	200005e0 	.word	0x200005e0

080229ac <cleanup_stdio>:
 80229ac:	6841      	ldr	r1, [r0, #4]
 80229ae:	4b0c      	ldr	r3, [pc, #48]	; (80229e0 <cleanup_stdio+0x34>)
 80229b0:	4299      	cmp	r1, r3
 80229b2:	b510      	push	{r4, lr}
 80229b4:	4604      	mov	r4, r0
 80229b6:	d001      	beq.n	80229bc <cleanup_stdio+0x10>
 80229b8:	f000 fe2a 	bl	8023610 <_fflush_r>
 80229bc:	68a1      	ldr	r1, [r4, #8]
 80229be:	4b09      	ldr	r3, [pc, #36]	; (80229e4 <cleanup_stdio+0x38>)
 80229c0:	4299      	cmp	r1, r3
 80229c2:	d002      	beq.n	80229ca <cleanup_stdio+0x1e>
 80229c4:	4620      	mov	r0, r4
 80229c6:	f000 fe23 	bl	8023610 <_fflush_r>
 80229ca:	68e1      	ldr	r1, [r4, #12]
 80229cc:	4b06      	ldr	r3, [pc, #24]	; (80229e8 <cleanup_stdio+0x3c>)
 80229ce:	4299      	cmp	r1, r3
 80229d0:	d004      	beq.n	80229dc <cleanup_stdio+0x30>
 80229d2:	4620      	mov	r0, r4
 80229d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80229d8:	f000 be1a 	b.w	8023610 <_fflush_r>
 80229dc:	bd10      	pop	{r4, pc}
 80229de:	bf00      	nop
 80229e0:	20004844 	.word	0x20004844
 80229e4:	200048ac 	.word	0x200048ac
 80229e8:	20004914 	.word	0x20004914

080229ec <global_stdio_init.part.0>:
 80229ec:	b510      	push	{r4, lr}
 80229ee:	4b0b      	ldr	r3, [pc, #44]	; (8022a1c <global_stdio_init.part.0+0x30>)
 80229f0:	4c0b      	ldr	r4, [pc, #44]	; (8022a20 <global_stdio_init.part.0+0x34>)
 80229f2:	4a0c      	ldr	r2, [pc, #48]	; (8022a24 <global_stdio_init.part.0+0x38>)
 80229f4:	601a      	str	r2, [r3, #0]
 80229f6:	4620      	mov	r0, r4
 80229f8:	2200      	movs	r2, #0
 80229fa:	2104      	movs	r1, #4
 80229fc:	f7ff ffa6 	bl	802294c <std>
 8022a00:	f104 0068 	add.w	r0, r4, #104	; 0x68
 8022a04:	2201      	movs	r2, #1
 8022a06:	2109      	movs	r1, #9
 8022a08:	f7ff ffa0 	bl	802294c <std>
 8022a0c:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
 8022a10:	2202      	movs	r2, #2
 8022a12:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8022a16:	2112      	movs	r1, #18
 8022a18:	f7ff bf98 	b.w	802294c <std>
 8022a1c:	2000497c 	.word	0x2000497c
 8022a20:	20004844 	.word	0x20004844
 8022a24:	08022995 	.word	0x08022995

08022a28 <__sfp_lock_acquire>:
 8022a28:	4801      	ldr	r0, [pc, #4]	; (8022a30 <__sfp_lock_acquire+0x8>)
 8022a2a:	f000 b9f7 	b.w	8022e1c <__retarget_lock_acquire_recursive>
 8022a2e:	bf00      	nop
 8022a30:	20004985 	.word	0x20004985

08022a34 <__sfp_lock_release>:
 8022a34:	4801      	ldr	r0, [pc, #4]	; (8022a3c <__sfp_lock_release+0x8>)
 8022a36:	f000 b9f2 	b.w	8022e1e <__retarget_lock_release_recursive>
 8022a3a:	bf00      	nop
 8022a3c:	20004985 	.word	0x20004985

08022a40 <__sinit>:
 8022a40:	b510      	push	{r4, lr}
 8022a42:	4604      	mov	r4, r0
 8022a44:	f7ff fff0 	bl	8022a28 <__sfp_lock_acquire>
 8022a48:	6a23      	ldr	r3, [r4, #32]
 8022a4a:	b11b      	cbz	r3, 8022a54 <__sinit+0x14>
 8022a4c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8022a50:	f7ff bff0 	b.w	8022a34 <__sfp_lock_release>
 8022a54:	4b04      	ldr	r3, [pc, #16]	; (8022a68 <__sinit+0x28>)
 8022a56:	6223      	str	r3, [r4, #32]
 8022a58:	4b04      	ldr	r3, [pc, #16]	; (8022a6c <__sinit+0x2c>)
 8022a5a:	681b      	ldr	r3, [r3, #0]
 8022a5c:	2b00      	cmp	r3, #0
 8022a5e:	d1f5      	bne.n	8022a4c <__sinit+0xc>
 8022a60:	f7ff ffc4 	bl	80229ec <global_stdio_init.part.0>
 8022a64:	e7f2      	b.n	8022a4c <__sinit+0xc>
 8022a66:	bf00      	nop
 8022a68:	080229ad 	.word	0x080229ad
 8022a6c:	2000497c 	.word	0x2000497c

08022a70 <fiprintf>:
 8022a70:	b40e      	push	{r1, r2, r3}
 8022a72:	b503      	push	{r0, r1, lr}
 8022a74:	4601      	mov	r1, r0
 8022a76:	ab03      	add	r3, sp, #12
 8022a78:	4805      	ldr	r0, [pc, #20]	; (8022a90 <fiprintf+0x20>)
 8022a7a:	f853 2b04 	ldr.w	r2, [r3], #4
 8022a7e:	6800      	ldr	r0, [r0, #0]
 8022a80:	9301      	str	r3, [sp, #4]
 8022a82:	f000 fa95 	bl	8022fb0 <_vfiprintf_r>
 8022a86:	b002      	add	sp, #8
 8022a88:	f85d eb04 	ldr.w	lr, [sp], #4
 8022a8c:	b003      	add	sp, #12
 8022a8e:	4770      	bx	lr
 8022a90:	2000062c 	.word	0x2000062c

08022a94 <_fwalk_sglue>:
 8022a94:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8022a98:	4607      	mov	r7, r0
 8022a9a:	4688      	mov	r8, r1
 8022a9c:	4614      	mov	r4, r2
 8022a9e:	2600      	movs	r6, #0
 8022aa0:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 8022aa4:	f1b9 0901 	subs.w	r9, r9, #1
 8022aa8:	d505      	bpl.n	8022ab6 <_fwalk_sglue+0x22>
 8022aaa:	6824      	ldr	r4, [r4, #0]
 8022aac:	2c00      	cmp	r4, #0
 8022aae:	d1f7      	bne.n	8022aa0 <_fwalk_sglue+0xc>
 8022ab0:	4630      	mov	r0, r6
 8022ab2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8022ab6:	89ab      	ldrh	r3, [r5, #12]
 8022ab8:	2b01      	cmp	r3, #1
 8022aba:	d907      	bls.n	8022acc <_fwalk_sglue+0x38>
 8022abc:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8022ac0:	3301      	adds	r3, #1
 8022ac2:	d003      	beq.n	8022acc <_fwalk_sglue+0x38>
 8022ac4:	4629      	mov	r1, r5
 8022ac6:	4638      	mov	r0, r7
 8022ac8:	47c0      	blx	r8
 8022aca:	4306      	orrs	r6, r0
 8022acc:	3568      	adds	r5, #104	; 0x68
 8022ace:	e7e9      	b.n	8022aa4 <_fwalk_sglue+0x10>

08022ad0 <__sread>:
 8022ad0:	b510      	push	{r4, lr}
 8022ad2:	460c      	mov	r4, r1
 8022ad4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8022ad8:	f000 f942 	bl	8022d60 <_read_r>
 8022adc:	2800      	cmp	r0, #0
 8022ade:	bfab      	itete	ge
 8022ae0:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 8022ae2:	89a3      	ldrhlt	r3, [r4, #12]
 8022ae4:	181b      	addge	r3, r3, r0
 8022ae6:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 8022aea:	bfac      	ite	ge
 8022aec:	6563      	strge	r3, [r4, #84]	; 0x54
 8022aee:	81a3      	strhlt	r3, [r4, #12]
 8022af0:	bd10      	pop	{r4, pc}

08022af2 <__swrite>:
 8022af2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8022af6:	461f      	mov	r7, r3
 8022af8:	898b      	ldrh	r3, [r1, #12]
 8022afa:	05db      	lsls	r3, r3, #23
 8022afc:	4605      	mov	r5, r0
 8022afe:	460c      	mov	r4, r1
 8022b00:	4616      	mov	r6, r2
 8022b02:	d505      	bpl.n	8022b10 <__swrite+0x1e>
 8022b04:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8022b08:	2302      	movs	r3, #2
 8022b0a:	2200      	movs	r2, #0
 8022b0c:	f000 f916 	bl	8022d3c <_lseek_r>
 8022b10:	89a3      	ldrh	r3, [r4, #12]
 8022b12:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8022b16:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8022b1a:	81a3      	strh	r3, [r4, #12]
 8022b1c:	4632      	mov	r2, r6
 8022b1e:	463b      	mov	r3, r7
 8022b20:	4628      	mov	r0, r5
 8022b22:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8022b26:	f000 b93d 	b.w	8022da4 <_write_r>

08022b2a <__sseek>:
 8022b2a:	b510      	push	{r4, lr}
 8022b2c:	460c      	mov	r4, r1
 8022b2e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8022b32:	f000 f903 	bl	8022d3c <_lseek_r>
 8022b36:	1c43      	adds	r3, r0, #1
 8022b38:	89a3      	ldrh	r3, [r4, #12]
 8022b3a:	bf15      	itete	ne
 8022b3c:	6560      	strne	r0, [r4, #84]	; 0x54
 8022b3e:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8022b42:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8022b46:	81a3      	strheq	r3, [r4, #12]
 8022b48:	bf18      	it	ne
 8022b4a:	81a3      	strhne	r3, [r4, #12]
 8022b4c:	bd10      	pop	{r4, pc}

08022b4e <__sclose>:
 8022b4e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8022b52:	f000 b8e3 	b.w	8022d1c <_close_r>

08022b56 <memcmp>:
 8022b56:	b510      	push	{r4, lr}
 8022b58:	3901      	subs	r1, #1
 8022b5a:	4402      	add	r2, r0
 8022b5c:	4290      	cmp	r0, r2
 8022b5e:	d101      	bne.n	8022b64 <memcmp+0xe>
 8022b60:	2000      	movs	r0, #0
 8022b62:	e005      	b.n	8022b70 <memcmp+0x1a>
 8022b64:	7803      	ldrb	r3, [r0, #0]
 8022b66:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8022b6a:	42a3      	cmp	r3, r4
 8022b6c:	d001      	beq.n	8022b72 <memcmp+0x1c>
 8022b6e:	1b18      	subs	r0, r3, r4
 8022b70:	bd10      	pop	{r4, pc}
 8022b72:	3001      	adds	r0, #1
 8022b74:	e7f2      	b.n	8022b5c <memcmp+0x6>

08022b76 <memset>:
 8022b76:	4402      	add	r2, r0
 8022b78:	4603      	mov	r3, r0
 8022b7a:	4293      	cmp	r3, r2
 8022b7c:	d100      	bne.n	8022b80 <memset+0xa>
 8022b7e:	4770      	bx	lr
 8022b80:	f803 1b01 	strb.w	r1, [r3], #1
 8022b84:	e7f9      	b.n	8022b7a <memset+0x4>

08022b86 <strcat>:
 8022b86:	b510      	push	{r4, lr}
 8022b88:	4602      	mov	r2, r0
 8022b8a:	7814      	ldrb	r4, [r2, #0]
 8022b8c:	4613      	mov	r3, r2
 8022b8e:	3201      	adds	r2, #1
 8022b90:	2c00      	cmp	r4, #0
 8022b92:	d1fa      	bne.n	8022b8a <strcat+0x4>
 8022b94:	3b01      	subs	r3, #1
 8022b96:	f811 2b01 	ldrb.w	r2, [r1], #1
 8022b9a:	f803 2f01 	strb.w	r2, [r3, #1]!
 8022b9e:	2a00      	cmp	r2, #0
 8022ba0:	d1f9      	bne.n	8022b96 <strcat+0x10>
 8022ba2:	bd10      	pop	{r4, pc}

08022ba4 <strchr>:
 8022ba4:	b2c9      	uxtb	r1, r1
 8022ba6:	4603      	mov	r3, r0
 8022ba8:	f810 2b01 	ldrb.w	r2, [r0], #1
 8022bac:	b11a      	cbz	r2, 8022bb6 <strchr+0x12>
 8022bae:	428a      	cmp	r2, r1
 8022bb0:	d1f9      	bne.n	8022ba6 <strchr+0x2>
 8022bb2:	4618      	mov	r0, r3
 8022bb4:	4770      	bx	lr
 8022bb6:	2900      	cmp	r1, #0
 8022bb8:	bf18      	it	ne
 8022bba:	2300      	movne	r3, #0
 8022bbc:	e7f9      	b.n	8022bb2 <strchr+0xe>

08022bbe <strncmp>:
 8022bbe:	b510      	push	{r4, lr}
 8022bc0:	b16a      	cbz	r2, 8022bde <strncmp+0x20>
 8022bc2:	3901      	subs	r1, #1
 8022bc4:	1884      	adds	r4, r0, r2
 8022bc6:	f810 2b01 	ldrb.w	r2, [r0], #1
 8022bca:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 8022bce:	429a      	cmp	r2, r3
 8022bd0:	d103      	bne.n	8022bda <strncmp+0x1c>
 8022bd2:	42a0      	cmp	r0, r4
 8022bd4:	d001      	beq.n	8022bda <strncmp+0x1c>
 8022bd6:	2a00      	cmp	r2, #0
 8022bd8:	d1f5      	bne.n	8022bc6 <strncmp+0x8>
 8022bda:	1ad0      	subs	r0, r2, r3
 8022bdc:	bd10      	pop	{r4, pc}
 8022bde:	4610      	mov	r0, r2
 8022be0:	e7fc      	b.n	8022bdc <strncmp+0x1e>

08022be2 <strncpy>:
 8022be2:	b510      	push	{r4, lr}
 8022be4:	3901      	subs	r1, #1
 8022be6:	4603      	mov	r3, r0
 8022be8:	b132      	cbz	r2, 8022bf8 <strncpy+0x16>
 8022bea:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8022bee:	f803 4b01 	strb.w	r4, [r3], #1
 8022bf2:	3a01      	subs	r2, #1
 8022bf4:	2c00      	cmp	r4, #0
 8022bf6:	d1f7      	bne.n	8022be8 <strncpy+0x6>
 8022bf8:	441a      	add	r2, r3
 8022bfa:	2100      	movs	r1, #0
 8022bfc:	4293      	cmp	r3, r2
 8022bfe:	d100      	bne.n	8022c02 <strncpy+0x20>
 8022c00:	bd10      	pop	{r4, pc}
 8022c02:	f803 1b01 	strb.w	r1, [r3], #1
 8022c06:	e7f9      	b.n	8022bfc <strncpy+0x1a>

08022c08 <strrchr>:
 8022c08:	b513      	push	{r0, r1, r4, lr}
 8022c0a:	f011 01ff 	ands.w	r1, r1, #255	; 0xff
 8022c0e:	4603      	mov	r3, r0
 8022c10:	d110      	bne.n	8022c34 <strrchr+0x2c>
 8022c12:	b002      	add	sp, #8
 8022c14:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8022c18:	f7ff bfc4 	b.w	8022ba4 <strchr>
 8022c1c:	1c43      	adds	r3, r0, #1
 8022c1e:	4604      	mov	r4, r0
 8022c20:	4618      	mov	r0, r3
 8022c22:	9101      	str	r1, [sp, #4]
 8022c24:	f7ff ffbe 	bl	8022ba4 <strchr>
 8022c28:	9901      	ldr	r1, [sp, #4]
 8022c2a:	2800      	cmp	r0, #0
 8022c2c:	d1f6      	bne.n	8022c1c <strrchr+0x14>
 8022c2e:	4620      	mov	r0, r4
 8022c30:	b002      	add	sp, #8
 8022c32:	bd10      	pop	{r4, pc}
 8022c34:	2400      	movs	r4, #0
 8022c36:	e7f3      	b.n	8022c20 <strrchr+0x18>

08022c38 <strtok>:
 8022c38:	4b16      	ldr	r3, [pc, #88]	; (8022c94 <strtok+0x5c>)
 8022c3a:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8022c3c:	681e      	ldr	r6, [r3, #0]
 8022c3e:	6c74      	ldr	r4, [r6, #68]	; 0x44
 8022c40:	4605      	mov	r5, r0
 8022c42:	b9fc      	cbnz	r4, 8022c84 <strtok+0x4c>
 8022c44:	2050      	movs	r0, #80	; 0x50
 8022c46:	9101      	str	r1, [sp, #4]
 8022c48:	f7ff fc32 	bl	80224b0 <malloc>
 8022c4c:	9901      	ldr	r1, [sp, #4]
 8022c4e:	6470      	str	r0, [r6, #68]	; 0x44
 8022c50:	4602      	mov	r2, r0
 8022c52:	b920      	cbnz	r0, 8022c5e <strtok+0x26>
 8022c54:	4b10      	ldr	r3, [pc, #64]	; (8022c98 <strtok+0x60>)
 8022c56:	4811      	ldr	r0, [pc, #68]	; (8022c9c <strtok+0x64>)
 8022c58:	215b      	movs	r1, #91	; 0x5b
 8022c5a:	f7ff fbed 	bl	8022438 <__assert_func>
 8022c5e:	e9c0 4400 	strd	r4, r4, [r0]
 8022c62:	e9c0 4402 	strd	r4, r4, [r0, #8]
 8022c66:	e9c0 4404 	strd	r4, r4, [r0, #16]
 8022c6a:	e9c0 440a 	strd	r4, r4, [r0, #40]	; 0x28
 8022c6e:	e9c0 440c 	strd	r4, r4, [r0, #48]	; 0x30
 8022c72:	e9c0 440e 	strd	r4, r4, [r0, #56]	; 0x38
 8022c76:	e9c0 4410 	strd	r4, r4, [r0, #64]	; 0x40
 8022c7a:	e9c0 4412 	strd	r4, r4, [r0, #72]	; 0x48
 8022c7e:	6184      	str	r4, [r0, #24]
 8022c80:	7704      	strb	r4, [r0, #28]
 8022c82:	6244      	str	r4, [r0, #36]	; 0x24
 8022c84:	6c72      	ldr	r2, [r6, #68]	; 0x44
 8022c86:	2301      	movs	r3, #1
 8022c88:	4628      	mov	r0, r5
 8022c8a:	b002      	add	sp, #8
 8022c8c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8022c90:	f000 b806 	b.w	8022ca0 <__strtok_r>
 8022c94:	2000062c 	.word	0x2000062c
 8022c98:	0802d155 	.word	0x0802d155
 8022c9c:	0802d16c 	.word	0x0802d16c

08022ca0 <__strtok_r>:
 8022ca0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8022ca2:	b908      	cbnz	r0, 8022ca8 <__strtok_r+0x8>
 8022ca4:	6810      	ldr	r0, [r2, #0]
 8022ca6:	b188      	cbz	r0, 8022ccc <__strtok_r+0x2c>
 8022ca8:	4604      	mov	r4, r0
 8022caa:	4620      	mov	r0, r4
 8022cac:	f814 5b01 	ldrb.w	r5, [r4], #1
 8022cb0:	460f      	mov	r7, r1
 8022cb2:	f817 6b01 	ldrb.w	r6, [r7], #1
 8022cb6:	b91e      	cbnz	r6, 8022cc0 <__strtok_r+0x20>
 8022cb8:	b965      	cbnz	r5, 8022cd4 <__strtok_r+0x34>
 8022cba:	6015      	str	r5, [r2, #0]
 8022cbc:	4628      	mov	r0, r5
 8022cbe:	e005      	b.n	8022ccc <__strtok_r+0x2c>
 8022cc0:	42b5      	cmp	r5, r6
 8022cc2:	d1f6      	bne.n	8022cb2 <__strtok_r+0x12>
 8022cc4:	2b00      	cmp	r3, #0
 8022cc6:	d1f0      	bne.n	8022caa <__strtok_r+0xa>
 8022cc8:	6014      	str	r4, [r2, #0]
 8022cca:	7003      	strb	r3, [r0, #0]
 8022ccc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8022cce:	461c      	mov	r4, r3
 8022cd0:	e00c      	b.n	8022cec <__strtok_r+0x4c>
 8022cd2:	b915      	cbnz	r5, 8022cda <__strtok_r+0x3a>
 8022cd4:	f814 3b01 	ldrb.w	r3, [r4], #1
 8022cd8:	460e      	mov	r6, r1
 8022cda:	f816 5b01 	ldrb.w	r5, [r6], #1
 8022cde:	42ab      	cmp	r3, r5
 8022ce0:	d1f7      	bne.n	8022cd2 <__strtok_r+0x32>
 8022ce2:	2b00      	cmp	r3, #0
 8022ce4:	d0f3      	beq.n	8022cce <__strtok_r+0x2e>
 8022ce6:	2300      	movs	r3, #0
 8022ce8:	f804 3c01 	strb.w	r3, [r4, #-1]
 8022cec:	6014      	str	r4, [r2, #0]
 8022cee:	e7ed      	b.n	8022ccc <__strtok_r+0x2c>

08022cf0 <strstr>:
 8022cf0:	780a      	ldrb	r2, [r1, #0]
 8022cf2:	b570      	push	{r4, r5, r6, lr}
 8022cf4:	b96a      	cbnz	r2, 8022d12 <strstr+0x22>
 8022cf6:	bd70      	pop	{r4, r5, r6, pc}
 8022cf8:	429a      	cmp	r2, r3
 8022cfa:	d109      	bne.n	8022d10 <strstr+0x20>
 8022cfc:	460c      	mov	r4, r1
 8022cfe:	4605      	mov	r5, r0
 8022d00:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 8022d04:	2b00      	cmp	r3, #0
 8022d06:	d0f6      	beq.n	8022cf6 <strstr+0x6>
 8022d08:	f815 6f01 	ldrb.w	r6, [r5, #1]!
 8022d0c:	429e      	cmp	r6, r3
 8022d0e:	d0f7      	beq.n	8022d00 <strstr+0x10>
 8022d10:	3001      	adds	r0, #1
 8022d12:	7803      	ldrb	r3, [r0, #0]
 8022d14:	2b00      	cmp	r3, #0
 8022d16:	d1ef      	bne.n	8022cf8 <strstr+0x8>
 8022d18:	4618      	mov	r0, r3
 8022d1a:	e7ec      	b.n	8022cf6 <strstr+0x6>

08022d1c <_close_r>:
 8022d1c:	b538      	push	{r3, r4, r5, lr}
 8022d1e:	4d06      	ldr	r5, [pc, #24]	; (8022d38 <_close_r+0x1c>)
 8022d20:	2300      	movs	r3, #0
 8022d22:	4604      	mov	r4, r0
 8022d24:	4608      	mov	r0, r1
 8022d26:	602b      	str	r3, [r5, #0]
 8022d28:	f7eb fafe 	bl	800e328 <_close>
 8022d2c:	1c43      	adds	r3, r0, #1
 8022d2e:	d102      	bne.n	8022d36 <_close_r+0x1a>
 8022d30:	682b      	ldr	r3, [r5, #0]
 8022d32:	b103      	cbz	r3, 8022d36 <_close_r+0x1a>
 8022d34:	6023      	str	r3, [r4, #0]
 8022d36:	bd38      	pop	{r3, r4, r5, pc}
 8022d38:	20004980 	.word	0x20004980

08022d3c <_lseek_r>:
 8022d3c:	b538      	push	{r3, r4, r5, lr}
 8022d3e:	4d07      	ldr	r5, [pc, #28]	; (8022d5c <_lseek_r+0x20>)
 8022d40:	4604      	mov	r4, r0
 8022d42:	4608      	mov	r0, r1
 8022d44:	4611      	mov	r1, r2
 8022d46:	2200      	movs	r2, #0
 8022d48:	602a      	str	r2, [r5, #0]
 8022d4a:	461a      	mov	r2, r3
 8022d4c:	f7eb faf6 	bl	800e33c <_lseek>
 8022d50:	1c43      	adds	r3, r0, #1
 8022d52:	d102      	bne.n	8022d5a <_lseek_r+0x1e>
 8022d54:	682b      	ldr	r3, [r5, #0]
 8022d56:	b103      	cbz	r3, 8022d5a <_lseek_r+0x1e>
 8022d58:	6023      	str	r3, [r4, #0]
 8022d5a:	bd38      	pop	{r3, r4, r5, pc}
 8022d5c:	20004980 	.word	0x20004980

08022d60 <_read_r>:
 8022d60:	b538      	push	{r3, r4, r5, lr}
 8022d62:	4d07      	ldr	r5, [pc, #28]	; (8022d80 <_read_r+0x20>)
 8022d64:	4604      	mov	r4, r0
 8022d66:	4608      	mov	r0, r1
 8022d68:	4611      	mov	r1, r2
 8022d6a:	2200      	movs	r2, #0
 8022d6c:	602a      	str	r2, [r5, #0]
 8022d6e:	461a      	mov	r2, r3
 8022d70:	f7eb fabc 	bl	800e2ec <_read>
 8022d74:	1c43      	adds	r3, r0, #1
 8022d76:	d102      	bne.n	8022d7e <_read_r+0x1e>
 8022d78:	682b      	ldr	r3, [r5, #0]
 8022d7a:	b103      	cbz	r3, 8022d7e <_read_r+0x1e>
 8022d7c:	6023      	str	r3, [r4, #0]
 8022d7e:	bd38      	pop	{r3, r4, r5, pc}
 8022d80:	20004980 	.word	0x20004980

08022d84 <_sbrk_r>:
 8022d84:	b538      	push	{r3, r4, r5, lr}
 8022d86:	4d06      	ldr	r5, [pc, #24]	; (8022da0 <_sbrk_r+0x1c>)
 8022d88:	2300      	movs	r3, #0
 8022d8a:	4604      	mov	r4, r0
 8022d8c:	4608      	mov	r0, r1
 8022d8e:	602b      	str	r3, [r5, #0]
 8022d90:	f7eb fad6 	bl	800e340 <_sbrk>
 8022d94:	1c43      	adds	r3, r0, #1
 8022d96:	d102      	bne.n	8022d9e <_sbrk_r+0x1a>
 8022d98:	682b      	ldr	r3, [r5, #0]
 8022d9a:	b103      	cbz	r3, 8022d9e <_sbrk_r+0x1a>
 8022d9c:	6023      	str	r3, [r4, #0]
 8022d9e:	bd38      	pop	{r3, r4, r5, pc}
 8022da0:	20004980 	.word	0x20004980

08022da4 <_write_r>:
 8022da4:	b538      	push	{r3, r4, r5, lr}
 8022da6:	4d07      	ldr	r5, [pc, #28]	; (8022dc4 <_write_r+0x20>)
 8022da8:	4604      	mov	r4, r0
 8022daa:	4608      	mov	r0, r1
 8022dac:	4611      	mov	r1, r2
 8022dae:	2200      	movs	r2, #0
 8022db0:	602a      	str	r2, [r5, #0]
 8022db2:	461a      	mov	r2, r3
 8022db4:	f7eb faaa 	bl	800e30c <_write>
 8022db8:	1c43      	adds	r3, r0, #1
 8022dba:	d102      	bne.n	8022dc2 <_write_r+0x1e>
 8022dbc:	682b      	ldr	r3, [r5, #0]
 8022dbe:	b103      	cbz	r3, 8022dc2 <_write_r+0x1e>
 8022dc0:	6023      	str	r3, [r4, #0]
 8022dc2:	bd38      	pop	{r3, r4, r5, pc}
 8022dc4:	20004980 	.word	0x20004980

08022dc8 <__errno>:
 8022dc8:	4b01      	ldr	r3, [pc, #4]	; (8022dd0 <__errno+0x8>)
 8022dca:	6818      	ldr	r0, [r3, #0]
 8022dcc:	4770      	bx	lr
 8022dce:	bf00      	nop
 8022dd0:	2000062c 	.word	0x2000062c

08022dd4 <__libc_init_array>:
 8022dd4:	b570      	push	{r4, r5, r6, lr}
 8022dd6:	4d0d      	ldr	r5, [pc, #52]	; (8022e0c <__libc_init_array+0x38>)
 8022dd8:	4c0d      	ldr	r4, [pc, #52]	; (8022e10 <__libc_init_array+0x3c>)
 8022dda:	1b64      	subs	r4, r4, r5
 8022ddc:	10a4      	asrs	r4, r4, #2
 8022dde:	2600      	movs	r6, #0
 8022de0:	42a6      	cmp	r6, r4
 8022de2:	d109      	bne.n	8022df8 <__libc_init_array+0x24>
 8022de4:	4d0b      	ldr	r5, [pc, #44]	; (8022e14 <__libc_init_array+0x40>)
 8022de6:	4c0c      	ldr	r4, [pc, #48]	; (8022e18 <__libc_init_array+0x44>)
 8022de8:	f002 fab6 	bl	8025358 <_init>
 8022dec:	1b64      	subs	r4, r4, r5
 8022dee:	10a4      	asrs	r4, r4, #2
 8022df0:	2600      	movs	r6, #0
 8022df2:	42a6      	cmp	r6, r4
 8022df4:	d105      	bne.n	8022e02 <__libc_init_array+0x2e>
 8022df6:	bd70      	pop	{r4, r5, r6, pc}
 8022df8:	f855 3b04 	ldr.w	r3, [r5], #4
 8022dfc:	4798      	blx	r3
 8022dfe:	3601      	adds	r6, #1
 8022e00:	e7ee      	b.n	8022de0 <__libc_init_array+0xc>
 8022e02:	f855 3b04 	ldr.w	r3, [r5], #4
 8022e06:	4798      	blx	r3
 8022e08:	3601      	adds	r6, #1
 8022e0a:	e7f2      	b.n	8022df2 <__libc_init_array+0x1e>
 8022e0c:	0802d660 	.word	0x0802d660
 8022e10:	0802d660 	.word	0x0802d660
 8022e14:	0802d660 	.word	0x0802d660
 8022e18:	0802d664 	.word	0x0802d664

08022e1c <__retarget_lock_acquire_recursive>:
 8022e1c:	4770      	bx	lr

08022e1e <__retarget_lock_release_recursive>:
 8022e1e:	4770      	bx	lr

08022e20 <strcpy>:
 8022e20:	4603      	mov	r3, r0
 8022e22:	f811 2b01 	ldrb.w	r2, [r1], #1
 8022e26:	f803 2b01 	strb.w	r2, [r3], #1
 8022e2a:	2a00      	cmp	r2, #0
 8022e2c:	d1f9      	bne.n	8022e22 <strcpy+0x2>
 8022e2e:	4770      	bx	lr

08022e30 <memcpy>:
 8022e30:	440a      	add	r2, r1
 8022e32:	4291      	cmp	r1, r2
 8022e34:	f100 33ff 	add.w	r3, r0, #4294967295
 8022e38:	d100      	bne.n	8022e3c <memcpy+0xc>
 8022e3a:	4770      	bx	lr
 8022e3c:	b510      	push	{r4, lr}
 8022e3e:	f811 4b01 	ldrb.w	r4, [r1], #1
 8022e42:	f803 4f01 	strb.w	r4, [r3, #1]!
 8022e46:	4291      	cmp	r1, r2
 8022e48:	d1f9      	bne.n	8022e3e <memcpy+0xe>
 8022e4a:	bd10      	pop	{r4, pc}

08022e4c <abort>:
 8022e4c:	b508      	push	{r3, lr}
 8022e4e:	2006      	movs	r0, #6
 8022e50:	f000 fcc4 	bl	80237dc <raise>
 8022e54:	2001      	movs	r0, #1
 8022e56:	f7eb fa43 	bl	800e2e0 <_exit>
	...

08022e5c <_free_r>:
 8022e5c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8022e5e:	2900      	cmp	r1, #0
 8022e60:	d044      	beq.n	8022eec <_free_r+0x90>
 8022e62:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8022e66:	9001      	str	r0, [sp, #4]
 8022e68:	2b00      	cmp	r3, #0
 8022e6a:	f1a1 0404 	sub.w	r4, r1, #4
 8022e6e:	bfb8      	it	lt
 8022e70:	18e4      	addlt	r4, r4, r3
 8022e72:	f7ff fbcd 	bl	8022610 <__malloc_lock>
 8022e76:	4a1e      	ldr	r2, [pc, #120]	; (8022ef0 <_free_r+0x94>)
 8022e78:	9801      	ldr	r0, [sp, #4]
 8022e7a:	6813      	ldr	r3, [r2, #0]
 8022e7c:	b933      	cbnz	r3, 8022e8c <_free_r+0x30>
 8022e7e:	6063      	str	r3, [r4, #4]
 8022e80:	6014      	str	r4, [r2, #0]
 8022e82:	b003      	add	sp, #12
 8022e84:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8022e88:	f7ff bbc8 	b.w	802261c <__malloc_unlock>
 8022e8c:	42a3      	cmp	r3, r4
 8022e8e:	d908      	bls.n	8022ea2 <_free_r+0x46>
 8022e90:	6825      	ldr	r5, [r4, #0]
 8022e92:	1961      	adds	r1, r4, r5
 8022e94:	428b      	cmp	r3, r1
 8022e96:	bf01      	itttt	eq
 8022e98:	6819      	ldreq	r1, [r3, #0]
 8022e9a:	685b      	ldreq	r3, [r3, #4]
 8022e9c:	1949      	addeq	r1, r1, r5
 8022e9e:	6021      	streq	r1, [r4, #0]
 8022ea0:	e7ed      	b.n	8022e7e <_free_r+0x22>
 8022ea2:	461a      	mov	r2, r3
 8022ea4:	685b      	ldr	r3, [r3, #4]
 8022ea6:	b10b      	cbz	r3, 8022eac <_free_r+0x50>
 8022ea8:	42a3      	cmp	r3, r4
 8022eaa:	d9fa      	bls.n	8022ea2 <_free_r+0x46>
 8022eac:	6811      	ldr	r1, [r2, #0]
 8022eae:	1855      	adds	r5, r2, r1
 8022eb0:	42a5      	cmp	r5, r4
 8022eb2:	d10b      	bne.n	8022ecc <_free_r+0x70>
 8022eb4:	6824      	ldr	r4, [r4, #0]
 8022eb6:	4421      	add	r1, r4
 8022eb8:	1854      	adds	r4, r2, r1
 8022eba:	42a3      	cmp	r3, r4
 8022ebc:	6011      	str	r1, [r2, #0]
 8022ebe:	d1e0      	bne.n	8022e82 <_free_r+0x26>
 8022ec0:	681c      	ldr	r4, [r3, #0]
 8022ec2:	685b      	ldr	r3, [r3, #4]
 8022ec4:	6053      	str	r3, [r2, #4]
 8022ec6:	440c      	add	r4, r1
 8022ec8:	6014      	str	r4, [r2, #0]
 8022eca:	e7da      	b.n	8022e82 <_free_r+0x26>
 8022ecc:	d902      	bls.n	8022ed4 <_free_r+0x78>
 8022ece:	230c      	movs	r3, #12
 8022ed0:	6003      	str	r3, [r0, #0]
 8022ed2:	e7d6      	b.n	8022e82 <_free_r+0x26>
 8022ed4:	6825      	ldr	r5, [r4, #0]
 8022ed6:	1961      	adds	r1, r4, r5
 8022ed8:	428b      	cmp	r3, r1
 8022eda:	bf04      	itt	eq
 8022edc:	6819      	ldreq	r1, [r3, #0]
 8022ede:	685b      	ldreq	r3, [r3, #4]
 8022ee0:	6063      	str	r3, [r4, #4]
 8022ee2:	bf04      	itt	eq
 8022ee4:	1949      	addeq	r1, r1, r5
 8022ee6:	6021      	streq	r1, [r4, #0]
 8022ee8:	6054      	str	r4, [r2, #4]
 8022eea:	e7ca      	b.n	8022e82 <_free_r+0x26>
 8022eec:	b003      	add	sp, #12
 8022eee:	bd30      	pop	{r4, r5, pc}
 8022ef0:	2000483c 	.word	0x2000483c

08022ef4 <_mallinfo_r>:
 8022ef4:	b570      	push	{r4, r5, r6, lr}
 8022ef6:	4c16      	ldr	r4, [pc, #88]	; (8022f50 <_mallinfo_r+0x5c>)
 8022ef8:	4605      	mov	r5, r0
 8022efa:	4608      	mov	r0, r1
 8022efc:	460e      	mov	r6, r1
 8022efe:	f7ff fb87 	bl	8022610 <__malloc_lock>
 8022f02:	6823      	ldr	r3, [r4, #0]
 8022f04:	b14b      	cbz	r3, 8022f1a <_mallinfo_r+0x26>
 8022f06:	2100      	movs	r1, #0
 8022f08:	4630      	mov	r0, r6
 8022f0a:	f7ff ff3b 	bl	8022d84 <_sbrk_r>
 8022f0e:	1c42      	adds	r2, r0, #1
 8022f10:	bf18      	it	ne
 8022f12:	6822      	ldrne	r2, [r4, #0]
 8022f14:	4603      	mov	r3, r0
 8022f16:	bf18      	it	ne
 8022f18:	1a83      	subne	r3, r0, r2
 8022f1a:	4a0e      	ldr	r2, [pc, #56]	; (8022f54 <_mallinfo_r+0x60>)
 8022f1c:	6811      	ldr	r1, [r2, #0]
 8022f1e:	2200      	movs	r2, #0
 8022f20:	b991      	cbnz	r1, 8022f48 <_mallinfo_r+0x54>
 8022f22:	4c0d      	ldr	r4, [pc, #52]	; (8022f58 <_mallinfo_r+0x64>)
 8022f24:	4630      	mov	r0, r6
 8022f26:	6023      	str	r3, [r4, #0]
 8022f28:	1a9b      	subs	r3, r3, r2
 8022f2a:	6222      	str	r2, [r4, #32]
 8022f2c:	61e3      	str	r3, [r4, #28]
 8022f2e:	f7ff fb75 	bl	802261c <__malloc_unlock>
 8022f32:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8022f34:	462e      	mov	r6, r5
 8022f36:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8022f38:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8022f3a:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8022f3c:	e894 0003 	ldmia.w	r4, {r0, r1}
 8022f40:	e886 0003 	stmia.w	r6, {r0, r1}
 8022f44:	4628      	mov	r0, r5
 8022f46:	bd70      	pop	{r4, r5, r6, pc}
 8022f48:	6808      	ldr	r0, [r1, #0]
 8022f4a:	6849      	ldr	r1, [r1, #4]
 8022f4c:	4402      	add	r2, r0
 8022f4e:	e7e7      	b.n	8022f20 <_mallinfo_r+0x2c>
 8022f50:	20004840 	.word	0x20004840
 8022f54:	2000483c 	.word	0x2000483c
 8022f58:	20004988 	.word	0x20004988

08022f5c <__sfputc_r>:
 8022f5c:	6893      	ldr	r3, [r2, #8]
 8022f5e:	3b01      	subs	r3, #1
 8022f60:	2b00      	cmp	r3, #0
 8022f62:	b410      	push	{r4}
 8022f64:	6093      	str	r3, [r2, #8]
 8022f66:	da08      	bge.n	8022f7a <__sfputc_r+0x1e>
 8022f68:	6994      	ldr	r4, [r2, #24]
 8022f6a:	42a3      	cmp	r3, r4
 8022f6c:	db01      	blt.n	8022f72 <__sfputc_r+0x16>
 8022f6e:	290a      	cmp	r1, #10
 8022f70:	d103      	bne.n	8022f7a <__sfputc_r+0x1e>
 8022f72:	f85d 4b04 	ldr.w	r4, [sp], #4
 8022f76:	f000 bb73 	b.w	8023660 <__swbuf_r>
 8022f7a:	6813      	ldr	r3, [r2, #0]
 8022f7c:	1c58      	adds	r0, r3, #1
 8022f7e:	6010      	str	r0, [r2, #0]
 8022f80:	7019      	strb	r1, [r3, #0]
 8022f82:	4608      	mov	r0, r1
 8022f84:	f85d 4b04 	ldr.w	r4, [sp], #4
 8022f88:	4770      	bx	lr

08022f8a <__sfputs_r>:
 8022f8a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8022f8c:	4606      	mov	r6, r0
 8022f8e:	460f      	mov	r7, r1
 8022f90:	4614      	mov	r4, r2
 8022f92:	18d5      	adds	r5, r2, r3
 8022f94:	42ac      	cmp	r4, r5
 8022f96:	d101      	bne.n	8022f9c <__sfputs_r+0x12>
 8022f98:	2000      	movs	r0, #0
 8022f9a:	e007      	b.n	8022fac <__sfputs_r+0x22>
 8022f9c:	f814 1b01 	ldrb.w	r1, [r4], #1
 8022fa0:	463a      	mov	r2, r7
 8022fa2:	4630      	mov	r0, r6
 8022fa4:	f7ff ffda 	bl	8022f5c <__sfputc_r>
 8022fa8:	1c43      	adds	r3, r0, #1
 8022faa:	d1f3      	bne.n	8022f94 <__sfputs_r+0xa>
 8022fac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08022fb0 <_vfiprintf_r>:
 8022fb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8022fb4:	460d      	mov	r5, r1
 8022fb6:	b09d      	sub	sp, #116	; 0x74
 8022fb8:	4614      	mov	r4, r2
 8022fba:	4698      	mov	r8, r3
 8022fbc:	4606      	mov	r6, r0
 8022fbe:	b118      	cbz	r0, 8022fc8 <_vfiprintf_r+0x18>
 8022fc0:	6a03      	ldr	r3, [r0, #32]
 8022fc2:	b90b      	cbnz	r3, 8022fc8 <_vfiprintf_r+0x18>
 8022fc4:	f7ff fd3c 	bl	8022a40 <__sinit>
 8022fc8:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8022fca:	07d9      	lsls	r1, r3, #31
 8022fcc:	d405      	bmi.n	8022fda <_vfiprintf_r+0x2a>
 8022fce:	89ab      	ldrh	r3, [r5, #12]
 8022fd0:	059a      	lsls	r2, r3, #22
 8022fd2:	d402      	bmi.n	8022fda <_vfiprintf_r+0x2a>
 8022fd4:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8022fd6:	f7ff ff21 	bl	8022e1c <__retarget_lock_acquire_recursive>
 8022fda:	89ab      	ldrh	r3, [r5, #12]
 8022fdc:	071b      	lsls	r3, r3, #28
 8022fde:	d501      	bpl.n	8022fe4 <_vfiprintf_r+0x34>
 8022fe0:	692b      	ldr	r3, [r5, #16]
 8022fe2:	b99b      	cbnz	r3, 802300c <_vfiprintf_r+0x5c>
 8022fe4:	4629      	mov	r1, r5
 8022fe6:	4630      	mov	r0, r6
 8022fe8:	f000 fb78 	bl	80236dc <__swsetup_r>
 8022fec:	b170      	cbz	r0, 802300c <_vfiprintf_r+0x5c>
 8022fee:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8022ff0:	07dc      	lsls	r4, r3, #31
 8022ff2:	d504      	bpl.n	8022ffe <_vfiprintf_r+0x4e>
 8022ff4:	f04f 30ff 	mov.w	r0, #4294967295
 8022ff8:	b01d      	add	sp, #116	; 0x74
 8022ffa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8022ffe:	89ab      	ldrh	r3, [r5, #12]
 8023000:	0598      	lsls	r0, r3, #22
 8023002:	d4f7      	bmi.n	8022ff4 <_vfiprintf_r+0x44>
 8023004:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8023006:	f7ff ff0a 	bl	8022e1e <__retarget_lock_release_recursive>
 802300a:	e7f3      	b.n	8022ff4 <_vfiprintf_r+0x44>
 802300c:	2300      	movs	r3, #0
 802300e:	9309      	str	r3, [sp, #36]	; 0x24
 8023010:	2320      	movs	r3, #32
 8023012:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8023016:	f8cd 800c 	str.w	r8, [sp, #12]
 802301a:	2330      	movs	r3, #48	; 0x30
 802301c:	f8df 81b0 	ldr.w	r8, [pc, #432]	; 80231d0 <_vfiprintf_r+0x220>
 8023020:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8023024:	f04f 0901 	mov.w	r9, #1
 8023028:	4623      	mov	r3, r4
 802302a:	469a      	mov	sl, r3
 802302c:	f813 2b01 	ldrb.w	r2, [r3], #1
 8023030:	b10a      	cbz	r2, 8023036 <_vfiprintf_r+0x86>
 8023032:	2a25      	cmp	r2, #37	; 0x25
 8023034:	d1f9      	bne.n	802302a <_vfiprintf_r+0x7a>
 8023036:	ebba 0b04 	subs.w	fp, sl, r4
 802303a:	d00b      	beq.n	8023054 <_vfiprintf_r+0xa4>
 802303c:	465b      	mov	r3, fp
 802303e:	4622      	mov	r2, r4
 8023040:	4629      	mov	r1, r5
 8023042:	4630      	mov	r0, r6
 8023044:	f7ff ffa1 	bl	8022f8a <__sfputs_r>
 8023048:	3001      	adds	r0, #1
 802304a:	f000 80a9 	beq.w	80231a0 <_vfiprintf_r+0x1f0>
 802304e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8023050:	445a      	add	r2, fp
 8023052:	9209      	str	r2, [sp, #36]	; 0x24
 8023054:	f89a 3000 	ldrb.w	r3, [sl]
 8023058:	2b00      	cmp	r3, #0
 802305a:	f000 80a1 	beq.w	80231a0 <_vfiprintf_r+0x1f0>
 802305e:	2300      	movs	r3, #0
 8023060:	f04f 32ff 	mov.w	r2, #4294967295
 8023064:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8023068:	f10a 0a01 	add.w	sl, sl, #1
 802306c:	9304      	str	r3, [sp, #16]
 802306e:	9307      	str	r3, [sp, #28]
 8023070:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8023074:	931a      	str	r3, [sp, #104]	; 0x68
 8023076:	4654      	mov	r4, sl
 8023078:	2205      	movs	r2, #5
 802307a:	f814 1b01 	ldrb.w	r1, [r4], #1
 802307e:	4854      	ldr	r0, [pc, #336]	; (80231d0 <_vfiprintf_r+0x220>)
 8023080:	f7e4 fff6 	bl	8008070 <memchr>
 8023084:	9a04      	ldr	r2, [sp, #16]
 8023086:	b9d8      	cbnz	r0, 80230c0 <_vfiprintf_r+0x110>
 8023088:	06d1      	lsls	r1, r2, #27
 802308a:	bf44      	itt	mi
 802308c:	2320      	movmi	r3, #32
 802308e:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8023092:	0713      	lsls	r3, r2, #28
 8023094:	bf44      	itt	mi
 8023096:	232b      	movmi	r3, #43	; 0x2b
 8023098:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 802309c:	f89a 3000 	ldrb.w	r3, [sl]
 80230a0:	2b2a      	cmp	r3, #42	; 0x2a
 80230a2:	d015      	beq.n	80230d0 <_vfiprintf_r+0x120>
 80230a4:	9a07      	ldr	r2, [sp, #28]
 80230a6:	4654      	mov	r4, sl
 80230a8:	2000      	movs	r0, #0
 80230aa:	f04f 0c0a 	mov.w	ip, #10
 80230ae:	4621      	mov	r1, r4
 80230b0:	f811 3b01 	ldrb.w	r3, [r1], #1
 80230b4:	3b30      	subs	r3, #48	; 0x30
 80230b6:	2b09      	cmp	r3, #9
 80230b8:	d94d      	bls.n	8023156 <_vfiprintf_r+0x1a6>
 80230ba:	b1b0      	cbz	r0, 80230ea <_vfiprintf_r+0x13a>
 80230bc:	9207      	str	r2, [sp, #28]
 80230be:	e014      	b.n	80230ea <_vfiprintf_r+0x13a>
 80230c0:	eba0 0308 	sub.w	r3, r0, r8
 80230c4:	fa09 f303 	lsl.w	r3, r9, r3
 80230c8:	4313      	orrs	r3, r2
 80230ca:	9304      	str	r3, [sp, #16]
 80230cc:	46a2      	mov	sl, r4
 80230ce:	e7d2      	b.n	8023076 <_vfiprintf_r+0xc6>
 80230d0:	9b03      	ldr	r3, [sp, #12]
 80230d2:	1d19      	adds	r1, r3, #4
 80230d4:	681b      	ldr	r3, [r3, #0]
 80230d6:	9103      	str	r1, [sp, #12]
 80230d8:	2b00      	cmp	r3, #0
 80230da:	bfbb      	ittet	lt
 80230dc:	425b      	neglt	r3, r3
 80230de:	f042 0202 	orrlt.w	r2, r2, #2
 80230e2:	9307      	strge	r3, [sp, #28]
 80230e4:	9307      	strlt	r3, [sp, #28]
 80230e6:	bfb8      	it	lt
 80230e8:	9204      	strlt	r2, [sp, #16]
 80230ea:	7823      	ldrb	r3, [r4, #0]
 80230ec:	2b2e      	cmp	r3, #46	; 0x2e
 80230ee:	d10c      	bne.n	802310a <_vfiprintf_r+0x15a>
 80230f0:	7863      	ldrb	r3, [r4, #1]
 80230f2:	2b2a      	cmp	r3, #42	; 0x2a
 80230f4:	d134      	bne.n	8023160 <_vfiprintf_r+0x1b0>
 80230f6:	9b03      	ldr	r3, [sp, #12]
 80230f8:	1d1a      	adds	r2, r3, #4
 80230fa:	681b      	ldr	r3, [r3, #0]
 80230fc:	9203      	str	r2, [sp, #12]
 80230fe:	2b00      	cmp	r3, #0
 8023100:	bfb8      	it	lt
 8023102:	f04f 33ff 	movlt.w	r3, #4294967295
 8023106:	3402      	adds	r4, #2
 8023108:	9305      	str	r3, [sp, #20]
 802310a:	f8df a0d4 	ldr.w	sl, [pc, #212]	; 80231e0 <_vfiprintf_r+0x230>
 802310e:	7821      	ldrb	r1, [r4, #0]
 8023110:	2203      	movs	r2, #3
 8023112:	4650      	mov	r0, sl
 8023114:	f7e4 ffac 	bl	8008070 <memchr>
 8023118:	b138      	cbz	r0, 802312a <_vfiprintf_r+0x17a>
 802311a:	9b04      	ldr	r3, [sp, #16]
 802311c:	eba0 000a 	sub.w	r0, r0, sl
 8023120:	2240      	movs	r2, #64	; 0x40
 8023122:	4082      	lsls	r2, r0
 8023124:	4313      	orrs	r3, r2
 8023126:	3401      	adds	r4, #1
 8023128:	9304      	str	r3, [sp, #16]
 802312a:	f814 1b01 	ldrb.w	r1, [r4], #1
 802312e:	4829      	ldr	r0, [pc, #164]	; (80231d4 <_vfiprintf_r+0x224>)
 8023130:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8023134:	2206      	movs	r2, #6
 8023136:	f7e4 ff9b 	bl	8008070 <memchr>
 802313a:	2800      	cmp	r0, #0
 802313c:	d03f      	beq.n	80231be <_vfiprintf_r+0x20e>
 802313e:	4b26      	ldr	r3, [pc, #152]	; (80231d8 <_vfiprintf_r+0x228>)
 8023140:	bb1b      	cbnz	r3, 802318a <_vfiprintf_r+0x1da>
 8023142:	9b03      	ldr	r3, [sp, #12]
 8023144:	3307      	adds	r3, #7
 8023146:	f023 0307 	bic.w	r3, r3, #7
 802314a:	3308      	adds	r3, #8
 802314c:	9303      	str	r3, [sp, #12]
 802314e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8023150:	443b      	add	r3, r7
 8023152:	9309      	str	r3, [sp, #36]	; 0x24
 8023154:	e768      	b.n	8023028 <_vfiprintf_r+0x78>
 8023156:	fb0c 3202 	mla	r2, ip, r2, r3
 802315a:	460c      	mov	r4, r1
 802315c:	2001      	movs	r0, #1
 802315e:	e7a6      	b.n	80230ae <_vfiprintf_r+0xfe>
 8023160:	2300      	movs	r3, #0
 8023162:	3401      	adds	r4, #1
 8023164:	9305      	str	r3, [sp, #20]
 8023166:	4619      	mov	r1, r3
 8023168:	f04f 0c0a 	mov.w	ip, #10
 802316c:	4620      	mov	r0, r4
 802316e:	f810 2b01 	ldrb.w	r2, [r0], #1
 8023172:	3a30      	subs	r2, #48	; 0x30
 8023174:	2a09      	cmp	r2, #9
 8023176:	d903      	bls.n	8023180 <_vfiprintf_r+0x1d0>
 8023178:	2b00      	cmp	r3, #0
 802317a:	d0c6      	beq.n	802310a <_vfiprintf_r+0x15a>
 802317c:	9105      	str	r1, [sp, #20]
 802317e:	e7c4      	b.n	802310a <_vfiprintf_r+0x15a>
 8023180:	fb0c 2101 	mla	r1, ip, r1, r2
 8023184:	4604      	mov	r4, r0
 8023186:	2301      	movs	r3, #1
 8023188:	e7f0      	b.n	802316c <_vfiprintf_r+0x1bc>
 802318a:	ab03      	add	r3, sp, #12
 802318c:	9300      	str	r3, [sp, #0]
 802318e:	462a      	mov	r2, r5
 8023190:	4b12      	ldr	r3, [pc, #72]	; (80231dc <_vfiprintf_r+0x22c>)
 8023192:	a904      	add	r1, sp, #16
 8023194:	4630      	mov	r0, r6
 8023196:	f3af 8000 	nop.w
 802319a:	4607      	mov	r7, r0
 802319c:	1c78      	adds	r0, r7, #1
 802319e:	d1d6      	bne.n	802314e <_vfiprintf_r+0x19e>
 80231a0:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 80231a2:	07d9      	lsls	r1, r3, #31
 80231a4:	d405      	bmi.n	80231b2 <_vfiprintf_r+0x202>
 80231a6:	89ab      	ldrh	r3, [r5, #12]
 80231a8:	059a      	lsls	r2, r3, #22
 80231aa:	d402      	bmi.n	80231b2 <_vfiprintf_r+0x202>
 80231ac:	6da8      	ldr	r0, [r5, #88]	; 0x58
 80231ae:	f7ff fe36 	bl	8022e1e <__retarget_lock_release_recursive>
 80231b2:	89ab      	ldrh	r3, [r5, #12]
 80231b4:	065b      	lsls	r3, r3, #25
 80231b6:	f53f af1d 	bmi.w	8022ff4 <_vfiprintf_r+0x44>
 80231ba:	9809      	ldr	r0, [sp, #36]	; 0x24
 80231bc:	e71c      	b.n	8022ff8 <_vfiprintf_r+0x48>
 80231be:	ab03      	add	r3, sp, #12
 80231c0:	9300      	str	r3, [sp, #0]
 80231c2:	462a      	mov	r2, r5
 80231c4:	4b05      	ldr	r3, [pc, #20]	; (80231dc <_vfiprintf_r+0x22c>)
 80231c6:	a904      	add	r1, sp, #16
 80231c8:	4630      	mov	r0, r6
 80231ca:	f000 f879 	bl	80232c0 <_printf_i>
 80231ce:	e7e4      	b.n	802319a <_vfiprintf_r+0x1ea>
 80231d0:	0802d1c6 	.word	0x0802d1c6
 80231d4:	0802d1d0 	.word	0x0802d1d0
 80231d8:	00000000 	.word	0x00000000
 80231dc:	08022f8b 	.word	0x08022f8b
 80231e0:	0802d1cc 	.word	0x0802d1cc

080231e4 <_printf_common>:
 80231e4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80231e8:	4616      	mov	r6, r2
 80231ea:	4699      	mov	r9, r3
 80231ec:	688a      	ldr	r2, [r1, #8]
 80231ee:	690b      	ldr	r3, [r1, #16]
 80231f0:	f8dd 8020 	ldr.w	r8, [sp, #32]
 80231f4:	4293      	cmp	r3, r2
 80231f6:	bfb8      	it	lt
 80231f8:	4613      	movlt	r3, r2
 80231fa:	6033      	str	r3, [r6, #0]
 80231fc:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 8023200:	4607      	mov	r7, r0
 8023202:	460c      	mov	r4, r1
 8023204:	b10a      	cbz	r2, 802320a <_printf_common+0x26>
 8023206:	3301      	adds	r3, #1
 8023208:	6033      	str	r3, [r6, #0]
 802320a:	6823      	ldr	r3, [r4, #0]
 802320c:	0699      	lsls	r1, r3, #26
 802320e:	bf42      	ittt	mi
 8023210:	6833      	ldrmi	r3, [r6, #0]
 8023212:	3302      	addmi	r3, #2
 8023214:	6033      	strmi	r3, [r6, #0]
 8023216:	6825      	ldr	r5, [r4, #0]
 8023218:	f015 0506 	ands.w	r5, r5, #6
 802321c:	d106      	bne.n	802322c <_printf_common+0x48>
 802321e:	f104 0a19 	add.w	sl, r4, #25
 8023222:	68e3      	ldr	r3, [r4, #12]
 8023224:	6832      	ldr	r2, [r6, #0]
 8023226:	1a9b      	subs	r3, r3, r2
 8023228:	42ab      	cmp	r3, r5
 802322a:	dc26      	bgt.n	802327a <_printf_common+0x96>
 802322c:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 8023230:	1e13      	subs	r3, r2, #0
 8023232:	6822      	ldr	r2, [r4, #0]
 8023234:	bf18      	it	ne
 8023236:	2301      	movne	r3, #1
 8023238:	0692      	lsls	r2, r2, #26
 802323a:	d42b      	bmi.n	8023294 <_printf_common+0xb0>
 802323c:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8023240:	4649      	mov	r1, r9
 8023242:	4638      	mov	r0, r7
 8023244:	47c0      	blx	r8
 8023246:	3001      	adds	r0, #1
 8023248:	d01e      	beq.n	8023288 <_printf_common+0xa4>
 802324a:	6823      	ldr	r3, [r4, #0]
 802324c:	6922      	ldr	r2, [r4, #16]
 802324e:	f003 0306 	and.w	r3, r3, #6
 8023252:	2b04      	cmp	r3, #4
 8023254:	bf02      	ittt	eq
 8023256:	68e5      	ldreq	r5, [r4, #12]
 8023258:	6833      	ldreq	r3, [r6, #0]
 802325a:	1aed      	subeq	r5, r5, r3
 802325c:	68a3      	ldr	r3, [r4, #8]
 802325e:	bf0c      	ite	eq
 8023260:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8023264:	2500      	movne	r5, #0
 8023266:	4293      	cmp	r3, r2
 8023268:	bfc4      	itt	gt
 802326a:	1a9b      	subgt	r3, r3, r2
 802326c:	18ed      	addgt	r5, r5, r3
 802326e:	2600      	movs	r6, #0
 8023270:	341a      	adds	r4, #26
 8023272:	42b5      	cmp	r5, r6
 8023274:	d11a      	bne.n	80232ac <_printf_common+0xc8>
 8023276:	2000      	movs	r0, #0
 8023278:	e008      	b.n	802328c <_printf_common+0xa8>
 802327a:	2301      	movs	r3, #1
 802327c:	4652      	mov	r2, sl
 802327e:	4649      	mov	r1, r9
 8023280:	4638      	mov	r0, r7
 8023282:	47c0      	blx	r8
 8023284:	3001      	adds	r0, #1
 8023286:	d103      	bne.n	8023290 <_printf_common+0xac>
 8023288:	f04f 30ff 	mov.w	r0, #4294967295
 802328c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8023290:	3501      	adds	r5, #1
 8023292:	e7c6      	b.n	8023222 <_printf_common+0x3e>
 8023294:	18e1      	adds	r1, r4, r3
 8023296:	1c5a      	adds	r2, r3, #1
 8023298:	2030      	movs	r0, #48	; 0x30
 802329a:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 802329e:	4422      	add	r2, r4
 80232a0:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 80232a4:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 80232a8:	3302      	adds	r3, #2
 80232aa:	e7c7      	b.n	802323c <_printf_common+0x58>
 80232ac:	2301      	movs	r3, #1
 80232ae:	4622      	mov	r2, r4
 80232b0:	4649      	mov	r1, r9
 80232b2:	4638      	mov	r0, r7
 80232b4:	47c0      	blx	r8
 80232b6:	3001      	adds	r0, #1
 80232b8:	d0e6      	beq.n	8023288 <_printf_common+0xa4>
 80232ba:	3601      	adds	r6, #1
 80232bc:	e7d9      	b.n	8023272 <_printf_common+0x8e>
	...

080232c0 <_printf_i>:
 80232c0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 80232c4:	7e0f      	ldrb	r7, [r1, #24]
 80232c6:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 80232c8:	2f78      	cmp	r7, #120	; 0x78
 80232ca:	4691      	mov	r9, r2
 80232cc:	4680      	mov	r8, r0
 80232ce:	460c      	mov	r4, r1
 80232d0:	469a      	mov	sl, r3
 80232d2:	f101 0243 	add.w	r2, r1, #67	; 0x43
 80232d6:	d807      	bhi.n	80232e8 <_printf_i+0x28>
 80232d8:	2f62      	cmp	r7, #98	; 0x62
 80232da:	d80a      	bhi.n	80232f2 <_printf_i+0x32>
 80232dc:	2f00      	cmp	r7, #0
 80232de:	f000 80d4 	beq.w	802348a <_printf_i+0x1ca>
 80232e2:	2f58      	cmp	r7, #88	; 0x58
 80232e4:	f000 80c0 	beq.w	8023468 <_printf_i+0x1a8>
 80232e8:	f104 0542 	add.w	r5, r4, #66	; 0x42
 80232ec:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 80232f0:	e03a      	b.n	8023368 <_printf_i+0xa8>
 80232f2:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 80232f6:	2b15      	cmp	r3, #21
 80232f8:	d8f6      	bhi.n	80232e8 <_printf_i+0x28>
 80232fa:	a101      	add	r1, pc, #4	; (adr r1, 8023300 <_printf_i+0x40>)
 80232fc:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8023300:	08023359 	.word	0x08023359
 8023304:	0802336d 	.word	0x0802336d
 8023308:	080232e9 	.word	0x080232e9
 802330c:	080232e9 	.word	0x080232e9
 8023310:	080232e9 	.word	0x080232e9
 8023314:	080232e9 	.word	0x080232e9
 8023318:	0802336d 	.word	0x0802336d
 802331c:	080232e9 	.word	0x080232e9
 8023320:	080232e9 	.word	0x080232e9
 8023324:	080232e9 	.word	0x080232e9
 8023328:	080232e9 	.word	0x080232e9
 802332c:	08023471 	.word	0x08023471
 8023330:	08023399 	.word	0x08023399
 8023334:	0802342b 	.word	0x0802342b
 8023338:	080232e9 	.word	0x080232e9
 802333c:	080232e9 	.word	0x080232e9
 8023340:	08023493 	.word	0x08023493
 8023344:	080232e9 	.word	0x080232e9
 8023348:	08023399 	.word	0x08023399
 802334c:	080232e9 	.word	0x080232e9
 8023350:	080232e9 	.word	0x080232e9
 8023354:	08023433 	.word	0x08023433
 8023358:	682b      	ldr	r3, [r5, #0]
 802335a:	1d1a      	adds	r2, r3, #4
 802335c:	681b      	ldr	r3, [r3, #0]
 802335e:	602a      	str	r2, [r5, #0]
 8023360:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8023364:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8023368:	2301      	movs	r3, #1
 802336a:	e09f      	b.n	80234ac <_printf_i+0x1ec>
 802336c:	6820      	ldr	r0, [r4, #0]
 802336e:	682b      	ldr	r3, [r5, #0]
 8023370:	0607      	lsls	r7, r0, #24
 8023372:	f103 0104 	add.w	r1, r3, #4
 8023376:	6029      	str	r1, [r5, #0]
 8023378:	d501      	bpl.n	802337e <_printf_i+0xbe>
 802337a:	681e      	ldr	r6, [r3, #0]
 802337c:	e003      	b.n	8023386 <_printf_i+0xc6>
 802337e:	0646      	lsls	r6, r0, #25
 8023380:	d5fb      	bpl.n	802337a <_printf_i+0xba>
 8023382:	f9b3 6000 	ldrsh.w	r6, [r3]
 8023386:	2e00      	cmp	r6, #0
 8023388:	da03      	bge.n	8023392 <_printf_i+0xd2>
 802338a:	232d      	movs	r3, #45	; 0x2d
 802338c:	4276      	negs	r6, r6
 802338e:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8023392:	485a      	ldr	r0, [pc, #360]	; (80234fc <_printf_i+0x23c>)
 8023394:	230a      	movs	r3, #10
 8023396:	e012      	b.n	80233be <_printf_i+0xfe>
 8023398:	682b      	ldr	r3, [r5, #0]
 802339a:	6820      	ldr	r0, [r4, #0]
 802339c:	1d19      	adds	r1, r3, #4
 802339e:	6029      	str	r1, [r5, #0]
 80233a0:	0605      	lsls	r5, r0, #24
 80233a2:	d501      	bpl.n	80233a8 <_printf_i+0xe8>
 80233a4:	681e      	ldr	r6, [r3, #0]
 80233a6:	e002      	b.n	80233ae <_printf_i+0xee>
 80233a8:	0641      	lsls	r1, r0, #25
 80233aa:	d5fb      	bpl.n	80233a4 <_printf_i+0xe4>
 80233ac:	881e      	ldrh	r6, [r3, #0]
 80233ae:	4853      	ldr	r0, [pc, #332]	; (80234fc <_printf_i+0x23c>)
 80233b0:	2f6f      	cmp	r7, #111	; 0x6f
 80233b2:	bf0c      	ite	eq
 80233b4:	2308      	moveq	r3, #8
 80233b6:	230a      	movne	r3, #10
 80233b8:	2100      	movs	r1, #0
 80233ba:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 80233be:	6865      	ldr	r5, [r4, #4]
 80233c0:	60a5      	str	r5, [r4, #8]
 80233c2:	2d00      	cmp	r5, #0
 80233c4:	bfa2      	ittt	ge
 80233c6:	6821      	ldrge	r1, [r4, #0]
 80233c8:	f021 0104 	bicge.w	r1, r1, #4
 80233cc:	6021      	strge	r1, [r4, #0]
 80233ce:	b90e      	cbnz	r6, 80233d4 <_printf_i+0x114>
 80233d0:	2d00      	cmp	r5, #0
 80233d2:	d04b      	beq.n	802346c <_printf_i+0x1ac>
 80233d4:	4615      	mov	r5, r2
 80233d6:	fbb6 f1f3 	udiv	r1, r6, r3
 80233da:	fb03 6711 	mls	r7, r3, r1, r6
 80233de:	5dc7      	ldrb	r7, [r0, r7]
 80233e0:	f805 7d01 	strb.w	r7, [r5, #-1]!
 80233e4:	4637      	mov	r7, r6
 80233e6:	42bb      	cmp	r3, r7
 80233e8:	460e      	mov	r6, r1
 80233ea:	d9f4      	bls.n	80233d6 <_printf_i+0x116>
 80233ec:	2b08      	cmp	r3, #8
 80233ee:	d10b      	bne.n	8023408 <_printf_i+0x148>
 80233f0:	6823      	ldr	r3, [r4, #0]
 80233f2:	07de      	lsls	r6, r3, #31
 80233f4:	d508      	bpl.n	8023408 <_printf_i+0x148>
 80233f6:	6923      	ldr	r3, [r4, #16]
 80233f8:	6861      	ldr	r1, [r4, #4]
 80233fa:	4299      	cmp	r1, r3
 80233fc:	bfde      	ittt	le
 80233fe:	2330      	movle	r3, #48	; 0x30
 8023400:	f805 3c01 	strble.w	r3, [r5, #-1]
 8023404:	f105 35ff 	addle.w	r5, r5, #4294967295
 8023408:	1b52      	subs	r2, r2, r5
 802340a:	6122      	str	r2, [r4, #16]
 802340c:	f8cd a000 	str.w	sl, [sp]
 8023410:	464b      	mov	r3, r9
 8023412:	aa03      	add	r2, sp, #12
 8023414:	4621      	mov	r1, r4
 8023416:	4640      	mov	r0, r8
 8023418:	f7ff fee4 	bl	80231e4 <_printf_common>
 802341c:	3001      	adds	r0, #1
 802341e:	d14a      	bne.n	80234b6 <_printf_i+0x1f6>
 8023420:	f04f 30ff 	mov.w	r0, #4294967295
 8023424:	b004      	add	sp, #16
 8023426:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802342a:	6823      	ldr	r3, [r4, #0]
 802342c:	f043 0320 	orr.w	r3, r3, #32
 8023430:	6023      	str	r3, [r4, #0]
 8023432:	4833      	ldr	r0, [pc, #204]	; (8023500 <_printf_i+0x240>)
 8023434:	2778      	movs	r7, #120	; 0x78
 8023436:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
 802343a:	6823      	ldr	r3, [r4, #0]
 802343c:	6829      	ldr	r1, [r5, #0]
 802343e:	061f      	lsls	r7, r3, #24
 8023440:	f851 6b04 	ldr.w	r6, [r1], #4
 8023444:	d402      	bmi.n	802344c <_printf_i+0x18c>
 8023446:	065f      	lsls	r7, r3, #25
 8023448:	bf48      	it	mi
 802344a:	b2b6      	uxthmi	r6, r6
 802344c:	07df      	lsls	r7, r3, #31
 802344e:	bf48      	it	mi
 8023450:	f043 0320 	orrmi.w	r3, r3, #32
 8023454:	6029      	str	r1, [r5, #0]
 8023456:	bf48      	it	mi
 8023458:	6023      	strmi	r3, [r4, #0]
 802345a:	b91e      	cbnz	r6, 8023464 <_printf_i+0x1a4>
 802345c:	6823      	ldr	r3, [r4, #0]
 802345e:	f023 0320 	bic.w	r3, r3, #32
 8023462:	6023      	str	r3, [r4, #0]
 8023464:	2310      	movs	r3, #16
 8023466:	e7a7      	b.n	80233b8 <_printf_i+0xf8>
 8023468:	4824      	ldr	r0, [pc, #144]	; (80234fc <_printf_i+0x23c>)
 802346a:	e7e4      	b.n	8023436 <_printf_i+0x176>
 802346c:	4615      	mov	r5, r2
 802346e:	e7bd      	b.n	80233ec <_printf_i+0x12c>
 8023470:	682b      	ldr	r3, [r5, #0]
 8023472:	6826      	ldr	r6, [r4, #0]
 8023474:	6961      	ldr	r1, [r4, #20]
 8023476:	1d18      	adds	r0, r3, #4
 8023478:	6028      	str	r0, [r5, #0]
 802347a:	0635      	lsls	r5, r6, #24
 802347c:	681b      	ldr	r3, [r3, #0]
 802347e:	d501      	bpl.n	8023484 <_printf_i+0x1c4>
 8023480:	6019      	str	r1, [r3, #0]
 8023482:	e002      	b.n	802348a <_printf_i+0x1ca>
 8023484:	0670      	lsls	r0, r6, #25
 8023486:	d5fb      	bpl.n	8023480 <_printf_i+0x1c0>
 8023488:	8019      	strh	r1, [r3, #0]
 802348a:	2300      	movs	r3, #0
 802348c:	6123      	str	r3, [r4, #16]
 802348e:	4615      	mov	r5, r2
 8023490:	e7bc      	b.n	802340c <_printf_i+0x14c>
 8023492:	682b      	ldr	r3, [r5, #0]
 8023494:	1d1a      	adds	r2, r3, #4
 8023496:	602a      	str	r2, [r5, #0]
 8023498:	681d      	ldr	r5, [r3, #0]
 802349a:	6862      	ldr	r2, [r4, #4]
 802349c:	2100      	movs	r1, #0
 802349e:	4628      	mov	r0, r5
 80234a0:	f7e4 fde6 	bl	8008070 <memchr>
 80234a4:	b108      	cbz	r0, 80234aa <_printf_i+0x1ea>
 80234a6:	1b40      	subs	r0, r0, r5
 80234a8:	6060      	str	r0, [r4, #4]
 80234aa:	6863      	ldr	r3, [r4, #4]
 80234ac:	6123      	str	r3, [r4, #16]
 80234ae:	2300      	movs	r3, #0
 80234b0:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 80234b4:	e7aa      	b.n	802340c <_printf_i+0x14c>
 80234b6:	6923      	ldr	r3, [r4, #16]
 80234b8:	462a      	mov	r2, r5
 80234ba:	4649      	mov	r1, r9
 80234bc:	4640      	mov	r0, r8
 80234be:	47d0      	blx	sl
 80234c0:	3001      	adds	r0, #1
 80234c2:	d0ad      	beq.n	8023420 <_printf_i+0x160>
 80234c4:	6823      	ldr	r3, [r4, #0]
 80234c6:	079b      	lsls	r3, r3, #30
 80234c8:	d413      	bmi.n	80234f2 <_printf_i+0x232>
 80234ca:	68e0      	ldr	r0, [r4, #12]
 80234cc:	9b03      	ldr	r3, [sp, #12]
 80234ce:	4298      	cmp	r0, r3
 80234d0:	bfb8      	it	lt
 80234d2:	4618      	movlt	r0, r3
 80234d4:	e7a6      	b.n	8023424 <_printf_i+0x164>
 80234d6:	2301      	movs	r3, #1
 80234d8:	4632      	mov	r2, r6
 80234da:	4649      	mov	r1, r9
 80234dc:	4640      	mov	r0, r8
 80234de:	47d0      	blx	sl
 80234e0:	3001      	adds	r0, #1
 80234e2:	d09d      	beq.n	8023420 <_printf_i+0x160>
 80234e4:	3501      	adds	r5, #1
 80234e6:	68e3      	ldr	r3, [r4, #12]
 80234e8:	9903      	ldr	r1, [sp, #12]
 80234ea:	1a5b      	subs	r3, r3, r1
 80234ec:	42ab      	cmp	r3, r5
 80234ee:	dcf2      	bgt.n	80234d6 <_printf_i+0x216>
 80234f0:	e7eb      	b.n	80234ca <_printf_i+0x20a>
 80234f2:	2500      	movs	r5, #0
 80234f4:	f104 0619 	add.w	r6, r4, #25
 80234f8:	e7f5      	b.n	80234e6 <_printf_i+0x226>
 80234fa:	bf00      	nop
 80234fc:	0802d1d7 	.word	0x0802d1d7
 8023500:	0802d1e8 	.word	0x0802d1e8

08023504 <__sflush_r>:
 8023504:	898a      	ldrh	r2, [r1, #12]
 8023506:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802350a:	4605      	mov	r5, r0
 802350c:	0710      	lsls	r0, r2, #28
 802350e:	460c      	mov	r4, r1
 8023510:	d458      	bmi.n	80235c4 <__sflush_r+0xc0>
 8023512:	684b      	ldr	r3, [r1, #4]
 8023514:	2b00      	cmp	r3, #0
 8023516:	dc05      	bgt.n	8023524 <__sflush_r+0x20>
 8023518:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 802351a:	2b00      	cmp	r3, #0
 802351c:	dc02      	bgt.n	8023524 <__sflush_r+0x20>
 802351e:	2000      	movs	r0, #0
 8023520:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8023524:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8023526:	2e00      	cmp	r6, #0
 8023528:	d0f9      	beq.n	802351e <__sflush_r+0x1a>
 802352a:	2300      	movs	r3, #0
 802352c:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 8023530:	682f      	ldr	r7, [r5, #0]
 8023532:	6a21      	ldr	r1, [r4, #32]
 8023534:	602b      	str	r3, [r5, #0]
 8023536:	d032      	beq.n	802359e <__sflush_r+0x9a>
 8023538:	6d60      	ldr	r0, [r4, #84]	; 0x54
 802353a:	89a3      	ldrh	r3, [r4, #12]
 802353c:	075a      	lsls	r2, r3, #29
 802353e:	d505      	bpl.n	802354c <__sflush_r+0x48>
 8023540:	6863      	ldr	r3, [r4, #4]
 8023542:	1ac0      	subs	r0, r0, r3
 8023544:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8023546:	b10b      	cbz	r3, 802354c <__sflush_r+0x48>
 8023548:	6c23      	ldr	r3, [r4, #64]	; 0x40
 802354a:	1ac0      	subs	r0, r0, r3
 802354c:	2300      	movs	r3, #0
 802354e:	4602      	mov	r2, r0
 8023550:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8023552:	6a21      	ldr	r1, [r4, #32]
 8023554:	4628      	mov	r0, r5
 8023556:	47b0      	blx	r6
 8023558:	1c43      	adds	r3, r0, #1
 802355a:	89a3      	ldrh	r3, [r4, #12]
 802355c:	d106      	bne.n	802356c <__sflush_r+0x68>
 802355e:	6829      	ldr	r1, [r5, #0]
 8023560:	291d      	cmp	r1, #29
 8023562:	d82b      	bhi.n	80235bc <__sflush_r+0xb8>
 8023564:	4a29      	ldr	r2, [pc, #164]	; (802360c <__sflush_r+0x108>)
 8023566:	410a      	asrs	r2, r1
 8023568:	07d6      	lsls	r6, r2, #31
 802356a:	d427      	bmi.n	80235bc <__sflush_r+0xb8>
 802356c:	2200      	movs	r2, #0
 802356e:	6062      	str	r2, [r4, #4]
 8023570:	04d9      	lsls	r1, r3, #19
 8023572:	6922      	ldr	r2, [r4, #16]
 8023574:	6022      	str	r2, [r4, #0]
 8023576:	d504      	bpl.n	8023582 <__sflush_r+0x7e>
 8023578:	1c42      	adds	r2, r0, #1
 802357a:	d101      	bne.n	8023580 <__sflush_r+0x7c>
 802357c:	682b      	ldr	r3, [r5, #0]
 802357e:	b903      	cbnz	r3, 8023582 <__sflush_r+0x7e>
 8023580:	6560      	str	r0, [r4, #84]	; 0x54
 8023582:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8023584:	602f      	str	r7, [r5, #0]
 8023586:	2900      	cmp	r1, #0
 8023588:	d0c9      	beq.n	802351e <__sflush_r+0x1a>
 802358a:	f104 0344 	add.w	r3, r4, #68	; 0x44
 802358e:	4299      	cmp	r1, r3
 8023590:	d002      	beq.n	8023598 <__sflush_r+0x94>
 8023592:	4628      	mov	r0, r5
 8023594:	f7ff fc62 	bl	8022e5c <_free_r>
 8023598:	2000      	movs	r0, #0
 802359a:	6360      	str	r0, [r4, #52]	; 0x34
 802359c:	e7c0      	b.n	8023520 <__sflush_r+0x1c>
 802359e:	2301      	movs	r3, #1
 80235a0:	4628      	mov	r0, r5
 80235a2:	47b0      	blx	r6
 80235a4:	1c41      	adds	r1, r0, #1
 80235a6:	d1c8      	bne.n	802353a <__sflush_r+0x36>
 80235a8:	682b      	ldr	r3, [r5, #0]
 80235aa:	2b00      	cmp	r3, #0
 80235ac:	d0c5      	beq.n	802353a <__sflush_r+0x36>
 80235ae:	2b1d      	cmp	r3, #29
 80235b0:	d001      	beq.n	80235b6 <__sflush_r+0xb2>
 80235b2:	2b16      	cmp	r3, #22
 80235b4:	d101      	bne.n	80235ba <__sflush_r+0xb6>
 80235b6:	602f      	str	r7, [r5, #0]
 80235b8:	e7b1      	b.n	802351e <__sflush_r+0x1a>
 80235ba:	89a3      	ldrh	r3, [r4, #12]
 80235bc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80235c0:	81a3      	strh	r3, [r4, #12]
 80235c2:	e7ad      	b.n	8023520 <__sflush_r+0x1c>
 80235c4:	690f      	ldr	r7, [r1, #16]
 80235c6:	2f00      	cmp	r7, #0
 80235c8:	d0a9      	beq.n	802351e <__sflush_r+0x1a>
 80235ca:	0793      	lsls	r3, r2, #30
 80235cc:	680e      	ldr	r6, [r1, #0]
 80235ce:	bf08      	it	eq
 80235d0:	694b      	ldreq	r3, [r1, #20]
 80235d2:	600f      	str	r7, [r1, #0]
 80235d4:	bf18      	it	ne
 80235d6:	2300      	movne	r3, #0
 80235d8:	eba6 0807 	sub.w	r8, r6, r7
 80235dc:	608b      	str	r3, [r1, #8]
 80235de:	f1b8 0f00 	cmp.w	r8, #0
 80235e2:	dd9c      	ble.n	802351e <__sflush_r+0x1a>
 80235e4:	6a21      	ldr	r1, [r4, #32]
 80235e6:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 80235e8:	4643      	mov	r3, r8
 80235ea:	463a      	mov	r2, r7
 80235ec:	4628      	mov	r0, r5
 80235ee:	47b0      	blx	r6
 80235f0:	2800      	cmp	r0, #0
 80235f2:	dc06      	bgt.n	8023602 <__sflush_r+0xfe>
 80235f4:	89a3      	ldrh	r3, [r4, #12]
 80235f6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80235fa:	81a3      	strh	r3, [r4, #12]
 80235fc:	f04f 30ff 	mov.w	r0, #4294967295
 8023600:	e78e      	b.n	8023520 <__sflush_r+0x1c>
 8023602:	4407      	add	r7, r0
 8023604:	eba8 0800 	sub.w	r8, r8, r0
 8023608:	e7e9      	b.n	80235de <__sflush_r+0xda>
 802360a:	bf00      	nop
 802360c:	dfbffffe 	.word	0xdfbffffe

08023610 <_fflush_r>:
 8023610:	b538      	push	{r3, r4, r5, lr}
 8023612:	690b      	ldr	r3, [r1, #16]
 8023614:	4605      	mov	r5, r0
 8023616:	460c      	mov	r4, r1
 8023618:	b913      	cbnz	r3, 8023620 <_fflush_r+0x10>
 802361a:	2500      	movs	r5, #0
 802361c:	4628      	mov	r0, r5
 802361e:	bd38      	pop	{r3, r4, r5, pc}
 8023620:	b118      	cbz	r0, 802362a <_fflush_r+0x1a>
 8023622:	6a03      	ldr	r3, [r0, #32]
 8023624:	b90b      	cbnz	r3, 802362a <_fflush_r+0x1a>
 8023626:	f7ff fa0b 	bl	8022a40 <__sinit>
 802362a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802362e:	2b00      	cmp	r3, #0
 8023630:	d0f3      	beq.n	802361a <_fflush_r+0xa>
 8023632:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8023634:	07d0      	lsls	r0, r2, #31
 8023636:	d404      	bmi.n	8023642 <_fflush_r+0x32>
 8023638:	0599      	lsls	r1, r3, #22
 802363a:	d402      	bmi.n	8023642 <_fflush_r+0x32>
 802363c:	6da0      	ldr	r0, [r4, #88]	; 0x58
 802363e:	f7ff fbed 	bl	8022e1c <__retarget_lock_acquire_recursive>
 8023642:	4628      	mov	r0, r5
 8023644:	4621      	mov	r1, r4
 8023646:	f7ff ff5d 	bl	8023504 <__sflush_r>
 802364a:	6e63      	ldr	r3, [r4, #100]	; 0x64
 802364c:	07da      	lsls	r2, r3, #31
 802364e:	4605      	mov	r5, r0
 8023650:	d4e4      	bmi.n	802361c <_fflush_r+0xc>
 8023652:	89a3      	ldrh	r3, [r4, #12]
 8023654:	059b      	lsls	r3, r3, #22
 8023656:	d4e1      	bmi.n	802361c <_fflush_r+0xc>
 8023658:	6da0      	ldr	r0, [r4, #88]	; 0x58
 802365a:	f7ff fbe0 	bl	8022e1e <__retarget_lock_release_recursive>
 802365e:	e7dd      	b.n	802361c <_fflush_r+0xc>

08023660 <__swbuf_r>:
 8023660:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8023662:	460e      	mov	r6, r1
 8023664:	4614      	mov	r4, r2
 8023666:	4605      	mov	r5, r0
 8023668:	b118      	cbz	r0, 8023672 <__swbuf_r+0x12>
 802366a:	6a03      	ldr	r3, [r0, #32]
 802366c:	b90b      	cbnz	r3, 8023672 <__swbuf_r+0x12>
 802366e:	f7ff f9e7 	bl	8022a40 <__sinit>
 8023672:	69a3      	ldr	r3, [r4, #24]
 8023674:	60a3      	str	r3, [r4, #8]
 8023676:	89a3      	ldrh	r3, [r4, #12]
 8023678:	071a      	lsls	r2, r3, #28
 802367a:	d525      	bpl.n	80236c8 <__swbuf_r+0x68>
 802367c:	6923      	ldr	r3, [r4, #16]
 802367e:	b31b      	cbz	r3, 80236c8 <__swbuf_r+0x68>
 8023680:	6823      	ldr	r3, [r4, #0]
 8023682:	6922      	ldr	r2, [r4, #16]
 8023684:	1a98      	subs	r0, r3, r2
 8023686:	6963      	ldr	r3, [r4, #20]
 8023688:	b2f6      	uxtb	r6, r6
 802368a:	4283      	cmp	r3, r0
 802368c:	4637      	mov	r7, r6
 802368e:	dc04      	bgt.n	802369a <__swbuf_r+0x3a>
 8023690:	4621      	mov	r1, r4
 8023692:	4628      	mov	r0, r5
 8023694:	f7ff ffbc 	bl	8023610 <_fflush_r>
 8023698:	b9e0      	cbnz	r0, 80236d4 <__swbuf_r+0x74>
 802369a:	68a3      	ldr	r3, [r4, #8]
 802369c:	3b01      	subs	r3, #1
 802369e:	60a3      	str	r3, [r4, #8]
 80236a0:	6823      	ldr	r3, [r4, #0]
 80236a2:	1c5a      	adds	r2, r3, #1
 80236a4:	6022      	str	r2, [r4, #0]
 80236a6:	701e      	strb	r6, [r3, #0]
 80236a8:	6962      	ldr	r2, [r4, #20]
 80236aa:	1c43      	adds	r3, r0, #1
 80236ac:	429a      	cmp	r2, r3
 80236ae:	d004      	beq.n	80236ba <__swbuf_r+0x5a>
 80236b0:	89a3      	ldrh	r3, [r4, #12]
 80236b2:	07db      	lsls	r3, r3, #31
 80236b4:	d506      	bpl.n	80236c4 <__swbuf_r+0x64>
 80236b6:	2e0a      	cmp	r6, #10
 80236b8:	d104      	bne.n	80236c4 <__swbuf_r+0x64>
 80236ba:	4621      	mov	r1, r4
 80236bc:	4628      	mov	r0, r5
 80236be:	f7ff ffa7 	bl	8023610 <_fflush_r>
 80236c2:	b938      	cbnz	r0, 80236d4 <__swbuf_r+0x74>
 80236c4:	4638      	mov	r0, r7
 80236c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80236c8:	4621      	mov	r1, r4
 80236ca:	4628      	mov	r0, r5
 80236cc:	f000 f806 	bl	80236dc <__swsetup_r>
 80236d0:	2800      	cmp	r0, #0
 80236d2:	d0d5      	beq.n	8023680 <__swbuf_r+0x20>
 80236d4:	f04f 37ff 	mov.w	r7, #4294967295
 80236d8:	e7f4      	b.n	80236c4 <__swbuf_r+0x64>
	...

080236dc <__swsetup_r>:
 80236dc:	b538      	push	{r3, r4, r5, lr}
 80236de:	4b2a      	ldr	r3, [pc, #168]	; (8023788 <__swsetup_r+0xac>)
 80236e0:	4605      	mov	r5, r0
 80236e2:	6818      	ldr	r0, [r3, #0]
 80236e4:	460c      	mov	r4, r1
 80236e6:	b118      	cbz	r0, 80236f0 <__swsetup_r+0x14>
 80236e8:	6a03      	ldr	r3, [r0, #32]
 80236ea:	b90b      	cbnz	r3, 80236f0 <__swsetup_r+0x14>
 80236ec:	f7ff f9a8 	bl	8022a40 <__sinit>
 80236f0:	89a3      	ldrh	r3, [r4, #12]
 80236f2:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 80236f6:	0718      	lsls	r0, r3, #28
 80236f8:	d422      	bmi.n	8023740 <__swsetup_r+0x64>
 80236fa:	06d9      	lsls	r1, r3, #27
 80236fc:	d407      	bmi.n	802370e <__swsetup_r+0x32>
 80236fe:	2309      	movs	r3, #9
 8023700:	602b      	str	r3, [r5, #0]
 8023702:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 8023706:	81a3      	strh	r3, [r4, #12]
 8023708:	f04f 30ff 	mov.w	r0, #4294967295
 802370c:	e034      	b.n	8023778 <__swsetup_r+0x9c>
 802370e:	0758      	lsls	r0, r3, #29
 8023710:	d512      	bpl.n	8023738 <__swsetup_r+0x5c>
 8023712:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8023714:	b141      	cbz	r1, 8023728 <__swsetup_r+0x4c>
 8023716:	f104 0344 	add.w	r3, r4, #68	; 0x44
 802371a:	4299      	cmp	r1, r3
 802371c:	d002      	beq.n	8023724 <__swsetup_r+0x48>
 802371e:	4628      	mov	r0, r5
 8023720:	f7ff fb9c 	bl	8022e5c <_free_r>
 8023724:	2300      	movs	r3, #0
 8023726:	6363      	str	r3, [r4, #52]	; 0x34
 8023728:	89a3      	ldrh	r3, [r4, #12]
 802372a:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 802372e:	81a3      	strh	r3, [r4, #12]
 8023730:	2300      	movs	r3, #0
 8023732:	6063      	str	r3, [r4, #4]
 8023734:	6923      	ldr	r3, [r4, #16]
 8023736:	6023      	str	r3, [r4, #0]
 8023738:	89a3      	ldrh	r3, [r4, #12]
 802373a:	f043 0308 	orr.w	r3, r3, #8
 802373e:	81a3      	strh	r3, [r4, #12]
 8023740:	6923      	ldr	r3, [r4, #16]
 8023742:	b94b      	cbnz	r3, 8023758 <__swsetup_r+0x7c>
 8023744:	89a3      	ldrh	r3, [r4, #12]
 8023746:	f403 7320 	and.w	r3, r3, #640	; 0x280
 802374a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 802374e:	d003      	beq.n	8023758 <__swsetup_r+0x7c>
 8023750:	4621      	mov	r1, r4
 8023752:	4628      	mov	r0, r5
 8023754:	f000 f884 	bl	8023860 <__smakebuf_r>
 8023758:	89a0      	ldrh	r0, [r4, #12]
 802375a:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 802375e:	f010 0301 	ands.w	r3, r0, #1
 8023762:	d00a      	beq.n	802377a <__swsetup_r+0x9e>
 8023764:	2300      	movs	r3, #0
 8023766:	60a3      	str	r3, [r4, #8]
 8023768:	6963      	ldr	r3, [r4, #20]
 802376a:	425b      	negs	r3, r3
 802376c:	61a3      	str	r3, [r4, #24]
 802376e:	6923      	ldr	r3, [r4, #16]
 8023770:	b943      	cbnz	r3, 8023784 <__swsetup_r+0xa8>
 8023772:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8023776:	d1c4      	bne.n	8023702 <__swsetup_r+0x26>
 8023778:	bd38      	pop	{r3, r4, r5, pc}
 802377a:	0781      	lsls	r1, r0, #30
 802377c:	bf58      	it	pl
 802377e:	6963      	ldrpl	r3, [r4, #20]
 8023780:	60a3      	str	r3, [r4, #8]
 8023782:	e7f4      	b.n	802376e <__swsetup_r+0x92>
 8023784:	2000      	movs	r0, #0
 8023786:	e7f7      	b.n	8023778 <__swsetup_r+0x9c>
 8023788:	2000062c 	.word	0x2000062c

0802378c <_raise_r>:
 802378c:	291f      	cmp	r1, #31
 802378e:	b538      	push	{r3, r4, r5, lr}
 8023790:	4604      	mov	r4, r0
 8023792:	460d      	mov	r5, r1
 8023794:	d904      	bls.n	80237a0 <_raise_r+0x14>
 8023796:	2316      	movs	r3, #22
 8023798:	6003      	str	r3, [r0, #0]
 802379a:	f04f 30ff 	mov.w	r0, #4294967295
 802379e:	bd38      	pop	{r3, r4, r5, pc}
 80237a0:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 80237a2:	b112      	cbz	r2, 80237aa <_raise_r+0x1e>
 80237a4:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 80237a8:	b94b      	cbnz	r3, 80237be <_raise_r+0x32>
 80237aa:	4620      	mov	r0, r4
 80237ac:	f000 f830 	bl	8023810 <_getpid_r>
 80237b0:	462a      	mov	r2, r5
 80237b2:	4601      	mov	r1, r0
 80237b4:	4620      	mov	r0, r4
 80237b6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80237ba:	f000 b817 	b.w	80237ec <_kill_r>
 80237be:	2b01      	cmp	r3, #1
 80237c0:	d00a      	beq.n	80237d8 <_raise_r+0x4c>
 80237c2:	1c59      	adds	r1, r3, #1
 80237c4:	d103      	bne.n	80237ce <_raise_r+0x42>
 80237c6:	2316      	movs	r3, #22
 80237c8:	6003      	str	r3, [r0, #0]
 80237ca:	2001      	movs	r0, #1
 80237cc:	e7e7      	b.n	802379e <_raise_r+0x12>
 80237ce:	2400      	movs	r4, #0
 80237d0:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
 80237d4:	4628      	mov	r0, r5
 80237d6:	4798      	blx	r3
 80237d8:	2000      	movs	r0, #0
 80237da:	e7e0      	b.n	802379e <_raise_r+0x12>

080237dc <raise>:
 80237dc:	4b02      	ldr	r3, [pc, #8]	; (80237e8 <raise+0xc>)
 80237de:	4601      	mov	r1, r0
 80237e0:	6818      	ldr	r0, [r3, #0]
 80237e2:	f7ff bfd3 	b.w	802378c <_raise_r>
 80237e6:	bf00      	nop
 80237e8:	2000062c 	.word	0x2000062c

080237ec <_kill_r>:
 80237ec:	b538      	push	{r3, r4, r5, lr}
 80237ee:	4d07      	ldr	r5, [pc, #28]	; (802380c <_kill_r+0x20>)
 80237f0:	2300      	movs	r3, #0
 80237f2:	4604      	mov	r4, r0
 80237f4:	4608      	mov	r0, r1
 80237f6:	4611      	mov	r1, r2
 80237f8:	602b      	str	r3, [r5, #0]
 80237fa:	f7ea fd69 	bl	800e2d0 <_kill>
 80237fe:	1c43      	adds	r3, r0, #1
 8023800:	d102      	bne.n	8023808 <_kill_r+0x1c>
 8023802:	682b      	ldr	r3, [r5, #0]
 8023804:	b103      	cbz	r3, 8023808 <_kill_r+0x1c>
 8023806:	6023      	str	r3, [r4, #0]
 8023808:	bd38      	pop	{r3, r4, r5, pc}
 802380a:	bf00      	nop
 802380c:	20004980 	.word	0x20004980

08023810 <_getpid_r>:
 8023810:	f7ea bd5c 	b.w	800e2cc <_getpid>

08023814 <__swhatbuf_r>:
 8023814:	b570      	push	{r4, r5, r6, lr}
 8023816:	460c      	mov	r4, r1
 8023818:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 802381c:	2900      	cmp	r1, #0
 802381e:	b096      	sub	sp, #88	; 0x58
 8023820:	4615      	mov	r5, r2
 8023822:	461e      	mov	r6, r3
 8023824:	da0d      	bge.n	8023842 <__swhatbuf_r+0x2e>
 8023826:	89a3      	ldrh	r3, [r4, #12]
 8023828:	f013 0f80 	tst.w	r3, #128	; 0x80
 802382c:	f04f 0100 	mov.w	r1, #0
 8023830:	bf0c      	ite	eq
 8023832:	f44f 6380 	moveq.w	r3, #1024	; 0x400
 8023836:	2340      	movne	r3, #64	; 0x40
 8023838:	2000      	movs	r0, #0
 802383a:	6031      	str	r1, [r6, #0]
 802383c:	602b      	str	r3, [r5, #0]
 802383e:	b016      	add	sp, #88	; 0x58
 8023840:	bd70      	pop	{r4, r5, r6, pc}
 8023842:	466a      	mov	r2, sp
 8023844:	f000 f848 	bl	80238d8 <_fstat_r>
 8023848:	2800      	cmp	r0, #0
 802384a:	dbec      	blt.n	8023826 <__swhatbuf_r+0x12>
 802384c:	9901      	ldr	r1, [sp, #4]
 802384e:	f401 4170 	and.w	r1, r1, #61440	; 0xf000
 8023852:	f5a1 5300 	sub.w	r3, r1, #8192	; 0x2000
 8023856:	4259      	negs	r1, r3
 8023858:	4159      	adcs	r1, r3
 802385a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 802385e:	e7eb      	b.n	8023838 <__swhatbuf_r+0x24>

08023860 <__smakebuf_r>:
 8023860:	898b      	ldrh	r3, [r1, #12]
 8023862:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8023864:	079d      	lsls	r5, r3, #30
 8023866:	4606      	mov	r6, r0
 8023868:	460c      	mov	r4, r1
 802386a:	d507      	bpl.n	802387c <__smakebuf_r+0x1c>
 802386c:	f104 0347 	add.w	r3, r4, #71	; 0x47
 8023870:	6023      	str	r3, [r4, #0]
 8023872:	6123      	str	r3, [r4, #16]
 8023874:	2301      	movs	r3, #1
 8023876:	6163      	str	r3, [r4, #20]
 8023878:	b002      	add	sp, #8
 802387a:	bd70      	pop	{r4, r5, r6, pc}
 802387c:	ab01      	add	r3, sp, #4
 802387e:	466a      	mov	r2, sp
 8023880:	f7ff ffc8 	bl	8023814 <__swhatbuf_r>
 8023884:	9900      	ldr	r1, [sp, #0]
 8023886:	4605      	mov	r5, r0
 8023888:	4630      	mov	r0, r6
 802388a:	f7fe fe41 	bl	8022510 <_malloc_r>
 802388e:	b948      	cbnz	r0, 80238a4 <__smakebuf_r+0x44>
 8023890:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8023894:	059a      	lsls	r2, r3, #22
 8023896:	d4ef      	bmi.n	8023878 <__smakebuf_r+0x18>
 8023898:	f023 0303 	bic.w	r3, r3, #3
 802389c:	f043 0302 	orr.w	r3, r3, #2
 80238a0:	81a3      	strh	r3, [r4, #12]
 80238a2:	e7e3      	b.n	802386c <__smakebuf_r+0xc>
 80238a4:	89a3      	ldrh	r3, [r4, #12]
 80238a6:	6020      	str	r0, [r4, #0]
 80238a8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80238ac:	81a3      	strh	r3, [r4, #12]
 80238ae:	9b00      	ldr	r3, [sp, #0]
 80238b0:	6163      	str	r3, [r4, #20]
 80238b2:	9b01      	ldr	r3, [sp, #4]
 80238b4:	6120      	str	r0, [r4, #16]
 80238b6:	b15b      	cbz	r3, 80238d0 <__smakebuf_r+0x70>
 80238b8:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80238bc:	4630      	mov	r0, r6
 80238be:	f000 f81d 	bl	80238fc <_isatty_r>
 80238c2:	b128      	cbz	r0, 80238d0 <__smakebuf_r+0x70>
 80238c4:	89a3      	ldrh	r3, [r4, #12]
 80238c6:	f023 0303 	bic.w	r3, r3, #3
 80238ca:	f043 0301 	orr.w	r3, r3, #1
 80238ce:	81a3      	strh	r3, [r4, #12]
 80238d0:	89a3      	ldrh	r3, [r4, #12]
 80238d2:	431d      	orrs	r5, r3
 80238d4:	81a5      	strh	r5, [r4, #12]
 80238d6:	e7cf      	b.n	8023878 <__smakebuf_r+0x18>

080238d8 <_fstat_r>:
 80238d8:	b538      	push	{r3, r4, r5, lr}
 80238da:	4d07      	ldr	r5, [pc, #28]	; (80238f8 <_fstat_r+0x20>)
 80238dc:	2300      	movs	r3, #0
 80238de:	4604      	mov	r4, r0
 80238e0:	4608      	mov	r0, r1
 80238e2:	4611      	mov	r1, r2
 80238e4:	602b      	str	r3, [r5, #0]
 80238e6:	f7ea fd22 	bl	800e32e <_fstat>
 80238ea:	1c43      	adds	r3, r0, #1
 80238ec:	d102      	bne.n	80238f4 <_fstat_r+0x1c>
 80238ee:	682b      	ldr	r3, [r5, #0]
 80238f0:	b103      	cbz	r3, 80238f4 <_fstat_r+0x1c>
 80238f2:	6023      	str	r3, [r4, #0]
 80238f4:	bd38      	pop	{r3, r4, r5, pc}
 80238f6:	bf00      	nop
 80238f8:	20004980 	.word	0x20004980

080238fc <_isatty_r>:
 80238fc:	b538      	push	{r3, r4, r5, lr}
 80238fe:	4d06      	ldr	r5, [pc, #24]	; (8023918 <_isatty_r+0x1c>)
 8023900:	2300      	movs	r3, #0
 8023902:	4604      	mov	r4, r0
 8023904:	4608      	mov	r0, r1
 8023906:	602b      	str	r3, [r5, #0]
 8023908:	f7ea fd16 	bl	800e338 <_isatty>
 802390c:	1c43      	adds	r3, r0, #1
 802390e:	d102      	bne.n	8023916 <_isatty_r+0x1a>
 8023910:	682b      	ldr	r3, [r5, #0]
 8023912:	b103      	cbz	r3, 8023916 <_isatty_r+0x1a>
 8023914:	6023      	str	r3, [r4, #0]
 8023916:	bd38      	pop	{r3, r4, r5, pc}
 8023918:	20004980 	.word	0x20004980

0802391c <atan2>:
 802391c:	f000 ba2c 	b.w	8023d78 <__ieee754_atan2>

08023920 <powf>:
 8023920:	b508      	push	{r3, lr}
 8023922:	ed2d 8b04 	vpush	{d8-d9}
 8023926:	eeb0 8a60 	vmov.f32	s16, s1
 802392a:	eeb0 9a40 	vmov.f32	s18, s0
 802392e:	f000 fe1b 	bl	8024568 <__ieee754_powf>
 8023932:	eeb4 8a48 	vcmp.f32	s16, s16
 8023936:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802393a:	eef0 8a40 	vmov.f32	s17, s0
 802393e:	d63e      	bvs.n	80239be <powf+0x9e>
 8023940:	eeb5 9a40 	vcmp.f32	s18, #0.0
 8023944:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023948:	d112      	bne.n	8023970 <powf+0x50>
 802394a:	eeb5 8a40 	vcmp.f32	s16, #0.0
 802394e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023952:	d039      	beq.n	80239c8 <powf+0xa8>
 8023954:	eeb0 0a48 	vmov.f32	s0, s16
 8023958:	f000 f90e 	bl	8023b78 <finitef>
 802395c:	b378      	cbz	r0, 80239be <powf+0x9e>
 802395e:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8023962:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023966:	d52a      	bpl.n	80239be <powf+0x9e>
 8023968:	f7ff fa2e 	bl	8022dc8 <__errno>
 802396c:	2322      	movs	r3, #34	; 0x22
 802396e:	e014      	b.n	802399a <powf+0x7a>
 8023970:	f000 f902 	bl	8023b78 <finitef>
 8023974:	b998      	cbnz	r0, 802399e <powf+0x7e>
 8023976:	eeb0 0a49 	vmov.f32	s0, s18
 802397a:	f000 f8fd 	bl	8023b78 <finitef>
 802397e:	b170      	cbz	r0, 802399e <powf+0x7e>
 8023980:	eeb0 0a48 	vmov.f32	s0, s16
 8023984:	f000 f8f8 	bl	8023b78 <finitef>
 8023988:	b148      	cbz	r0, 802399e <powf+0x7e>
 802398a:	eef4 8a68 	vcmp.f32	s17, s17
 802398e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023992:	d7e9      	bvc.n	8023968 <powf+0x48>
 8023994:	f7ff fa18 	bl	8022dc8 <__errno>
 8023998:	2321      	movs	r3, #33	; 0x21
 802399a:	6003      	str	r3, [r0, #0]
 802399c:	e00f      	b.n	80239be <powf+0x9e>
 802399e:	eef5 8a40 	vcmp.f32	s17, #0.0
 80239a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80239a6:	d10a      	bne.n	80239be <powf+0x9e>
 80239a8:	eeb0 0a49 	vmov.f32	s0, s18
 80239ac:	f000 f8e4 	bl	8023b78 <finitef>
 80239b0:	b128      	cbz	r0, 80239be <powf+0x9e>
 80239b2:	eeb0 0a48 	vmov.f32	s0, s16
 80239b6:	f000 f8df 	bl	8023b78 <finitef>
 80239ba:	2800      	cmp	r0, #0
 80239bc:	d1d4      	bne.n	8023968 <powf+0x48>
 80239be:	eeb0 0a68 	vmov.f32	s0, s17
 80239c2:	ecbd 8b04 	vpop	{d8-d9}
 80239c6:	bd08      	pop	{r3, pc}
 80239c8:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
 80239cc:	e7f7      	b.n	80239be <powf+0x9e>
	...

080239d0 <sqrtf>:
 80239d0:	b508      	push	{r3, lr}
 80239d2:	ed2d 8b02 	vpush	{d8}
 80239d6:	eeb0 8a40 	vmov.f32	s16, s0
 80239da:	f000 f907 	bl	8023bec <__ieee754_sqrtf>
 80239de:	eeb4 8a48 	vcmp.f32	s16, s16
 80239e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80239e6:	d60c      	bvs.n	8023a02 <sqrtf+0x32>
 80239e8:	eddf 8a07 	vldr	s17, [pc, #28]	; 8023a08 <sqrtf+0x38>
 80239ec:	eeb4 8ae8 	vcmpe.f32	s16, s17
 80239f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80239f4:	d505      	bpl.n	8023a02 <sqrtf+0x32>
 80239f6:	f7ff f9e7 	bl	8022dc8 <__errno>
 80239fa:	ee88 0aa8 	vdiv.f32	s0, s17, s17
 80239fe:	2321      	movs	r3, #33	; 0x21
 8023a00:	6003      	str	r3, [r0, #0]
 8023a02:	ecbd 8b02 	vpop	{d8}
 8023a06:	bd08      	pop	{r3, pc}
 8023a08:	00000000 	.word	0x00000000

08023a0c <cosf>:
 8023a0c:	ee10 3a10 	vmov	r3, s0
 8023a10:	b507      	push	{r0, r1, r2, lr}
 8023a12:	4a1e      	ldr	r2, [pc, #120]	; (8023a8c <cosf+0x80>)
 8023a14:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8023a18:	4293      	cmp	r3, r2
 8023a1a:	dc06      	bgt.n	8023a2a <cosf+0x1e>
 8023a1c:	eddf 0a1c 	vldr	s1, [pc, #112]	; 8023a90 <cosf+0x84>
 8023a20:	b003      	add	sp, #12
 8023a22:	f85d eb04 	ldr.w	lr, [sp], #4
 8023a26:	f000 bc19 	b.w	802425c <__kernel_cosf>
 8023a2a:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8023a2e:	db04      	blt.n	8023a3a <cosf+0x2e>
 8023a30:	ee30 0a40 	vsub.f32	s0, s0, s0
 8023a34:	b003      	add	sp, #12
 8023a36:	f85d fb04 	ldr.w	pc, [sp], #4
 8023a3a:	4668      	mov	r0, sp
 8023a3c:	f001 f85e 	bl	8024afc <__ieee754_rem_pio2f>
 8023a40:	f000 0003 	and.w	r0, r0, #3
 8023a44:	2801      	cmp	r0, #1
 8023a46:	d009      	beq.n	8023a5c <cosf+0x50>
 8023a48:	2802      	cmp	r0, #2
 8023a4a:	d010      	beq.n	8023a6e <cosf+0x62>
 8023a4c:	b9b0      	cbnz	r0, 8023a7c <cosf+0x70>
 8023a4e:	eddd 0a01 	vldr	s1, [sp, #4]
 8023a52:	ed9d 0a00 	vldr	s0, [sp]
 8023a56:	f000 fc01 	bl	802425c <__kernel_cosf>
 8023a5a:	e7eb      	b.n	8023a34 <cosf+0x28>
 8023a5c:	eddd 0a01 	vldr	s1, [sp, #4]
 8023a60:	ed9d 0a00 	vldr	s0, [sp]
 8023a64:	f000 fc58 	bl	8024318 <__kernel_sinf>
 8023a68:	eeb1 0a40 	vneg.f32	s0, s0
 8023a6c:	e7e2      	b.n	8023a34 <cosf+0x28>
 8023a6e:	eddd 0a01 	vldr	s1, [sp, #4]
 8023a72:	ed9d 0a00 	vldr	s0, [sp]
 8023a76:	f000 fbf1 	bl	802425c <__kernel_cosf>
 8023a7a:	e7f5      	b.n	8023a68 <cosf+0x5c>
 8023a7c:	eddd 0a01 	vldr	s1, [sp, #4]
 8023a80:	ed9d 0a00 	vldr	s0, [sp]
 8023a84:	2001      	movs	r0, #1
 8023a86:	f000 fc47 	bl	8024318 <__kernel_sinf>
 8023a8a:	e7d3      	b.n	8023a34 <cosf+0x28>
 8023a8c:	3f490fd8 	.word	0x3f490fd8
 8023a90:	00000000 	.word	0x00000000

08023a94 <sinf>:
 8023a94:	ee10 3a10 	vmov	r3, s0
 8023a98:	b507      	push	{r0, r1, r2, lr}
 8023a9a:	4a1f      	ldr	r2, [pc, #124]	; (8023b18 <sinf+0x84>)
 8023a9c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8023aa0:	4293      	cmp	r3, r2
 8023aa2:	dc07      	bgt.n	8023ab4 <sinf+0x20>
 8023aa4:	eddf 0a1d 	vldr	s1, [pc, #116]	; 8023b1c <sinf+0x88>
 8023aa8:	2000      	movs	r0, #0
 8023aaa:	b003      	add	sp, #12
 8023aac:	f85d eb04 	ldr.w	lr, [sp], #4
 8023ab0:	f000 bc32 	b.w	8024318 <__kernel_sinf>
 8023ab4:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8023ab8:	db04      	blt.n	8023ac4 <sinf+0x30>
 8023aba:	ee30 0a40 	vsub.f32	s0, s0, s0
 8023abe:	b003      	add	sp, #12
 8023ac0:	f85d fb04 	ldr.w	pc, [sp], #4
 8023ac4:	4668      	mov	r0, sp
 8023ac6:	f001 f819 	bl	8024afc <__ieee754_rem_pio2f>
 8023aca:	f000 0003 	and.w	r0, r0, #3
 8023ace:	2801      	cmp	r0, #1
 8023ad0:	d00a      	beq.n	8023ae8 <sinf+0x54>
 8023ad2:	2802      	cmp	r0, #2
 8023ad4:	d00f      	beq.n	8023af6 <sinf+0x62>
 8023ad6:	b9c0      	cbnz	r0, 8023b0a <sinf+0x76>
 8023ad8:	eddd 0a01 	vldr	s1, [sp, #4]
 8023adc:	ed9d 0a00 	vldr	s0, [sp]
 8023ae0:	2001      	movs	r0, #1
 8023ae2:	f000 fc19 	bl	8024318 <__kernel_sinf>
 8023ae6:	e7ea      	b.n	8023abe <sinf+0x2a>
 8023ae8:	eddd 0a01 	vldr	s1, [sp, #4]
 8023aec:	ed9d 0a00 	vldr	s0, [sp]
 8023af0:	f000 fbb4 	bl	802425c <__kernel_cosf>
 8023af4:	e7e3      	b.n	8023abe <sinf+0x2a>
 8023af6:	eddd 0a01 	vldr	s1, [sp, #4]
 8023afa:	ed9d 0a00 	vldr	s0, [sp]
 8023afe:	2001      	movs	r0, #1
 8023b00:	f000 fc0a 	bl	8024318 <__kernel_sinf>
 8023b04:	eeb1 0a40 	vneg.f32	s0, s0
 8023b08:	e7d9      	b.n	8023abe <sinf+0x2a>
 8023b0a:	eddd 0a01 	vldr	s1, [sp, #4]
 8023b0e:	ed9d 0a00 	vldr	s0, [sp]
 8023b12:	f000 fba3 	bl	802425c <__kernel_cosf>
 8023b16:	e7f5      	b.n	8023b04 <sinf+0x70>
 8023b18:	3f490fd8 	.word	0x3f490fd8
 8023b1c:	00000000 	.word	0x00000000

08023b20 <tanf>:
 8023b20:	ee10 3a10 	vmov	r3, s0
 8023b24:	b507      	push	{r0, r1, r2, lr}
 8023b26:	4a12      	ldr	r2, [pc, #72]	; (8023b70 <tanf+0x50>)
 8023b28:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8023b2c:	4293      	cmp	r3, r2
 8023b2e:	dc07      	bgt.n	8023b40 <tanf+0x20>
 8023b30:	eddf 0a10 	vldr	s1, [pc, #64]	; 8023b74 <tanf+0x54>
 8023b34:	2001      	movs	r0, #1
 8023b36:	b003      	add	sp, #12
 8023b38:	f85d eb04 	ldr.w	lr, [sp], #4
 8023b3c:	f000 bc34 	b.w	80243a8 <__kernel_tanf>
 8023b40:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8023b44:	db04      	blt.n	8023b50 <tanf+0x30>
 8023b46:	ee30 0a40 	vsub.f32	s0, s0, s0
 8023b4a:	b003      	add	sp, #12
 8023b4c:	f85d fb04 	ldr.w	pc, [sp], #4
 8023b50:	4668      	mov	r0, sp
 8023b52:	f000 ffd3 	bl	8024afc <__ieee754_rem_pio2f>
 8023b56:	0040      	lsls	r0, r0, #1
 8023b58:	f000 0002 	and.w	r0, r0, #2
 8023b5c:	eddd 0a01 	vldr	s1, [sp, #4]
 8023b60:	ed9d 0a00 	vldr	s0, [sp]
 8023b64:	f1c0 0001 	rsb	r0, r0, #1
 8023b68:	f000 fc1e 	bl	80243a8 <__kernel_tanf>
 8023b6c:	e7ed      	b.n	8023b4a <tanf+0x2a>
 8023b6e:	bf00      	nop
 8023b70:	3f490fda 	.word	0x3f490fda
 8023b74:	00000000 	.word	0x00000000

08023b78 <finitef>:
 8023b78:	b082      	sub	sp, #8
 8023b7a:	ed8d 0a01 	vstr	s0, [sp, #4]
 8023b7e:	9801      	ldr	r0, [sp, #4]
 8023b80:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 8023b84:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 8023b88:	bfac      	ite	ge
 8023b8a:	2000      	movge	r0, #0
 8023b8c:	2001      	movlt	r0, #1
 8023b8e:	b002      	add	sp, #8
 8023b90:	4770      	bx	lr

08023b92 <lroundf>:
 8023b92:	ee10 1a10 	vmov	r1, s0
 8023b96:	f3c1 53c7 	ubfx	r3, r1, #23, #8
 8023b9a:	2900      	cmp	r1, #0
 8023b9c:	f1a3 027f 	sub.w	r2, r3, #127	; 0x7f
 8023ba0:	bfb4      	ite	lt
 8023ba2:	f04f 30ff 	movlt.w	r0, #4294967295
 8023ba6:	2001      	movge	r0, #1
 8023ba8:	2a1e      	cmp	r2, #30
 8023baa:	dc1a      	bgt.n	8023be2 <lroundf+0x50>
 8023bac:	2a00      	cmp	r2, #0
 8023bae:	da03      	bge.n	8023bb8 <lroundf+0x26>
 8023bb0:	3201      	adds	r2, #1
 8023bb2:	bf18      	it	ne
 8023bb4:	2000      	movne	r0, #0
 8023bb6:	4770      	bx	lr
 8023bb8:	2a16      	cmp	r2, #22
 8023bba:	bfd8      	it	le
 8023bbc:	f44f 0380 	movle.w	r3, #4194304	; 0x400000
 8023bc0:	f3c1 0116 	ubfx	r1, r1, #0, #23
 8023bc4:	bfd8      	it	le
 8023bc6:	4113      	asrle	r3, r2
 8023bc8:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 8023bcc:	bfcd      	iteet	gt
 8023bce:	3b96      	subgt	r3, #150	; 0x96
 8023bd0:	185b      	addle	r3, r3, r1
 8023bd2:	f1c2 0217 	rsble	r2, r2, #23
 8023bd6:	fa01 f303 	lslgt.w	r3, r1, r3
 8023bda:	bfd8      	it	le
 8023bdc:	40d3      	lsrle	r3, r2
 8023bde:	4358      	muls	r0, r3
 8023be0:	4770      	bx	lr
 8023be2:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8023be6:	ee17 0a90 	vmov	r0, s15
 8023bea:	4770      	bx	lr

08023bec <__ieee754_sqrtf>:
 8023bec:	eeb1 0ac0 	vsqrt.f32	s0, s0
 8023bf0:	4770      	bx	lr
	...

08023bf4 <ceilf>:
 8023bf4:	ee10 3a10 	vmov	r3, s0
 8023bf8:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 8023bfc:	3a7f      	subs	r2, #127	; 0x7f
 8023bfe:	2a16      	cmp	r2, #22
 8023c00:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 8023c04:	dc2a      	bgt.n	8023c5c <ceilf+0x68>
 8023c06:	2a00      	cmp	r2, #0
 8023c08:	da11      	bge.n	8023c2e <ceilf+0x3a>
 8023c0a:	eddf 7a19 	vldr	s15, [pc, #100]	; 8023c70 <ceilf+0x7c>
 8023c0e:	ee30 0a27 	vadd.f32	s0, s0, s15
 8023c12:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8023c16:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023c1a:	dd05      	ble.n	8023c28 <ceilf+0x34>
 8023c1c:	2b00      	cmp	r3, #0
 8023c1e:	db23      	blt.n	8023c68 <ceilf+0x74>
 8023c20:	2900      	cmp	r1, #0
 8023c22:	bf18      	it	ne
 8023c24:	f04f 537e 	movne.w	r3, #1065353216	; 0x3f800000
 8023c28:	ee00 3a10 	vmov	s0, r3
 8023c2c:	4770      	bx	lr
 8023c2e:	4911      	ldr	r1, [pc, #68]	; (8023c74 <ceilf+0x80>)
 8023c30:	4111      	asrs	r1, r2
 8023c32:	420b      	tst	r3, r1
 8023c34:	d0fa      	beq.n	8023c2c <ceilf+0x38>
 8023c36:	eddf 7a0e 	vldr	s15, [pc, #56]	; 8023c70 <ceilf+0x7c>
 8023c3a:	ee30 0a27 	vadd.f32	s0, s0, s15
 8023c3e:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8023c42:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023c46:	ddef      	ble.n	8023c28 <ceilf+0x34>
 8023c48:	2b00      	cmp	r3, #0
 8023c4a:	bfc2      	ittt	gt
 8023c4c:	f44f 0000 	movgt.w	r0, #8388608	; 0x800000
 8023c50:	fa40 f202 	asrgt.w	r2, r0, r2
 8023c54:	189b      	addgt	r3, r3, r2
 8023c56:	ea23 0301 	bic.w	r3, r3, r1
 8023c5a:	e7e5      	b.n	8023c28 <ceilf+0x34>
 8023c5c:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 8023c60:	d3e4      	bcc.n	8023c2c <ceilf+0x38>
 8023c62:	ee30 0a00 	vadd.f32	s0, s0, s0
 8023c66:	4770      	bx	lr
 8023c68:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 8023c6c:	e7dc      	b.n	8023c28 <ceilf+0x34>
 8023c6e:	bf00      	nop
 8023c70:	7149f2ca 	.word	0x7149f2ca
 8023c74:	007fffff 	.word	0x007fffff

08023c78 <floorf>:
 8023c78:	ee10 3a10 	vmov	r3, s0
 8023c7c:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 8023c80:	3a7f      	subs	r2, #127	; 0x7f
 8023c82:	2a16      	cmp	r2, #22
 8023c84:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 8023c88:	dc2a      	bgt.n	8023ce0 <floorf+0x68>
 8023c8a:	2a00      	cmp	r2, #0
 8023c8c:	da11      	bge.n	8023cb2 <floorf+0x3a>
 8023c8e:	eddf 7a18 	vldr	s15, [pc, #96]	; 8023cf0 <floorf+0x78>
 8023c92:	ee30 0a27 	vadd.f32	s0, s0, s15
 8023c96:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8023c9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023c9e:	dd05      	ble.n	8023cac <floorf+0x34>
 8023ca0:	2b00      	cmp	r3, #0
 8023ca2:	da23      	bge.n	8023cec <floorf+0x74>
 8023ca4:	4a13      	ldr	r2, [pc, #76]	; (8023cf4 <floorf+0x7c>)
 8023ca6:	2900      	cmp	r1, #0
 8023ca8:	bf18      	it	ne
 8023caa:	4613      	movne	r3, r2
 8023cac:	ee00 3a10 	vmov	s0, r3
 8023cb0:	4770      	bx	lr
 8023cb2:	4911      	ldr	r1, [pc, #68]	; (8023cf8 <floorf+0x80>)
 8023cb4:	4111      	asrs	r1, r2
 8023cb6:	420b      	tst	r3, r1
 8023cb8:	d0fa      	beq.n	8023cb0 <floorf+0x38>
 8023cba:	eddf 7a0d 	vldr	s15, [pc, #52]	; 8023cf0 <floorf+0x78>
 8023cbe:	ee30 0a27 	vadd.f32	s0, s0, s15
 8023cc2:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8023cc6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023cca:	ddef      	ble.n	8023cac <floorf+0x34>
 8023ccc:	2b00      	cmp	r3, #0
 8023cce:	bfbe      	ittt	lt
 8023cd0:	f44f 0000 	movlt.w	r0, #8388608	; 0x800000
 8023cd4:	fa40 f202 	asrlt.w	r2, r0, r2
 8023cd8:	189b      	addlt	r3, r3, r2
 8023cda:	ea23 0301 	bic.w	r3, r3, r1
 8023cde:	e7e5      	b.n	8023cac <floorf+0x34>
 8023ce0:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 8023ce4:	d3e4      	bcc.n	8023cb0 <floorf+0x38>
 8023ce6:	ee30 0a00 	vadd.f32	s0, s0, s0
 8023cea:	4770      	bx	lr
 8023cec:	2300      	movs	r3, #0
 8023cee:	e7dd      	b.n	8023cac <floorf+0x34>
 8023cf0:	7149f2ca 	.word	0x7149f2ca
 8023cf4:	bf800000 	.word	0xbf800000
 8023cf8:	007fffff 	.word	0x007fffff

08023cfc <roundf>:
 8023cfc:	ee10 0a10 	vmov	r0, s0
 8023d00:	f3c0 52c7 	ubfx	r2, r0, #23, #8
 8023d04:	3a7f      	subs	r2, #127	; 0x7f
 8023d06:	2a16      	cmp	r2, #22
 8023d08:	dc15      	bgt.n	8023d36 <roundf+0x3a>
 8023d0a:	2a00      	cmp	r2, #0
 8023d0c:	da08      	bge.n	8023d20 <roundf+0x24>
 8023d0e:	3201      	adds	r2, #1
 8023d10:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8023d14:	d101      	bne.n	8023d1a <roundf+0x1e>
 8023d16:	f043 537e 	orr.w	r3, r3, #1065353216	; 0x3f800000
 8023d1a:	ee00 3a10 	vmov	s0, r3
 8023d1e:	4770      	bx	lr
 8023d20:	4907      	ldr	r1, [pc, #28]	; (8023d40 <roundf+0x44>)
 8023d22:	4111      	asrs	r1, r2
 8023d24:	4208      	tst	r0, r1
 8023d26:	d0fa      	beq.n	8023d1e <roundf+0x22>
 8023d28:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8023d2c:	4113      	asrs	r3, r2
 8023d2e:	4403      	add	r3, r0
 8023d30:	ea23 0301 	bic.w	r3, r3, r1
 8023d34:	e7f1      	b.n	8023d1a <roundf+0x1e>
 8023d36:	2a80      	cmp	r2, #128	; 0x80
 8023d38:	d1f1      	bne.n	8023d1e <roundf+0x22>
 8023d3a:	ee30 0a00 	vadd.f32	s0, s0, s0
 8023d3e:	4770      	bx	lr
 8023d40:	007fffff 	.word	0x007fffff

08023d44 <truncf>:
 8023d44:	ee10 1a10 	vmov	r1, s0
 8023d48:	f3c1 52c7 	ubfx	r2, r1, #23, #8
 8023d4c:	3a7f      	subs	r2, #127	; 0x7f
 8023d4e:	2a16      	cmp	r2, #22
 8023d50:	dc09      	bgt.n	8023d66 <truncf+0x22>
 8023d52:	2a00      	cmp	r2, #0
 8023d54:	bfa5      	ittet	ge
 8023d56:	4b06      	ldrge	r3, [pc, #24]	; (8023d70 <truncf+0x2c>)
 8023d58:	4113      	asrge	r3, r2
 8023d5a:	f001 4300 	andlt.w	r3, r1, #2147483648	; 0x80000000
 8023d5e:	400b      	andge	r3, r1
 8023d60:	ee00 3a10 	vmov	s0, r3
 8023d64:	4770      	bx	lr
 8023d66:	2a80      	cmp	r2, #128	; 0x80
 8023d68:	bf08      	it	eq
 8023d6a:	ee30 0a00 	vaddeq.f32	s0, s0, s0
 8023d6e:	4770      	bx	lr
 8023d70:	ff800000 	.word	0xff800000
 8023d74:	00000000 	.word	0x00000000

08023d78 <__ieee754_atan2>:
 8023d78:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8023d7c:	ec57 6b11 	vmov	r6, r7, d1
 8023d80:	4273      	negs	r3, r6
 8023d82:	f8df 817c 	ldr.w	r8, [pc, #380]	; 8023f00 <__ieee754_atan2+0x188>
 8023d86:	f027 4200 	bic.w	r2, r7, #2147483648	; 0x80000000
 8023d8a:	4333      	orrs	r3, r6
 8023d8c:	ea42 73d3 	orr.w	r3, r2, r3, lsr #31
 8023d90:	4543      	cmp	r3, r8
 8023d92:	ec51 0b10 	vmov	r0, r1, d0
 8023d96:	ee11 5a10 	vmov	r5, s2
 8023d9a:	d80a      	bhi.n	8023db2 <__ieee754_atan2+0x3a>
 8023d9c:	4244      	negs	r4, r0
 8023d9e:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 8023da2:	4304      	orrs	r4, r0
 8023da4:	ea43 74d4 	orr.w	r4, r3, r4, lsr #31
 8023da8:	4544      	cmp	r4, r8
 8023daa:	ee10 9a10 	vmov	r9, s0
 8023dae:	468e      	mov	lr, r1
 8023db0:	d907      	bls.n	8023dc2 <__ieee754_atan2+0x4a>
 8023db2:	4632      	mov	r2, r6
 8023db4:	463b      	mov	r3, r7
 8023db6:	f7e4 f9b1 	bl	800811c <__adddf3>
 8023dba:	ec41 0b10 	vmov	d0, r0, r1
 8023dbe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8023dc2:	f107 4440 	add.w	r4, r7, #3221225472	; 0xc0000000
 8023dc6:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
 8023dca:	4334      	orrs	r4, r6
 8023dcc:	d103      	bne.n	8023dd6 <__ieee754_atan2+0x5e>
 8023dce:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8023dd2:	f000 b899 	b.w	8023f08 <atan>
 8023dd6:	17bc      	asrs	r4, r7, #30
 8023dd8:	f004 0402 	and.w	r4, r4, #2
 8023ddc:	ea53 0909 	orrs.w	r9, r3, r9
 8023de0:	ea44 74d1 	orr.w	r4, r4, r1, lsr #31
 8023de4:	d107      	bne.n	8023df6 <__ieee754_atan2+0x7e>
 8023de6:	2c02      	cmp	r4, #2
 8023de8:	d05f      	beq.n	8023eaa <__ieee754_atan2+0x132>
 8023dea:	2c03      	cmp	r4, #3
 8023dec:	d1e5      	bne.n	8023dba <__ieee754_atan2+0x42>
 8023dee:	a140      	add	r1, pc, #256	; (adr r1, 8023ef0 <__ieee754_atan2+0x178>)
 8023df0:	e9d1 0100 	ldrd	r0, r1, [r1]
 8023df4:	e7e1      	b.n	8023dba <__ieee754_atan2+0x42>
 8023df6:	4315      	orrs	r5, r2
 8023df8:	d106      	bne.n	8023e08 <__ieee754_atan2+0x90>
 8023dfa:	f1be 0f00 	cmp.w	lr, #0
 8023dfe:	da5f      	bge.n	8023ec0 <__ieee754_atan2+0x148>
 8023e00:	a13d      	add	r1, pc, #244	; (adr r1, 8023ef8 <__ieee754_atan2+0x180>)
 8023e02:	e9d1 0100 	ldrd	r0, r1, [r1]
 8023e06:	e7d8      	b.n	8023dba <__ieee754_atan2+0x42>
 8023e08:	4542      	cmp	r2, r8
 8023e0a:	d10f      	bne.n	8023e2c <__ieee754_atan2+0xb4>
 8023e0c:	4293      	cmp	r3, r2
 8023e0e:	f104 34ff 	add.w	r4, r4, #4294967295
 8023e12:	d107      	bne.n	8023e24 <__ieee754_atan2+0xac>
 8023e14:	2c02      	cmp	r4, #2
 8023e16:	d84c      	bhi.n	8023eb2 <__ieee754_atan2+0x13a>
 8023e18:	4b33      	ldr	r3, [pc, #204]	; (8023ee8 <__ieee754_atan2+0x170>)
 8023e1a:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 8023e1e:	e9d3 0100 	ldrd	r0, r1, [r3]
 8023e22:	e7ca      	b.n	8023dba <__ieee754_atan2+0x42>
 8023e24:	2c02      	cmp	r4, #2
 8023e26:	d848      	bhi.n	8023eba <__ieee754_atan2+0x142>
 8023e28:	4b30      	ldr	r3, [pc, #192]	; (8023eec <__ieee754_atan2+0x174>)
 8023e2a:	e7f6      	b.n	8023e1a <__ieee754_atan2+0xa2>
 8023e2c:	4543      	cmp	r3, r8
 8023e2e:	d0e4      	beq.n	8023dfa <__ieee754_atan2+0x82>
 8023e30:	1a9b      	subs	r3, r3, r2
 8023e32:	f1b3 7f74 	cmp.w	r3, #63963136	; 0x3d00000
 8023e36:	ea4f 5223 	mov.w	r2, r3, asr #20
 8023e3a:	da1e      	bge.n	8023e7a <__ieee754_atan2+0x102>
 8023e3c:	2f00      	cmp	r7, #0
 8023e3e:	da01      	bge.n	8023e44 <__ieee754_atan2+0xcc>
 8023e40:	323c      	adds	r2, #60	; 0x3c
 8023e42:	db1e      	blt.n	8023e82 <__ieee754_atan2+0x10a>
 8023e44:	4632      	mov	r2, r6
 8023e46:	463b      	mov	r3, r7
 8023e48:	f7e4 fc48 	bl	80086dc <__aeabi_ddiv>
 8023e4c:	ec41 0b10 	vmov	d0, r0, r1
 8023e50:	f000 f9fa 	bl	8024248 <fabs>
 8023e54:	f000 f858 	bl	8023f08 <atan>
 8023e58:	ec51 0b10 	vmov	r0, r1, d0
 8023e5c:	2c01      	cmp	r4, #1
 8023e5e:	d013      	beq.n	8023e88 <__ieee754_atan2+0x110>
 8023e60:	2c02      	cmp	r4, #2
 8023e62:	d015      	beq.n	8023e90 <__ieee754_atan2+0x118>
 8023e64:	2c00      	cmp	r4, #0
 8023e66:	d0a8      	beq.n	8023dba <__ieee754_atan2+0x42>
 8023e68:	a317      	add	r3, pc, #92	; (adr r3, 8023ec8 <__ieee754_atan2+0x150>)
 8023e6a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8023e6e:	f7e4 f953 	bl	8008118 <__aeabi_dsub>
 8023e72:	a317      	add	r3, pc, #92	; (adr r3, 8023ed0 <__ieee754_atan2+0x158>)
 8023e74:	e9d3 2300 	ldrd	r2, r3, [r3]
 8023e78:	e014      	b.n	8023ea4 <__ieee754_atan2+0x12c>
 8023e7a:	a117      	add	r1, pc, #92	; (adr r1, 8023ed8 <__ieee754_atan2+0x160>)
 8023e7c:	e9d1 0100 	ldrd	r0, r1, [r1]
 8023e80:	e7ec      	b.n	8023e5c <__ieee754_atan2+0xe4>
 8023e82:	2000      	movs	r0, #0
 8023e84:	2100      	movs	r1, #0
 8023e86:	e7e9      	b.n	8023e5c <__ieee754_atan2+0xe4>
 8023e88:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 8023e8c:	4619      	mov	r1, r3
 8023e8e:	e794      	b.n	8023dba <__ieee754_atan2+0x42>
 8023e90:	a30d      	add	r3, pc, #52	; (adr r3, 8023ec8 <__ieee754_atan2+0x150>)
 8023e92:	e9d3 2300 	ldrd	r2, r3, [r3]
 8023e96:	f7e4 f93f 	bl	8008118 <__aeabi_dsub>
 8023e9a:	4602      	mov	r2, r0
 8023e9c:	460b      	mov	r3, r1
 8023e9e:	a10c      	add	r1, pc, #48	; (adr r1, 8023ed0 <__ieee754_atan2+0x158>)
 8023ea0:	e9d1 0100 	ldrd	r0, r1, [r1]
 8023ea4:	f7e4 f938 	bl	8008118 <__aeabi_dsub>
 8023ea8:	e787      	b.n	8023dba <__ieee754_atan2+0x42>
 8023eaa:	a109      	add	r1, pc, #36	; (adr r1, 8023ed0 <__ieee754_atan2+0x158>)
 8023eac:	e9d1 0100 	ldrd	r0, r1, [r1]
 8023eb0:	e783      	b.n	8023dba <__ieee754_atan2+0x42>
 8023eb2:	a10b      	add	r1, pc, #44	; (adr r1, 8023ee0 <__ieee754_atan2+0x168>)
 8023eb4:	e9d1 0100 	ldrd	r0, r1, [r1]
 8023eb8:	e77f      	b.n	8023dba <__ieee754_atan2+0x42>
 8023eba:	2000      	movs	r0, #0
 8023ebc:	2100      	movs	r1, #0
 8023ebe:	e77c      	b.n	8023dba <__ieee754_atan2+0x42>
 8023ec0:	a105      	add	r1, pc, #20	; (adr r1, 8023ed8 <__ieee754_atan2+0x160>)
 8023ec2:	e9d1 0100 	ldrd	r0, r1, [r1]
 8023ec6:	e778      	b.n	8023dba <__ieee754_atan2+0x42>
 8023ec8:	33145c07 	.word	0x33145c07
 8023ecc:	3ca1a626 	.word	0x3ca1a626
 8023ed0:	54442d18 	.word	0x54442d18
 8023ed4:	400921fb 	.word	0x400921fb
 8023ed8:	54442d18 	.word	0x54442d18
 8023edc:	3ff921fb 	.word	0x3ff921fb
 8023ee0:	54442d18 	.word	0x54442d18
 8023ee4:	3fe921fb 	.word	0x3fe921fb
 8023ee8:	0802d200 	.word	0x0802d200
 8023eec:	0802d218 	.word	0x0802d218
 8023ef0:	54442d18 	.word	0x54442d18
 8023ef4:	c00921fb 	.word	0xc00921fb
 8023ef8:	54442d18 	.word	0x54442d18
 8023efc:	bff921fb 	.word	0xbff921fb
 8023f00:	7ff00000 	.word	0x7ff00000
 8023f04:	00000000 	.word	0x00000000

08023f08 <atan>:
 8023f08:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023f0c:	ec55 4b10 	vmov	r4, r5, d0
 8023f10:	4bc3      	ldr	r3, [pc, #780]	; (8024220 <atan+0x318>)
 8023f12:	f025 4600 	bic.w	r6, r5, #2147483648	; 0x80000000
 8023f16:	429e      	cmp	r6, r3
 8023f18:	46ab      	mov	fp, r5
 8023f1a:	dd18      	ble.n	8023f4e <atan+0x46>
 8023f1c:	4bc1      	ldr	r3, [pc, #772]	; (8024224 <atan+0x31c>)
 8023f1e:	429e      	cmp	r6, r3
 8023f20:	dc01      	bgt.n	8023f26 <atan+0x1e>
 8023f22:	d109      	bne.n	8023f38 <atan+0x30>
 8023f24:	b144      	cbz	r4, 8023f38 <atan+0x30>
 8023f26:	4622      	mov	r2, r4
 8023f28:	462b      	mov	r3, r5
 8023f2a:	4620      	mov	r0, r4
 8023f2c:	4629      	mov	r1, r5
 8023f2e:	f7e4 f8f5 	bl	800811c <__adddf3>
 8023f32:	4604      	mov	r4, r0
 8023f34:	460d      	mov	r5, r1
 8023f36:	e006      	b.n	8023f46 <atan+0x3e>
 8023f38:	f1bb 0f00 	cmp.w	fp, #0
 8023f3c:	f300 8131 	bgt.w	80241a2 <atan+0x29a>
 8023f40:	a59b      	add	r5, pc, #620	; (adr r5, 80241b0 <atan+0x2a8>)
 8023f42:	e9d5 4500 	ldrd	r4, r5, [r5]
 8023f46:	ec45 4b10 	vmov	d0, r4, r5
 8023f4a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8023f4e:	4bb6      	ldr	r3, [pc, #728]	; (8024228 <atan+0x320>)
 8023f50:	429e      	cmp	r6, r3
 8023f52:	dc14      	bgt.n	8023f7e <atan+0x76>
 8023f54:	f1a3 73de 	sub.w	r3, r3, #29097984	; 0x1bc0000
 8023f58:	429e      	cmp	r6, r3
 8023f5a:	dc0d      	bgt.n	8023f78 <atan+0x70>
 8023f5c:	a396      	add	r3, pc, #600	; (adr r3, 80241b8 <atan+0x2b0>)
 8023f5e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8023f62:	ee10 0a10 	vmov	r0, s0
 8023f66:	4629      	mov	r1, r5
 8023f68:	f7e4 f8d8 	bl	800811c <__adddf3>
 8023f6c:	4baf      	ldr	r3, [pc, #700]	; (802422c <atan+0x324>)
 8023f6e:	2200      	movs	r2, #0
 8023f70:	f7e4 fd1a 	bl	80089a8 <__aeabi_dcmpgt>
 8023f74:	2800      	cmp	r0, #0
 8023f76:	d1e6      	bne.n	8023f46 <atan+0x3e>
 8023f78:	f04f 3aff 	mov.w	sl, #4294967295
 8023f7c:	e02b      	b.n	8023fd6 <atan+0xce>
 8023f7e:	f000 f963 	bl	8024248 <fabs>
 8023f82:	4bab      	ldr	r3, [pc, #684]	; (8024230 <atan+0x328>)
 8023f84:	429e      	cmp	r6, r3
 8023f86:	ec55 4b10 	vmov	r4, r5, d0
 8023f8a:	f300 80bf 	bgt.w	802410c <atan+0x204>
 8023f8e:	f5a3 2350 	sub.w	r3, r3, #851968	; 0xd0000
 8023f92:	429e      	cmp	r6, r3
 8023f94:	f300 80a0 	bgt.w	80240d8 <atan+0x1d0>
 8023f98:	ee10 2a10 	vmov	r2, s0
 8023f9c:	ee10 0a10 	vmov	r0, s0
 8023fa0:	462b      	mov	r3, r5
 8023fa2:	4629      	mov	r1, r5
 8023fa4:	f7e4 f8ba 	bl	800811c <__adddf3>
 8023fa8:	4ba0      	ldr	r3, [pc, #640]	; (802422c <atan+0x324>)
 8023faa:	2200      	movs	r2, #0
 8023fac:	f7e4 f8b4 	bl	8008118 <__aeabi_dsub>
 8023fb0:	2200      	movs	r2, #0
 8023fb2:	4606      	mov	r6, r0
 8023fb4:	460f      	mov	r7, r1
 8023fb6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8023fba:	4620      	mov	r0, r4
 8023fbc:	4629      	mov	r1, r5
 8023fbe:	f7e4 f8ad 	bl	800811c <__adddf3>
 8023fc2:	4602      	mov	r2, r0
 8023fc4:	460b      	mov	r3, r1
 8023fc6:	4630      	mov	r0, r6
 8023fc8:	4639      	mov	r1, r7
 8023fca:	f7e4 fb87 	bl	80086dc <__aeabi_ddiv>
 8023fce:	f04f 0a00 	mov.w	sl, #0
 8023fd2:	4604      	mov	r4, r0
 8023fd4:	460d      	mov	r5, r1
 8023fd6:	4622      	mov	r2, r4
 8023fd8:	462b      	mov	r3, r5
 8023fda:	4620      	mov	r0, r4
 8023fdc:	4629      	mov	r1, r5
 8023fde:	f7e4 fa53 	bl	8008488 <__aeabi_dmul>
 8023fe2:	4602      	mov	r2, r0
 8023fe4:	460b      	mov	r3, r1
 8023fe6:	4680      	mov	r8, r0
 8023fe8:	4689      	mov	r9, r1
 8023fea:	f7e4 fa4d 	bl	8008488 <__aeabi_dmul>
 8023fee:	a374      	add	r3, pc, #464	; (adr r3, 80241c0 <atan+0x2b8>)
 8023ff0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8023ff4:	4606      	mov	r6, r0
 8023ff6:	460f      	mov	r7, r1
 8023ff8:	f7e4 fa46 	bl	8008488 <__aeabi_dmul>
 8023ffc:	a372      	add	r3, pc, #456	; (adr r3, 80241c8 <atan+0x2c0>)
 8023ffe:	e9d3 2300 	ldrd	r2, r3, [r3]
 8024002:	f7e4 f88b 	bl	800811c <__adddf3>
 8024006:	4632      	mov	r2, r6
 8024008:	463b      	mov	r3, r7
 802400a:	f7e4 fa3d 	bl	8008488 <__aeabi_dmul>
 802400e:	a370      	add	r3, pc, #448	; (adr r3, 80241d0 <atan+0x2c8>)
 8024010:	e9d3 2300 	ldrd	r2, r3, [r3]
 8024014:	f7e4 f882 	bl	800811c <__adddf3>
 8024018:	4632      	mov	r2, r6
 802401a:	463b      	mov	r3, r7
 802401c:	f7e4 fa34 	bl	8008488 <__aeabi_dmul>
 8024020:	a36d      	add	r3, pc, #436	; (adr r3, 80241d8 <atan+0x2d0>)
 8024022:	e9d3 2300 	ldrd	r2, r3, [r3]
 8024026:	f7e4 f879 	bl	800811c <__adddf3>
 802402a:	4632      	mov	r2, r6
 802402c:	463b      	mov	r3, r7
 802402e:	f7e4 fa2b 	bl	8008488 <__aeabi_dmul>
 8024032:	a36b      	add	r3, pc, #428	; (adr r3, 80241e0 <atan+0x2d8>)
 8024034:	e9d3 2300 	ldrd	r2, r3, [r3]
 8024038:	f7e4 f870 	bl	800811c <__adddf3>
 802403c:	4632      	mov	r2, r6
 802403e:	463b      	mov	r3, r7
 8024040:	f7e4 fa22 	bl	8008488 <__aeabi_dmul>
 8024044:	a368      	add	r3, pc, #416	; (adr r3, 80241e8 <atan+0x2e0>)
 8024046:	e9d3 2300 	ldrd	r2, r3, [r3]
 802404a:	f7e4 f867 	bl	800811c <__adddf3>
 802404e:	4642      	mov	r2, r8
 8024050:	464b      	mov	r3, r9
 8024052:	f7e4 fa19 	bl	8008488 <__aeabi_dmul>
 8024056:	a366      	add	r3, pc, #408	; (adr r3, 80241f0 <atan+0x2e8>)
 8024058:	e9d3 2300 	ldrd	r2, r3, [r3]
 802405c:	4680      	mov	r8, r0
 802405e:	4689      	mov	r9, r1
 8024060:	4630      	mov	r0, r6
 8024062:	4639      	mov	r1, r7
 8024064:	f7e4 fa10 	bl	8008488 <__aeabi_dmul>
 8024068:	a363      	add	r3, pc, #396	; (adr r3, 80241f8 <atan+0x2f0>)
 802406a:	e9d3 2300 	ldrd	r2, r3, [r3]
 802406e:	f7e4 f853 	bl	8008118 <__aeabi_dsub>
 8024072:	4632      	mov	r2, r6
 8024074:	463b      	mov	r3, r7
 8024076:	f7e4 fa07 	bl	8008488 <__aeabi_dmul>
 802407a:	a361      	add	r3, pc, #388	; (adr r3, 8024200 <atan+0x2f8>)
 802407c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8024080:	f7e4 f84a 	bl	8008118 <__aeabi_dsub>
 8024084:	4632      	mov	r2, r6
 8024086:	463b      	mov	r3, r7
 8024088:	f7e4 f9fe 	bl	8008488 <__aeabi_dmul>
 802408c:	a35e      	add	r3, pc, #376	; (adr r3, 8024208 <atan+0x300>)
 802408e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8024092:	f7e4 f841 	bl	8008118 <__aeabi_dsub>
 8024096:	4632      	mov	r2, r6
 8024098:	463b      	mov	r3, r7
 802409a:	f7e4 f9f5 	bl	8008488 <__aeabi_dmul>
 802409e:	a35c      	add	r3, pc, #368	; (adr r3, 8024210 <atan+0x308>)
 80240a0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80240a4:	f7e4 f838 	bl	8008118 <__aeabi_dsub>
 80240a8:	4632      	mov	r2, r6
 80240aa:	463b      	mov	r3, r7
 80240ac:	f7e4 f9ec 	bl	8008488 <__aeabi_dmul>
 80240b0:	4602      	mov	r2, r0
 80240b2:	460b      	mov	r3, r1
 80240b4:	4640      	mov	r0, r8
 80240b6:	4649      	mov	r1, r9
 80240b8:	f7e4 f830 	bl	800811c <__adddf3>
 80240bc:	4622      	mov	r2, r4
 80240be:	462b      	mov	r3, r5
 80240c0:	f7e4 f9e2 	bl	8008488 <__aeabi_dmul>
 80240c4:	f1ba 3fff 	cmp.w	sl, #4294967295
 80240c8:	4602      	mov	r2, r0
 80240ca:	460b      	mov	r3, r1
 80240cc:	d14b      	bne.n	8024166 <atan+0x25e>
 80240ce:	4620      	mov	r0, r4
 80240d0:	4629      	mov	r1, r5
 80240d2:	f7e4 f821 	bl	8008118 <__aeabi_dsub>
 80240d6:	e72c      	b.n	8023f32 <atan+0x2a>
 80240d8:	ee10 0a10 	vmov	r0, s0
 80240dc:	4b53      	ldr	r3, [pc, #332]	; (802422c <atan+0x324>)
 80240de:	2200      	movs	r2, #0
 80240e0:	4629      	mov	r1, r5
 80240e2:	f7e4 f819 	bl	8008118 <__aeabi_dsub>
 80240e6:	4b51      	ldr	r3, [pc, #324]	; (802422c <atan+0x324>)
 80240e8:	4606      	mov	r6, r0
 80240ea:	460f      	mov	r7, r1
 80240ec:	2200      	movs	r2, #0
 80240ee:	4620      	mov	r0, r4
 80240f0:	4629      	mov	r1, r5
 80240f2:	f7e4 f813 	bl	800811c <__adddf3>
 80240f6:	4602      	mov	r2, r0
 80240f8:	460b      	mov	r3, r1
 80240fa:	4630      	mov	r0, r6
 80240fc:	4639      	mov	r1, r7
 80240fe:	f7e4 faed 	bl	80086dc <__aeabi_ddiv>
 8024102:	f04f 0a01 	mov.w	sl, #1
 8024106:	4604      	mov	r4, r0
 8024108:	460d      	mov	r5, r1
 802410a:	e764      	b.n	8023fd6 <atan+0xce>
 802410c:	4b49      	ldr	r3, [pc, #292]	; (8024234 <atan+0x32c>)
 802410e:	429e      	cmp	r6, r3
 8024110:	da1d      	bge.n	802414e <atan+0x246>
 8024112:	ee10 0a10 	vmov	r0, s0
 8024116:	4b48      	ldr	r3, [pc, #288]	; (8024238 <atan+0x330>)
 8024118:	2200      	movs	r2, #0
 802411a:	4629      	mov	r1, r5
 802411c:	f7e3 fffc 	bl	8008118 <__aeabi_dsub>
 8024120:	4b45      	ldr	r3, [pc, #276]	; (8024238 <atan+0x330>)
 8024122:	4606      	mov	r6, r0
 8024124:	460f      	mov	r7, r1
 8024126:	2200      	movs	r2, #0
 8024128:	4620      	mov	r0, r4
 802412a:	4629      	mov	r1, r5
 802412c:	f7e4 f9ac 	bl	8008488 <__aeabi_dmul>
 8024130:	4b3e      	ldr	r3, [pc, #248]	; (802422c <atan+0x324>)
 8024132:	2200      	movs	r2, #0
 8024134:	f7e3 fff2 	bl	800811c <__adddf3>
 8024138:	4602      	mov	r2, r0
 802413a:	460b      	mov	r3, r1
 802413c:	4630      	mov	r0, r6
 802413e:	4639      	mov	r1, r7
 8024140:	f7e4 facc 	bl	80086dc <__aeabi_ddiv>
 8024144:	f04f 0a02 	mov.w	sl, #2
 8024148:	4604      	mov	r4, r0
 802414a:	460d      	mov	r5, r1
 802414c:	e743      	b.n	8023fd6 <atan+0xce>
 802414e:	462b      	mov	r3, r5
 8024150:	ee10 2a10 	vmov	r2, s0
 8024154:	4939      	ldr	r1, [pc, #228]	; (802423c <atan+0x334>)
 8024156:	2000      	movs	r0, #0
 8024158:	f7e4 fac0 	bl	80086dc <__aeabi_ddiv>
 802415c:	f04f 0a03 	mov.w	sl, #3
 8024160:	4604      	mov	r4, r0
 8024162:	460d      	mov	r5, r1
 8024164:	e737      	b.n	8023fd6 <atan+0xce>
 8024166:	4b36      	ldr	r3, [pc, #216]	; (8024240 <atan+0x338>)
 8024168:	4e36      	ldr	r6, [pc, #216]	; (8024244 <atan+0x33c>)
 802416a:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
 802416e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8024172:	f7e3 ffd1 	bl	8008118 <__aeabi_dsub>
 8024176:	4622      	mov	r2, r4
 8024178:	462b      	mov	r3, r5
 802417a:	f7e3 ffcd 	bl	8008118 <__aeabi_dsub>
 802417e:	eb06 06ca 	add.w	r6, r6, sl, lsl #3
 8024182:	4602      	mov	r2, r0
 8024184:	460b      	mov	r3, r1
 8024186:	e9d6 0100 	ldrd	r0, r1, [r6]
 802418a:	f7e3 ffc5 	bl	8008118 <__aeabi_dsub>
 802418e:	f1bb 0f00 	cmp.w	fp, #0
 8024192:	4604      	mov	r4, r0
 8024194:	460d      	mov	r5, r1
 8024196:	f6bf aed6 	bge.w	8023f46 <atan+0x3e>
 802419a:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 802419e:	461d      	mov	r5, r3
 80241a0:	e6d1      	b.n	8023f46 <atan+0x3e>
 80241a2:	a51d      	add	r5, pc, #116	; (adr r5, 8024218 <atan+0x310>)
 80241a4:	e9d5 4500 	ldrd	r4, r5, [r5]
 80241a8:	e6cd      	b.n	8023f46 <atan+0x3e>
 80241aa:	bf00      	nop
 80241ac:	f3af 8000 	nop.w
 80241b0:	54442d18 	.word	0x54442d18
 80241b4:	bff921fb 	.word	0xbff921fb
 80241b8:	8800759c 	.word	0x8800759c
 80241bc:	7e37e43c 	.word	0x7e37e43c
 80241c0:	e322da11 	.word	0xe322da11
 80241c4:	3f90ad3a 	.word	0x3f90ad3a
 80241c8:	24760deb 	.word	0x24760deb
 80241cc:	3fa97b4b 	.word	0x3fa97b4b
 80241d0:	a0d03d51 	.word	0xa0d03d51
 80241d4:	3fb10d66 	.word	0x3fb10d66
 80241d8:	c54c206e 	.word	0xc54c206e
 80241dc:	3fb745cd 	.word	0x3fb745cd
 80241e0:	920083ff 	.word	0x920083ff
 80241e4:	3fc24924 	.word	0x3fc24924
 80241e8:	5555550d 	.word	0x5555550d
 80241ec:	3fd55555 	.word	0x3fd55555
 80241f0:	2c6a6c2f 	.word	0x2c6a6c2f
 80241f4:	bfa2b444 	.word	0xbfa2b444
 80241f8:	52defd9a 	.word	0x52defd9a
 80241fc:	3fadde2d 	.word	0x3fadde2d
 8024200:	af749a6d 	.word	0xaf749a6d
 8024204:	3fb3b0f2 	.word	0x3fb3b0f2
 8024208:	fe231671 	.word	0xfe231671
 802420c:	3fbc71c6 	.word	0x3fbc71c6
 8024210:	9998ebc4 	.word	0x9998ebc4
 8024214:	3fc99999 	.word	0x3fc99999
 8024218:	54442d18 	.word	0x54442d18
 802421c:	3ff921fb 	.word	0x3ff921fb
 8024220:	440fffff 	.word	0x440fffff
 8024224:	7ff00000 	.word	0x7ff00000
 8024228:	3fdbffff 	.word	0x3fdbffff
 802422c:	3ff00000 	.word	0x3ff00000
 8024230:	3ff2ffff 	.word	0x3ff2ffff
 8024234:	40038000 	.word	0x40038000
 8024238:	3ff80000 	.word	0x3ff80000
 802423c:	bff00000 	.word	0xbff00000
 8024240:	0802d250 	.word	0x0802d250
 8024244:	0802d230 	.word	0x0802d230

08024248 <fabs>:
 8024248:	ec51 0b10 	vmov	r0, r1, d0
 802424c:	ee10 2a10 	vmov	r2, s0
 8024250:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 8024254:	ec43 2b10 	vmov	d0, r2, r3
 8024258:	4770      	bx	lr
	...

0802425c <__kernel_cosf>:
 802425c:	ee10 3a10 	vmov	r3, s0
 8024260:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8024264:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 8024268:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 802426c:	da05      	bge.n	802427a <__kernel_cosf+0x1e>
 802426e:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8024272:	ee17 2a90 	vmov	r2, s15
 8024276:	2a00      	cmp	r2, #0
 8024278:	d03b      	beq.n	80242f2 <__kernel_cosf+0x96>
 802427a:	ee20 7a00 	vmul.f32	s14, s0, s0
 802427e:	eddf 7a1e 	vldr	s15, [pc, #120]	; 80242f8 <__kernel_cosf+0x9c>
 8024282:	ed9f 6a1e 	vldr	s12, [pc, #120]	; 80242fc <__kernel_cosf+0xa0>
 8024286:	4a1e      	ldr	r2, [pc, #120]	; (8024300 <__kernel_cosf+0xa4>)
 8024288:	eea7 6a27 	vfma.f32	s12, s14, s15
 802428c:	4293      	cmp	r3, r2
 802428e:	eddf 7a1d 	vldr	s15, [pc, #116]	; 8024304 <__kernel_cosf+0xa8>
 8024292:	eee6 7a07 	vfma.f32	s15, s12, s14
 8024296:	ed9f 6a1c 	vldr	s12, [pc, #112]	; 8024308 <__kernel_cosf+0xac>
 802429a:	eea7 6a87 	vfma.f32	s12, s15, s14
 802429e:	eddf 7a1b 	vldr	s15, [pc, #108]	; 802430c <__kernel_cosf+0xb0>
 80242a2:	eee6 7a07 	vfma.f32	s15, s12, s14
 80242a6:	ed9f 6a1a 	vldr	s12, [pc, #104]	; 8024310 <__kernel_cosf+0xb4>
 80242aa:	eea7 6a87 	vfma.f32	s12, s15, s14
 80242ae:	ee60 0ac0 	vnmul.f32	s1, s1, s0
 80242b2:	ee26 6a07 	vmul.f32	s12, s12, s14
 80242b6:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 80242ba:	eee7 0a06 	vfma.f32	s1, s14, s12
 80242be:	ee67 7a27 	vmul.f32	s15, s14, s15
 80242c2:	dc04      	bgt.n	80242ce <__kernel_cosf+0x72>
 80242c4:	ee77 7ae0 	vsub.f32	s15, s15, s1
 80242c8:	ee36 0ae7 	vsub.f32	s0, s13, s15
 80242cc:	4770      	bx	lr
 80242ce:	4a11      	ldr	r2, [pc, #68]	; (8024314 <__kernel_cosf+0xb8>)
 80242d0:	4293      	cmp	r3, r2
 80242d2:	bfda      	itte	le
 80242d4:	f103 437f 	addle.w	r3, r3, #4278190080	; 0xff000000
 80242d8:	ee07 3a10 	vmovle	s14, r3
 80242dc:	eeb5 7a02 	vmovgt.f32	s14, #82	; 0x3e900000  0.2812500
 80242e0:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80242e4:	ee36 0ac7 	vsub.f32	s0, s13, s14
 80242e8:	ee77 7ae0 	vsub.f32	s15, s15, s1
 80242ec:	ee30 0a67 	vsub.f32	s0, s0, s15
 80242f0:	4770      	bx	lr
 80242f2:	eeb0 0a66 	vmov.f32	s0, s13
 80242f6:	4770      	bx	lr
 80242f8:	ad47d74e 	.word	0xad47d74e
 80242fc:	310f74f6 	.word	0x310f74f6
 8024300:	3e999999 	.word	0x3e999999
 8024304:	b493f27c 	.word	0xb493f27c
 8024308:	37d00d01 	.word	0x37d00d01
 802430c:	bab60b61 	.word	0xbab60b61
 8024310:	3d2aaaab 	.word	0x3d2aaaab
 8024314:	3f480000 	.word	0x3f480000

08024318 <__kernel_sinf>:
 8024318:	ee10 3a10 	vmov	r3, s0
 802431c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8024320:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 8024324:	da04      	bge.n	8024330 <__kernel_sinf+0x18>
 8024326:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 802432a:	ee17 3a90 	vmov	r3, s15
 802432e:	b35b      	cbz	r3, 8024388 <__kernel_sinf+0x70>
 8024330:	ee20 7a00 	vmul.f32	s14, s0, s0
 8024334:	eddf 7a15 	vldr	s15, [pc, #84]	; 802438c <__kernel_sinf+0x74>
 8024338:	ed9f 6a15 	vldr	s12, [pc, #84]	; 8024390 <__kernel_sinf+0x78>
 802433c:	eea7 6a27 	vfma.f32	s12, s14, s15
 8024340:	eddf 7a14 	vldr	s15, [pc, #80]	; 8024394 <__kernel_sinf+0x7c>
 8024344:	eee6 7a07 	vfma.f32	s15, s12, s14
 8024348:	ed9f 6a13 	vldr	s12, [pc, #76]	; 8024398 <__kernel_sinf+0x80>
 802434c:	eea7 6a87 	vfma.f32	s12, s15, s14
 8024350:	eddf 7a12 	vldr	s15, [pc, #72]	; 802439c <__kernel_sinf+0x84>
 8024354:	ee60 6a07 	vmul.f32	s13, s0, s14
 8024358:	eee6 7a07 	vfma.f32	s15, s12, s14
 802435c:	b930      	cbnz	r0, 802436c <__kernel_sinf+0x54>
 802435e:	ed9f 6a10 	vldr	s12, [pc, #64]	; 80243a0 <__kernel_sinf+0x88>
 8024362:	eea7 6a27 	vfma.f32	s12, s14, s15
 8024366:	eea6 0a26 	vfma.f32	s0, s12, s13
 802436a:	4770      	bx	lr
 802436c:	ee67 7ae6 	vnmul.f32	s15, s15, s13
 8024370:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
 8024374:	eee0 7a86 	vfma.f32	s15, s1, s12
 8024378:	eed7 0a87 	vfnms.f32	s1, s15, s14
 802437c:	eddf 7a09 	vldr	s15, [pc, #36]	; 80243a4 <__kernel_sinf+0x8c>
 8024380:	eee6 0aa7 	vfma.f32	s1, s13, s15
 8024384:	ee30 0a60 	vsub.f32	s0, s0, s1
 8024388:	4770      	bx	lr
 802438a:	bf00      	nop
 802438c:	2f2ec9d3 	.word	0x2f2ec9d3
 8024390:	b2d72f34 	.word	0xb2d72f34
 8024394:	3638ef1b 	.word	0x3638ef1b
 8024398:	b9500d01 	.word	0xb9500d01
 802439c:	3c088889 	.word	0x3c088889
 80243a0:	be2aaaab 	.word	0xbe2aaaab
 80243a4:	3e2aaaab 	.word	0x3e2aaaab

080243a8 <__kernel_tanf>:
 80243a8:	b508      	push	{r3, lr}
 80243aa:	ee10 3a10 	vmov	r3, s0
 80243ae:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 80243b2:	f1b2 5f46 	cmp.w	r2, #830472192	; 0x31800000
 80243b6:	eef0 7a40 	vmov.f32	s15, s0
 80243ba:	da17      	bge.n	80243ec <__kernel_tanf+0x44>
 80243bc:	eebd 7ac0 	vcvt.s32.f32	s14, s0
 80243c0:	ee17 1a10 	vmov	r1, s14
 80243c4:	bb41      	cbnz	r1, 8024418 <__kernel_tanf+0x70>
 80243c6:	1c43      	adds	r3, r0, #1
 80243c8:	4313      	orrs	r3, r2
 80243ca:	d108      	bne.n	80243de <__kernel_tanf+0x36>
 80243cc:	f000 fcc2 	bl	8024d54 <fabsf>
 80243d0:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80243d4:	eec7 7a00 	vdiv.f32	s15, s14, s0
 80243d8:	eeb0 0a67 	vmov.f32	s0, s15
 80243dc:	bd08      	pop	{r3, pc}
 80243de:	2801      	cmp	r0, #1
 80243e0:	d0fa      	beq.n	80243d8 <__kernel_tanf+0x30>
 80243e2:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 80243e6:	eec7 7a00 	vdiv.f32	s15, s14, s0
 80243ea:	e7f5      	b.n	80243d8 <__kernel_tanf+0x30>
 80243ec:	494c      	ldr	r1, [pc, #304]	; (8024520 <__kernel_tanf+0x178>)
 80243ee:	428a      	cmp	r2, r1
 80243f0:	db12      	blt.n	8024418 <__kernel_tanf+0x70>
 80243f2:	2b00      	cmp	r3, #0
 80243f4:	ed9f 7a4b 	vldr	s14, [pc, #300]	; 8024524 <__kernel_tanf+0x17c>
 80243f8:	bfb8      	it	lt
 80243fa:	eef1 7a40 	vneglt.f32	s15, s0
 80243fe:	ee37 7a67 	vsub.f32	s14, s14, s15
 8024402:	eddf 7a49 	vldr	s15, [pc, #292]	; 8024528 <__kernel_tanf+0x180>
 8024406:	bfb8      	it	lt
 8024408:	eef1 0a60 	vneglt.f32	s1, s1
 802440c:	ee77 7ae0 	vsub.f32	s15, s15, s1
 8024410:	eddf 0a46 	vldr	s1, [pc, #280]	; 802452c <__kernel_tanf+0x184>
 8024414:	ee77 7a87 	vadd.f32	s15, s15, s14
 8024418:	ee67 6aa7 	vmul.f32	s13, s15, s15
 802441c:	eddf 5a44 	vldr	s11, [pc, #272]	; 8024530 <__kernel_tanf+0x188>
 8024420:	ed9f 6a44 	vldr	s12, [pc, #272]	; 8024534 <__kernel_tanf+0x18c>
 8024424:	ed9f 5a44 	vldr	s10, [pc, #272]	; 8024538 <__kernel_tanf+0x190>
 8024428:	493d      	ldr	r1, [pc, #244]	; (8024520 <__kernel_tanf+0x178>)
 802442a:	ee26 7aa6 	vmul.f32	s14, s13, s13
 802442e:	428a      	cmp	r2, r1
 8024430:	eea7 6a25 	vfma.f32	s12, s14, s11
 8024434:	eddf 5a41 	vldr	s11, [pc, #260]	; 802453c <__kernel_tanf+0x194>
 8024438:	eee6 5a07 	vfma.f32	s11, s12, s14
 802443c:	ed9f 6a40 	vldr	s12, [pc, #256]	; 8024540 <__kernel_tanf+0x198>
 8024440:	eea5 6a87 	vfma.f32	s12, s11, s14
 8024444:	eddf 5a3f 	vldr	s11, [pc, #252]	; 8024544 <__kernel_tanf+0x19c>
 8024448:	eee6 5a07 	vfma.f32	s11, s12, s14
 802444c:	ed9f 6a3e 	vldr	s12, [pc, #248]	; 8024548 <__kernel_tanf+0x1a0>
 8024450:	eea5 6a87 	vfma.f32	s12, s11, s14
 8024454:	eddf 5a3d 	vldr	s11, [pc, #244]	; 802454c <__kernel_tanf+0x1a4>
 8024458:	eee7 5a05 	vfma.f32	s11, s14, s10
 802445c:	ed9f 5a3c 	vldr	s10, [pc, #240]	; 8024550 <__kernel_tanf+0x1a8>
 8024460:	eea5 5a87 	vfma.f32	s10, s11, s14
 8024464:	eddf 5a3b 	vldr	s11, [pc, #236]	; 8024554 <__kernel_tanf+0x1ac>
 8024468:	eee5 5a07 	vfma.f32	s11, s10, s14
 802446c:	ed9f 5a3a 	vldr	s10, [pc, #232]	; 8024558 <__kernel_tanf+0x1b0>
 8024470:	eea5 5a87 	vfma.f32	s10, s11, s14
 8024474:	eddf 5a39 	vldr	s11, [pc, #228]	; 802455c <__kernel_tanf+0x1b4>
 8024478:	eee5 5a07 	vfma.f32	s11, s10, s14
 802447c:	eeb0 7a46 	vmov.f32	s14, s12
 8024480:	eea5 7aa6 	vfma.f32	s14, s11, s13
 8024484:	ee27 5aa6 	vmul.f32	s10, s15, s13
 8024488:	eeb0 6a60 	vmov.f32	s12, s1
 802448c:	eea7 6a05 	vfma.f32	s12, s14, s10
 8024490:	ed9f 7a33 	vldr	s14, [pc, #204]	; 8024560 <__kernel_tanf+0x1b8>
 8024494:	eee6 0a26 	vfma.f32	s1, s12, s13
 8024498:	eee5 0a07 	vfma.f32	s1, s10, s14
 802449c:	ee77 6aa0 	vadd.f32	s13, s15, s1
 80244a0:	db1d      	blt.n	80244de <__kernel_tanf+0x136>
 80244a2:	ee07 0a10 	vmov	s14, r0
 80244a6:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 80244aa:	ee66 5aa6 	vmul.f32	s11, s13, s13
 80244ae:	ee76 6a87 	vadd.f32	s13, s13, s14
 80244b2:	179b      	asrs	r3, r3, #30
 80244b4:	ee85 6aa6 	vdiv.f32	s12, s11, s13
 80244b8:	f003 0302 	and.w	r3, r3, #2
 80244bc:	f1c3 0301 	rsb	r3, r3, #1
 80244c0:	ee76 6a60 	vsub.f32	s13, s12, s1
 80244c4:	ee77 7ae6 	vsub.f32	s15, s15, s13
 80244c8:	eef0 6a00 	vmov.f32	s13, #0	; 0x40000000  2.0
 80244cc:	eea7 7ae6 	vfms.f32	s14, s15, s13
 80244d0:	ee07 3a90 	vmov	s15, r3
 80244d4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80244d8:	ee67 7a87 	vmul.f32	s15, s15, s14
 80244dc:	e77c      	b.n	80243d8 <__kernel_tanf+0x30>
 80244de:	2801      	cmp	r0, #1
 80244e0:	d01b      	beq.n	802451a <__kernel_tanf+0x172>
 80244e2:	4b20      	ldr	r3, [pc, #128]	; (8024564 <__kernel_tanf+0x1bc>)
 80244e4:	ee16 2a90 	vmov	r2, s13
 80244e8:	401a      	ands	r2, r3
 80244ea:	ee05 2a90 	vmov	s11, r2
 80244ee:	ee75 7ae7 	vsub.f32	s15, s11, s15
 80244f2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80244f6:	ee70 0ae7 	vsub.f32	s1, s1, s15
 80244fa:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 80244fe:	ee87 6aa6 	vdiv.f32	s12, s15, s13
 8024502:	ee16 2a10 	vmov	r2, s12
 8024506:	4013      	ands	r3, r2
 8024508:	ee07 3a90 	vmov	s15, r3
 802450c:	eea5 7aa7 	vfma.f32	s14, s11, s15
 8024510:	eea0 7aa7 	vfma.f32	s14, s1, s15
 8024514:	eee7 7a06 	vfma.f32	s15, s14, s12
 8024518:	e75e      	b.n	80243d8 <__kernel_tanf+0x30>
 802451a:	eef0 7a66 	vmov.f32	s15, s13
 802451e:	e75b      	b.n	80243d8 <__kernel_tanf+0x30>
 8024520:	3f2ca140 	.word	0x3f2ca140
 8024524:	3f490fda 	.word	0x3f490fda
 8024528:	33222168 	.word	0x33222168
 802452c:	00000000 	.word	0x00000000
 8024530:	b79bae5f 	.word	0xb79bae5f
 8024534:	38a3f445 	.word	0x38a3f445
 8024538:	37d95384 	.word	0x37d95384
 802453c:	3a1a26c8 	.word	0x3a1a26c8
 8024540:	3b6b6916 	.word	0x3b6b6916
 8024544:	3cb327a4 	.word	0x3cb327a4
 8024548:	3e088889 	.word	0x3e088889
 802454c:	3895c07a 	.word	0x3895c07a
 8024550:	398137b9 	.word	0x398137b9
 8024554:	3abede48 	.word	0x3abede48
 8024558:	3c11371f 	.word	0x3c11371f
 802455c:	3d5d0dd1 	.word	0x3d5d0dd1
 8024560:	3eaaaaab 	.word	0x3eaaaaab
 8024564:	fffff000 	.word	0xfffff000

08024568 <__ieee754_powf>:
 8024568:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802456c:	ee10 4a90 	vmov	r4, s1
 8024570:	f034 4800 	bics.w	r8, r4, #2147483648	; 0x80000000
 8024574:	ed2d 8b02 	vpush	{d8}
 8024578:	ee10 7a10 	vmov	r7, s0
 802457c:	eeb0 8a40 	vmov.f32	s16, s0
 8024580:	eef0 8a60 	vmov.f32	s17, s1
 8024584:	d10c      	bne.n	80245a0 <__ieee754_powf+0x38>
 8024586:	f487 0780 	eor.w	r7, r7, #4194304	; 0x400000
 802458a:	007f      	lsls	r7, r7, #1
 802458c:	f517 0f00 	cmn.w	r7, #8388608	; 0x800000
 8024590:	f240 8292 	bls.w	8024ab8 <__ieee754_powf+0x550>
 8024594:	ee38 0a28 	vadd.f32	s0, s16, s17
 8024598:	ecbd 8b02 	vpop	{d8}
 802459c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80245a0:	f027 4500 	bic.w	r5, r7, #2147483648	; 0x80000000
 80245a4:	f1b5 4fff 	cmp.w	r5, #2139095040	; 0x7f800000
 80245a8:	dcf4      	bgt.n	8024594 <__ieee754_powf+0x2c>
 80245aa:	f1b8 4fff 	cmp.w	r8, #2139095040	; 0x7f800000
 80245ae:	dd08      	ble.n	80245c2 <__ieee754_powf+0x5a>
 80245b0:	f1b7 5f7e 	cmp.w	r7, #1065353216	; 0x3f800000
 80245b4:	d1ee      	bne.n	8024594 <__ieee754_powf+0x2c>
 80245b6:	f484 0480 	eor.w	r4, r4, #4194304	; 0x400000
 80245ba:	0064      	lsls	r4, r4, #1
 80245bc:	f514 0f00 	cmn.w	r4, #8388608	; 0x800000
 80245c0:	e7e6      	b.n	8024590 <__ieee754_powf+0x28>
 80245c2:	2f00      	cmp	r7, #0
 80245c4:	da20      	bge.n	8024608 <__ieee754_powf+0xa0>
 80245c6:	f1b8 4f97 	cmp.w	r8, #1266679808	; 0x4b800000
 80245ca:	da2d      	bge.n	8024628 <__ieee754_powf+0xc0>
 80245cc:	f1b8 5f7e 	cmp.w	r8, #1065353216	; 0x3f800000
 80245d0:	f2c0 827b 	blt.w	8024aca <__ieee754_powf+0x562>
 80245d4:	ea4f 53e8 	mov.w	r3, r8, asr #23
 80245d8:	f1c3 0396 	rsb	r3, r3, #150	; 0x96
 80245dc:	fa48 f603 	asr.w	r6, r8, r3
 80245e0:	fa06 f303 	lsl.w	r3, r6, r3
 80245e4:	4543      	cmp	r3, r8
 80245e6:	f040 8270 	bne.w	8024aca <__ieee754_powf+0x562>
 80245ea:	f006 0601 	and.w	r6, r6, #1
 80245ee:	f1c6 0602 	rsb	r6, r6, #2
 80245f2:	f1b8 5f7e 	cmp.w	r8, #1065353216	; 0x3f800000
 80245f6:	d11f      	bne.n	8024638 <__ieee754_powf+0xd0>
 80245f8:	2c00      	cmp	r4, #0
 80245fa:	f280 8263 	bge.w	8024ac4 <__ieee754_powf+0x55c>
 80245fe:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8024602:	ee87 0a88 	vdiv.f32	s0, s15, s16
 8024606:	e7c7      	b.n	8024598 <__ieee754_powf+0x30>
 8024608:	2600      	movs	r6, #0
 802460a:	f1b8 4fff 	cmp.w	r8, #2139095040	; 0x7f800000
 802460e:	d1f0      	bne.n	80245f2 <__ieee754_powf+0x8a>
 8024610:	f1b5 5f7e 	cmp.w	r5, #1065353216	; 0x3f800000
 8024614:	f000 8250 	beq.w	8024ab8 <__ieee754_powf+0x550>
 8024618:	dd08      	ble.n	802462c <__ieee754_powf+0xc4>
 802461a:	ed9f 0ac1 	vldr	s0, [pc, #772]	; 8024920 <__ieee754_powf+0x3b8>
 802461e:	2c00      	cmp	r4, #0
 8024620:	bfa8      	it	ge
 8024622:	eeb0 0a68 	vmovge.f32	s0, s17
 8024626:	e7b7      	b.n	8024598 <__ieee754_powf+0x30>
 8024628:	2602      	movs	r6, #2
 802462a:	e7ee      	b.n	802460a <__ieee754_powf+0xa2>
 802462c:	2c00      	cmp	r4, #0
 802462e:	f280 8246 	bge.w	8024abe <__ieee754_powf+0x556>
 8024632:	eeb1 0a68 	vneg.f32	s0, s17
 8024636:	e7af      	b.n	8024598 <__ieee754_powf+0x30>
 8024638:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
 802463c:	d102      	bne.n	8024644 <__ieee754_powf+0xdc>
 802463e:	ee28 0a08 	vmul.f32	s0, s16, s16
 8024642:	e7a9      	b.n	8024598 <__ieee754_powf+0x30>
 8024644:	f1b4 5f7c 	cmp.w	r4, #1056964608	; 0x3f000000
 8024648:	eeb0 0a48 	vmov.f32	s0, s16
 802464c:	d107      	bne.n	802465e <__ieee754_powf+0xf6>
 802464e:	2f00      	cmp	r7, #0
 8024650:	db05      	blt.n	802465e <__ieee754_powf+0xf6>
 8024652:	ecbd 8b02 	vpop	{d8}
 8024656:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 802465a:	f7ff bac7 	b.w	8023bec <__ieee754_sqrtf>
 802465e:	f000 fb79 	bl	8024d54 <fabsf>
 8024662:	b125      	cbz	r5, 802466e <__ieee754_powf+0x106>
 8024664:	f027 4340 	bic.w	r3, r7, #3221225472	; 0xc0000000
 8024668:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
 802466c:	d115      	bne.n	802469a <__ieee754_powf+0x132>
 802466e:	2c00      	cmp	r4, #0
 8024670:	bfbc      	itt	lt
 8024672:	eef7 7a00 	vmovlt.f32	s15, #112	; 0x3f800000  1.0
 8024676:	ee87 0a80 	vdivlt.f32	s0, s15, s0
 802467a:	2f00      	cmp	r7, #0
 802467c:	da8c      	bge.n	8024598 <__ieee754_powf+0x30>
 802467e:	f1a5 557e 	sub.w	r5, r5, #1065353216	; 0x3f800000
 8024682:	4335      	orrs	r5, r6
 8024684:	d104      	bne.n	8024690 <__ieee754_powf+0x128>
 8024686:	ee70 7a40 	vsub.f32	s15, s0, s0
 802468a:	ee87 0aa7 	vdiv.f32	s0, s15, s15
 802468e:	e783      	b.n	8024598 <__ieee754_powf+0x30>
 8024690:	2e01      	cmp	r6, #1
 8024692:	d181      	bne.n	8024598 <__ieee754_powf+0x30>
 8024694:	eeb1 0a40 	vneg.f32	s0, s0
 8024698:	e77e      	b.n	8024598 <__ieee754_powf+0x30>
 802469a:	0ff8      	lsrs	r0, r7, #31
 802469c:	3801      	subs	r0, #1
 802469e:	ea56 0300 	orrs.w	r3, r6, r0
 80246a2:	d104      	bne.n	80246ae <__ieee754_powf+0x146>
 80246a4:	ee38 8a48 	vsub.f32	s16, s16, s16
 80246a8:	ee88 0a08 	vdiv.f32	s0, s16, s16
 80246ac:	e774      	b.n	8024598 <__ieee754_powf+0x30>
 80246ae:	f1b8 4f9a 	cmp.w	r8, #1291845632	; 0x4d000000
 80246b2:	dd73      	ble.n	802479c <__ieee754_powf+0x234>
 80246b4:	4b9b      	ldr	r3, [pc, #620]	; (8024924 <__ieee754_powf+0x3bc>)
 80246b6:	429d      	cmp	r5, r3
 80246b8:	dc08      	bgt.n	80246cc <__ieee754_powf+0x164>
 80246ba:	2c00      	cmp	r4, #0
 80246bc:	da0b      	bge.n	80246d6 <__ieee754_powf+0x16e>
 80246be:	2000      	movs	r0, #0
 80246c0:	ecbd 8b02 	vpop	{d8}
 80246c4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80246c8:	f000 bbce 	b.w	8024e68 <__math_oflowf>
 80246cc:	4b96      	ldr	r3, [pc, #600]	; (8024928 <__ieee754_powf+0x3c0>)
 80246ce:	429d      	cmp	r5, r3
 80246d0:	dd08      	ble.n	80246e4 <__ieee754_powf+0x17c>
 80246d2:	2c00      	cmp	r4, #0
 80246d4:	dcf3      	bgt.n	80246be <__ieee754_powf+0x156>
 80246d6:	2000      	movs	r0, #0
 80246d8:	ecbd 8b02 	vpop	{d8}
 80246dc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80246e0:	f000 bbbc 	b.w	8024e5c <__math_uflowf>
 80246e4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80246e8:	ee30 0a67 	vsub.f32	s0, s0, s15
 80246ec:	eddf 6a8f 	vldr	s13, [pc, #572]	; 802492c <__ieee754_powf+0x3c4>
 80246f0:	eef5 7a00 	vmov.f32	s15, #80	; 0x3e800000  0.250
 80246f4:	eee0 6a67 	vfms.f32	s13, s0, s15
 80246f8:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 80246fc:	eee6 7ac0 	vfms.f32	s15, s13, s0
 8024700:	ee20 7a00 	vmul.f32	s14, s0, s0
 8024704:	ee27 7a27 	vmul.f32	s14, s14, s15
 8024708:	eddf 7a89 	vldr	s15, [pc, #548]	; 8024930 <__ieee754_powf+0x3c8>
 802470c:	ee67 7ac7 	vnmul.f32	s15, s15, s14
 8024710:	ed9f 7a88 	vldr	s14, [pc, #544]	; 8024934 <__ieee754_powf+0x3cc>
 8024714:	eee0 7a07 	vfma.f32	s15, s0, s14
 8024718:	ed9f 7a87 	vldr	s14, [pc, #540]	; 8024938 <__ieee754_powf+0x3d0>
 802471c:	eef0 6a67 	vmov.f32	s13, s15
 8024720:	eee0 6a07 	vfma.f32	s13, s0, s14
 8024724:	ee16 3a90 	vmov	r3, s13
 8024728:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 802472c:	f023 030f 	bic.w	r3, r3, #15
 8024730:	ee06 3a90 	vmov	s13, r3
 8024734:	eee0 6a47 	vfms.f32	s13, s0, s14
 8024738:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802473c:	3e01      	subs	r6, #1
 802473e:	f424 647f 	bic.w	r4, r4, #4080	; 0xff0
 8024742:	4306      	orrs	r6, r0
 8024744:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 8024748:	f024 040f 	bic.w	r4, r4, #15
 802474c:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
 8024750:	bf08      	it	eq
 8024752:	eeb0 8a47 	vmoveq.f32	s16, s14
 8024756:	ee07 4a10 	vmov	s14, r4
 802475a:	ee67 0aa8 	vmul.f32	s1, s15, s17
 802475e:	ee38 7ac7 	vsub.f32	s14, s17, s14
 8024762:	ee07 3a90 	vmov	s15, r3
 8024766:	eee7 0a27 	vfma.f32	s1, s14, s15
 802476a:	ee07 4a10 	vmov	s14, r4
 802476e:	ee67 7a87 	vmul.f32	s15, s15, s14
 8024772:	ee30 7aa7 	vadd.f32	s14, s1, s15
 8024776:	ee17 1a10 	vmov	r1, s14
 802477a:	2900      	cmp	r1, #0
 802477c:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 8024780:	f340 817c 	ble.w	8024a7c <__ieee754_powf+0x514>
 8024784:	f1b3 4f86 	cmp.w	r3, #1124073472	; 0x43000000
 8024788:	f340 80f8 	ble.w	802497c <__ieee754_powf+0x414>
 802478c:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8024790:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024794:	bf4c      	ite	mi
 8024796:	2001      	movmi	r0, #1
 8024798:	2000      	movpl	r0, #0
 802479a:	e791      	b.n	80246c0 <__ieee754_powf+0x158>
 802479c:	f017 4fff 	tst.w	r7, #2139095040	; 0x7f800000
 80247a0:	bf01      	itttt	eq
 80247a2:	eddf 7a66 	vldreq	s15, [pc, #408]	; 802493c <__ieee754_powf+0x3d4>
 80247a6:	ee60 7a27 	vmuleq.f32	s15, s0, s15
 80247aa:	f06f 0317 	mvneq.w	r3, #23
 80247ae:	ee17 5a90 	vmoveq	r5, s15
 80247b2:	ea4f 52e5 	mov.w	r2, r5, asr #23
 80247b6:	bf18      	it	ne
 80247b8:	2300      	movne	r3, #0
 80247ba:	3a7f      	subs	r2, #127	; 0x7f
 80247bc:	441a      	add	r2, r3
 80247be:	4b60      	ldr	r3, [pc, #384]	; (8024940 <__ieee754_powf+0x3d8>)
 80247c0:	f3c5 0516 	ubfx	r5, r5, #0, #23
 80247c4:	429d      	cmp	r5, r3
 80247c6:	f045 517e 	orr.w	r1, r5, #1065353216	; 0x3f800000
 80247ca:	dd06      	ble.n	80247da <__ieee754_powf+0x272>
 80247cc:	4b5d      	ldr	r3, [pc, #372]	; (8024944 <__ieee754_powf+0x3dc>)
 80247ce:	429d      	cmp	r5, r3
 80247d0:	f340 80a4 	ble.w	802491c <__ieee754_powf+0x3b4>
 80247d4:	3201      	adds	r2, #1
 80247d6:	f5a1 0100 	sub.w	r1, r1, #8388608	; 0x800000
 80247da:	2500      	movs	r5, #0
 80247dc:	4b5a      	ldr	r3, [pc, #360]	; (8024948 <__ieee754_powf+0x3e0>)
 80247de:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 80247e2:	ee07 1a10 	vmov	s14, r1
 80247e6:	edd3 5a00 	vldr	s11, [r3]
 80247ea:	4b58      	ldr	r3, [pc, #352]	; (802494c <__ieee754_powf+0x3e4>)
 80247ec:	ee75 7a87 	vadd.f32	s15, s11, s14
 80247f0:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 80247f4:	eec6 4aa7 	vdiv.f32	s9, s13, s15
 80247f8:	1049      	asrs	r1, r1, #1
 80247fa:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
 80247fe:	f501 2180 	add.w	r1, r1, #262144	; 0x40000
 8024802:	eb01 5145 	add.w	r1, r1, r5, lsl #21
 8024806:	ee37 6a65 	vsub.f32	s12, s14, s11
 802480a:	ee07 1a90 	vmov	s15, r1
 802480e:	ee26 5a24 	vmul.f32	s10, s12, s9
 8024812:	ee77 5ae5 	vsub.f32	s11, s15, s11
 8024816:	ee15 7a10 	vmov	r7, s10
 802481a:	401f      	ands	r7, r3
 802481c:	ee06 7a90 	vmov	s13, r7
 8024820:	eea6 6ae7 	vfms.f32	s12, s13, s15
 8024824:	ee37 7a65 	vsub.f32	s14, s14, s11
 8024828:	ee65 7a05 	vmul.f32	s15, s10, s10
 802482c:	eea6 6ac7 	vfms.f32	s12, s13, s14
 8024830:	eddf 5a47 	vldr	s11, [pc, #284]	; 8024950 <__ieee754_powf+0x3e8>
 8024834:	ed9f 7a47 	vldr	s14, [pc, #284]	; 8024954 <__ieee754_powf+0x3ec>
 8024838:	eee7 5a87 	vfma.f32	s11, s15, s14
 802483c:	ed9f 7a46 	vldr	s14, [pc, #280]	; 8024958 <__ieee754_powf+0x3f0>
 8024840:	eea5 7aa7 	vfma.f32	s14, s11, s15
 8024844:	eddf 5a39 	vldr	s11, [pc, #228]	; 802492c <__ieee754_powf+0x3c4>
 8024848:	eee7 5a27 	vfma.f32	s11, s14, s15
 802484c:	ed9f 7a43 	vldr	s14, [pc, #268]	; 802495c <__ieee754_powf+0x3f4>
 8024850:	eea5 7aa7 	vfma.f32	s14, s11, s15
 8024854:	eddf 5a42 	vldr	s11, [pc, #264]	; 8024960 <__ieee754_powf+0x3f8>
 8024858:	ee26 6a24 	vmul.f32	s12, s12, s9
 802485c:	eee7 5a27 	vfma.f32	s11, s14, s15
 8024860:	ee35 7a26 	vadd.f32	s14, s10, s13
 8024864:	ee67 4aa7 	vmul.f32	s9, s15, s15
 8024868:	ee27 7a06 	vmul.f32	s14, s14, s12
 802486c:	eef0 7a08 	vmov.f32	s15, #8	; 0x40400000  3.0
 8024870:	eea4 7aa5 	vfma.f32	s14, s9, s11
 8024874:	eef0 5a67 	vmov.f32	s11, s15
 8024878:	eee6 5aa6 	vfma.f32	s11, s13, s13
 802487c:	ee75 5a87 	vadd.f32	s11, s11, s14
 8024880:	ee15 1a90 	vmov	r1, s11
 8024884:	4019      	ands	r1, r3
 8024886:	ee05 1a90 	vmov	s11, r1
 802488a:	ee75 7ae7 	vsub.f32	s15, s11, s15
 802488e:	eee6 7ae6 	vfms.f32	s15, s13, s13
 8024892:	ee77 7a67 	vsub.f32	s15, s14, s15
 8024896:	ee67 7a85 	vmul.f32	s15, s15, s10
 802489a:	eee6 7a25 	vfma.f32	s15, s12, s11
 802489e:	eeb0 6a67 	vmov.f32	s12, s15
 80248a2:	eea6 6aa5 	vfma.f32	s12, s13, s11
 80248a6:	ee16 1a10 	vmov	r1, s12
 80248aa:	4019      	ands	r1, r3
 80248ac:	ee07 1a10 	vmov	s14, r1
 80248b0:	eea6 7ae5 	vfms.f32	s14, s13, s11
 80248b4:	ee06 1a10 	vmov	s12, r1
 80248b8:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80248bc:	ed9f 7a29 	vldr	s14, [pc, #164]	; 8024964 <__ieee754_powf+0x3fc>
 80248c0:	4929      	ldr	r1, [pc, #164]	; (8024968 <__ieee754_powf+0x400>)
 80248c2:	eddf 5a2a 	vldr	s11, [pc, #168]	; 802496c <__ieee754_powf+0x404>
 80248c6:	ee67 7a87 	vmul.f32	s15, s15, s14
 80248ca:	ed9f 7a29 	vldr	s14, [pc, #164]	; 8024970 <__ieee754_powf+0x408>
 80248ce:	eee6 7a07 	vfma.f32	s15, s12, s14
 80248d2:	eb01 0185 	add.w	r1, r1, r5, lsl #2
 80248d6:	ed91 7a00 	vldr	s14, [r1]
 80248da:	ee77 7a87 	vadd.f32	s15, s15, s14
 80248de:	ee07 2a10 	vmov	s14, r2
 80248e2:	eef0 6a67 	vmov.f32	s13, s15
 80248e6:	4a23      	ldr	r2, [pc, #140]	; (8024974 <__ieee754_powf+0x40c>)
 80248e8:	eee6 6a25 	vfma.f32	s13, s12, s11
 80248ec:	eb02 0285 	add.w	r2, r2, r5, lsl #2
 80248f0:	ed92 5a00 	vldr	s10, [r2]
 80248f4:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 80248f8:	ee76 6a85 	vadd.f32	s13, s13, s10
 80248fc:	ee76 6a87 	vadd.f32	s13, s13, s14
 8024900:	ee16 2a90 	vmov	r2, s13
 8024904:	4013      	ands	r3, r2
 8024906:	ee06 3a90 	vmov	s13, r3
 802490a:	ee36 7ac7 	vsub.f32	s14, s13, s14
 802490e:	ee37 7a45 	vsub.f32	s14, s14, s10
 8024912:	eea6 7a65 	vfms.f32	s14, s12, s11
 8024916:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802491a:	e70f      	b.n	802473c <__ieee754_powf+0x1d4>
 802491c:	2501      	movs	r5, #1
 802491e:	e75d      	b.n	80247dc <__ieee754_powf+0x274>
 8024920:	00000000 	.word	0x00000000
 8024924:	3f7ffff3 	.word	0x3f7ffff3
 8024928:	3f800007 	.word	0x3f800007
 802492c:	3eaaaaab 	.word	0x3eaaaaab
 8024930:	3fb8aa3b 	.word	0x3fb8aa3b
 8024934:	36eca570 	.word	0x36eca570
 8024938:	3fb8aa00 	.word	0x3fb8aa00
 802493c:	4b800000 	.word	0x4b800000
 8024940:	001cc471 	.word	0x001cc471
 8024944:	005db3d6 	.word	0x005db3d6
 8024948:	0802d270 	.word	0x0802d270
 802494c:	fffff000 	.word	0xfffff000
 8024950:	3e6c3255 	.word	0x3e6c3255
 8024954:	3e53f142 	.word	0x3e53f142
 8024958:	3e8ba305 	.word	0x3e8ba305
 802495c:	3edb6db7 	.word	0x3edb6db7
 8024960:	3f19999a 	.word	0x3f19999a
 8024964:	3f76384f 	.word	0x3f76384f
 8024968:	0802d280 	.word	0x0802d280
 802496c:	3f763800 	.word	0x3f763800
 8024970:	369dc3a0 	.word	0x369dc3a0
 8024974:	0802d278 	.word	0x0802d278
 8024978:	3338aa3c 	.word	0x3338aa3c
 802497c:	f040 8093 	bne.w	8024aa6 <__ieee754_powf+0x53e>
 8024980:	ed5f 6a03 	vldr	s13, [pc, #-12]	; 8024978 <__ieee754_powf+0x410>
 8024984:	ee37 7a67 	vsub.f32	s14, s14, s15
 8024988:	ee70 6aa6 	vadd.f32	s13, s1, s13
 802498c:	eef4 6ac7 	vcmpe.f32	s13, s14
 8024990:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024994:	f73f aefa 	bgt.w	802478c <__ieee754_powf+0x224>
 8024998:	15db      	asrs	r3, r3, #23
 802499a:	3b7e      	subs	r3, #126	; 0x7e
 802499c:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 80249a0:	4118      	asrs	r0, r3
 80249a2:	4408      	add	r0, r1
 80249a4:	f3c0 53c7 	ubfx	r3, r0, #23, #8
 80249a8:	4a49      	ldr	r2, [pc, #292]	; (8024ad0 <__ieee754_powf+0x568>)
 80249aa:	3b7f      	subs	r3, #127	; 0x7f
 80249ac:	411a      	asrs	r2, r3
 80249ae:	4002      	ands	r2, r0
 80249b0:	ee07 2a10 	vmov	s14, r2
 80249b4:	f3c0 0016 	ubfx	r0, r0, #0, #23
 80249b8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80249bc:	f1c3 0317 	rsb	r3, r3, #23
 80249c0:	4118      	asrs	r0, r3
 80249c2:	2900      	cmp	r1, #0
 80249c4:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80249c8:	bfb8      	it	lt
 80249ca:	4240      	neglt	r0, r0
 80249cc:	ee37 7aa0 	vadd.f32	s14, s15, s1
 80249d0:	eddf 6a40 	vldr	s13, [pc, #256]	; 8024ad4 <__ieee754_powf+0x56c>
 80249d4:	ed9f 6a40 	vldr	s12, [pc, #256]	; 8024ad8 <__ieee754_powf+0x570>
 80249d8:	ee17 3a10 	vmov	r3, s14
 80249dc:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 80249e0:	f023 030f 	bic.w	r3, r3, #15
 80249e4:	ee07 3a10 	vmov	s14, r3
 80249e8:	ee77 7a67 	vsub.f32	s15, s14, s15
 80249ec:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80249f0:	ee70 0ae7 	vsub.f32	s1, s1, s15
 80249f4:	eddf 7a39 	vldr	s15, [pc, #228]	; 8024adc <__ieee754_powf+0x574>
 80249f8:	ee67 7a27 	vmul.f32	s15, s14, s15
 80249fc:	eee0 7aa6 	vfma.f32	s15, s1, s13
 8024a00:	eef0 6a67 	vmov.f32	s13, s15
 8024a04:	eee7 6a06 	vfma.f32	s13, s14, s12
 8024a08:	eef0 5a66 	vmov.f32	s11, s13
 8024a0c:	eee7 5a46 	vfms.f32	s11, s14, s12
 8024a10:	ee26 7aa6 	vmul.f32	s14, s13, s13
 8024a14:	ee77 7ae5 	vsub.f32	s15, s15, s11
 8024a18:	ed9f 6a31 	vldr	s12, [pc, #196]	; 8024ae0 <__ieee754_powf+0x578>
 8024a1c:	eddf 5a31 	vldr	s11, [pc, #196]	; 8024ae4 <__ieee754_powf+0x57c>
 8024a20:	eea7 6a25 	vfma.f32	s12, s14, s11
 8024a24:	eddf 5a30 	vldr	s11, [pc, #192]	; 8024ae8 <__ieee754_powf+0x580>
 8024a28:	eee6 5a07 	vfma.f32	s11, s12, s14
 8024a2c:	ed9f 6a2f 	vldr	s12, [pc, #188]	; 8024aec <__ieee754_powf+0x584>
 8024a30:	eea5 6a87 	vfma.f32	s12, s11, s14
 8024a34:	eddf 5a2e 	vldr	s11, [pc, #184]	; 8024af0 <__ieee754_powf+0x588>
 8024a38:	eee6 5a07 	vfma.f32	s11, s12, s14
 8024a3c:	eeb0 6a66 	vmov.f32	s12, s13
 8024a40:	eea5 6ac7 	vfms.f32	s12, s11, s14
 8024a44:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
 8024a48:	ee66 5a86 	vmul.f32	s11, s13, s12
 8024a4c:	ee36 6a47 	vsub.f32	s12, s12, s14
 8024a50:	eee6 7aa7 	vfma.f32	s15, s13, s15
 8024a54:	ee85 7a86 	vdiv.f32	s14, s11, s12
 8024a58:	ee77 7a67 	vsub.f32	s15, s14, s15
 8024a5c:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8024a60:	ee30 0a67 	vsub.f32	s0, s0, s15
 8024a64:	ee10 3a10 	vmov	r3, s0
 8024a68:	eb03 53c0 	add.w	r3, r3, r0, lsl #23
 8024a6c:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8024a70:	da1f      	bge.n	8024ab2 <__ieee754_powf+0x54a>
 8024a72:	f000 f977 	bl	8024d64 <scalbnf>
 8024a76:	ee20 0a08 	vmul.f32	s0, s0, s16
 8024a7a:	e58d      	b.n	8024598 <__ieee754_powf+0x30>
 8024a7c:	4a1d      	ldr	r2, [pc, #116]	; (8024af4 <__ieee754_powf+0x58c>)
 8024a7e:	4293      	cmp	r3, r2
 8024a80:	dd07      	ble.n	8024a92 <__ieee754_powf+0x52a>
 8024a82:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8024a86:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024a8a:	bf4c      	ite	mi
 8024a8c:	2001      	movmi	r0, #1
 8024a8e:	2000      	movpl	r0, #0
 8024a90:	e622      	b.n	80246d8 <__ieee754_powf+0x170>
 8024a92:	d108      	bne.n	8024aa6 <__ieee754_powf+0x53e>
 8024a94:	ee37 7a67 	vsub.f32	s14, s14, s15
 8024a98:	eeb4 7ae0 	vcmpe.f32	s14, s1
 8024a9c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024aa0:	f6ff af7a 	blt.w	8024998 <__ieee754_powf+0x430>
 8024aa4:	e7ed      	b.n	8024a82 <__ieee754_powf+0x51a>
 8024aa6:	f1b3 5f7c 	cmp.w	r3, #1056964608	; 0x3f000000
 8024aaa:	f73f af75 	bgt.w	8024998 <__ieee754_powf+0x430>
 8024aae:	2000      	movs	r0, #0
 8024ab0:	e78c      	b.n	80249cc <__ieee754_powf+0x464>
 8024ab2:	ee00 3a10 	vmov	s0, r3
 8024ab6:	e7de      	b.n	8024a76 <__ieee754_powf+0x50e>
 8024ab8:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8024abc:	e56c      	b.n	8024598 <__ieee754_powf+0x30>
 8024abe:	ed9f 0a0e 	vldr	s0, [pc, #56]	; 8024af8 <__ieee754_powf+0x590>
 8024ac2:	e569      	b.n	8024598 <__ieee754_powf+0x30>
 8024ac4:	eeb0 0a48 	vmov.f32	s0, s16
 8024ac8:	e566      	b.n	8024598 <__ieee754_powf+0x30>
 8024aca:	2600      	movs	r6, #0
 8024acc:	e591      	b.n	80245f2 <__ieee754_powf+0x8a>
 8024ace:	bf00      	nop
 8024ad0:	ff800000 	.word	0xff800000
 8024ad4:	3f317218 	.word	0x3f317218
 8024ad8:	3f317200 	.word	0x3f317200
 8024adc:	35bfbe8c 	.word	0x35bfbe8c
 8024ae0:	b5ddea0e 	.word	0xb5ddea0e
 8024ae4:	3331bb4c 	.word	0x3331bb4c
 8024ae8:	388ab355 	.word	0x388ab355
 8024aec:	bb360b61 	.word	0xbb360b61
 8024af0:	3e2aaaab 	.word	0x3e2aaaab
 8024af4:	43160000 	.word	0x43160000
 8024af8:	00000000 	.word	0x00000000

08024afc <__ieee754_rem_pio2f>:
 8024afc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8024afe:	ee10 6a10 	vmov	r6, s0
 8024b02:	4b86      	ldr	r3, [pc, #536]	; (8024d1c <__ieee754_rem_pio2f+0x220>)
 8024b04:	f026 4500 	bic.w	r5, r6, #2147483648	; 0x80000000
 8024b08:	429d      	cmp	r5, r3
 8024b0a:	b087      	sub	sp, #28
 8024b0c:	4604      	mov	r4, r0
 8024b0e:	dc05      	bgt.n	8024b1c <__ieee754_rem_pio2f+0x20>
 8024b10:	2300      	movs	r3, #0
 8024b12:	ed80 0a00 	vstr	s0, [r0]
 8024b16:	6043      	str	r3, [r0, #4]
 8024b18:	2000      	movs	r0, #0
 8024b1a:	e020      	b.n	8024b5e <__ieee754_rem_pio2f+0x62>
 8024b1c:	4b80      	ldr	r3, [pc, #512]	; (8024d20 <__ieee754_rem_pio2f+0x224>)
 8024b1e:	429d      	cmp	r5, r3
 8024b20:	dc38      	bgt.n	8024b94 <__ieee754_rem_pio2f+0x98>
 8024b22:	2e00      	cmp	r6, #0
 8024b24:	ed9f 7a7f 	vldr	s14, [pc, #508]	; 8024d24 <__ieee754_rem_pio2f+0x228>
 8024b28:	4b7f      	ldr	r3, [pc, #508]	; (8024d28 <__ieee754_rem_pio2f+0x22c>)
 8024b2a:	f025 050f 	bic.w	r5, r5, #15
 8024b2e:	dd18      	ble.n	8024b62 <__ieee754_rem_pio2f+0x66>
 8024b30:	429d      	cmp	r5, r3
 8024b32:	ee70 7a47 	vsub.f32	s15, s0, s14
 8024b36:	bf09      	itett	eq
 8024b38:	ed9f 7a7c 	vldreq	s14, [pc, #496]	; 8024d2c <__ieee754_rem_pio2f+0x230>
 8024b3c:	ed9f 7a7c 	vldrne	s14, [pc, #496]	; 8024d30 <__ieee754_rem_pio2f+0x234>
 8024b40:	ee77 7ac7 	vsubeq.f32	s15, s15, s14
 8024b44:	ed9f 7a7b 	vldreq	s14, [pc, #492]	; 8024d34 <__ieee754_rem_pio2f+0x238>
 8024b48:	ee77 6ac7 	vsub.f32	s13, s15, s14
 8024b4c:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8024b50:	edc0 6a00 	vstr	s13, [r0]
 8024b54:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8024b58:	edc0 7a01 	vstr	s15, [r0, #4]
 8024b5c:	2001      	movs	r0, #1
 8024b5e:	b007      	add	sp, #28
 8024b60:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8024b62:	429d      	cmp	r5, r3
 8024b64:	ee70 7a07 	vadd.f32	s15, s0, s14
 8024b68:	bf09      	itett	eq
 8024b6a:	ed9f 7a70 	vldreq	s14, [pc, #448]	; 8024d2c <__ieee754_rem_pio2f+0x230>
 8024b6e:	ed9f 7a70 	vldrne	s14, [pc, #448]	; 8024d30 <__ieee754_rem_pio2f+0x234>
 8024b72:	ee77 7a87 	vaddeq.f32	s15, s15, s14
 8024b76:	ed9f 7a6f 	vldreq	s14, [pc, #444]	; 8024d34 <__ieee754_rem_pio2f+0x238>
 8024b7a:	ee77 6a87 	vadd.f32	s13, s15, s14
 8024b7e:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8024b82:	edc0 6a00 	vstr	s13, [r0]
 8024b86:	ee77 7a87 	vadd.f32	s15, s15, s14
 8024b8a:	edc0 7a01 	vstr	s15, [r0, #4]
 8024b8e:	f04f 30ff 	mov.w	r0, #4294967295
 8024b92:	e7e4      	b.n	8024b5e <__ieee754_rem_pio2f+0x62>
 8024b94:	4b68      	ldr	r3, [pc, #416]	; (8024d38 <__ieee754_rem_pio2f+0x23c>)
 8024b96:	429d      	cmp	r5, r3
 8024b98:	dc71      	bgt.n	8024c7e <__ieee754_rem_pio2f+0x182>
 8024b9a:	f000 f8db 	bl	8024d54 <fabsf>
 8024b9e:	ed9f 7a67 	vldr	s14, [pc, #412]	; 8024d3c <__ieee754_rem_pio2f+0x240>
 8024ba2:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8024ba6:	eee0 7a07 	vfma.f32	s15, s0, s14
 8024baa:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8024bae:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8024bb2:	ee17 0a90 	vmov	r0, s15
 8024bb6:	eddf 7a5b 	vldr	s15, [pc, #364]	; 8024d24 <__ieee754_rem_pio2f+0x228>
 8024bba:	eea7 0a67 	vfms.f32	s0, s14, s15
 8024bbe:	281f      	cmp	r0, #31
 8024bc0:	eddf 7a5b 	vldr	s15, [pc, #364]	; 8024d30 <__ieee754_rem_pio2f+0x234>
 8024bc4:	ee67 7a27 	vmul.f32	s15, s14, s15
 8024bc8:	eeb1 6a47 	vneg.f32	s12, s14
 8024bcc:	ee70 6a67 	vsub.f32	s13, s0, s15
 8024bd0:	ee16 2a90 	vmov	r2, s13
 8024bd4:	dc1c      	bgt.n	8024c10 <__ieee754_rem_pio2f+0x114>
 8024bd6:	495a      	ldr	r1, [pc, #360]	; (8024d40 <__ieee754_rem_pio2f+0x244>)
 8024bd8:	1e47      	subs	r7, r0, #1
 8024bda:	f025 03ff 	bic.w	r3, r5, #255	; 0xff
 8024bde:	f851 1027 	ldr.w	r1, [r1, r7, lsl #2]
 8024be2:	428b      	cmp	r3, r1
 8024be4:	d014      	beq.n	8024c10 <__ieee754_rem_pio2f+0x114>
 8024be6:	6022      	str	r2, [r4, #0]
 8024be8:	ed94 7a00 	vldr	s14, [r4]
 8024bec:	ee30 0a47 	vsub.f32	s0, s0, s14
 8024bf0:	2e00      	cmp	r6, #0
 8024bf2:	ee30 0a67 	vsub.f32	s0, s0, s15
 8024bf6:	ed84 0a01 	vstr	s0, [r4, #4]
 8024bfa:	dab0      	bge.n	8024b5e <__ieee754_rem_pio2f+0x62>
 8024bfc:	eeb1 7a47 	vneg.f32	s14, s14
 8024c00:	eeb1 0a40 	vneg.f32	s0, s0
 8024c04:	ed84 7a00 	vstr	s14, [r4]
 8024c08:	ed84 0a01 	vstr	s0, [r4, #4]
 8024c0c:	4240      	negs	r0, r0
 8024c0e:	e7a6      	b.n	8024b5e <__ieee754_rem_pio2f+0x62>
 8024c10:	f3c2 51c7 	ubfx	r1, r2, #23, #8
 8024c14:	ebc1 51d5 	rsb	r1, r1, r5, lsr #23
 8024c18:	2908      	cmp	r1, #8
 8024c1a:	ea4f 53e5 	mov.w	r3, r5, asr #23
 8024c1e:	dde2      	ble.n	8024be6 <__ieee754_rem_pio2f+0xea>
 8024c20:	eddf 5a42 	vldr	s11, [pc, #264]	; 8024d2c <__ieee754_rem_pio2f+0x230>
 8024c24:	eef0 6a40 	vmov.f32	s13, s0
 8024c28:	eee6 6a25 	vfma.f32	s13, s12, s11
 8024c2c:	ee70 7a66 	vsub.f32	s15, s0, s13
 8024c30:	eee6 7a25 	vfma.f32	s15, s12, s11
 8024c34:	eddf 5a3f 	vldr	s11, [pc, #252]	; 8024d34 <__ieee754_rem_pio2f+0x238>
 8024c38:	eed7 7a25 	vfnms.f32	s15, s14, s11
 8024c3c:	ee76 5ae7 	vsub.f32	s11, s13, s15
 8024c40:	ee15 2a90 	vmov	r2, s11
 8024c44:	f3c2 51c7 	ubfx	r1, r2, #23, #8
 8024c48:	1a5b      	subs	r3, r3, r1
 8024c4a:	2b19      	cmp	r3, #25
 8024c4c:	dc04      	bgt.n	8024c58 <__ieee754_rem_pio2f+0x15c>
 8024c4e:	edc4 5a00 	vstr	s11, [r4]
 8024c52:	eeb0 0a66 	vmov.f32	s0, s13
 8024c56:	e7c7      	b.n	8024be8 <__ieee754_rem_pio2f+0xec>
 8024c58:	eddf 5a3a 	vldr	s11, [pc, #232]	; 8024d44 <__ieee754_rem_pio2f+0x248>
 8024c5c:	eeb0 0a66 	vmov.f32	s0, s13
 8024c60:	eea6 0a25 	vfma.f32	s0, s12, s11
 8024c64:	ee76 7ac0 	vsub.f32	s15, s13, s0
 8024c68:	eddf 6a37 	vldr	s13, [pc, #220]	; 8024d48 <__ieee754_rem_pio2f+0x24c>
 8024c6c:	eee6 7a25 	vfma.f32	s15, s12, s11
 8024c70:	eed7 7a26 	vfnms.f32	s15, s14, s13
 8024c74:	ee30 7a67 	vsub.f32	s14, s0, s15
 8024c78:	ed84 7a00 	vstr	s14, [r4]
 8024c7c:	e7b4      	b.n	8024be8 <__ieee754_rem_pio2f+0xec>
 8024c7e:	f1b5 4fff 	cmp.w	r5, #2139095040	; 0x7f800000
 8024c82:	db06      	blt.n	8024c92 <__ieee754_rem_pio2f+0x196>
 8024c84:	ee70 7a40 	vsub.f32	s15, s0, s0
 8024c88:	edc0 7a01 	vstr	s15, [r0, #4]
 8024c8c:	edc0 7a00 	vstr	s15, [r0]
 8024c90:	e742      	b.n	8024b18 <__ieee754_rem_pio2f+0x1c>
 8024c92:	15ea      	asrs	r2, r5, #23
 8024c94:	3a86      	subs	r2, #134	; 0x86
 8024c96:	eba5 53c2 	sub.w	r3, r5, r2, lsl #23
 8024c9a:	ee07 3a90 	vmov	s15, r3
 8024c9e:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 8024ca2:	eddf 6a2a 	vldr	s13, [pc, #168]	; 8024d4c <__ieee754_rem_pio2f+0x250>
 8024ca6:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8024caa:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8024cae:	ed8d 7a03 	vstr	s14, [sp, #12]
 8024cb2:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8024cb6:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 8024cba:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8024cbe:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8024cc2:	ed8d 7a04 	vstr	s14, [sp, #16]
 8024cc6:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8024cca:	eef5 7a40 	vcmp.f32	s15, #0.0
 8024cce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024cd2:	edcd 7a05 	vstr	s15, [sp, #20]
 8024cd6:	d11e      	bne.n	8024d16 <__ieee754_rem_pio2f+0x21a>
 8024cd8:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8024cdc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024ce0:	bf14      	ite	ne
 8024ce2:	2302      	movne	r3, #2
 8024ce4:	2301      	moveq	r3, #1
 8024ce6:	491a      	ldr	r1, [pc, #104]	; (8024d50 <__ieee754_rem_pio2f+0x254>)
 8024ce8:	9101      	str	r1, [sp, #4]
 8024cea:	2102      	movs	r1, #2
 8024cec:	9100      	str	r1, [sp, #0]
 8024cee:	a803      	add	r0, sp, #12
 8024cf0:	4621      	mov	r1, r4
 8024cf2:	f000 f8bf 	bl	8024e74 <__kernel_rem_pio2f>
 8024cf6:	2e00      	cmp	r6, #0
 8024cf8:	f6bf af31 	bge.w	8024b5e <__ieee754_rem_pio2f+0x62>
 8024cfc:	edd4 7a00 	vldr	s15, [r4]
 8024d00:	eef1 7a67 	vneg.f32	s15, s15
 8024d04:	edc4 7a00 	vstr	s15, [r4]
 8024d08:	edd4 7a01 	vldr	s15, [r4, #4]
 8024d0c:	eef1 7a67 	vneg.f32	s15, s15
 8024d10:	edc4 7a01 	vstr	s15, [r4, #4]
 8024d14:	e77a      	b.n	8024c0c <__ieee754_rem_pio2f+0x110>
 8024d16:	2303      	movs	r3, #3
 8024d18:	e7e5      	b.n	8024ce6 <__ieee754_rem_pio2f+0x1ea>
 8024d1a:	bf00      	nop
 8024d1c:	3f490fd8 	.word	0x3f490fd8
 8024d20:	4016cbe3 	.word	0x4016cbe3
 8024d24:	3fc90f80 	.word	0x3fc90f80
 8024d28:	3fc90fd0 	.word	0x3fc90fd0
 8024d2c:	37354400 	.word	0x37354400
 8024d30:	37354443 	.word	0x37354443
 8024d34:	2e85a308 	.word	0x2e85a308
 8024d38:	43490f80 	.word	0x43490f80
 8024d3c:	3f22f984 	.word	0x3f22f984
 8024d40:	0802d288 	.word	0x0802d288
 8024d44:	2e85a300 	.word	0x2e85a300
 8024d48:	248d3132 	.word	0x248d3132
 8024d4c:	43800000 	.word	0x43800000
 8024d50:	0802d308 	.word	0x0802d308

08024d54 <fabsf>:
 8024d54:	ee10 3a10 	vmov	r3, s0
 8024d58:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8024d5c:	ee00 3a10 	vmov	s0, r3
 8024d60:	4770      	bx	lr
	...

08024d64 <scalbnf>:
 8024d64:	ee10 3a10 	vmov	r3, s0
 8024d68:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
 8024d6c:	d02b      	beq.n	8024dc6 <scalbnf+0x62>
 8024d6e:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 8024d72:	d302      	bcc.n	8024d7a <scalbnf+0x16>
 8024d74:	ee30 0a00 	vadd.f32	s0, s0, s0
 8024d78:	4770      	bx	lr
 8024d7a:	f013 4fff 	tst.w	r3, #2139095040	; 0x7f800000
 8024d7e:	d123      	bne.n	8024dc8 <scalbnf+0x64>
 8024d80:	4b24      	ldr	r3, [pc, #144]	; (8024e14 <scalbnf+0xb0>)
 8024d82:	eddf 7a25 	vldr	s15, [pc, #148]	; 8024e18 <scalbnf+0xb4>
 8024d86:	4298      	cmp	r0, r3
 8024d88:	ee20 0a27 	vmul.f32	s0, s0, s15
 8024d8c:	db17      	blt.n	8024dbe <scalbnf+0x5a>
 8024d8e:	ee10 3a10 	vmov	r3, s0
 8024d92:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 8024d96:	3a19      	subs	r2, #25
 8024d98:	f24c 3150 	movw	r1, #50000	; 0xc350
 8024d9c:	4288      	cmp	r0, r1
 8024d9e:	dd15      	ble.n	8024dcc <scalbnf+0x68>
 8024da0:	eddf 7a1e 	vldr	s15, [pc, #120]	; 8024e1c <scalbnf+0xb8>
 8024da4:	eddf 6a1e 	vldr	s13, [pc, #120]	; 8024e20 <scalbnf+0xbc>
 8024da8:	ee10 3a10 	vmov	r3, s0
 8024dac:	eeb0 7a67 	vmov.f32	s14, s15
 8024db0:	2b00      	cmp	r3, #0
 8024db2:	bfb8      	it	lt
 8024db4:	eef0 7a66 	vmovlt.f32	s15, s13
 8024db8:	ee27 0a87 	vmul.f32	s0, s15, s14
 8024dbc:	4770      	bx	lr
 8024dbe:	eddf 7a19 	vldr	s15, [pc, #100]	; 8024e24 <scalbnf+0xc0>
 8024dc2:	ee27 0a80 	vmul.f32	s0, s15, s0
 8024dc6:	4770      	bx	lr
 8024dc8:	0dd2      	lsrs	r2, r2, #23
 8024dca:	e7e5      	b.n	8024d98 <scalbnf+0x34>
 8024dcc:	4410      	add	r0, r2
 8024dce:	28fe      	cmp	r0, #254	; 0xfe
 8024dd0:	dce6      	bgt.n	8024da0 <scalbnf+0x3c>
 8024dd2:	2800      	cmp	r0, #0
 8024dd4:	dd06      	ble.n	8024de4 <scalbnf+0x80>
 8024dd6:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 8024dda:	ea43 53c0 	orr.w	r3, r3, r0, lsl #23
 8024dde:	ee00 3a10 	vmov	s0, r3
 8024de2:	4770      	bx	lr
 8024de4:	f110 0f16 	cmn.w	r0, #22
 8024de8:	da09      	bge.n	8024dfe <scalbnf+0x9a>
 8024dea:	eddf 7a0e 	vldr	s15, [pc, #56]	; 8024e24 <scalbnf+0xc0>
 8024dee:	eddf 6a0e 	vldr	s13, [pc, #56]	; 8024e28 <scalbnf+0xc4>
 8024df2:	ee10 3a10 	vmov	r3, s0
 8024df6:	eeb0 7a67 	vmov.f32	s14, s15
 8024dfa:	2b00      	cmp	r3, #0
 8024dfc:	e7d9      	b.n	8024db2 <scalbnf+0x4e>
 8024dfe:	3019      	adds	r0, #25
 8024e00:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 8024e04:	ea43 53c0 	orr.w	r3, r3, r0, lsl #23
 8024e08:	ed9f 0a08 	vldr	s0, [pc, #32]	; 8024e2c <scalbnf+0xc8>
 8024e0c:	ee07 3a90 	vmov	s15, r3
 8024e10:	e7d7      	b.n	8024dc2 <scalbnf+0x5e>
 8024e12:	bf00      	nop
 8024e14:	ffff3cb0 	.word	0xffff3cb0
 8024e18:	4c000000 	.word	0x4c000000
 8024e1c:	7149f2ca 	.word	0x7149f2ca
 8024e20:	f149f2ca 	.word	0xf149f2ca
 8024e24:	0da24260 	.word	0x0da24260
 8024e28:	8da24260 	.word	0x8da24260
 8024e2c:	33000000 	.word	0x33000000

08024e30 <with_errnof>:
 8024e30:	b513      	push	{r0, r1, r4, lr}
 8024e32:	4604      	mov	r4, r0
 8024e34:	ed8d 0a01 	vstr	s0, [sp, #4]
 8024e38:	f7fd ffc6 	bl	8022dc8 <__errno>
 8024e3c:	ed9d 0a01 	vldr	s0, [sp, #4]
 8024e40:	6004      	str	r4, [r0, #0]
 8024e42:	b002      	add	sp, #8
 8024e44:	bd10      	pop	{r4, pc}

08024e46 <xflowf>:
 8024e46:	b130      	cbz	r0, 8024e56 <xflowf+0x10>
 8024e48:	eef1 7a40 	vneg.f32	s15, s0
 8024e4c:	ee27 0a80 	vmul.f32	s0, s15, s0
 8024e50:	2022      	movs	r0, #34	; 0x22
 8024e52:	f7ff bfed 	b.w	8024e30 <with_errnof>
 8024e56:	eef0 7a40 	vmov.f32	s15, s0
 8024e5a:	e7f7      	b.n	8024e4c <xflowf+0x6>

08024e5c <__math_uflowf>:
 8024e5c:	ed9f 0a01 	vldr	s0, [pc, #4]	; 8024e64 <__math_uflowf+0x8>
 8024e60:	f7ff bff1 	b.w	8024e46 <xflowf>
 8024e64:	10000000 	.word	0x10000000

08024e68 <__math_oflowf>:
 8024e68:	ed9f 0a01 	vldr	s0, [pc, #4]	; 8024e70 <__math_oflowf+0x8>
 8024e6c:	f7ff bfeb 	b.w	8024e46 <xflowf>
 8024e70:	70000000 	.word	0x70000000

08024e74 <__kernel_rem_pio2f>:
 8024e74:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024e78:	ed2d 8b04 	vpush	{d8-d9}
 8024e7c:	b0d9      	sub	sp, #356	; 0x164
 8024e7e:	4688      	mov	r8, r1
 8024e80:	9002      	str	r0, [sp, #8]
 8024e82:	49b8      	ldr	r1, [pc, #736]	; (8025164 <__kernel_rem_pio2f+0x2f0>)
 8024e84:	9866      	ldr	r0, [sp, #408]	; 0x198
 8024e86:	9301      	str	r3, [sp, #4]
 8024e88:	f851 a020 	ldr.w	sl, [r1, r0, lsl #2]
 8024e8c:	9901      	ldr	r1, [sp, #4]
 8024e8e:	9b67      	ldr	r3, [sp, #412]	; 0x19c
 8024e90:	f101 3bff 	add.w	fp, r1, #4294967295
 8024e94:	1d11      	adds	r1, r2, #4
 8024e96:	db25      	blt.n	8024ee4 <__kernel_rem_pio2f+0x70>
 8024e98:	1ed0      	subs	r0, r2, #3
 8024e9a:	bf48      	it	mi
 8024e9c:	1d10      	addmi	r0, r2, #4
 8024e9e:	10c0      	asrs	r0, r0, #3
 8024ea0:	1c45      	adds	r5, r0, #1
 8024ea2:	00e9      	lsls	r1, r5, #3
 8024ea4:	eba0 070b 	sub.w	r7, r0, fp
 8024ea8:	ed9f 7ab2 	vldr	s14, [pc, #712]	; 8025174 <__kernel_rem_pio2f+0x300>
 8024eac:	9103      	str	r1, [sp, #12]
 8024eae:	eba2 05c5 	sub.w	r5, r2, r5, lsl #3
 8024eb2:	eb0a 0c0b 	add.w	ip, sl, fp
 8024eb6:	ae1c      	add	r6, sp, #112	; 0x70
 8024eb8:	eb03 0e87 	add.w	lr, r3, r7, lsl #2
 8024ebc:	2400      	movs	r4, #0
 8024ebe:	4564      	cmp	r4, ip
 8024ec0:	dd12      	ble.n	8024ee8 <__kernel_rem_pio2f+0x74>
 8024ec2:	9901      	ldr	r1, [sp, #4]
 8024ec4:	ac1c      	add	r4, sp, #112	; 0x70
 8024ec6:	eb04 0481 	add.w	r4, r4, r1, lsl #2
 8024eca:	f50d 7988 	add.w	r9, sp, #272	; 0x110
 8024ece:	f04f 0c00 	mov.w	ip, #0
 8024ed2:	45d4      	cmp	ip, sl
 8024ed4:	dc27      	bgt.n	8024f26 <__kernel_rem_pio2f+0xb2>
 8024ed6:	f8dd e008 	ldr.w	lr, [sp, #8]
 8024eda:	eddf 7aa6 	vldr	s15, [pc, #664]	; 8025174 <__kernel_rem_pio2f+0x300>
 8024ede:	4627      	mov	r7, r4
 8024ee0:	2600      	movs	r6, #0
 8024ee2:	e016      	b.n	8024f12 <__kernel_rem_pio2f+0x9e>
 8024ee4:	2000      	movs	r0, #0
 8024ee6:	e7db      	b.n	8024ea0 <__kernel_rem_pio2f+0x2c>
 8024ee8:	42e7      	cmn	r7, r4
 8024eea:	bf5d      	ittte	pl
 8024eec:	f85e 1024 	ldrpl.w	r1, [lr, r4, lsl #2]
 8024ef0:	ee07 1a90 	vmovpl	s15, r1
 8024ef4:	eef8 7ae7 	vcvtpl.f32.s32	s15, s15
 8024ef8:	eef0 7a47 	vmovmi.f32	s15, s14
 8024efc:	ece6 7a01 	vstmia	r6!, {s15}
 8024f00:	3401      	adds	r4, #1
 8024f02:	e7dc      	b.n	8024ebe <__kernel_rem_pio2f+0x4a>
 8024f04:	ecfe 6a01 	vldmia	lr!, {s13}
 8024f08:	ed97 7a00 	vldr	s14, [r7]
 8024f0c:	eee6 7a87 	vfma.f32	s15, s13, s14
 8024f10:	3601      	adds	r6, #1
 8024f12:	455e      	cmp	r6, fp
 8024f14:	f1a7 0704 	sub.w	r7, r7, #4
 8024f18:	ddf4      	ble.n	8024f04 <__kernel_rem_pio2f+0x90>
 8024f1a:	ece9 7a01 	vstmia	r9!, {s15}
 8024f1e:	f10c 0c01 	add.w	ip, ip, #1
 8024f22:	3404      	adds	r4, #4
 8024f24:	e7d5      	b.n	8024ed2 <__kernel_rem_pio2f+0x5e>
 8024f26:	a908      	add	r1, sp, #32
 8024f28:	eb01 018a 	add.w	r1, r1, sl, lsl #2
 8024f2c:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 8024f30:	eddf 8a8f 	vldr	s17, [pc, #572]	; 8025170 <__kernel_rem_pio2f+0x2fc>
 8024f34:	ed9f 9a8d 	vldr	s18, [pc, #564]	; 802516c <__kernel_rem_pio2f+0x2f8>
 8024f38:	9105      	str	r1, [sp, #20]
 8024f3a:	9304      	str	r3, [sp, #16]
 8024f3c:	4656      	mov	r6, sl
 8024f3e:	00b3      	lsls	r3, r6, #2
 8024f40:	9306      	str	r3, [sp, #24]
 8024f42:	ab58      	add	r3, sp, #352	; 0x160
 8024f44:	eb03 0086 	add.w	r0, r3, r6, lsl #2
 8024f48:	ac08      	add	r4, sp, #32
 8024f4a:	ab44      	add	r3, sp, #272	; 0x110
 8024f4c:	ed10 0a14 	vldr	s0, [r0, #-80]	; 0xffffffb0
 8024f50:	46a4      	mov	ip, r4
 8024f52:	eb03 0086 	add.w	r0, r3, r6, lsl #2
 8024f56:	4637      	mov	r7, r6
 8024f58:	2f00      	cmp	r7, #0
 8024f5a:	f1a0 0004 	sub.w	r0, r0, #4
 8024f5e:	dc4a      	bgt.n	8024ff6 <__kernel_rem_pio2f+0x182>
 8024f60:	4628      	mov	r0, r5
 8024f62:	9207      	str	r2, [sp, #28]
 8024f64:	f7ff fefe 	bl	8024d64 <scalbnf>
 8024f68:	eeb0 8a40 	vmov.f32	s16, s0
 8024f6c:	eeb4 0a00 	vmov.f32	s0, #64	; 0x3e000000  0.125
 8024f70:	ee28 0a00 	vmul.f32	s0, s16, s0
 8024f74:	f7fe fe80 	bl	8023c78 <floorf>
 8024f78:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
 8024f7c:	eea0 8a67 	vfms.f32	s16, s0, s15
 8024f80:	2d00      	cmp	r5, #0
 8024f82:	9a07      	ldr	r2, [sp, #28]
 8024f84:	eefd 7ac8 	vcvt.s32.f32	s15, s16
 8024f88:	ee17 9a90 	vmov	r9, s15
 8024f8c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8024f90:	ee38 8a67 	vsub.f32	s16, s16, s15
 8024f94:	dd41      	ble.n	802501a <__kernel_rem_pio2f+0x1a6>
 8024f96:	f106 3cff 	add.w	ip, r6, #4294967295
 8024f9a:	ab08      	add	r3, sp, #32
 8024f9c:	f1c5 0e08 	rsb	lr, r5, #8
 8024fa0:	f853 702c 	ldr.w	r7, [r3, ip, lsl #2]
 8024fa4:	fa47 f00e 	asr.w	r0, r7, lr
 8024fa8:	4481      	add	r9, r0
 8024faa:	fa00 f00e 	lsl.w	r0, r0, lr
 8024fae:	1a3f      	subs	r7, r7, r0
 8024fb0:	f1c5 0007 	rsb	r0, r5, #7
 8024fb4:	f843 702c 	str.w	r7, [r3, ip, lsl #2]
 8024fb8:	4107      	asrs	r7, r0
 8024fba:	2f00      	cmp	r7, #0
 8024fbc:	dd3c      	ble.n	8025038 <__kernel_rem_pio2f+0x1c4>
 8024fbe:	f04f 0e00 	mov.w	lr, #0
 8024fc2:	f109 0901 	add.w	r9, r9, #1
 8024fc6:	4671      	mov	r1, lr
 8024fc8:	4576      	cmp	r6, lr
 8024fca:	dc67      	bgt.n	802509c <__kernel_rem_pio2f+0x228>
 8024fcc:	2d00      	cmp	r5, #0
 8024fce:	dd03      	ble.n	8024fd8 <__kernel_rem_pio2f+0x164>
 8024fd0:	2d01      	cmp	r5, #1
 8024fd2:	d074      	beq.n	80250be <__kernel_rem_pio2f+0x24a>
 8024fd4:	2d02      	cmp	r5, #2
 8024fd6:	d07b      	beq.n	80250d0 <__kernel_rem_pio2f+0x25c>
 8024fd8:	2f02      	cmp	r7, #2
 8024fda:	d12d      	bne.n	8025038 <__kernel_rem_pio2f+0x1c4>
 8024fdc:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8024fe0:	ee30 8a48 	vsub.f32	s16, s0, s16
 8024fe4:	b341      	cbz	r1, 8025038 <__kernel_rem_pio2f+0x1c4>
 8024fe6:	4628      	mov	r0, r5
 8024fe8:	9207      	str	r2, [sp, #28]
 8024fea:	f7ff febb 	bl	8024d64 <scalbnf>
 8024fee:	9a07      	ldr	r2, [sp, #28]
 8024ff0:	ee38 8a40 	vsub.f32	s16, s16, s0
 8024ff4:	e020      	b.n	8025038 <__kernel_rem_pio2f+0x1c4>
 8024ff6:	ee60 7a28 	vmul.f32	s15, s0, s17
 8024ffa:	3f01      	subs	r7, #1
 8024ffc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8025000:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8025004:	eea7 0ac9 	vfms.f32	s0, s15, s18
 8025008:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 802500c:	ecac 0a01 	vstmia	ip!, {s0}
 8025010:	ed90 0a00 	vldr	s0, [r0]
 8025014:	ee37 0a80 	vadd.f32	s0, s15, s0
 8025018:	e79e      	b.n	8024f58 <__kernel_rem_pio2f+0xe4>
 802501a:	d105      	bne.n	8025028 <__kernel_rem_pio2f+0x1b4>
 802501c:	1e70      	subs	r0, r6, #1
 802501e:	ab08      	add	r3, sp, #32
 8025020:	f853 7020 	ldr.w	r7, [r3, r0, lsl #2]
 8025024:	11ff      	asrs	r7, r7, #7
 8025026:	e7c8      	b.n	8024fba <__kernel_rem_pio2f+0x146>
 8025028:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 802502c:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8025030:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025034:	da30      	bge.n	8025098 <__kernel_rem_pio2f+0x224>
 8025036:	2700      	movs	r7, #0
 8025038:	eeb5 8a40 	vcmp.f32	s16, #0.0
 802503c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025040:	f040 809a 	bne.w	8025178 <__kernel_rem_pio2f+0x304>
 8025044:	1e74      	subs	r4, r6, #1
 8025046:	46a4      	mov	ip, r4
 8025048:	2100      	movs	r1, #0
 802504a:	45d4      	cmp	ip, sl
 802504c:	da47      	bge.n	80250de <__kernel_rem_pio2f+0x26a>
 802504e:	2900      	cmp	r1, #0
 8025050:	d063      	beq.n	802511a <__kernel_rem_pio2f+0x2a6>
 8025052:	ab08      	add	r3, sp, #32
 8025054:	3d08      	subs	r5, #8
 8025056:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 802505a:	2b00      	cmp	r3, #0
 802505c:	d07f      	beq.n	802515e <__kernel_rem_pio2f+0x2ea>
 802505e:	4628      	mov	r0, r5
 8025060:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8025064:	f7ff fe7e 	bl	8024d64 <scalbnf>
 8025068:	1c63      	adds	r3, r4, #1
 802506a:	aa44      	add	r2, sp, #272	; 0x110
 802506c:	ed9f 7a40 	vldr	s14, [pc, #256]	; 8025170 <__kernel_rem_pio2f+0x2fc>
 8025070:	0099      	lsls	r1, r3, #2
 8025072:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8025076:	4623      	mov	r3, r4
 8025078:	2b00      	cmp	r3, #0
 802507a:	f280 80ad 	bge.w	80251d8 <__kernel_rem_pio2f+0x364>
 802507e:	4623      	mov	r3, r4
 8025080:	2b00      	cmp	r3, #0
 8025082:	f2c0 80cb 	blt.w	802521c <__kernel_rem_pio2f+0x3a8>
 8025086:	aa44      	add	r2, sp, #272	; 0x110
 8025088:	eb02 0583 	add.w	r5, r2, r3, lsl #2
 802508c:	4e36      	ldr	r6, [pc, #216]	; (8025168 <__kernel_rem_pio2f+0x2f4>)
 802508e:	eddf 7a39 	vldr	s15, [pc, #228]	; 8025174 <__kernel_rem_pio2f+0x300>
 8025092:	2000      	movs	r0, #0
 8025094:	1ae2      	subs	r2, r4, r3
 8025096:	e0b6      	b.n	8025206 <__kernel_rem_pio2f+0x392>
 8025098:	2702      	movs	r7, #2
 802509a:	e790      	b.n	8024fbe <__kernel_rem_pio2f+0x14a>
 802509c:	6820      	ldr	r0, [r4, #0]
 802509e:	b949      	cbnz	r1, 80250b4 <__kernel_rem_pio2f+0x240>
 80250a0:	b118      	cbz	r0, 80250aa <__kernel_rem_pio2f+0x236>
 80250a2:	f5c0 7080 	rsb	r0, r0, #256	; 0x100
 80250a6:	6020      	str	r0, [r4, #0]
 80250a8:	2001      	movs	r0, #1
 80250aa:	f10e 0e01 	add.w	lr, lr, #1
 80250ae:	3404      	adds	r4, #4
 80250b0:	4601      	mov	r1, r0
 80250b2:	e789      	b.n	8024fc8 <__kernel_rem_pio2f+0x154>
 80250b4:	f1c0 00ff 	rsb	r0, r0, #255	; 0xff
 80250b8:	6020      	str	r0, [r4, #0]
 80250ba:	4608      	mov	r0, r1
 80250bc:	e7f5      	b.n	80250aa <__kernel_rem_pio2f+0x236>
 80250be:	1e74      	subs	r4, r6, #1
 80250c0:	ab08      	add	r3, sp, #32
 80250c2:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 80250c6:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 80250ca:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
 80250ce:	e783      	b.n	8024fd8 <__kernel_rem_pio2f+0x164>
 80250d0:	1e74      	subs	r4, r6, #1
 80250d2:	ab08      	add	r3, sp, #32
 80250d4:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 80250d8:	f000 003f 	and.w	r0, r0, #63	; 0x3f
 80250dc:	e7f5      	b.n	80250ca <__kernel_rem_pio2f+0x256>
 80250de:	ab08      	add	r3, sp, #32
 80250e0:	f853 002c 	ldr.w	r0, [r3, ip, lsl #2]
 80250e4:	f10c 3cff 	add.w	ip, ip, #4294967295
 80250e8:	4301      	orrs	r1, r0
 80250ea:	e7ae      	b.n	802504a <__kernel_rem_pio2f+0x1d6>
 80250ec:	3001      	adds	r0, #1
 80250ee:	f854 7d04 	ldr.w	r7, [r4, #-4]!
 80250f2:	2f00      	cmp	r7, #0
 80250f4:	d0fa      	beq.n	80250ec <__kernel_rem_pio2f+0x278>
 80250f6:	9b06      	ldr	r3, [sp, #24]
 80250f8:	f503 73b0 	add.w	r3, r3, #352	; 0x160
 80250fc:	eb0d 0403 	add.w	r4, sp, r3
 8025100:	9b01      	ldr	r3, [sp, #4]
 8025102:	18f7      	adds	r7, r6, r3
 8025104:	ab1c      	add	r3, sp, #112	; 0x70
 8025106:	f106 0c01 	add.w	ip, r6, #1
 802510a:	3c4c      	subs	r4, #76	; 0x4c
 802510c:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 8025110:	4430      	add	r0, r6
 8025112:	4560      	cmp	r0, ip
 8025114:	da04      	bge.n	8025120 <__kernel_rem_pio2f+0x2ac>
 8025116:	4606      	mov	r6, r0
 8025118:	e711      	b.n	8024f3e <__kernel_rem_pio2f+0xca>
 802511a:	9c05      	ldr	r4, [sp, #20]
 802511c:	2001      	movs	r0, #1
 802511e:	e7e6      	b.n	80250ee <__kernel_rem_pio2f+0x27a>
 8025120:	9b04      	ldr	r3, [sp, #16]
 8025122:	f8dd e008 	ldr.w	lr, [sp, #8]
 8025126:	f853 302c 	ldr.w	r3, [r3, ip, lsl #2]
 802512a:	9306      	str	r3, [sp, #24]
 802512c:	ee07 3a90 	vmov	s15, r3
 8025130:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8025134:	2600      	movs	r6, #0
 8025136:	ece7 7a01 	vstmia	r7!, {s15}
 802513a:	eddf 7a0e 	vldr	s15, [pc, #56]	; 8025174 <__kernel_rem_pio2f+0x300>
 802513e:	46b9      	mov	r9, r7
 8025140:	455e      	cmp	r6, fp
 8025142:	dd04      	ble.n	802514e <__kernel_rem_pio2f+0x2da>
 8025144:	ece4 7a01 	vstmia	r4!, {s15}
 8025148:	f10c 0c01 	add.w	ip, ip, #1
 802514c:	e7e1      	b.n	8025112 <__kernel_rem_pio2f+0x29e>
 802514e:	ecfe 6a01 	vldmia	lr!, {s13}
 8025152:	ed39 7a01 	vldmdb	r9!, {s14}
 8025156:	3601      	adds	r6, #1
 8025158:	eee6 7a87 	vfma.f32	s15, s13, s14
 802515c:	e7f0      	b.n	8025140 <__kernel_rem_pio2f+0x2cc>
 802515e:	3c01      	subs	r4, #1
 8025160:	e777      	b.n	8025052 <__kernel_rem_pio2f+0x1de>
 8025162:	bf00      	nop
 8025164:	0802d64c 	.word	0x0802d64c
 8025168:	0802d620 	.word	0x0802d620
 802516c:	43800000 	.word	0x43800000
 8025170:	3b800000 	.word	0x3b800000
 8025174:	00000000 	.word	0x00000000
 8025178:	9b03      	ldr	r3, [sp, #12]
 802517a:	eeb0 0a48 	vmov.f32	s0, s16
 802517e:	1a98      	subs	r0, r3, r2
 8025180:	f7ff fdf0 	bl	8024d64 <scalbnf>
 8025184:	ed1f 7a07 	vldr	s14, [pc, #-28]	; 802516c <__kernel_rem_pio2f+0x2f8>
 8025188:	eeb4 0ac7 	vcmpe.f32	s0, s14
 802518c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025190:	db19      	blt.n	80251c6 <__kernel_rem_pio2f+0x352>
 8025192:	ed5f 7a09 	vldr	s15, [pc, #-36]	; 8025170 <__kernel_rem_pio2f+0x2fc>
 8025196:	ee60 7a27 	vmul.f32	s15, s0, s15
 802519a:	aa08      	add	r2, sp, #32
 802519c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80251a0:	1c74      	adds	r4, r6, #1
 80251a2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80251a6:	3508      	adds	r5, #8
 80251a8:	eea7 0ac7 	vfms.f32	s0, s15, s14
 80251ac:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80251b0:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 80251b4:	ee10 3a10 	vmov	r3, s0
 80251b8:	f842 3026 	str.w	r3, [r2, r6, lsl #2]
 80251bc:	ee17 3a90 	vmov	r3, s15
 80251c0:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
 80251c4:	e74b      	b.n	802505e <__kernel_rem_pio2f+0x1ea>
 80251c6:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 80251ca:	aa08      	add	r2, sp, #32
 80251cc:	ee10 3a10 	vmov	r3, s0
 80251d0:	4634      	mov	r4, r6
 80251d2:	f842 3026 	str.w	r3, [r2, r6, lsl #2]
 80251d6:	e742      	b.n	802505e <__kernel_rem_pio2f+0x1ea>
 80251d8:	a808      	add	r0, sp, #32
 80251da:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
 80251de:	9001      	str	r0, [sp, #4]
 80251e0:	ee07 0a90 	vmov	s15, r0
 80251e4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80251e8:	3b01      	subs	r3, #1
 80251ea:	ee67 7a80 	vmul.f32	s15, s15, s0
 80251ee:	ee20 0a07 	vmul.f32	s0, s0, s14
 80251f2:	ed62 7a01 	vstmdb	r2!, {s15}
 80251f6:	e73f      	b.n	8025078 <__kernel_rem_pio2f+0x204>
 80251f8:	ecf6 6a01 	vldmia	r6!, {s13}
 80251fc:	ecb5 7a01 	vldmia	r5!, {s14}
 8025200:	eee6 7a87 	vfma.f32	s15, s13, s14
 8025204:	3001      	adds	r0, #1
 8025206:	4550      	cmp	r0, sl
 8025208:	dc01      	bgt.n	802520e <__kernel_rem_pio2f+0x39a>
 802520a:	4290      	cmp	r0, r2
 802520c:	ddf4      	ble.n	80251f8 <__kernel_rem_pio2f+0x384>
 802520e:	a858      	add	r0, sp, #352	; 0x160
 8025210:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8025214:	ed42 7a28 	vstr	s15, [r2, #-160]	; 0xffffff60
 8025218:	3b01      	subs	r3, #1
 802521a:	e731      	b.n	8025080 <__kernel_rem_pio2f+0x20c>
 802521c:	9b66      	ldr	r3, [sp, #408]	; 0x198
 802521e:	2b02      	cmp	r3, #2
 8025220:	dc09      	bgt.n	8025236 <__kernel_rem_pio2f+0x3c2>
 8025222:	2b00      	cmp	r3, #0
 8025224:	dc2b      	bgt.n	802527e <__kernel_rem_pio2f+0x40a>
 8025226:	d044      	beq.n	80252b2 <__kernel_rem_pio2f+0x43e>
 8025228:	f009 0007 	and.w	r0, r9, #7
 802522c:	b059      	add	sp, #356	; 0x164
 802522e:	ecbd 8b04 	vpop	{d8-d9}
 8025232:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025236:	9b66      	ldr	r3, [sp, #408]	; 0x198
 8025238:	2b03      	cmp	r3, #3
 802523a:	d1f5      	bne.n	8025228 <__kernel_rem_pio2f+0x3b4>
 802523c:	aa30      	add	r2, sp, #192	; 0xc0
 802523e:	1f0b      	subs	r3, r1, #4
 8025240:	4413      	add	r3, r2
 8025242:	461a      	mov	r2, r3
 8025244:	4620      	mov	r0, r4
 8025246:	2800      	cmp	r0, #0
 8025248:	f1a2 0204 	sub.w	r2, r2, #4
 802524c:	dc52      	bgt.n	80252f4 <__kernel_rem_pio2f+0x480>
 802524e:	4622      	mov	r2, r4
 8025250:	2a01      	cmp	r2, #1
 8025252:	f1a3 0304 	sub.w	r3, r3, #4
 8025256:	dc5d      	bgt.n	8025314 <__kernel_rem_pio2f+0x4a0>
 8025258:	ab30      	add	r3, sp, #192	; 0xc0
 802525a:	ed5f 7a3a 	vldr	s15, [pc, #-232]	; 8025174 <__kernel_rem_pio2f+0x300>
 802525e:	440b      	add	r3, r1
 8025260:	2c01      	cmp	r4, #1
 8025262:	dc67      	bgt.n	8025334 <__kernel_rem_pio2f+0x4c0>
 8025264:	eddd 6a30 	vldr	s13, [sp, #192]	; 0xc0
 8025268:	ed9d 7a31 	vldr	s14, [sp, #196]	; 0xc4
 802526c:	2f00      	cmp	r7, #0
 802526e:	d167      	bne.n	8025340 <__kernel_rem_pio2f+0x4cc>
 8025270:	edc8 6a00 	vstr	s13, [r8]
 8025274:	ed88 7a01 	vstr	s14, [r8, #4]
 8025278:	edc8 7a02 	vstr	s15, [r8, #8]
 802527c:	e7d4      	b.n	8025228 <__kernel_rem_pio2f+0x3b4>
 802527e:	ab30      	add	r3, sp, #192	; 0xc0
 8025280:	ed1f 7a44 	vldr	s14, [pc, #-272]	; 8025174 <__kernel_rem_pio2f+0x300>
 8025284:	440b      	add	r3, r1
 8025286:	4622      	mov	r2, r4
 8025288:	2a00      	cmp	r2, #0
 802528a:	da24      	bge.n	80252d6 <__kernel_rem_pio2f+0x462>
 802528c:	b34f      	cbz	r7, 80252e2 <__kernel_rem_pio2f+0x46e>
 802528e:	eef1 7a47 	vneg.f32	s15, s14
 8025292:	edc8 7a00 	vstr	s15, [r8]
 8025296:	eddd 7a30 	vldr	s15, [sp, #192]	; 0xc0
 802529a:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802529e:	aa31      	add	r2, sp, #196	; 0xc4
 80252a0:	2301      	movs	r3, #1
 80252a2:	429c      	cmp	r4, r3
 80252a4:	da20      	bge.n	80252e8 <__kernel_rem_pio2f+0x474>
 80252a6:	b10f      	cbz	r7, 80252ac <__kernel_rem_pio2f+0x438>
 80252a8:	eef1 7a67 	vneg.f32	s15, s15
 80252ac:	edc8 7a01 	vstr	s15, [r8, #4]
 80252b0:	e7ba      	b.n	8025228 <__kernel_rem_pio2f+0x3b4>
 80252b2:	ab30      	add	r3, sp, #192	; 0xc0
 80252b4:	ed5f 7a51 	vldr	s15, [pc, #-324]	; 8025174 <__kernel_rem_pio2f+0x300>
 80252b8:	440b      	add	r3, r1
 80252ba:	2c00      	cmp	r4, #0
 80252bc:	da05      	bge.n	80252ca <__kernel_rem_pio2f+0x456>
 80252be:	b10f      	cbz	r7, 80252c4 <__kernel_rem_pio2f+0x450>
 80252c0:	eef1 7a67 	vneg.f32	s15, s15
 80252c4:	edc8 7a00 	vstr	s15, [r8]
 80252c8:	e7ae      	b.n	8025228 <__kernel_rem_pio2f+0x3b4>
 80252ca:	ed33 7a01 	vldmdb	r3!, {s14}
 80252ce:	3c01      	subs	r4, #1
 80252d0:	ee77 7a87 	vadd.f32	s15, s15, s14
 80252d4:	e7f1      	b.n	80252ba <__kernel_rem_pio2f+0x446>
 80252d6:	ed73 7a01 	vldmdb	r3!, {s15}
 80252da:	3a01      	subs	r2, #1
 80252dc:	ee37 7a27 	vadd.f32	s14, s14, s15
 80252e0:	e7d2      	b.n	8025288 <__kernel_rem_pio2f+0x414>
 80252e2:	eef0 7a47 	vmov.f32	s15, s14
 80252e6:	e7d4      	b.n	8025292 <__kernel_rem_pio2f+0x41e>
 80252e8:	ecb2 7a01 	vldmia	r2!, {s14}
 80252ec:	3301      	adds	r3, #1
 80252ee:	ee77 7a87 	vadd.f32	s15, s15, s14
 80252f2:	e7d6      	b.n	80252a2 <__kernel_rem_pio2f+0x42e>
 80252f4:	edd2 7a00 	vldr	s15, [r2]
 80252f8:	edd2 6a01 	vldr	s13, [r2, #4]
 80252fc:	ee37 7aa6 	vadd.f32	s14, s15, s13
 8025300:	3801      	subs	r0, #1
 8025302:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8025306:	ed82 7a00 	vstr	s14, [r2]
 802530a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 802530e:	edc2 7a01 	vstr	s15, [r2, #4]
 8025312:	e798      	b.n	8025246 <__kernel_rem_pio2f+0x3d2>
 8025314:	edd3 7a00 	vldr	s15, [r3]
 8025318:	edd3 6a01 	vldr	s13, [r3, #4]
 802531c:	ee37 7aa6 	vadd.f32	s14, s15, s13
 8025320:	3a01      	subs	r2, #1
 8025322:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8025326:	ed83 7a00 	vstr	s14, [r3]
 802532a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 802532e:	edc3 7a01 	vstr	s15, [r3, #4]
 8025332:	e78d      	b.n	8025250 <__kernel_rem_pio2f+0x3dc>
 8025334:	ed33 7a01 	vldmdb	r3!, {s14}
 8025338:	3c01      	subs	r4, #1
 802533a:	ee77 7a87 	vadd.f32	s15, s15, s14
 802533e:	e78f      	b.n	8025260 <__kernel_rem_pio2f+0x3ec>
 8025340:	eef1 6a66 	vneg.f32	s13, s13
 8025344:	eeb1 7a47 	vneg.f32	s14, s14
 8025348:	edc8 6a00 	vstr	s13, [r8]
 802534c:	ed88 7a01 	vstr	s14, [r8, #4]
 8025350:	eef1 7a67 	vneg.f32	s15, s15
 8025354:	e790      	b.n	8025278 <__kernel_rem_pio2f+0x404>
 8025356:	bf00      	nop

08025358 <_init>:
 8025358:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802535a:	bf00      	nop
 802535c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 802535e:	bc08      	pop	{r3}
 8025360:	469e      	mov	lr, r3
 8025362:	4770      	bx	lr

08025364 <_fini>:
 8025364:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8025366:	bf00      	nop
 8025368:	bcf8      	pop	{r3, r4, r5, r6, r7}
 802536a:	bc08      	pop	{r3}
 802536c:	469e      	mov	lr, r3
 802536e:	4770      	bx	lr
